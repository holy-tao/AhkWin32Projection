#Requires AutoHotkey v2.0.0 64-bit
#Include ..\..\..\..\Win32Handle.ahk
#Include ..\..\..\..\Guid.ahk
#Include .\NCRYPT_PROV_HANDLE.ahk
#Include .\NCRYPT_KEY_HANDLE.ahk
#Include .\NCRYPT_SECRET_HANDLE.ahk
#Include .\HCERTSTORE.ahk
#Include ..\NCRYPT_DESCRIPTOR_HANDLE.ahk
#Include ..\NCRYPT_STREAM_HANDLE.ahk
#Include .\BCRYPT_KEY_HANDLE.ahk
#Include .\NCRYPT_HASH_HANDLE.ahk
#Include .\Apis.ahk
#Include .\BCRYPT_ALG_HANDLE.ahk

/**
 * @namespace Windows.Win32.Security.Cryptography
 * @version v4.0.30319
 */
class Cryptography {

;@region Constants

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_CURRENT_USER => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_LOCAL_MACHINE => 131072

    /**
     * @type {Integer (Int32)}
     */
    static CERT_COMPARE_SHIFT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_OBJECT_ALIGNMENT => 16

    /**
     * @type {String}
     */
    static BCRYPT_KDF_HASH => "HASH"

    /**
     * @type {String}
     */
    static BCRYPT_KDF_HMAC => "HMAC"

    /**
     * @type {String}
     */
    static BCRYPT_KDF_TLS_PRF => "TLS_PRF"

    /**
     * @type {String}
     */
    static BCRYPT_KDF_SP80056A_CONCAT => "SP800_56A_CONCAT"

    /**
     * @type {String}
     */
    static BCRYPT_KDF_RAW_SECRET => "TRUNCATE"

    /**
     * @type {String}
     */
    static BCRYPT_KDF_HKDF => "HKDF"

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_HASH_ALGORITHM => 0

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_SECRET_PREPEND => 1

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_SECRET_APPEND => 2

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_HMAC_KEY => 3

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_TLS_PRF_LABEL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_TLS_PRF_SEED => 5

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_SECRET_HANDLE => 6

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_TLS_PRF_PROTOCOL => 7

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_ALGORITHMID => 8

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_PARTYUINFO => 9

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_PARTYVINFO => 10

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_SUPPPUBINFO => 11

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_SUPPPRIVINFO => 12

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_LABEL => 13

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_CONTEXT => 14

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_SALT => 15

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_ITERATION_COUNT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_GENERIC_PARAMETER => 17

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_KEYBITLENGTH => 18

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_HKDF_SALT => 19

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_HKDF_INFO => 20

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_USE_SECRET_AS_HMAC_KEY_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_AUTH_MODE_IN_PROGRESS_FLAG => 2

    /**
     * @type {String}
     */
    static BCRYPT_OPAQUE_KEY_BLOB => "OpaqueKeyBlob"

    /**
     * @type {String}
     */
    static BCRYPT_KEY_DATA_BLOB => "KeyDataBlob"

    /**
     * @type {String}
     */
    static BCRYPT_AES_WRAP_KEY_BLOB => "Rfc3565KeyWrapBlob"

    /**
     * @type {String}
     */
    static BCRYPT_PKCS11_RSA_AES_WRAP_KEY_BLOB => "PKCS11RsaAesWrapBlob"

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_PKCS11_RSA_AES_WRAP_BLOB_MAGIC => 1464877394

    /**
     * @type {String}
     */
    static BCRYPT_OBJECT_LENGTH => "ObjectLength"

    /**
     * @type {String}
     */
    static BCRYPT_ALGORITHM_NAME => "AlgorithmName"

    /**
     * @type {String}
     */
    static BCRYPT_PROVIDER_HANDLE => "ProviderHandle"

    /**
     * @type {String}
     */
    static BCRYPT_CHAINING_MODE => "ChainingMode"

    /**
     * @type {String}
     */
    static BCRYPT_BLOCK_LENGTH => "BlockLength"

    /**
     * @type {String}
     */
    static BCRYPT_KEY_LENGTH => "KeyLength"

    /**
     * @type {String}
     */
    static BCRYPT_KEY_OBJECT_LENGTH => "KeyObjectLength"

    /**
     * @type {String}
     */
    static BCRYPT_KEY_STRENGTH => "KeyStrength"

    /**
     * @type {String}
     */
    static BCRYPT_KEY_LENGTHS => "KeyLengths"

    /**
     * @type {String}
     */
    static BCRYPT_BLOCK_SIZE_LIST => "BlockSizeList"

    /**
     * @type {String}
     */
    static BCRYPT_EFFECTIVE_KEY_LENGTH => "EffectiveKeyLength"

    /**
     * @type {String}
     */
    static BCRYPT_HASH_LENGTH => "HashDigestLength"

    /**
     * @type {String}
     */
    static BCRYPT_HASH_OID_LIST => "HashOIDList"

    /**
     * @type {String}
     */
    static BCRYPT_PADDING_SCHEMES => "PaddingSchemes"

    /**
     * @type {String}
     */
    static BCRYPT_SIGNATURE_LENGTH => "SignatureLength"

    /**
     * @type {String}
     */
    static BCRYPT_HASH_BLOCK_LENGTH => "HashBlockLength"

    /**
     * @type {String}
     */
    static BCRYPT_AUTH_TAG_LENGTH => "AuthTagLength"

    /**
     * @type {String}
     */
    static BCRYPT_FUNCTION_NAME_STRING => "FunctionNameString"

    /**
     * @type {String}
     */
    static BCRYPT_CUSTOMIZATION_STRING => "CustomizationString"

    /**
     * @type {String}
     */
    static BCRYPT_PRIMITIVE_TYPE => "PrimitiveType"

    /**
     * @type {String}
     */
    static BCRYPT_IS_KEYED_HASH => "IsKeyedHash"

    /**
     * @type {String}
     */
    static BCRYPT_IS_REUSABLE_HASH => "IsReusableHash"

    /**
     * @type {String}
     */
    static BCRYPT_MESSAGE_BLOCK_LENGTH => "MessageBlockLength"

    /**
     * @type {String}
     */
    static BCRYPT_PUBLIC_KEY_LENGTH => "PublicKeyLength"

    /**
     * @type {String}
     */
    static BCRYPT_PCP_PLATFORM_TYPE_PROPERTY => "PCP_PLATFORM_TYPE"

    /**
     * @type {String}
     */
    static BCRYPT_PCP_PROVIDER_VERSION_PROPERTY => "PCP_PROVIDER_VERSION"

    /**
     * @type {String}
     */
    static BCRYPT_MULTI_OBJECT_LENGTH => "MultiObjectLength"

    /**
     * @type {String}
     */
    static BCRYPT_IS_IFX_TPM_WEAK_KEY => "IsIfxTpmWeakKey"

    /**
     * @type {String}
     */
    static BCRYPT_HKDF_HASH_ALGORITHM => "HkdfHashAlgorithm"

    /**
     * @type {String}
     */
    static BCRYPT_HKDF_SALT_AND_FINALIZE => "HkdfSaltAndFinalize"

    /**
     * @type {String}
     */
    static BCRYPT_HKDF_PRK_AND_FINALIZE => "HkdfPrkAndFinalize"

    /**
     * @type {String}
     */
    static BCRYPT_INITIALIZATION_VECTOR => "IV"

    /**
     * @type {String}
     */
    static BCRYPT_CHAIN_MODE_NA => "ChainingModeN/A"

    /**
     * @type {String}
     */
    static BCRYPT_CHAIN_MODE_CBC => "ChainingModeCBC"

    /**
     * @type {String}
     */
    static BCRYPT_CHAIN_MODE_ECB => "ChainingModeECB"

    /**
     * @type {String}
     */
    static BCRYPT_CHAIN_MODE_CFB => "ChainingModeCFB"

    /**
     * @type {String}
     */
    static BCRYPT_CHAIN_MODE_CCM => "ChainingModeCCM"

    /**
     * @type {String}
     */
    static BCRYPT_CHAIN_MODE_GCM => "ChainingModeGCM"

    /**
     * @type {String}
     */
    static BCRYPT_CHAIN_MODE_KWP => "ChainingModeKWP"

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_SUPPORTED_PAD_ROUTER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_SUPPORTED_PAD_PKCS1_ENC => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_SUPPORTED_PAD_PKCS1_SIG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_SUPPORTED_PAD_OAEP => 8

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_SUPPORTED_PAD_PSS => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_GENERATE_IV => 32

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_PAD_PKCS1_OPTIONAL_HASH_OID => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPTBUFFER_VERSION => 0

    /**
     * @type {String}
     */
    static BCRYPT_PUBLIC_KEY_BLOB => "PUBLICBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_PRIVATE_KEY_BLOB => "PRIVATEBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_RSAPUBLIC_BLOB => "RSAPUBLICBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_RSAPRIVATE_BLOB => "RSAPRIVATEBLOB"

    /**
     * @type {String}
     */
    static LEGACY_RSAPUBLIC_BLOB => "CAPIPUBLICBLOB"

    /**
     * @type {String}
     */
    static LEGACY_RSAPRIVATE_BLOB => "CAPIPRIVATEBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_RSAFULLPRIVATE_BLOB => "RSAFULLPRIVATEBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_GLOBAL_PARAMETERS => "SecretAgreementParam"

    /**
     * @type {String}
     */
    static BCRYPT_PRIVATE_KEY => "PrivKeyVal"

    /**
     * @type {String}
     */
    static BCRYPT_ECCPUBLIC_BLOB => "ECCPUBLICBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_ECCPRIVATE_BLOB => "ECCPRIVATEBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_ECCFULLPUBLIC_BLOB => "ECCFULLPUBLICBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_ECCFULLPRIVATE_BLOB => "ECCFULLPRIVATEBLOB"

    /**
     * @type {String}
     */
    static SSL_ECCPUBLIC_BLOB => "SSLECCPUBLICBLOB"

    /**
     * @type {String}
     */
    static TLS_13_PRE_SHARED_KEY => "TLS13PRESHAREDKEY"

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_PUBLIC_P256_MAGIC => 827016005

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_PRIVATE_P256_MAGIC => 843793221

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_PUBLIC_P384_MAGIC => 860570437

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_PRIVATE_P384_MAGIC => 877347653

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_PUBLIC_P521_MAGIC => 894124869

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_PRIVATE_P521_MAGIC => 910902085

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_PUBLIC_GENERIC_MAGIC => 1347109701

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_PRIVATE_GENERIC_MAGIC => 1447772997

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_PUBLIC_P256_MAGIC => 827540293

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_PRIVATE_P256_MAGIC => 844317509

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_PUBLIC_P384_MAGIC => 861094725

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_PRIVATE_P384_MAGIC => 877871941

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_PUBLIC_P521_MAGIC => 894649157

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_PRIVATE_P521_MAGIC => 911426373

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_PUBLIC_GENERIC_MAGIC => 1346650949

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_PRIVATE_GENERIC_MAGIC => 1447314245

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECC_FULLKEY_BLOB_V1 => 1

    /**
     * @type {String}
     */
    static BCRYPT_DH_PUBLIC_BLOB => "DHPUBLICBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_DH_PRIVATE_BLOB => "DHPRIVATEBLOB"

    /**
     * @type {String}
     */
    static LEGACY_DH_PUBLIC_BLOB => "CAPIDHPUBLICBLOB"

    /**
     * @type {String}
     */
    static LEGACY_DH_PRIVATE_BLOB => "CAPIDHPRIVATEBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_DH_PARAMETERS => "DHParameters"

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DH_PARAMETERS_MAGIC => 1297107012

    /**
     * @type {String}
     */
    static BCRYPT_DSA_PUBLIC_BLOB => "DSAPUBLICBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_DSA_PRIVATE_BLOB => "DSAPRIVATEBLOB"

    /**
     * @type {String}
     */
    static LEGACY_DSA_PUBLIC_BLOB => "CAPIDSAPUBLICBLOB"

    /**
     * @type {String}
     */
    static LEGACY_DSA_PRIVATE_BLOB => "CAPIDSAPRIVATEBLOB"

    /**
     * @type {String}
     */
    static LEGACY_DSA_V2_PUBLIC_BLOB => "V2CAPIDSAPUBLICBLOB"

    /**
     * @type {String}
     */
    static LEGACY_DSA_V2_PRIVATE_BLOB => "V2CAPIDSAPRIVATEBLOB"

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DSA_PUBLIC_MAGIC_V2 => 843206724

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DSA_PRIVATE_MAGIC_V2 => 844517444

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_KEY_DATA_BLOB_MAGIC => 1296188491

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_KEY_DATA_BLOB_VERSION1 => 1

    /**
     * @type {String}
     */
    static BCRYPT_DSA_PARAMETERS => "DSAParameters"

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DSA_PARAMETERS_MAGIC => 1297109828

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DSA_PARAMETERS_MAGIC_V2 => 843927620

    /**
     * @type {String}
     */
    static BCRYPT_ECC_PARAMETERS => "ECCParameters"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NAME => "ECCCurveName"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NAME_LIST => "ECCCurveNameList"

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECC_PARAMETERS_MAGIC => 1346585413

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP160R1 => "brainpoolP160r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP160T1 => "brainpoolP160t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP192R1 => "brainpoolP192r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP192T1 => "brainpoolP192t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP224R1 => "brainpoolP224r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP224T1 => "brainpoolP224t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP256R1 => "brainpoolP256r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP256T1 => "brainpoolP256t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP320R1 => "brainpoolP320r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP320T1 => "brainpoolP320t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP384R1 => "brainpoolP384r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP384T1 => "brainpoolP384t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP512R1 => "brainpoolP512r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP512T1 => "brainpoolP512t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_25519 => "curve25519"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_EC192WAPI => "ec192wapi"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NISTP192 => "nistP192"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NISTP224 => "nistP224"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NISTP256 => "nistP256"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NISTP384 => "nistP384"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NISTP521 => "nistP521"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NUMSP256T1 => "numsP256t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NUMSP384T1 => "numsP384t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NUMSP512T1 => "numsP512t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP160K1 => "secP160k1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP160R1 => "secP160r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP160R2 => "secP160r2"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP192K1 => "secP192k1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP192R1 => "secP192r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP224K1 => "secP224k1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP224R1 => "secP224r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP256K1 => "secP256k1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP256R1 => "secP256r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP384R1 => "secP384r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP521R1 => "secP521r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_WTLS7 => "wtls7"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_WTLS9 => "wtls9"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_WTLS12 => "wtls12"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_X962P192V1 => "x962P192v1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_X962P192V2 => "x962P192v2"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_X962P192V3 => "x962P192v3"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_X962P239V1 => "x962P239v1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_X962P239V2 => "x962P239v2"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_X962P239V3 => "x962P239v3"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_X962P256V1 => "x962P256v1"

    /**
     * @type {String}
     */
    static MS_PRIMITIVE_PROVIDER => "Microsoft Primitive Provider"

    /**
     * @type {String}
     */
    static MS_PLATFORM_CRYPTO_PROVIDER => "Microsoft Platform Crypto Provider"

    /**
     * @type {String}
     */
    static BCRYPT_RSA_ALGORITHM => "RSA"

    /**
     * @type {String}
     */
    static BCRYPT_RSA_SIGN_ALGORITHM => "RSA_SIGN"

    /**
     * @type {String}
     */
    static BCRYPT_DH_ALGORITHM => "DH"

    /**
     * @type {String}
     */
    static BCRYPT_DSA_ALGORITHM => "DSA"

    /**
     * @type {String}
     */
    static BCRYPT_RC2_ALGORITHM => "RC2"

    /**
     * @type {String}
     */
    static BCRYPT_RC4_ALGORITHM => "RC4"

    /**
     * @type {String}
     */
    static BCRYPT_AES_ALGORITHM => "AES"

    /**
     * @type {String}
     */
    static BCRYPT_DES_ALGORITHM => "DES"

    /**
     * @type {String}
     */
    static BCRYPT_DESX_ALGORITHM => "DESX"

    /**
     * @type {String}
     */
    static BCRYPT_3DES_ALGORITHM => "3DES"

    /**
     * @type {String}
     */
    static BCRYPT_3DES_112_ALGORITHM => "3DES_112"

    /**
     * @type {String}
     */
    static BCRYPT_MD2_ALGORITHM => "MD2"

    /**
     * @type {String}
     */
    static BCRYPT_MD4_ALGORITHM => "MD4"

    /**
     * @type {String}
     */
    static BCRYPT_MD5_ALGORITHM => "MD5"

    /**
     * @type {String}
     */
    static BCRYPT_SHA1_ALGORITHM => "SHA1"

    /**
     * @type {String}
     */
    static BCRYPT_SHA256_ALGORITHM => "SHA256"

    /**
     * @type {String}
     */
    static BCRYPT_SHA384_ALGORITHM => "SHA384"

    /**
     * @type {String}
     */
    static BCRYPT_SHA512_ALGORITHM => "SHA512"

    /**
     * @type {String}
     */
    static BCRYPT_AES_GMAC_ALGORITHM => "AES-GMAC"

    /**
     * @type {String}
     */
    static BCRYPT_AES_CMAC_ALGORITHM => "AES-CMAC"

    /**
     * @type {String}
     */
    static BCRYPT_ECDSA_P256_ALGORITHM => "ECDSA_P256"

    /**
     * @type {String}
     */
    static BCRYPT_ECDSA_P384_ALGORITHM => "ECDSA_P384"

    /**
     * @type {String}
     */
    static BCRYPT_ECDSA_P521_ALGORITHM => "ECDSA_P521"

    /**
     * @type {String}
     */
    static BCRYPT_ECDH_P256_ALGORITHM => "ECDH_P256"

    /**
     * @type {String}
     */
    static BCRYPT_ECDH_P384_ALGORITHM => "ECDH_P384"

    /**
     * @type {String}
     */
    static BCRYPT_ECDH_P521_ALGORITHM => "ECDH_P521"

    /**
     * @type {String}
     */
    static BCRYPT_RNG_ALGORITHM => "RNG"

    /**
     * @type {String}
     */
    static BCRYPT_RNG_FIPS186_DSA_ALGORITHM => "FIPS186DSARNG"

    /**
     * @type {String}
     */
    static BCRYPT_RNG_DUAL_EC_ALGORITHM => "DUALECRNG"

    /**
     * @type {String}
     */
    static BCRYPT_SP800108_CTR_HMAC_ALGORITHM => "SP800_108_CTR_HMAC"

    /**
     * @type {String}
     */
    static BCRYPT_SP80056A_CONCAT_ALGORITHM => "SP800_56A_CONCAT"

    /**
     * @type {String}
     */
    static BCRYPT_PBKDF2_ALGORITHM => "PBKDF2"

    /**
     * @type {String}
     */
    static BCRYPT_CAPI_KDF_ALGORITHM => "CAPI_KDF"

    /**
     * @type {String}
     */
    static BCRYPT_TLS1_1_KDF_ALGORITHM => "TLS1_1_KDF"

    /**
     * @type {String}
     */
    static BCRYPT_TLS1_2_KDF_ALGORITHM => "TLS1_2_KDF"

    /**
     * @type {String}
     */
    static BCRYPT_ECDSA_ALGORITHM => "ECDSA"

    /**
     * @type {String}
     */
    static BCRYPT_ECDH_ALGORITHM => "ECDH"

    /**
     * @type {String}
     */
    static BCRYPT_XTS_AES_ALGORITHM => "XTS-AES"

    /**
     * @type {String}
     */
    static BCRYPT_HKDF_ALGORITHM => "HKDF"

    /**
     * @type {String}
     */
    static BCRYPT_CHACHA20_POLY1305_ALGORITHM => "CHACHA20_POLY1305"

    /**
     * @type {String}
     */
    static BCRYPT_SHA3_256_ALGORITHM => "SHA3-256"

    /**
     * @type {String}
     */
    static BCRYPT_SHA3_384_ALGORITHM => "SHA3-384"

    /**
     * @type {String}
     */
    static BCRYPT_SHA3_512_ALGORITHM => "SHA3-512"

    /**
     * @type {String}
     */
    static BCRYPT_CSHAKE128_ALGORITHM => "CSHAKE128"

    /**
     * @type {String}
     */
    static BCRYPT_CSHAKE256_ALGORITHM => "CSHAKE256"

    /**
     * @type {String}
     */
    static BCRYPT_KMAC128_ALGORITHM => "KMAC128"

    /**
     * @type {String}
     */
    static BCRYPT_KMAC256_ALGORITHM => "KMAC256"

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_KEY_DERIVATION_INTERFACE => 7

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_MD2_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 1}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_MD4_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 17}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_MD5_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 33}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_SHA1_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 49}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_SHA256_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 65}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_SHA384_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 81}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_SHA512_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 97}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_RC4_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 113}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_RNG_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 129}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_HMAC_MD5_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 145}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_HMAC_SHA1_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 161}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_HMAC_SHA256_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 177}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_HMAC_SHA384_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 193}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_HMAC_SHA512_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 209}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_RSA_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 225}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_ECDSA_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 241}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_AES_CMAC_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 257}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_AES_GMAC_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 273}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_HMAC_MD2_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 289}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_HMAC_MD4_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 305}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_3DES_CBC_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 321}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_3DES_ECB_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 337}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_3DES_CFB_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 353}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_3DES_112_CBC_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 369}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_3DES_112_ECB_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 385}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_3DES_112_CFB_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 401}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_AES_CBC_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 417}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_AES_ECB_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 433}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_AES_CFB_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 449}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_AES_CCM_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 465}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_AES_GCM_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 481}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_DES_CBC_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 497}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_DES_ECB_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 513}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_DES_CFB_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 529}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_DESX_CBC_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 545}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_DESX_ECB_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 561}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_DESX_CFB_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 577}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_RC2_CBC_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 593}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_RC2_ECB_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 609}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_RC2_CFB_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 625}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_DH_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 641}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_ECDH_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 657}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_ECDH_P256_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 673}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_ECDH_P384_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 689}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_ECDH_P521_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 705}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_DSA_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 721}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_ECDSA_P256_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 737}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_ECDSA_P384_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 753}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_ECDSA_P521_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 769}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_RSA_SIGN_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 785}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_CAPI_KDF_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 801}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_PBKDF2_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 817}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_SP800108_CTR_HMAC_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 833}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_SP80056A_CONCAT_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 849}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_TLS1_1_KDF_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 865}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_TLS1_2_KDF_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 881}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_XTS_AES_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 897}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_HKDF_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 913}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_CHACHA20_POLY1305_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 929}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_SHA3_256_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 945}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_SHA3_384_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 961}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_SHA3_512_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 977}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_HMAC_SHA3_256_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 993}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_HMAC_SHA3_384_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 1009}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_HMAC_SHA3_512_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 1025}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_CSHAKE128_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 1041}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_CSHAKE256_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 1057}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_KMAC128_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 1073}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_KMAC256_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 1089}, false)

    /**
     * @type {BCRYPT_ALG_HANDLE}
     */
    static BCRYPT_AES_KWP_ALG_HANDLE => BCRYPT_ALG_HANDLE({Value: 1105}, false)

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_CAPI_AES_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_MULTI_FLAG => 64

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_HASH_DONT_RESET_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_TLS_CBC_HMAC_VERIFY_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_BUFFERS_LOCKED_FLAG => 64

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_EXTENDED_KEYSIZE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ENABLE_INCOMPATIBLE_FIPS_CHECKS => 256

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_KEY_DERIVATION_OPERATION => 64

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_PUBLIC_KEY_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_PRIVATE_KEY_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_NO_KEY_VALIDATION => 8

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_KEY_VALIDATION_RANGE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_KEY_VALIDATION_RANGE_AND_ORDER => 24

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_KEY_VALIDATION_REGENERATE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_HASH_INTERFACE_MAJORVERSION_2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OVERWRITE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_PRIORITY_TOP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_PRIORITY_BOTTOM => 4294967295

    /**
     * @type {String}
     */
    static CRYPT_DEFAULT_CONTEXT => "Default"

    /**
     * @type {String}
     */
    static wszXMLNS_DIGSIG => "http://www.w3.org/2000/09/xmldsig#"

    /**
     * @type {String}
     */
    static wszXMLNS_DIGSIG_SignatureProperties => "http://www.w3.org/2000/09/xmldsig#SignatureProperties"

    /**
     * @type {String}
     */
    static wszXMLNS_DIGSIG_Id => "Id"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_BASE64 => "http://www.w3.org/2000/09/xmldsig#base64"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_SHA1 => "http://www.w3.org/2000/09/xmldsig#sha1"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_SHA256 => "http://www.w3.org/2001/04/xmlenc#sha256"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_SHA384 => "http://www.w3.org/2001/04/xmldsig-more#sha384"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_SHA512 => "http://www.w3.org/2001/04/xmlenc#sha512"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_RSA_SHA1 => "http://www.w3.org/2000/09/xmldsig#rsa-sha1"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_DSA_SHA1 => "http://www.w3.org/2000/09/xmldsig#dsa-sha1"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_RSA_SHA256 => "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_RSA_SHA384 => "http://www.w3.org/2001/04/xmldsig-more#rsa-sha384"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_RSA_SHA512 => "http://www.w3.org/2001/04/xmldsig-more#rsa-sha512"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_ECDSA_SHA1 => "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha1"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_ECDSA_SHA256 => "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_ECDSA_SHA384 => "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_ECDSA_SHA512 => "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_HMAC_SHA1 => "http://www.w3.org/2000/09/xmldsig#hmac-sha1"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_HMAC_SHA256 => "http://www.w3.org/2001/04/xmldsig-more#hmac-sha256"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_HMAC_SHA384 => "http://www.w3.org/2001/04/xmldsig-more#hmac-sha384"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_HMAC_SHA512 => "http://www.w3.org/2001/04/xmldsig-more#hmac-sha512"

    /**
     * @type {String}
     */
    static wszURI_CANONICALIZATION_C14N => "http://www.w3.org/TR/2001/REC-xml-c14n-20010315"

    /**
     * @type {String}
     */
    static wszURI_CANONICALIZATION_C14NC => "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments"

    /**
     * @type {String}
     */
    static wszURI_CANONICALIZATION_EXSLUSIVE_C14N => "http://www.w3.org/2001/10/xml-exc-c14n#"

    /**
     * @type {String}
     */
    static wszURI_CANONICALIZATION_EXSLUSIVE_C14NC => "http://www.w3.org/2001/10/xml-exc-c14n#WithComments"

    /**
     * @type {String}
     */
    static wszURI_TRANSFORM_XPATH => "http://www.w3.org/TR/1999/REC-xpath-19991116"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_TRANSFORM_BASE64 => "http://www.w3.org/2000/09/xmldsig#base64"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_TRANSFORM_ENVELOPED => "http://www.w3.org/2000/09/xmldsig#enveloped-signature"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_BLOB_MAX => 2147483640

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_ID_MAX => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_SIGNATURES_MAX => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_TRANSFORM_MAX => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_SIGNATURE_VALUE_MAX => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_DIGEST_VALUE_MAX => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_OBJECTS_MAX => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_REFERENCES_MAX => 32760

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_BASE => -2146885376

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_LARGE => -2146885375

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_TOO_MANY_TRANSFORMS => -2146885374

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_ENCODING => -2146885373

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_ALGORITHM => -2146885372

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_TRANSFORM => -2146885371

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_HANDLE => -2146885370

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_OPERATION => -2146885369

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_UNRESOLVED_REFERENCE => -2146885368

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_INVALID_DIGEST => -2146885367

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_INVALID_SIGNATURE => -2146885366

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_HASH_FAILED => -2146885365

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_SIGN_FAILED => -2146885364

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_VERIFY_FAILED => -2146885363

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_TOO_MANY_SIGNATURES => -2146885362

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_INVALID_KEYVALUE => -2146885361

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_UNEXPECTED_XML => -2146885360

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_SIGNER => -2146885359

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_NON_UNIQUE_ID => -2146885358

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_LAST => -2146885358

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_FLAG_ALWAYS_RETURN_ENCODED_OBJECT => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_FLAG_ENFORCE_ID_NCNAME_FORMAT => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_FLAG_ENFORCE_ID_NAME_FORMAT => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_FLAG_ECDSA_DSIG11 => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_STATUS_NO_ERROR => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_FLAG_ADD_OBJECT_CREATE_COPY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_FLAG_CREATE_REFERENCE_AS_OBJECT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_DIGEST_REFERENCE_DATA_TRANSFORMED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_ALGORITHM_INFO_FIND_BY_URI => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_ALGORITHM_INFO_FIND_BY_NAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_ALGORITHM_INFO_FIND_BY_CNG_ALGID => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_ALGORITHM_INFO_FIND_BY_CNG_SIGN_ALGID => 4

    /**
     * @type {String}
     */
    static szFORCE_KEY_PROTECTION => "ForceKeyProtection"

    /**
     * @type {Integer (UInt32)}
     */
    static dwFORCE_KEY_PROTECTION_DISABLED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static dwFORCE_KEY_PROTECTION_USER_SELECT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static dwFORCE_KEY_PROTECTION_HIGH => 2

    /**
     * @type {Guid}
     */
    static CRYPTPROTECT_DEFAULT_PROVIDER => Guid("{df9d8cd0-1501-11d1-8c7a-00c04fc297eb}")

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_PROMPT_ON_UNPROTECT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_PROMPT_ON_PROTECT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_PROMPT_RESERVED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_PROMPT_STRONG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_PROMPT_REQUIRE_STRONG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_UI_FORBIDDEN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_LOCAL_MACHINE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_CRED_SYNC => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_AUDIT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_NO_RECOVERY => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_VERIFY_PROTECTION => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_CRED_REGENERATE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_FIRST_RESERVED_FLAGVAL => 268435455

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_LAST_RESERVED_FLAGVAL => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECTMEMORY_BLOCK_SIZE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECTMEMORY_SAME_PROCESS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECTMEMORY_CROSS_PROCESS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECTMEMORY_SAME_LOGON => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_MAX_KEY_NAME_LENGTH => 512

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_MAX_ALG_ID_LENGTH => 512

    /**
     * @type {String}
     */
    static MS_KEY_STORAGE_PROVIDER => "Microsoft Software Key Storage Provider"

    /**
     * @type {String}
     */
    static MS_SMART_CARD_KEY_STORAGE_PROVIDER => "Microsoft Smart Card Key Storage Provider"

    /**
     * @type {String}
     */
    static MS_PLATFORM_KEY_STORAGE_PROVIDER => "Microsoft Platform Crypto Provider"

    /**
     * @type {String}
     */
    static MS_NGC_KEY_STORAGE_PROVIDER => "Microsoft Passport Key Storage Provider"

    /**
     * @type {String}
     */
    static MS_PLUTON_CRYPTO_PROVIDER => "Microsoft Pluton Cryptographic Provider"

    /**
     * @type {String}
     */
    static TPM_RSA_SRK_SEAL_KEY => "MICROSOFT_PCP_KSP_RSA_SEAL_KEY_3BD1C4BF-004E-4E2F-8A4D-0BF633DCB074"

    /**
     * @type {String}
     */
    static NCRYPT_RSA_ALGORITHM => "RSA"

    /**
     * @type {String}
     */
    static NCRYPT_RSA_SIGN_ALGORITHM => "RSA_SIGN"

    /**
     * @type {String}
     */
    static NCRYPT_DH_ALGORITHM => "DH"

    /**
     * @type {String}
     */
    static NCRYPT_DSA_ALGORITHM => "DSA"

    /**
     * @type {String}
     */
    static NCRYPT_MD2_ALGORITHM => "MD2"

    /**
     * @type {String}
     */
    static NCRYPT_MD4_ALGORITHM => "MD4"

    /**
     * @type {String}
     */
    static NCRYPT_MD5_ALGORITHM => "MD5"

    /**
     * @type {String}
     */
    static NCRYPT_SHA1_ALGORITHM => "SHA1"

    /**
     * @type {String}
     */
    static NCRYPT_SHA256_ALGORITHM => "SHA256"

    /**
     * @type {String}
     */
    static NCRYPT_SHA384_ALGORITHM => "SHA384"

    /**
     * @type {String}
     */
    static NCRYPT_SHA512_ALGORITHM => "SHA512"

    /**
     * @type {String}
     */
    static NCRYPT_ECDSA_P256_ALGORITHM => "ECDSA_P256"

    /**
     * @type {String}
     */
    static NCRYPT_ECDSA_P384_ALGORITHM => "ECDSA_P384"

    /**
     * @type {String}
     */
    static NCRYPT_ECDSA_P521_ALGORITHM => "ECDSA_P521"

    /**
     * @type {String}
     */
    static NCRYPT_ECDH_P256_ALGORITHM => "ECDH_P256"

    /**
     * @type {String}
     */
    static NCRYPT_ECDH_P384_ALGORITHM => "ECDH_P384"

    /**
     * @type {String}
     */
    static NCRYPT_ECDH_P521_ALGORITHM => "ECDH_P521"

    /**
     * @type {String}
     */
    static NCRYPT_AES_ALGORITHM => "AES"

    /**
     * @type {String}
     */
    static NCRYPT_RC2_ALGORITHM => "RC2"

    /**
     * @type {String}
     */
    static NCRYPT_3DES_ALGORITHM => "3DES"

    /**
     * @type {String}
     */
    static NCRYPT_DES_ALGORITHM => "DES"

    /**
     * @type {String}
     */
    static NCRYPT_DESX_ALGORITHM => "DESX"

    /**
     * @type {String}
     */
    static NCRYPT_3DES_112_ALGORITHM => "3DES_112"

    /**
     * @type {String}
     */
    static NCRYPT_SP800108_CTR_HMAC_ALGORITHM => "SP800_108_CTR_HMAC"

    /**
     * @type {String}
     */
    static NCRYPT_SP80056A_CONCAT_ALGORITHM => "SP800_56A_CONCAT"

    /**
     * @type {String}
     */
    static NCRYPT_PBKDF2_ALGORITHM => "PBKDF2"

    /**
     * @type {String}
     */
    static NCRYPT_CAPI_KDF_ALGORITHM => "CAPI_KDF"

    /**
     * @type {String}
     */
    static NCRYPT_ECDSA_ALGORITHM => "ECDSA"

    /**
     * @type {String}
     */
    static NCRYPT_ECDH_ALGORITHM => "ECDH"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_STORAGE_ALGORITHM => "KEY_STORAGE"

    /**
     * @type {String}
     */
    static NCRYPT_HMAC_SHA256_ALGORITHM => "HMAC-SHA256"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_KEY_DERIVATION_INTERFACE => 7

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_KEY_PROTECTION_INTERFACE => 65540

    /**
     * @type {String}
     */
    static NCRYPT_RSA_ALGORITHM_GROUP => "RSA"

    /**
     * @type {String}
     */
    static NCRYPT_DH_ALGORITHM_GROUP => "DH"

    /**
     * @type {String}
     */
    static NCRYPT_DSA_ALGORITHM_GROUP => "DSA"

    /**
     * @type {String}
     */
    static NCRYPT_ECDSA_ALGORITHM_GROUP => "ECDSA"

    /**
     * @type {String}
     */
    static NCRYPT_ECDH_ALGORITHM_GROUP => "ECDH"

    /**
     * @type {String}
     */
    static NCRYPT_AES_ALGORITHM_GROUP => "AES"

    /**
     * @type {String}
     */
    static NCRYPT_RC2_ALGORITHM_GROUP => "RC2"

    /**
     * @type {String}
     */
    static NCRYPT_DES_ALGORITHM_GROUP => "DES"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_DERIVATION_GROUP => "KEY_DERIVATION"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_EMPTY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_DATA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PROTECTION_DESCRIPTOR_STRING => 3

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PROTECTION_FLAGS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_SSL_CLIENT_RANDOM => 20

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_SSL_SERVER_RANDOM => 21

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_SSL_HIGHEST_VERSION => 22

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_SSL_CLEAR_KEY => 23

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_SSL_KEY_ARG_DATA => 24

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_SSL_SESSION_HASH => 25

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PKCS_OID => 40

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PKCS_ALG_OID => 41

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PKCS_ALG_PARAM => 42

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PKCS_ALG_ID => 43

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PKCS_ATTRS => 44

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PKCS_KEY_NAME => 45

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PKCS_SECRET => 46

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_CERT_BLOB => 47

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_CLAIM_IDBINDING_NONCE => 48

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_CLAIM_KEYATTESTATION_NONCE => 49

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_KEY_PROPERTY_FLAGS => 50

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_ATTESTATIONSTATEMENT_BLOB => 51

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_ATTESTATION_CLAIM_TYPE => 52

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_ATTESTATION_CLAIM_CHALLENGE_REQUIRED => 53

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_ECC_CURVE_NAME => 60

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_ECC_PARAMETERS => 61

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_TPM_SEAL_PASSWORD => 70

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_TPM_SEAL_POLICYINFO => 71

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_TPM_SEAL_TICKET => 72

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_TPM_SEAL_NO_DA_PROTECTION => 73

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_TPM_PLATFORM_CLAIM_PCR_MASK => 80

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_TPM_PLATFORM_CLAIM_NONCE => 81

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_TPM_PLATFORM_CLAIM_STATIC_CREATE => 82

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_ATTESTATION_STATEMENT_SIGNATURE_HASH => 90

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_ATTESTATION_STATEMENT_SIGNATURE_PADDING_SCHEME => 91

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_ATTESTATION_STATEMENT_SIGNATURE_PADDING_ALGO => 92

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_ATTESTATION_STATEMENT_SIGNATURE_PADDING_SALT_SIZE => 93

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_ATTESTATION_STATEMENT_SIGNATURE_PADDING_SALT => 93

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_ATTESTATION_STATEMENT_NONCE => 49

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_VBS_ATTESTATION_STATEMENT_ROOT_DETAILS => 94

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_VBS_ATTESTATION_STATEMENT_IDENTITY_DETAILS => 95

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CIPHER_NO_PADDING_FLAG => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CIPHER_BLOCK_PADDING_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CIPHER_OTHER_PADDING_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PLATFORM_ATTEST_MAGIC => 1146110288

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_KEY_ATTEST_MAGIC => 1146110283

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CLAIM_AUTHORITY_ONLY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CLAIM_SUBJECT_ONLY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CLAIM_AUTHORITY_AND_SUBJECT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CLAIM_VBS_KEY_ATTESTATION_STATEMENT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CLAIM_VBS_ROOT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CLAIM_VBS_IDENTITY => 6

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CLAIM_WEB_AUTH_SUBJECT_ONLY => 258

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CLAIM_UNKNOWN => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CLAIM_PLATFORM => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CLAIM_WEB_AUTH_SUBJECT_ONLY_V2 => 259

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ISOLATED_KEY_FLAG_CREATED_IN_ISOLATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ISOLATED_KEY_FLAG_IMPORT_ONLY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ISOLATED_KEY_FLAG_PER_BOOT_KEY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VBS_KEY_FLAG_CREATED_IN_ISOLATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VBS_KEY_FLAG_IMPORT_ONLY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VBS_KEY_FLAG_PER_BOOT_KEY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VBS_KEY_FLAG_IMPORT_EPHEMERAL_ONLY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_V0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VBS_KEY_ATTESTED_ATTRIBUTES_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_V0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VBS_ROOT_ATTESTATION_HEADER_V0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VBS_ROOT_ATTESTATION_HEADER_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static VBS_ROOT_ATTESTATION_HEADER_MAGIC => 1212371542

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VBS_IDENTITY_ATTESTATION_PADDING_V0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VBS_IDENTITY_ATTESTATION_PADDING_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VBS_IDENTITY_ATTESTATION_HEADER_V0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VBS_IDENTITY_ATTESTATION_HEADER_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static VBS_IDENTITY_ATTESTATION_HEADER_MAGIC => 1212369238

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VBS_KEY_ATTESTATION_STATEMENT_V1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VBS_KEY_ATTESTATION_STATEMENT_V2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VBS_KEY_ATTESTATION_STATEMENT_CURRENT_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static VBS_KEY_ATTESTATION_STATEMENT_MAGIC => 1396788054

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_V0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PAD_CIPHER_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ATTESTATION_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SEALING_FLAG => 256

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_DO_NOT_FINALIZE_FLAG => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_EXPORT_LEGACY_FLAG => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_IGNORE_DEVICE_STATE_FLAG => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TREAT_NIST_AS_GENERIC_ECC_FLAG => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_NO_CACHED_PASSWORD => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PROTECT_TO_LOCAL_SYSTEM => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_REQUIRE_KDS_LRPC_BIND_FLAG => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PREFER_VIRTUAL_ISOLATION_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_USE_VIRTUAL_ISOLATION_FLAG => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_USE_PER_BOOT_KEY_FLAG => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PREFER_VBS_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_REQUIRE_VBS_FLAG => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_USE_VBS_PER_BOOT_KEY_FLAG => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VBS_RETURN_CLAIM_DETAILS_FLAG => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_KEY_DERIVATION_OPERATION => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_AUTHORITY_KEY_FLAG => 256

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_EXTENDED_ERRORS_FLAG => 268435456

    /**
     * @type {String}
     */
    static NCRYPT_NAME_PROPERTY => "Name"

    /**
     * @type {String}
     */
    static NCRYPT_EPHEMERAL_NAME_PROPERTY => "Ephemeral Name"

    /**
     * @type {String}
     */
    static NCRYPT_UNIQUE_NAME_PROPERTY => "Unique Name"

    /**
     * @type {String}
     */
    static NCRYPT_ALGORITHM_PROPERTY => "Algorithm Name"

    /**
     * @type {String}
     */
    static NCRYPT_LENGTH_PROPERTY => "Length"

    /**
     * @type {String}
     */
    static NCRYPT_LENGTHS_PROPERTY => "Lengths"

    /**
     * @type {String}
     */
    static NCRYPT_BLOCK_LENGTH_PROPERTY => "Block Length"

    /**
     * @type {String}
     */
    static NCRYPT_PUBLIC_LENGTH_PROPERTY => "PublicKeyLength"

    /**
     * @type {String}
     */
    static NCRYPT_SIGNATURE_LENGTH_PROPERTY => "SignatureLength"

    /**
     * @type {String}
     */
    static NCRYPT_CHAINING_MODE_PROPERTY => "Chaining Mode"

    /**
     * @type {String}
     */
    static NCRYPT_AUTH_TAG_LENGTH => "AuthTagLength"

    /**
     * @type {String}
     */
    static NCRYPT_UI_POLICY_PROPERTY => "UI Policy"

    /**
     * @type {String}
     */
    static NCRYPT_EXPORT_POLICY_PROPERTY => "Export Policy"

    /**
     * @type {String}
     */
    static NCRYPT_WINDOW_HANDLE_PROPERTY => "HWND Handle"

    /**
     * @type {String}
     */
    static NCRYPT_USE_CONTEXT_PROPERTY => "Use Context"

    /**
     * @type {String}
     */
    static NCRYPT_IMPL_TYPE_PROPERTY => "Impl Type"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_USAGE_PROPERTY => "Key Usage"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_TYPE_PROPERTY => "Key Type"

    /**
     * @type {String}
     */
    static NCRYPT_VERSION_PROPERTY => "Version"

    /**
     * @type {String}
     */
    static NCRYPT_SECURITY_DESCR_SUPPORT_PROPERTY => "Security Descr Support"

    /**
     * @type {String}
     */
    static NCRYPT_SECURITY_DESCR_PROPERTY => "Security Descr"

    /**
     * @type {String}
     */
    static NCRYPT_USE_COUNT_ENABLED_PROPERTY => "Enabled Use Count"

    /**
     * @type {String}
     */
    static NCRYPT_USE_COUNT_PROPERTY => "Use Count"

    /**
     * @type {String}
     */
    static NCRYPT_LAST_MODIFIED_PROPERTY => "Modified"

    /**
     * @type {String}
     */
    static NCRYPT_MAX_NAME_LENGTH_PROPERTY => "Max Name Length"

    /**
     * @type {String}
     */
    static NCRYPT_ALGORITHM_GROUP_PROPERTY => "Algorithm Group"

    /**
     * @type {String}
     */
    static NCRYPT_DH_PARAMETERS_PROPERTY => "DHParameters"

    /**
     * @type {String}
     */
    static NCRYPT_ECC_PARAMETERS_PROPERTY => "ECCParameters"

    /**
     * @type {String}
     */
    static NCRYPT_ECC_CURVE_NAME_PROPERTY => "ECCCurveName"

    /**
     * @type {String}
     */
    static NCRYPT_ECC_CURVE_NAME_LIST_PROPERTY => "ECCCurveNameList"

    /**
     * @type {String}
     */
    static NCRYPT_USE_VIRTUAL_ISOLATION_PROPERTY => "Virtual Iso"

    /**
     * @type {String}
     */
    static NCRYPT_USE_PER_BOOT_KEY_PROPERTY => "Per Boot Key"

    /**
     * @type {String}
     */
    static NCRYPT_PROVIDER_HANDLE_PROPERTY => "Provider Handle"

    /**
     * @type {String}
     */
    static NCRYPT_PIN_PROPERTY => "SmartCardPin"

    /**
     * @type {String}
     */
    static NCRYPT_READER_PROPERTY => "SmartCardReader"

    /**
     * @type {String}
     */
    static NCRYPT_SMARTCARD_GUID_PROPERTY => "SmartCardGuid"

    /**
     * @type {String}
     */
    static NCRYPT_CERTIFICATE_PROPERTY => "SmartCardKeyCertificate"

    /**
     * @type {String}
     */
    static NCRYPT_PIN_PROMPT_PROPERTY => "SmartCardPinPrompt"

    /**
     * @type {String}
     */
    static NCRYPT_USER_CERTSTORE_PROPERTY => "SmartCardUserCertStore"

    /**
     * @type {String}
     */
    static NCRYPT_ROOT_CERTSTORE_PROPERTY => "SmartcardRootCertStore"

    /**
     * @type {String}
     */
    static NCRYPT_SECURE_PIN_PROPERTY => "SmartCardSecurePin"

    /**
     * @type {String}
     */
    static NCRYPT_ASSOCIATED_ECDH_KEY => "SmartCardAssociatedECDHKey"

    /**
     * @type {String}
     */
    static NCRYPT_SCARD_PIN_ID => "SmartCardPinId"

    /**
     * @type {String}
     */
    static NCRYPT_SCARD_PIN_INFO => "SmartCardPinInfo"

    /**
     * @type {String}
     */
    static NCRYPT_READER_ICON_PROPERTY => "SmartCardReaderIcon"

    /**
     * @type {String}
     */
    static NCRYPT_KDF_SECRET_VALUE => "KDFKeySecret"

    /**
     * @type {String}
     */
    static NCRYPT_DISMISS_UI_TIMEOUT_SEC_PROPERTY => "SmartCardDismissUITimeoutSeconds"

    /**
     * @type {String}
     */
    static NCRYPT_VBS_ROOT_PUB_PROPERTY => "VBS_ROOT_PUB"

    /**
     * @type {String}
     */
    static NCRYPT_CERTIFICATE_FROM_NVRAM_PROPERTY => "KeyCertificateFromTpmNvram"

    /**
     * @type {String}
     */
    static NCRYPT_PKCS11_KWP_AES_KEY_BITS_PROPERTY => "Pkcs11AesKeyBits"

    /**
     * @type {String}
     */
    static NCRYPT_PKCS11_KWP_OAEP_HASH_ALGO_PROPERTY => "Pkcs11OaepHashAlgorithm"

    /**
     * @type {String}
     */
    static NCRYPT_PKCS11_KWP_OAEP_LABEL_PROPERTY => "Pkcs11OaepLabel"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PLATFORM_TYPE_PROPERTY => "PCP_PLATFORM_TYPE"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PROVIDER_VERSION_PROPERTY => "PCP_PROVIDER_VERSION"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_EKPUB_PROPERTY => "PCP_EKPUB"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_EKCERT_PROPERTY => "PCP_EKCERT"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_EKNVCERT_PROPERTY => "PCP_EKNVCERT"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_RSA_EKPUB_PROPERTY => "PCP_RSA_EKPUB"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_RSA_EKCERT_PROPERTY => "PCP_RSA_EKCERT"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_RSA_EKNVCERT_PROPERTY => "PCP_RSA_EKNVCERT"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_ECC_EKPUB_PROPERTY => "PCP_ECC_EKPUB"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_ECC_EKCERT_PROPERTY => "PCP_ECC_EKCERT"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_ECC_EKNVCERT_PROPERTY => "PCP_ECC_EKNVCERT"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_SRKPUB_PROPERTY => "PCP_SRKPUB"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PCRTABLE_PROPERTY => "PCP_PCRTABLE"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_CHANGEPASSWORD_PROPERTY => "PCP_CHANGEPASSWORD"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PASSWORD_REQUIRED_PROPERTY => "PCP_PASSWORD_REQUIRED"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_USAGEAUTH_PROPERTY => "PCP_USAGEAUTH"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_MIGRATIONPASSWORD_PROPERTY => "PCP_MIGRATIONPASSWORD"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_EXPORT_ALLOWED_PROPERTY => "PCP_EXPORT_ALLOWED"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_STORAGEPARENT_PROPERTY => "PCP_STORAGEPARENT"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PROVIDERHANDLE_PROPERTY => "PCP_PROVIDERMHANDLE"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PLATFORMHANDLE_PROPERTY => "PCP_PLATFORMHANDLE"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PLATFORM_BINDING_PCRMASK_PROPERTY => "PCP_PLATFORM_BINDING_PCRMASK"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PLATFORM_BINDING_PCRDIGESTLIST_PROPERTY => "PCP_PLATFORM_BINDING_PCRDIGESTLIST"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PLATFORM_BINDING_PCRDIGEST_PROPERTY => "PCP_PLATFORM_BINDING_PCRDIGEST"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_KEY_USAGE_POLICY_PROPERTY => "PCP_KEY_USAGE_POLICY"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_RSA_SCHEME_PROPERTY => "PCP_RSA_SCHEME"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM12_IDBINDING_PROPERTY => "PCP_TPM12_IDBINDING"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM12_IDBINDING_DYNAMIC_PROPERTY => "PCP_TPM12_IDBINDING_DYNAMIC"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM12_IDACTIVATION_PROPERTY => "PCP_TPM12_IDACTIVATION"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_KEYATTESTATION_PROPERTY => "PCP_TPM12_KEYATTESTATION"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_ALTERNATE_KEY_STORAGE_LOCATION_PROPERTY => "PCP_ALTERNATE_KEY_STORAGE_LOCATION"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PLATFORM_BINDING_PCRALGID_PROPERTY => "PCP_PLATFORM_BINDING_PCRALGID"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_HMAC_AUTH_POLICYREF => "PCP_HMAC_AUTH_POLICYREF"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_HMAC_AUTH_POLICYINFO => "PCP_HMAC_AUTH_POLICYINFO"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_HMAC_AUTH_NONCE => "PCP_HMAC_AUTH_NONCE"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_HMAC_AUTH_SIGNATURE => "PCP_HMAC_AUTH_SIGNATURE"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_HMAC_AUTH_TICKET => "PCP_HMAC_AUTH_TICKET"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_NO_DA_PROTECTION_PROPERTY => "PCP_NO_DA_PROTECTION"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM_MANUFACTURER_ID_PROPERTY => "PCP_TPM_MANUFACTURER_ID"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM_FW_VERSION_PROPERTY => "PCP_TPM_FW_VERSION"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM2BNAME_PROPERTY => "PCP_TPM2BNAME"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM_VERSION_PROPERTY => "PCP_TPM_VERSION"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_RAW_POLICYDIGEST_PROPERTY => "PCP_RAW_POLICYDIGEST"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_KEY_CREATIONHASH_PROPERTY => "PCP_KEY_CREATIONHASH"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_KEY_CREATIONTICKET_PROPERTY => "PCP_KEY_CREATIONTICKET"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_RSA_SCHEME_HASH_ALG_PROPERTY => "PCP_RSA_SCHEME_HASH_ALG"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM_IFX_RSA_KEYGEN_PROHIBITED_PROPERTY => "PCP_TPM_IFX_RSA_KEYGEN_PROHIBITED"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM_IFX_RSA_KEYGEN_VULNERABILITY_PROPERTY => "PCP_TPM_IFX_RSA_KEYGEN_VULNERABILITY"

    /**
     * @type {Integer (UInt32)}
     */
    static IFX_RSA_KEYGEN_VUL_NOT_AFFECTED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_2 => 2

    /**
     * @type {String}
     */
    static NCRYPT_PCP_SESSIONID_PROPERTY => "PCP_SESSIONID"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PSS_SALT_SIZE_PROPERTY => "PSS Salt Size"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TPM_PSS_SALT_SIZE_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TPM_PSS_SALT_SIZE_MAXIMUM => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TPM_PSS_SALT_SIZE_HASHSIZE => 2

    /**
     * @type {String}
     */
    static NCRYPT_PCP_INTERMEDIATE_CA_EKCERT_PROPERTY => "PCP_INTERMEDIATE_CA_EKCERT"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PCRTABLE_ALGORITHM_PROPERTY => "PCP_PCRTABLE_ALGORITHM"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_SYMMETRIC_KEYBITS_PROPERTY => "PCP_SYMMETRIC_KEYBITS"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TPM_PAD_PSS_IGNORE_SALT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TPM12_PROVIDER => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PCP_SIGNATURE_KEY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PCP_ENCRYPTION_KEY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PCP_STORAGE_KEY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PCP_IDENTITY_KEY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PCP_HMACVERIFICATION_KEY => 16

    /**
     * @type {String}
     */
    static NCRYPT_SCARD_NGC_KEY_NAME => "SmartCardNgcKeyName"

    /**
     * @type {String}
     */
    static NCRYPT_PLUTON_EKCERT_PROPERTY => "PLUTON_EKCERT"

    /**
     * @type {String}
     */
    static NCRYPT_PLUTON_EKPUB_PROPERTY => "PLUTON_EKPUB"

    /**
     * @type {String}
     */
    static NCRYPT_PLUTON_RSA_EKCERT_PROPERTY => "PLUTON_RSA_EKCERT"

    /**
     * @type {String}
     */
    static NCRYPT_PLUTON_RSA_EKPUB_PROPERTY => "PLUTON_RSA_EKPUB"

    /**
     * @type {String}
     */
    static NCRYPT_PLUTON_ECC_EKCERT_PROPERTY => "PLUTON_ECC_EKCERT"

    /**
     * @type {String}
     */
    static NCRYPT_PLUTON_ECC_EKPUB_PROPERTY => "PLUTON_ECC_EKPUB"

    /**
     * @type {String}
     */
    static NCRYPT_PLUTON_SESSION_ID_PROPERTY => "PLUTON_SESSION_ID"

    /**
     * @type {String}
     */
    static NCRYPT_PLUTON_KDF_PARENT_KEY_UNIQUE_NAME_PROPERTY => "PlutonKdfParentKeyUniqueName"

    /**
     * @type {String}
     */
    static NCRYPT_PLUTON_KDF_PARAMS_BUFFER_DESC_PROPERTY => "PlutonKdfParamsBufferDesc"

    /**
     * @type {String}
     */
    static NCRYPT_INITIALIZATION_VECTOR => "IV"

    /**
     * @type {String}
     */
    static NCRYPT_CHANGEPASSWORD_PROPERTY => "PCP_CHANGEPASSWORD"

    /**
     * @type {String}
     */
    static NCRYPT_ALTERNATE_KEY_STORAGE_LOCATION_PROPERTY => "PCP_ALTERNATE_KEY_STORAGE_LOCATION"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_ACCESS_POLICY_PROPERTY => "Key Access Policy"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_MAX_PROPERTY_NAME => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_MAX_PROPERTY_DATA => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_EXPORT_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_ARCHIVING_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_PLAINTEXT_ARCHIVING_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_PKCS11_RSA_AES_EXPORT_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_IMPL_HARDWARE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_IMPL_SOFTWARE_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_IMPL_REMOVABLE_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_IMPL_HARDWARE_RNG_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_IMPL_VIRTUAL_ISOLATION_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_DECRYPT_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_SIGNING_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_KEY_AGREEMENT_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_KEY_ENVELOPE_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_KEY_IMPORT_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_KEY_ATTESTATION_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_KEY_IMPORT_EPHEMERAL_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_ALL_USAGES => 16777215

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_UI_PROTECT_KEY_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_UI_FORCE_HIGH_PROTECTION_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_UI_FINGERPRINT_PROTECTION_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_UI_APPCONTAINER_ACCESS_MEDIUM_FLAG => 8

    /**
     * @type {String}
     */
    static NCRYPT_PIN_CACHE_FREE_APPLICATION_TICKET_PROPERTY => "PinCacheFreeApplicationTicket"

    /**
     * @type {String}
     */
    static NCRYPT_PIN_CACHE_FLAGS_PROPERTY => "PinCacheFlags"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PIN_CACHE_DISABLE_DPL_FLAG => 1

    /**
     * @type {String}
     */
    static NCRYPT_PIN_CACHE_APPLICATION_TICKET_PROPERTY => "PinCacheApplicationTicket"

    /**
     * @type {String}
     */
    static NCRYPT_PIN_CACHE_APPLICATION_IMAGE_PROPERTY => "PinCacheApplicationImage"

    /**
     * @type {String}
     */
    static NCRYPT_PIN_CACHE_APPLICATION_STATUS_PROPERTY => "PinCacheApplicationStatus"

    /**
     * @type {String}
     */
    static NCRYPT_PIN_CACHE_PIN_PROPERTY => "PinCachePin"

    /**
     * @type {String}
     */
    static NCRYPT_PIN_CACHE_IS_GESTURE_REQUIRED_PROPERTY => "PinCacheIsGestureRequired"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PIN_CACHE_REQUIRE_GESTURE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PIN_CACHE_APPLICATION_TICKET_BYTE_LENGTH => 90

    /**
     * @type {String}
     */
    static NCRYPT_PIN_CACHE_CLEAR_PROPERTY => "PinCacheClear"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PIN_CACHE_CLEAR_FOR_CALLING_PROCESS_OPTION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_KEY_ACCESS_POLICY_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_SILENT_KEY_ACCESS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CIPHER_KEY_BLOB_MAGIC => 1380470851

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_KDF_KEY_BLOB_MAGIC => 826688587

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PROTECTED_KEY_BLOB_MAGIC => 1263817296

    /**
     * @type {String}
     */
    static NCRYPT_CIPHER_KEY_BLOB => "CipherKeyBlob"

    /**
     * @type {String}
     */
    static NCRYPT_KDF_KEY_BLOB => "KDFKeyBlob"

    /**
     * @type {String}
     */
    static NCRYPT_PROTECTED_KEY_BLOB => "ProtectedKeyBlob"

    /**
     * @type {String}
     */
    static NCRYPT_TPM_LOADABLE_KEY_BLOB => "PcpTpmProtectedKeyBlob"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TPM_LOADABLE_KEY_BLOB_MAGIC => 1297371211

    /**
     * @type {String}
     */
    static NCRYPT_TPM_PERSISTENT_KEY_BLOB => "PcpTpmPersistentKeyBlob"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TPM_PERSISTENT_KEY_BLOB_MAGIC => 1297371211

    /**
     * @type {String}
     */
    static NCRYPT_PKCS7_ENVELOPE_BLOB => "PKCS7_ENVELOPE"

    /**
     * @type {String}
     */
    static NCRYPT_PKCS8_PRIVATE_KEY_BLOB => "PKCS8_PRIVATEKEY"

    /**
     * @type {String}
     */
    static NCRYPT_OPAQUETRANSPORT_BLOB => "OpaqueTransport"

    /**
     * @type {String}
     */
    static NCRYPT_ISOLATED_KEY_ENVELOPE_BLOB => "ISOLATED_KEY_ENVELOPE"

    /**
     * @type {String}
     */
    static NCRYPT_DESCR_DELIMITER_OR => "OR"

    /**
     * @type {String}
     */
    static NCRYPT_DESCR_DELIMITER_AND => "AND"

    /**
     * @type {String}
     */
    static NCRYPT_DESCR_EQUAL => "="

    /**
     * @type {String}
     */
    static MS_KEY_PROTECTION_PROVIDER => "Microsoft Key Protection Provider"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_ALGORITHM_SID => "SID"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_ALGORITHM_LOCAL => "LOCAL"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_LOCAL_LOGON => "logon"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_LOCAL_USER => "user"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_LOCAL_MACHINE => "machine"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_ALGORITHM_SDDL => "SDDL"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_ALGORITHM_WEBCREDENTIALS => "WEBCREDENTIALS"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_ALGORITHM_LOCKEDCREDENTIALS => "LOCKEDCREDENTIALS"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_ALGORITHM_CERTIFICATE => "CERTIFICATE"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_CERT_HASHID => "HashId"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_CERT_CERTBLOB => "CertBlob"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_NAMED_DESCRIPTOR_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PROTECTION_INFO_TYPE_DESCRIPTOR_STRING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_CLASS_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_CLASS_SIGNATURE => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_CLASS_MSG_ENCRYPT => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_CLASS_DATA_ENCRYPT => 24576

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_CLASS_HASH => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_CLASS_KEY_EXCHANGE => 40960

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_CLASS_ALL => 57344

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_DSS => 512

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_RSA => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_BLOCK => 1536

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_STREAM => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_DH => 2560

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_SECURECHANNEL => 3072

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_ECDH => 3584

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_THIRDPARTY => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_THIRDPARTY_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RSA_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RSA_PKCS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RSA_MSATWORK => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RSA_ENTRUST => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RSA_PGP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_DSS_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_DSS_PKCS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_DSS_DMS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_ECDSA => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_DES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_3DES => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_DESX => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_IDEA => 5

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_CAST => 6

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SAFERSK64 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SAFERSK128 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_3DES_112 => 9

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_CYLINK_MEK => 12

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RC5 => 13

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_AES_128 => 14

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_AES_192 => 15

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_AES_256 => 16

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_AES => 17

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SKIPJACK => 10

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_TEK => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_CBCI => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_CFBP => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_OFBP => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_CBCOFM => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_CBCOFMI => 10

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RC2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RC4 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SEAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_DH_SANDF => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_DH_EPHEM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_AGREED_KEY_ANY => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_KEA => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_ECDH => 5

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_ECDH_EPHEM => 6

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_MD2 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_MD4 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_MD5 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SHA => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SHA1 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_MAC => 5

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RIPEMD => 6

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RIPEMD160 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SSL3SHAMD5 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_HMAC => 9

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_TLS1PRF => 10

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_HASH_REPLACE_OWF => 11

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SHA_256 => 12

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SHA_384 => 13

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SHA_512 => 14

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SSL3_MASTER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SCHANNEL_MASTER_HASH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SCHANNEL_MAC_KEY => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_PCT1_MASTER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SSL2_MASTER => 5

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_TLS1_MASTER => 6

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SCHANNEL_ENC_KEY => 7

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_ECMQV => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_EXAMPLE => 80

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNATURE_RESOURCE_NUMBER => 666

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFYCONTEXT => 4026531840

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_NEWKEYSET => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DELETEKEYSET => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SILENT => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DEFAULT_CONTAINER_OPTIONAL => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_UPDATE_KEY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_USER_PROTECTED_STRONG => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static RSA1024BIT_KEY => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SERVER => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static KEY_LENGTH_MASK => 4294901760

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECRYPT_RSA_NO_PADDING_CHECK => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SECRETDIGEST => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OWF_REPL_LM_HASH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_LITTLE_ENDIAN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_NOHASHOID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_TYPE2_FORMAT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_X931_FORMAT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MACHINE_DEFAULT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_USER_DEFAULT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DELETE_DEFAULT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SIMPLEBLOB => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PUBLICKEYBLOB => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PRIVATEKEYBLOB => 7

    /**
     * @type {Integer (UInt32)}
     */
    static PLAINTEXTKEYBLOB => 8

    /**
     * @type {Integer (UInt32)}
     */
    static OPAQUEKEYBLOB => 9

    /**
     * @type {Integer (UInt32)}
     */
    static PUBLICKEYBLOBEX => 10

    /**
     * @type {Integer (UInt32)}
     */
    static SYMMETRICWRAPKEYBLOB => 11

    /**
     * @type {Integer (UInt32)}
     */
    static KEYSTATEBLOB => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_USERDATA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static KP_IV => 1

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PADDING => 3

    /**
     * @type {Integer (UInt32)}
     */
    static KP_MODE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static KP_MODE_BITS => 5

    /**
     * @type {Integer (UInt32)}
     */
    static KP_P => 11

    /**
     * @type {Integer (UInt32)}
     */
    static KP_G => 12

    /**
     * @type {Integer (UInt32)}
     */
    static KP_Q => 13

    /**
     * @type {Integer (UInt32)}
     */
    static KP_X => 14

    /**
     * @type {Integer (UInt32)}
     */
    static KP_Y => 15

    /**
     * @type {Integer (UInt32)}
     */
    static KP_RA => 16

    /**
     * @type {Integer (UInt32)}
     */
    static KP_RB => 17

    /**
     * @type {Integer (UInt32)}
     */
    static KP_INFO => 18

    /**
     * @type {Integer (UInt32)}
     */
    static KP_EFFECTIVE_KEYLEN => 19

    /**
     * @type {Integer (UInt32)}
     */
    static KP_SCHANNEL_ALG => 20

    /**
     * @type {Integer (UInt32)}
     */
    static KP_CLIENT_RANDOM => 21

    /**
     * @type {Integer (UInt32)}
     */
    static KP_SERVER_RANDOM => 22

    /**
     * @type {Integer (UInt32)}
     */
    static KP_RP => 23

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PRECOMP_MD5 => 24

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PRECOMP_SHA => 25

    /**
     * @type {Integer (UInt32)}
     */
    static KP_CLEAR_KEY => 27

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PUB_EX_LEN => 28

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PUB_EX_VAL => 29

    /**
     * @type {Integer (UInt32)}
     */
    static KP_KEYVAL => 30

    /**
     * @type {Integer (UInt32)}
     */
    static KP_ADMIN_PIN => 31

    /**
     * @type {Integer (UInt32)}
     */
    static KP_KEYEXCHANGE_PIN => 32

    /**
     * @type {Integer (UInt32)}
     */
    static KP_SIGNATURE_PIN => 33

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PREHASH => 34

    /**
     * @type {Integer (UInt32)}
     */
    static KP_ROUNDS => 35

    /**
     * @type {Integer (UInt32)}
     */
    static KP_OAEP_PARAMS => 36

    /**
     * @type {Integer (UInt32)}
     */
    static KP_CMS_KEY_INFO => 37

    /**
     * @type {Integer (UInt32)}
     */
    static KP_CMS_DH_KEY_INFO => 38

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PUB_PARAMS => 39

    /**
     * @type {Integer (UInt32)}
     */
    static KP_VERIFY_PARAMS => 40

    /**
     * @type {Integer (UInt32)}
     */
    static KP_HIGHEST_VERSION => 41

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PIN_ID => 43

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PIN_INFO => 44

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS5_PADDING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RANDOM_PADDING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ZERO_PADDING => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_CBC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_ECB => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_OFB => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_CFB => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_CTS => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ENCRYPT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECRYPT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_EXPORT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_READ => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_WRITE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MAC => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_EXPORT_KEY => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_IMPORT_KEY => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ARCHIVE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static HP_ALGID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static HP_HASHSIZE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static HP_TLS1PRF_LABEL => 6

    /**
     * @type {Integer (UInt32)}
     */
    static HP_TLS1PRF_SEED => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FAILED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SUCCEED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PP_ENUMALGS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PP_ENUMCONTAINERS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PP_IMPTYPE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PP_NAME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PP_VERSION => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PP_CONTAINER => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PP_CHANGE_PASSWORD => 7

    /**
     * @type {Integer (UInt32)}
     */
    static PP_CERTCHAIN => 9

    /**
     * @type {Integer (UInt32)}
     */
    static PP_KEY_TYPE_SUBTYPE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static PP_PROVTYPE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static PP_KEYSTORAGE => 17

    /**
     * @type {Integer (UInt32)}
     */
    static PP_APPLI_CERT => 18

    /**
     * @type {Integer (UInt32)}
     */
    static PP_SYM_KEYSIZE => 19

    /**
     * @type {Integer (UInt32)}
     */
    static PP_SESSION_KEYSIZE => 20

    /**
     * @type {Integer (UInt32)}
     */
    static PP_ENUMALGS_EX => 22

    /**
     * @type {Integer (UInt32)}
     */
    static PP_ENUMMANDROOTS => 25

    /**
     * @type {Integer (UInt32)}
     */
    static PP_ENUMELECTROOTS => 26

    /**
     * @type {Integer (UInt32)}
     */
    static PP_KEYSET_TYPE => 27

    /**
     * @type {Integer (UInt32)}
     */
    static PP_ADMIN_PIN => 31

    /**
     * @type {Integer (UInt32)}
     */
    static PP_SIG_KEYSIZE_INC => 34

    /**
     * @type {Integer (UInt32)}
     */
    static PP_KEYX_KEYSIZE_INC => 35

    /**
     * @type {Integer (UInt32)}
     */
    static PP_UNIQUE_CONTAINER => 36

    /**
     * @type {Integer (UInt32)}
     */
    static PP_SGC_INFO => 37

    /**
     * @type {Integer (UInt32)}
     */
    static PP_KEYSPEC => 39

    /**
     * @type {Integer (UInt32)}
     */
    static PP_ENUMEX_SIGNING_PROT => 40

    /**
     * @type {Integer (UInt32)}
     */
    static PP_CRYPT_COUNT_KEY_USE => 41

    /**
     * @type {Integer (UInt32)}
     */
    static PP_SMARTCARD_GUID => 45

    /**
     * @type {Integer (UInt32)}
     */
    static PP_SMARTCARD_READER_ICON => 47

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FIRST => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_NEXT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SGC_ENUM => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_IMPL_HARDWARE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_IMPL_SOFTWARE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_IMPL_MIXED => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_IMPL_UNKNOWN => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_IMPL_REMOVABLE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SEC_DESCR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_PSTORE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_UI_PROMPT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FLAG_PCT1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FLAG_SSL2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FLAG_SSL3 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FLAG_TLS1 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FLAG_IPSEC => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FLAG_SIGNING => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SGC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FASTSGC => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PP_CONTEXT_INFO => 11

    /**
     * @type {Integer (UInt32)}
     */
    static PP_DISMISS_PIN_UI_SEC => 49

    /**
     * @type {Integer (UInt32)}
     */
    static PP_IS_PFX_EPHEMERAL => 50

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_RSA_FULL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_RSA_SIG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_DSS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_FORTEZZA => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_MS_EXCHANGE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_SSL => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_RSA_SCHANNEL => 12

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_DSS_DH => 13

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_EC_ECDSA_SIG => 14

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_EC_ECNRA_SIG => 15

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_EC_ECDSA_FULL => 16

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_EC_ECNRA_FULL => 17

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_DH_SCHANNEL => 18

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_SPYRUS_LYNKS => 20

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_RNG => 21

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_INTEL_SEC => 22

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_REPLACE_OWF => 23

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_RSA_AES => 24

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_STT_MER => 7

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_STT_ACQ => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_STT_BRND => 9

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_STT_ROOT => 10

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_STT_ISS => 11

    /**
     * @type {String}
     */
    static MS_DEF_PROV_A => "Microsoft Base Cryptographic Provider v1.0"

    /**
     * @type {String}
     */
    static MS_DEF_PROV_W => "Microsoft Base Cryptographic Provider v1.0"

    /**
     * @type {String}
     */
    static MS_DEF_PROV => "Microsoft Base Cryptographic Provider v1.0"

    /**
     * @type {String}
     */
    static MS_ENHANCED_PROV_A => "Microsoft Enhanced Cryptographic Provider v1.0"

    /**
     * @type {String}
     */
    static MS_ENHANCED_PROV_W => "Microsoft Enhanced Cryptographic Provider v1.0"

    /**
     * @type {String}
     */
    static MS_ENHANCED_PROV => "Microsoft Enhanced Cryptographic Provider v1.0"

    /**
     * @type {String}
     */
    static MS_STRONG_PROV_A => "Microsoft Strong Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_STRONG_PROV_W => "Microsoft Strong Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_STRONG_PROV => "Microsoft Strong Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_RSA_SIG_PROV_A => "Microsoft RSA Signature Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_RSA_SIG_PROV_W => "Microsoft RSA Signature Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_RSA_SIG_PROV => "Microsoft RSA Signature Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_RSA_SCHANNEL_PROV_A => "Microsoft RSA SChannel Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_RSA_SCHANNEL_PROV_W => "Microsoft RSA SChannel Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_RSA_SCHANNEL_PROV => "Microsoft RSA SChannel Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DSS_PROV_A => "Microsoft Base DSS Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DSS_PROV_W => "Microsoft Base DSS Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DSS_PROV => "Microsoft Base DSS Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DSS_DH_PROV_A => "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DSS_DH_PROV_W => "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DSS_DH_PROV => "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_ENH_DSS_DH_PROV_A => "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_ENH_DSS_DH_PROV_W => "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_ENH_DSS_DH_PROV => "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DH_SCHANNEL_PROV_A => "Microsoft DH SChannel Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DH_SCHANNEL_PROV_W => "Microsoft DH SChannel Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DH_SCHANNEL_PROV => "Microsoft DH SChannel Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_SCARD_PROV_A => "Microsoft Base Smart Card Crypto Provider"

    /**
     * @type {String}
     */
    static MS_SCARD_PROV_W => "Microsoft Base Smart Card Crypto Provider"

    /**
     * @type {String}
     */
    static MS_SCARD_PROV => "Microsoft Base Smart Card Crypto Provider"

    /**
     * @type {String}
     */
    static MS_ENH_RSA_AES_PROV_A => "Microsoft Enhanced RSA and AES Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_ENH_RSA_AES_PROV_W => "Microsoft Enhanced RSA and AES Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_ENH_RSA_AES_PROV_XP_A => "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)"

    /**
     * @type {String}
     */
    static MS_ENH_RSA_AES_PROV_XP_W => "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)"

    /**
     * @type {String}
     */
    static MS_ENH_RSA_AES_PROV_XP => "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)"

    /**
     * @type {String}
     */
    static MS_ENH_RSA_AES_PROV => "Microsoft Enhanced RSA and AES Cryptographic Provider"

    /**
     * @type {Integer (UInt32)}
     */
    static MAXUIDLEN => 64

    /**
     * @type {String}
     */
    static EXPO_OFFLOAD_REG_VALUE => "ExpoOffload"

    /**
     * @type {String}
     */
    static EXPO_OFFLOAD_FUNC_NAME => "OffloadModExpo"

    /**
     * @type {String}
     */
    static szKEY_CRYPTOAPI_PRIVATE_KEY_OPTIONS => "Software\Policies\Microsoft\Cryptography"

    /**
     * @type {String}
     */
    static szKEY_CACHE_ENABLED => "CachePrivateKeys"

    /**
     * @type {String}
     */
    static szKEY_CACHE_SECONDS => "PrivateKeyLifetimeSeconds"

    /**
     * @type {String}
     */
    static szPRIV_KEY_CACHE_MAX_ITEMS => "PrivKeyCacheMaxItems"

    /**
     * @type {Integer (UInt32)}
     */
    static cPRIV_KEY_CACHE_MAX_ITEMS_DEFAULT => 20

    /**
     * @type {String}
     */
    static szPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS => "PrivKeyCachePurgeIntervalSeconds"

    /**
     * @type {Integer (UInt32)}
     */
    static cPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS_DEFAULT => 86400

    /**
     * @type {Integer (UInt32)}
     */
    static CUR_BLOB_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SCHANNEL_MAC_KEY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SCHANNEL_ENC_KEY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static INTERNATIONAL_USAGE => 1

    /**
     * @type {String}
     */
    static szOID_RSA => "1.2.840.113549"

    /**
     * @type {String}
     */
    static szOID_PKCS => "1.2.840.113549.1"

    /**
     * @type {String}
     */
    static szOID_RSA_HASH => "1.2.840.113549.2"

    /**
     * @type {String}
     */
    static szOID_RSA_ENCRYPT => "1.2.840.113549.3"

    /**
     * @type {String}
     */
    static szOID_PKCS_1 => "1.2.840.113549.1.1"

    /**
     * @type {String}
     */
    static szOID_PKCS_2 => "1.2.840.113549.1.2"

    /**
     * @type {String}
     */
    static szOID_PKCS_3 => "1.2.840.113549.1.3"

    /**
     * @type {String}
     */
    static szOID_PKCS_4 => "1.2.840.113549.1.4"

    /**
     * @type {String}
     */
    static szOID_PKCS_5 => "1.2.840.113549.1.5"

    /**
     * @type {String}
     */
    static szOID_PKCS_6 => "1.2.840.113549.1.6"

    /**
     * @type {String}
     */
    static szOID_PKCS_7 => "1.2.840.113549.1.7"

    /**
     * @type {String}
     */
    static szOID_PKCS_8 => "1.2.840.113549.1.8"

    /**
     * @type {String}
     */
    static szOID_PKCS_9 => "1.2.840.113549.1.9"

    /**
     * @type {String}
     */
    static szOID_PKCS_10 => "1.2.840.113549.1.10"

    /**
     * @type {String}
     */
    static szOID_PKCS_12 => "1.2.840.113549.1.12"

    /**
     * @type {String}
     */
    static szOID_RSA_RSA => "1.2.840.113549.1.1.1"

    /**
     * @type {String}
     */
    static szOID_RSA_MD2RSA => "1.2.840.113549.1.1.2"

    /**
     * @type {String}
     */
    static szOID_RSA_MD4RSA => "1.2.840.113549.1.1.3"

    /**
     * @type {String}
     */
    static szOID_RSA_MD5RSA => "1.2.840.113549.1.1.4"

    /**
     * @type {String}
     */
    static szOID_RSA_SHA1RSA => "1.2.840.113549.1.1.5"

    /**
     * @type {String}
     */
    static szOID_RSA_SETOAEP_RSA => "1.2.840.113549.1.1.6"

    /**
     * @type {String}
     */
    static szOID_RSAES_OAEP => "1.2.840.113549.1.1.7"

    /**
     * @type {String}
     */
    static szOID_RSA_MGF1 => "1.2.840.113549.1.1.8"

    /**
     * @type {String}
     */
    static szOID_RSA_PSPECIFIED => "1.2.840.113549.1.1.9"

    /**
     * @type {String}
     */
    static szOID_RSA_SSA_PSS => "1.2.840.113549.1.1.10"

    /**
     * @type {String}
     */
    static szOID_RSA_SHA256RSA => "1.2.840.113549.1.1.11"

    /**
     * @type {String}
     */
    static szOID_RSA_SHA384RSA => "1.2.840.113549.1.1.12"

    /**
     * @type {String}
     */
    static szOID_RSA_SHA512RSA => "1.2.840.113549.1.1.13"

    /**
     * @type {String}
     */
    static szOID_RSA_DH => "1.2.840.113549.1.3.1"

    /**
     * @type {String}
     */
    static szOID_RSA_data => "1.2.840.113549.1.7.1"

    /**
     * @type {String}
     */
    static szOID_RSA_signedData => "1.2.840.113549.1.7.2"

    /**
     * @type {String}
     */
    static szOID_RSA_envelopedData => "1.2.840.113549.1.7.3"

    /**
     * @type {String}
     */
    static szOID_RSA_signEnvData => "1.2.840.113549.1.7.4"

    /**
     * @type {String}
     */
    static szOID_RSA_digestedData => "1.2.840.113549.1.7.5"

    /**
     * @type {String}
     */
    static szOID_RSA_hashedData => "1.2.840.113549.1.7.5"

    /**
     * @type {String}
     */
    static szOID_RSA_encryptedData => "1.2.840.113549.1.7.6"

    /**
     * @type {String}
     */
    static szOID_RSA_emailAddr => "1.2.840.113549.1.9.1"

    /**
     * @type {String}
     */
    static szOID_RSA_unstructName => "1.2.840.113549.1.9.2"

    /**
     * @type {String}
     */
    static szOID_RSA_contentType => "1.2.840.113549.1.9.3"

    /**
     * @type {String}
     */
    static szOID_RSA_messageDigest => "1.2.840.113549.1.9.4"

    /**
     * @type {String}
     */
    static szOID_RSA_signingTime => "1.2.840.113549.1.9.5"

    /**
     * @type {String}
     */
    static szOID_RSA_counterSign => "1.2.840.113549.1.9.6"

    /**
     * @type {String}
     */
    static szOID_RSA_challengePwd => "1.2.840.113549.1.9.7"

    /**
     * @type {String}
     */
    static szOID_RSA_unstructAddr => "1.2.840.113549.1.9.8"

    /**
     * @type {String}
     */
    static szOID_RSA_extCertAttrs => "1.2.840.113549.1.9.9"

    /**
     * @type {String}
     */
    static szOID_RSA_certExtensions => "1.2.840.113549.1.9.14"

    /**
     * @type {String}
     */
    static szOID_RSA_SMIMECapabilities => "1.2.840.113549.1.9.15"

    /**
     * @type {String}
     */
    static szOID_RSA_preferSignedData => "1.2.840.113549.1.9.15.1"

    /**
     * @type {String}
     */
    static szOID_TIMESTAMP_TOKEN => "1.2.840.113549.1.9.16.1.4"

    /**
     * @type {String}
     */
    static szOID_RFC3161_counterSign => "1.3.6.1.4.1.311.3.3.1"

    /**
     * @type {String}
     */
    static szOID_RFC3161v21_counterSign => "1.3.6.1.4.1.311.3.3.2"

    /**
     * @type {String}
     */
    static szOID_RFC3161v21_thumbprints => "1.3.6.1.4.1.311.3.3.3"

    /**
     * @type {String}
     */
    static szOID_RSA_SMIMEalg => "1.2.840.113549.1.9.16.3"

    /**
     * @type {String}
     */
    static szOID_RSA_SMIMEalgESDH => "1.2.840.113549.1.9.16.3.5"

    /**
     * @type {String}
     */
    static szOID_RSA_SMIMEalgCMS3DESwrap => "1.2.840.113549.1.9.16.3.6"

    /**
     * @type {String}
     */
    static szOID_RSA_SMIMEalgCMSRC2wrap => "1.2.840.113549.1.9.16.3.7"

    /**
     * @type {String}
     */
    static szOID_RSA_MD2 => "1.2.840.113549.2.2"

    /**
     * @type {String}
     */
    static szOID_RSA_MD4 => "1.2.840.113549.2.4"

    /**
     * @type {String}
     */
    static szOID_RSA_MD5 => "1.2.840.113549.2.5"

    /**
     * @type {String}
     */
    static szOID_RSA_RC2CBC => "1.2.840.113549.3.2"

    /**
     * @type {String}
     */
    static szOID_RSA_RC4 => "1.2.840.113549.3.4"

    /**
     * @type {String}
     */
    static szOID_RSA_DES_EDE3_CBC => "1.2.840.113549.3.7"

    /**
     * @type {String}
     */
    static szOID_RSA_RC5_CBCPad => "1.2.840.113549.3.9"

    /**
     * @type {String}
     */
    static szOID_ANSI_X942 => "1.2.840.10046"

    /**
     * @type {String}
     */
    static szOID_ANSI_X942_DH => "1.2.840.10046.2.1"

    /**
     * @type {String}
     */
    static szOID_X957 => "1.2.840.10040"

    /**
     * @type {String}
     */
    static szOID_X957_DSA => "1.2.840.10040.4.1"

    /**
     * @type {String}
     */
    static szOID_X957_SHA1DSA => "1.2.840.10040.4.3"

    /**
     * @type {String}
     */
    static szOID_ECC_PUBLIC_KEY => "1.2.840.10045.2.1"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_P256 => "1.2.840.10045.3.1.7"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_P384 => "1.3.132.0.34"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_P521 => "1.3.132.0.35"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP160R1 => "1.3.36.3.3.2.8.1.1.1"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP160T1 => "1.3.36.3.3.2.8.1.1.2"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP192R1 => "1.3.36.3.3.2.8.1.1.3"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP192T1 => "1.3.36.3.3.2.8.1.1.4"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP224R1 => "1.3.36.3.3.2.8.1.1.5"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP224T1 => "1.3.36.3.3.2.8.1.1.6"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP256R1 => "1.3.36.3.3.2.8.1.1.7"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP256T1 => "1.3.36.3.3.2.8.1.1.8"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP320R1 => "1.3.36.3.3.2.8.1.1.9"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP320T1 => "1.3.36.3.3.2.8.1.1.10"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP384R1 => "1.3.36.3.3.2.8.1.1.11"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP384T1 => "1.3.36.3.3.2.8.1.1.12"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP512R1 => "1.3.36.3.3.2.8.1.1.13"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP512T1 => "1.3.36.3.3.2.8.1.1.14"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_EC192WAPI => "1.2.156.11235.1.1.2.1"

    /**
     * @type {String}
     */
    static szOID_CN_ECDSA_SHA256 => "1.2.156.11235.1.1.1"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_NISTP192 => "1.2.840.10045.3.1.1"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_NISTP224 => "1.3.132.0.33"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_NISTP256 => "1.2.840.10045.3.1.7"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_NISTP384 => "1.3.132.0.34"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_NISTP521 => "1.3.132.0.35"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP160K1 => "1.3.132.0.9"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP160R1 => "1.3.132.0.8"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP160R2 => "1.3.132.0.30"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP192K1 => "1.3.132.0.31"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP192R1 => "1.2.840.10045.3.1.1"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP224K1 => "1.3.132.0.32"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP224R1 => "1.3.132.0.33"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP256K1 => "1.3.132.0.10"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP256R1 => "1.2.840.10045.3.1.7"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP384R1 => "1.3.132.0.34"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP521R1 => "1.3.132.0.35"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_WTLS7 => "1.3.132.0.30"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_WTLS9 => "2.23.43.1.4.9"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_WTLS12 => "1.3.132.0.33"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_X962P192V1 => "1.2.840.10045.3.1.1"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_X962P192V2 => "1.2.840.10045.3.1.2"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_X962P192V3 => "1.2.840.10045.3.1.3"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_X962P239V1 => "1.2.840.10045.3.1.4"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_X962P239V2 => "1.2.840.10045.3.1.5"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_X962P239V3 => "1.2.840.10045.3.1.6"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_X962P256V1 => "1.2.840.10045.3.1.7"

    /**
     * @type {String}
     */
    static szOID_ECDSA_SHA1 => "1.2.840.10045.4.1"

    /**
     * @type {String}
     */
    static szOID_ECDSA_SPECIFIED => "1.2.840.10045.4.3"

    /**
     * @type {String}
     */
    static szOID_ECDSA_SHA256 => "1.2.840.10045.4.3.2"

    /**
     * @type {String}
     */
    static szOID_ECDSA_SHA384 => "1.2.840.10045.4.3.3"

    /**
     * @type {String}
     */
    static szOID_ECDSA_SHA512 => "1.2.840.10045.4.3.4"

    /**
     * @type {String}
     */
    static szOID_NIST_AES128_CBC => "2.16.840.1.101.3.4.1.2"

    /**
     * @type {String}
     */
    static szOID_NIST_AES192_CBC => "2.16.840.1.101.3.4.1.22"

    /**
     * @type {String}
     */
    static szOID_NIST_AES256_CBC => "2.16.840.1.101.3.4.1.42"

    /**
     * @type {String}
     */
    static szOID_NIST_AES128_WRAP => "2.16.840.1.101.3.4.1.5"

    /**
     * @type {String}
     */
    static szOID_NIST_AES192_WRAP => "2.16.840.1.101.3.4.1.25"

    /**
     * @type {String}
     */
    static szOID_NIST_AES256_WRAP => "2.16.840.1.101.3.4.1.45"

    /**
     * @type {String}
     */
    static szOID_DH_SINGLE_PASS_STDDH_SHA1_KDF => "1.3.133.16.840.63.0.2"

    /**
     * @type {String}
     */
    static szOID_DH_SINGLE_PASS_STDDH_SHA256_KDF => "1.3.132.1.11.1"

    /**
     * @type {String}
     */
    static szOID_DH_SINGLE_PASS_STDDH_SHA384_KDF => "1.3.132.1.11.2"

    /**
     * @type {String}
     */
    static szOID_DS => "2.5"

    /**
     * @type {String}
     */
    static szOID_DSALG => "2.5.8"

    /**
     * @type {String}
     */
    static szOID_DSALG_CRPT => "2.5.8.1"

    /**
     * @type {String}
     */
    static szOID_DSALG_HASH => "2.5.8.2"

    /**
     * @type {String}
     */
    static szOID_DSALG_SIGN => "2.5.8.3"

    /**
     * @type {String}
     */
    static szOID_DSALG_RSA => "2.5.8.1.1"

    /**
     * @type {String}
     */
    static szOID_OIW => "1.3.14"

    /**
     * @type {String}
     */
    static szOID_OIWSEC => "1.3.14.3.2"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_md4RSA => "1.3.14.3.2.2"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_md5RSA => "1.3.14.3.2.3"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_md4RSA2 => "1.3.14.3.2.4"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_desECB => "1.3.14.3.2.6"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_desCBC => "1.3.14.3.2.7"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_desOFB => "1.3.14.3.2.8"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_desCFB => "1.3.14.3.2.9"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_desMAC => "1.3.14.3.2.10"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_rsaSign => "1.3.14.3.2.11"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_dsa => "1.3.14.3.2.12"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_shaDSA => "1.3.14.3.2.13"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_mdc2RSA => "1.3.14.3.2.14"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_shaRSA => "1.3.14.3.2.15"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_dhCommMod => "1.3.14.3.2.16"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_desEDE => "1.3.14.3.2.17"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_sha => "1.3.14.3.2.18"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_mdc2 => "1.3.14.3.2.19"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_dsaComm => "1.3.14.3.2.20"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_dsaCommSHA => "1.3.14.3.2.21"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_rsaXchg => "1.3.14.3.2.22"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_keyHashSeal => "1.3.14.3.2.23"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_md2RSASign => "1.3.14.3.2.24"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_md5RSASign => "1.3.14.3.2.25"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_sha1 => "1.3.14.3.2.26"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_dsaSHA1 => "1.3.14.3.2.27"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_dsaCommSHA1 => "1.3.14.3.2.28"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_sha1RSASign => "1.3.14.3.2.29"

    /**
     * @type {String}
     */
    static szOID_OIWDIR => "1.3.14.7.2"

    /**
     * @type {String}
     */
    static szOID_OIWDIR_CRPT => "1.3.14.7.2.1"

    /**
     * @type {String}
     */
    static szOID_OIWDIR_HASH => "1.3.14.7.2.2"

    /**
     * @type {String}
     */
    static szOID_OIWDIR_SIGN => "1.3.14.7.2.3"

    /**
     * @type {String}
     */
    static szOID_OIWDIR_md2 => "1.3.14.7.2.2.1"

    /**
     * @type {String}
     */
    static szOID_OIWDIR_md2RSA => "1.3.14.7.2.3.1"

    /**
     * @type {String}
     */
    static szOID_INFOSEC => "2.16.840.1.101.2.1"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_sdnsSignature => "2.16.840.1.101.2.1.1.1"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicSignature => "2.16.840.1.101.2.1.1.2"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_sdnsConfidentiality => "2.16.840.1.101.2.1.1.3"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicConfidentiality => "2.16.840.1.101.2.1.1.4"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_sdnsIntegrity => "2.16.840.1.101.2.1.1.5"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicIntegrity => "2.16.840.1.101.2.1.1.6"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_sdnsTokenProtection => "2.16.840.1.101.2.1.1.7"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicTokenProtection => "2.16.840.1.101.2.1.1.8"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_sdnsKeyManagement => "2.16.840.1.101.2.1.1.9"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicKeyManagement => "2.16.840.1.101.2.1.1.10"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_sdnsKMandSig => "2.16.840.1.101.2.1.1.11"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicKMandSig => "2.16.840.1.101.2.1.1.12"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_SuiteASignature => "2.16.840.1.101.2.1.1.13"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_SuiteAConfidentiality => "2.16.840.1.101.2.1.1.14"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_SuiteAIntegrity => "2.16.840.1.101.2.1.1.15"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_SuiteATokenProtection => "2.16.840.1.101.2.1.1.16"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_SuiteAKeyManagement => "2.16.840.1.101.2.1.1.17"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_SuiteAKMandSig => "2.16.840.1.101.2.1.1.18"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicUpdatedSig => "2.16.840.1.101.2.1.1.19"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicKMandUpdSig => "2.16.840.1.101.2.1.1.20"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicUpdatedInteg => "2.16.840.1.101.2.1.1.21"

    /**
     * @type {String}
     */
    static szOID_NIST_sha256 => "2.16.840.1.101.3.4.2.1"

    /**
     * @type {String}
     */
    static szOID_NIST_sha384 => "2.16.840.1.101.3.4.2.2"

    /**
     * @type {String}
     */
    static szOID_NIST_sha512 => "2.16.840.1.101.3.4.2.3"

    /**
     * @type {String}
     */
    static szOID_COMMON_NAME => "2.5.4.3"

    /**
     * @type {String}
     */
    static szOID_SUR_NAME => "2.5.4.4"

    /**
     * @type {String}
     */
    static szOID_DEVICE_SERIAL_NUMBER => "2.5.4.5"

    /**
     * @type {String}
     */
    static szOID_COUNTRY_NAME => "2.5.4.6"

    /**
     * @type {String}
     */
    static szOID_LOCALITY_NAME => "2.5.4.7"

    /**
     * @type {String}
     */
    static szOID_STATE_OR_PROVINCE_NAME => "2.5.4.8"

    /**
     * @type {String}
     */
    static szOID_STREET_ADDRESS => "2.5.4.9"

    /**
     * @type {String}
     */
    static szOID_ORGANIZATION_NAME => "2.5.4.10"

    /**
     * @type {String}
     */
    static szOID_ORGANIZATIONAL_UNIT_NAME => "2.5.4.11"

    /**
     * @type {String}
     */
    static szOID_TITLE => "2.5.4.12"

    /**
     * @type {String}
     */
    static szOID_DESCRIPTION => "2.5.4.13"

    /**
     * @type {String}
     */
    static szOID_SEARCH_GUIDE => "2.5.4.14"

    /**
     * @type {String}
     */
    static szOID_BUSINESS_CATEGORY => "2.5.4.15"

    /**
     * @type {String}
     */
    static szOID_POSTAL_ADDRESS => "2.5.4.16"

    /**
     * @type {String}
     */
    static szOID_POSTAL_CODE => "2.5.4.17"

    /**
     * @type {String}
     */
    static szOID_POST_OFFICE_BOX => "2.5.4.18"

    /**
     * @type {String}
     */
    static szOID_PHYSICAL_DELIVERY_OFFICE_NAME => "2.5.4.19"

    /**
     * @type {String}
     */
    static szOID_TELEPHONE_NUMBER => "2.5.4.20"

    /**
     * @type {String}
     */
    static szOID_TELEX_NUMBER => "2.5.4.21"

    /**
     * @type {String}
     */
    static szOID_TELETEXT_TERMINAL_IDENTIFIER => "2.5.4.22"

    /**
     * @type {String}
     */
    static szOID_FACSIMILE_TELEPHONE_NUMBER => "2.5.4.23"

    /**
     * @type {String}
     */
    static szOID_X21_ADDRESS => "2.5.4.24"

    /**
     * @type {String}
     */
    static szOID_INTERNATIONAL_ISDN_NUMBER => "2.5.4.25"

    /**
     * @type {String}
     */
    static szOID_REGISTERED_ADDRESS => "2.5.4.26"

    /**
     * @type {String}
     */
    static szOID_DESTINATION_INDICATOR => "2.5.4.27"

    /**
     * @type {String}
     */
    static szOID_PREFERRED_DELIVERY_METHOD => "2.5.4.28"

    /**
     * @type {String}
     */
    static szOID_PRESENTATION_ADDRESS => "2.5.4.29"

    /**
     * @type {String}
     */
    static szOID_SUPPORTED_APPLICATION_CONTEXT => "2.5.4.30"

    /**
     * @type {String}
     */
    static szOID_MEMBER => "2.5.4.31"

    /**
     * @type {String}
     */
    static szOID_OWNER => "2.5.4.32"

    /**
     * @type {String}
     */
    static szOID_ROLE_OCCUPANT => "2.5.4.33"

    /**
     * @type {String}
     */
    static szOID_SEE_ALSO => "2.5.4.34"

    /**
     * @type {String}
     */
    static szOID_USER_PASSWORD => "2.5.4.35"

    /**
     * @type {String}
     */
    static szOID_USER_CERTIFICATE => "2.5.4.36"

    /**
     * @type {String}
     */
    static szOID_CA_CERTIFICATE => "2.5.4.37"

    /**
     * @type {String}
     */
    static szOID_AUTHORITY_REVOCATION_LIST => "2.5.4.38"

    /**
     * @type {String}
     */
    static szOID_CERTIFICATE_REVOCATION_LIST => "2.5.4.39"

    /**
     * @type {String}
     */
    static szOID_CROSS_CERTIFICATE_PAIR => "2.5.4.40"

    /**
     * @type {String}
     */
    static szOID_GIVEN_NAME => "2.5.4.42"

    /**
     * @type {String}
     */
    static szOID_INITIALS => "2.5.4.43"

    /**
     * @type {String}
     */
    static szOID_DN_QUALIFIER => "2.5.4.46"

    /**
     * @type {String}
     */
    static szOID_DOMAIN_COMPONENT => "0.9.2342.19200300.100.1.25"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_FRIENDLY_NAME_ATTR => "1.2.840.113549.1.9.20"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_LOCAL_KEY_ID => "1.2.840.113549.1.9.21"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR => "1.3.6.1.4.1.311.17.1"

    /**
     * @type {String}
     */
    static szOID_LOCAL_MACHINE_KEYSET => "1.3.6.1.4.1.311.17.2"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_EXTENDED_ATTRIBUTES => "1.3.6.1.4.1.311.17.3"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_PROTECTED_PASSWORD_SECRET_BAG_TYPE_ID => "1.3.6.1.4.1.311.17.4"

    /**
     * @type {String}
     */
    static szOID_KEYID_RDN => "1.3.6.1.4.1.311.10.7.1"

    /**
     * @type {String}
     */
    static szOID_EV_RDN_LOCALE => "1.3.6.1.4.1.311.60.2.1.1"

    /**
     * @type {String}
     */
    static szOID_EV_RDN_STATE_OR_PROVINCE => "1.3.6.1.4.1.311.60.2.1.2"

    /**
     * @type {String}
     */
    static szOID_EV_RDN_COUNTRY => "1.3.6.1.4.1.311.60.2.1.3"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RDN_TYPE_MASK => 255

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RDN_FLAGS_MASK => 4278190080

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RDN_ENABLE_T61_UNICODE_FLAG => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RDN_ENABLE_UTF8_UNICODE_FLAG => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RDN_FORCE_UTF8_UNICODE_FLAG => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RDN_DISABLE_CHECK_TYPE_FLAG => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RDN_DISABLE_IE4_UTF8_FLAG => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RDN_ENABLE_PUNYCODE_FLAG => 33554432

    /**
     * @type {String}
     */
    static CERT_RSA_PUBLIC_KEY_OBJID => "1.2.840.113549.1.1.1"

    /**
     * @type {String}
     */
    static CERT_DEFAULT_OID_PUBLIC_KEY_SIGN => "1.2.840.113549.1.1.1"

    /**
     * @type {String}
     */
    static CERT_DEFAULT_OID_PUBLIC_KEY_XCHG => "1.2.840.113549.1.1.1"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ECC_PRIVATE_KEY_INFO_v1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_V1 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_V2 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_V3 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_VERSION_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_SERIAL_NUMBER_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_SIGNATURE_ALGORITHM_FLAG => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_ISSUER_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_NOT_BEFORE_FLAG => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_NOT_AFTER_FLAG => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_SUBJECT_FLAG => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_SUBJECT_PUBLIC_KEY_INFO_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_ISSUER_UNIQUE_ID_FLAG => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_SUBJECT_UNIQUE_ID_FLAG => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_EXTENSION_FLAG => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_V1 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_V2 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_BUNDLE_CERTIFICATE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_BUNDLE_CRL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REQUEST_V1 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEYGEN_REQUEST_V1 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CTL_V1 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ENCODING_TYPE_MASK => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENCODING_TYPE_MASK => 4294901760

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ASN_ENCODING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_NDR_ENCODING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static X509_NDR_ENCODING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS_7_NDR_ENCODING => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_STR_MULTI_LINE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_STR_NO_HEX => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_SIMPLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_X509 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_OID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_RDN_SEMICOLON => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_RDN_CRLF => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_RDN_UNQUOTE => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_RDN_REVERSE => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_COMMA => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_SEMICOLON => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_CRLF => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ENCODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_UNICODE_NAME_ENCODE_FORCE_UTF8_UNICODE_FLAG => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SORTED_CTL_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ENCODE_ENABLE_UTF8PERCENT_FLAG => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECODE_NOCOPY_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECODE_TO_BE_SIGNED_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECODE_SHARE_OID_STRING_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECODE_ALLOC_FLAG => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECODE_ENABLE_PUNYCODE_FLAG => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECODE_ENABLE_UTF8PERCENT_FLAG => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ENCODE_DECODE_NONE => 0

    /**
     * @type {Integer (Int32)}
     */
    static X509_CERT => 1

    /**
     * @type {Integer (Int32)}
     */
    static X509_CERT_TO_BE_SIGNED => 2

    /**
     * @type {Integer (Int32)}
     */
    static X509_CERT_CRL_TO_BE_SIGNED => 3

    /**
     * @type {Integer (Int32)}
     */
    static X509_CERT_REQUEST_TO_BE_SIGNED => 4

    /**
     * @type {Integer (Int32)}
     */
    static X509_NAME_VALUE => 6

    /**
     * @type {Integer (Int32)}
     */
    static X509_PUBLIC_KEY_INFO => 8

    /**
     * @type {Integer (Int32)}
     */
    static X509_EXTENSIONS => 5

    /**
     * @type {Integer (Int32)}
     */
    static X509_NAME => 7

    /**
     * @type {Integer (Int32)}
     */
    static WINCRYPT_X509_EXTENSIONS => 5

    /**
     * @type {Integer (Int32)}
     */
    static WINCRYPT_X509_NAME => 7

    /**
     * @type {Integer (Int32)}
     */
    static X509_AUTHORITY_KEY_ID => 9

    /**
     * @type {Integer (Int32)}
     */
    static X509_KEY_ATTRIBUTES => 10

    /**
     * @type {Integer (Int32)}
     */
    static X509_KEY_USAGE_RESTRICTION => 11

    /**
     * @type {Integer (Int32)}
     */
    static X509_ALTERNATE_NAME => 12

    /**
     * @type {Integer (Int32)}
     */
    static X509_BASIC_CONSTRAINTS => 13

    /**
     * @type {Integer (Int32)}
     */
    static X509_KEY_USAGE => 14

    /**
     * @type {Integer (Int32)}
     */
    static X509_BASIC_CONSTRAINTS2 => 15

    /**
     * @type {Integer (Int32)}
     */
    static X509_CERT_POLICIES => 16

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_UTC_TIME => 17

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_TIME_REQUEST => 18

    /**
     * @type {Integer (Int32)}
     */
    static RSA_CSP_PUBLICKEYBLOB => 19

    /**
     * @type {Integer (Int32)}
     */
    static X509_UNICODE_NAME => 20

    /**
     * @type {Integer (Int32)}
     */
    static X509_KEYGEN_REQUEST_TO_BE_SIGNED => 21

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_ATTRIBUTE => 22

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_CONTENT_INFO_SEQUENCE_OF_ANY => 23

    /**
     * @type {Integer (Int32)}
     */
    static X509_UNICODE_NAME_VALUE => 24

    /**
     * @type {Integer (Int32)}
     */
    static X509_ANY_STRING => 6

    /**
     * @type {Integer (Int32)}
     */
    static X509_UNICODE_ANY_STRING => 24

    /**
     * @type {Integer (Int32)}
     */
    static X509_OCTET_STRING => 25

    /**
     * @type {Integer (Int32)}
     */
    static X509_BITS => 26

    /**
     * @type {Integer (Int32)}
     */
    static X509_INTEGER => 27

    /**
     * @type {Integer (Int32)}
     */
    static X509_MULTI_BYTE_INTEGER => 28

    /**
     * @type {Integer (Int32)}
     */
    static X509_ENUMERATED => 29

    /**
     * @type {Integer (Int32)}
     */
    static X509_CHOICE_OF_TIME => 30

    /**
     * @type {Integer (Int32)}
     */
    static X509_AUTHORITY_KEY_ID2 => 31

    /**
     * @type {Integer (Int32)}
     */
    static X509_AUTHORITY_INFO_ACCESS => 32

    /**
     * @type {Integer (Int32)}
     */
    static X509_SUBJECT_INFO_ACCESS => 32

    /**
     * @type {Integer (Int32)}
     */
    static X509_CRL_REASON_CODE => 29

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_CONTENT_INFO => 33

    /**
     * @type {Integer (Int32)}
     */
    static X509_SEQUENCE_OF_ANY => 34

    /**
     * @type {Integer (Int32)}
     */
    static X509_CRL_DIST_POINTS => 35

    /**
     * @type {Integer (Int32)}
     */
    static X509_ENHANCED_KEY_USAGE => 36

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_CTL => 37

    /**
     * @type {Integer (Int32)}
     */
    static X509_MULTI_BYTE_UINT => 38

    /**
     * @type {Integer (Int32)}
     */
    static X509_DSS_PUBLICKEY => 38

    /**
     * @type {Integer (Int32)}
     */
    static X509_DSS_PARAMETERS => 39

    /**
     * @type {Integer (Int32)}
     */
    static X509_DSS_SIGNATURE => 40

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_RC2_CBC_PARAMETERS => 41

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_SMIME_CAPABILITIES => 42

    /**
     * @type {Integer (Int32)}
     */
    static X509_QC_STATEMENTS_EXT => 42

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_RSA_PRIVATE_KEY => 43

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_PRIVATE_KEY_INFO => 44

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_ENCRYPTED_PRIVATE_KEY_INFO => 45

    /**
     * @type {Integer (Int32)}
     */
    static X509_PKIX_POLICY_QUALIFIER_USERNOTICE => 46

    /**
     * @type {Integer (Int32)}
     */
    static X509_DH_PUBLICKEY => 38

    /**
     * @type {Integer (Int32)}
     */
    static X509_DH_PARAMETERS => 47

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_ATTRIBUTES => 48

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_SORTED_CTL => 49

    /**
     * @type {Integer (Int32)}
     */
    static X509_ECC_SIGNATURE => 47

    /**
     * @type {Integer (Int32)}
     */
    static X942_DH_PARAMETERS => 50

    /**
     * @type {Integer (Int32)}
     */
    static X509_BITS_WITHOUT_TRAILING_ZEROES => 51

    /**
     * @type {Integer (Int32)}
     */
    static X942_OTHER_INFO => 52

    /**
     * @type {Integer (Int32)}
     */
    static X509_CERT_PAIR => 53

    /**
     * @type {Integer (Int32)}
     */
    static X509_ISSUING_DIST_POINT => 54

    /**
     * @type {Integer (Int32)}
     */
    static X509_NAME_CONSTRAINTS => 55

    /**
     * @type {Integer (Int32)}
     */
    static X509_POLICY_MAPPINGS => 56

    /**
     * @type {Integer (Int32)}
     */
    static X509_POLICY_CONSTRAINTS => 57

    /**
     * @type {Integer (Int32)}
     */
    static X509_CROSS_CERT_DIST_POINTS => 58

    /**
     * @type {Integer (Int32)}
     */
    static CMC_DATA => 59

    /**
     * @type {Integer (Int32)}
     */
    static CMC_RESPONSE => 60

    /**
     * @type {Integer (Int32)}
     */
    static CMC_STATUS => 61

    /**
     * @type {Integer (Int32)}
     */
    static CMC_ADD_EXTENSIONS => 62

    /**
     * @type {Integer (Int32)}
     */
    static CMC_ADD_ATTRIBUTES => 63

    /**
     * @type {Integer (Int32)}
     */
    static X509_CERTIFICATE_TEMPLATE => 64

    /**
     * @type {Integer (Int32)}
     */
    static OCSP_SIGNED_REQUEST => 65

    /**
     * @type {Integer (Int32)}
     */
    static OCSP_BASIC_SIGNED_RESPONSE => 68

    /**
     * @type {Integer (Int32)}
     */
    static OCSP_BASIC_RESPONSE => 69

    /**
     * @type {Integer (Int32)}
     */
    static OCSP_REQUEST => 66

    /**
     * @type {Integer (Int32)}
     */
    static OCSP_RESPONSE => 67

    /**
     * @type {Integer (Int32)}
     */
    static WINCRYPT_OCSP_REQUEST => 66

    /**
     * @type {Integer (Int32)}
     */
    static WINCRYPT_OCSP_RESPONSE => 67

    /**
     * @type {Integer (Int32)}
     */
    static X509_LOGOTYPE_EXT => 70

    /**
     * @type {Integer (Int32)}
     */
    static X509_BIOMETRIC_EXT => 71

    /**
     * @type {Integer (Int32)}
     */
    static CNG_RSA_PUBLIC_KEY_BLOB => 72

    /**
     * @type {Integer (Int32)}
     */
    static X509_OBJECT_IDENTIFIER => 73

    /**
     * @type {Integer (Int32)}
     */
    static X509_ALGORITHM_IDENTIFIER => 74

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_RSA_SSA_PSS_PARAMETERS => 75

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_RSAES_OAEP_PARAMETERS => 76

    /**
     * @type {Integer (Int32)}
     */
    static ECC_CMS_SHARED_INFO => 77

    /**
     * @type {Integer (Int32)}
     */
    static TIMESTAMP_REQUEST => 78

    /**
     * @type {Integer (Int32)}
     */
    static TIMESTAMP_RESPONSE => 79

    /**
     * @type {Integer (Int32)}
     */
    static TIMESTAMP_INFO => 80

    /**
     * @type {Integer (Int32)}
     */
    static X509_CERT_BUNDLE => 81

    /**
     * @type {Integer (Int32)}
     */
    static X509_ECC_PRIVATE_KEY => 82

    /**
     * @type {Integer (Int32)}
     */
    static CNG_RSA_PRIVATE_KEY_BLOB => 83

    /**
     * @type {Integer (Int32)}
     */
    static X509_SUBJECT_DIR_ATTRS => 84

    /**
     * @type {Integer (Int32)}
     */
    static X509_ECC_PARAMETERS => 85

    /**
     * @type {Integer (Int32)}
     */
    static PKCS7_SIGNER_INFO => 500

    /**
     * @type {Integer (Int32)}
     */
    static WINCRYPT_PKCS7_SIGNER_INFO => 500

    /**
     * @type {Integer (Int32)}
     */
    static CMS_SIGNER_INFO => 501

    /**
     * @type {String}
     */
    static szOID_AUTHORITY_KEY_IDENTIFIER => "2.5.29.1"

    /**
     * @type {String}
     */
    static szOID_KEY_ATTRIBUTES => "2.5.29.2"

    /**
     * @type {String}
     */
    static szOID_CERT_POLICIES_95 => "2.5.29.3"

    /**
     * @type {String}
     */
    static szOID_KEY_USAGE_RESTRICTION => "2.5.29.4"

    /**
     * @type {String}
     */
    static szOID_SUBJECT_ALT_NAME => "2.5.29.7"

    /**
     * @type {String}
     */
    static szOID_ISSUER_ALT_NAME => "2.5.29.8"

    /**
     * @type {String}
     */
    static szOID_BASIC_CONSTRAINTS => "2.5.29.10"

    /**
     * @type {String}
     */
    static szOID_KEY_USAGE => "2.5.29.15"

    /**
     * @type {String}
     */
    static szOID_PRIVATEKEY_USAGE_PERIOD => "2.5.29.16"

    /**
     * @type {String}
     */
    static szOID_BASIC_CONSTRAINTS2 => "2.5.29.19"

    /**
     * @type {String}
     */
    static szOID_CERT_POLICIES => "2.5.29.32"

    /**
     * @type {String}
     */
    static szOID_ANY_CERT_POLICY => "2.5.29.32.0"

    /**
     * @type {String}
     */
    static szOID_INHIBIT_ANY_POLICY => "2.5.29.54"

    /**
     * @type {String}
     */
    static szOID_AUTHORITY_KEY_IDENTIFIER2 => "2.5.29.35"

    /**
     * @type {String}
     */
    static szOID_SUBJECT_KEY_IDENTIFIER => "2.5.29.14"

    /**
     * @type {String}
     */
    static szOID_SUBJECT_ALT_NAME2 => "2.5.29.17"

    /**
     * @type {String}
     */
    static szOID_ISSUER_ALT_NAME2 => "2.5.29.18"

    /**
     * @type {String}
     */
    static szOID_CRL_REASON_CODE => "2.5.29.21"

    /**
     * @type {String}
     */
    static szOID_REASON_CODE_HOLD => "2.5.29.23"

    /**
     * @type {String}
     */
    static szOID_CRL_DIST_POINTS => "2.5.29.31"

    /**
     * @type {String}
     */
    static szOID_ENHANCED_KEY_USAGE => "2.5.29.37"

    /**
     * @type {String}
     */
    static szOID_ANY_ENHANCED_KEY_USAGE => "2.5.29.37.0"

    /**
     * @type {String}
     */
    static szOID_CRL_NUMBER => "2.5.29.20"

    /**
     * @type {String}
     */
    static szOID_DELTA_CRL_INDICATOR => "2.5.29.27"

    /**
     * @type {String}
     */
    static szOID_ISSUING_DIST_POINT => "2.5.29.28"

    /**
     * @type {String}
     */
    static szOID_FRESHEST_CRL => "2.5.29.46"

    /**
     * @type {String}
     */
    static szOID_NAME_CONSTRAINTS => "2.5.29.30"

    /**
     * @type {String}
     */
    static szOID_POLICY_MAPPINGS => "2.5.29.33"

    /**
     * @type {String}
     */
    static szOID_LEGACY_POLICY_MAPPINGS => "2.5.29.5"

    /**
     * @type {String}
     */
    static szOID_POLICY_CONSTRAINTS => "2.5.29.36"

    /**
     * @type {String}
     */
    static szOID_RENEWAL_CERTIFICATE => "1.3.6.1.4.1.311.13.1"

    /**
     * @type {String}
     */
    static szOID_ENROLLMENT_NAME_VALUE_PAIR => "1.3.6.1.4.1.311.13.2.1"

    /**
     * @type {String}
     */
    static szOID_ENROLLMENT_CSP_PROVIDER => "1.3.6.1.4.1.311.13.2.2"

    /**
     * @type {String}
     */
    static szOID_OS_VERSION => "1.3.6.1.4.1.311.13.2.3"

    /**
     * @type {String}
     */
    static szOID_ENROLLMENT_AGENT => "1.3.6.1.4.1.311.20.2.1"

    /**
     * @type {String}
     */
    static szOID_PKIX => "1.3.6.1.5.5.7"

    /**
     * @type {String}
     */
    static szOID_PKIX_PE => "1.3.6.1.5.5.7.1"

    /**
     * @type {String}
     */
    static szOID_AUTHORITY_INFO_ACCESS => "1.3.6.1.5.5.7.1.1"

    /**
     * @type {String}
     */
    static szOID_SUBJECT_INFO_ACCESS => "1.3.6.1.5.5.7.1.11"

    /**
     * @type {String}
     */
    static szOID_BIOMETRIC_EXT => "1.3.6.1.5.5.7.1.2"

    /**
     * @type {String}
     */
    static szOID_QC_STATEMENTS_EXT => "1.3.6.1.5.5.7.1.3"

    /**
     * @type {String}
     */
    static szOID_LOGOTYPE_EXT => "1.3.6.1.5.5.7.1.12"

    /**
     * @type {String}
     */
    static szOID_TLS_FEATURES_EXT => "1.3.6.1.5.5.7.1.24"

    /**
     * @type {String}
     */
    static szOID_CERT_EXTENSIONS => "1.3.6.1.4.1.311.2.1.14"

    /**
     * @type {String}
     */
    static szOID_NEXT_UPDATE_LOCATION => "1.3.6.1.4.1.311.10.2"

    /**
     * @type {String}
     */
    static szOID_REMOVE_CERTIFICATE => "1.3.6.1.4.1.311.10.8.1"

    /**
     * @type {String}
     */
    static szOID_CROSS_CERT_DIST_POINTS => "1.3.6.1.4.1.311.10.9.1"

    /**
     * @type {String}
     */
    static szOID_CTL => "1.3.6.1.4.1.311.10.1"

    /**
     * @type {String}
     */
    static szOID_SORTED_CTL => "1.3.6.1.4.1.311.10.1.1"

    /**
     * @type {String}
     */
    static szOID_SERIALIZED => "1.3.6.1.4.1.311.10.3.3.1"

    /**
     * @type {String}
     */
    static szOID_NT_PRINCIPAL_NAME => "1.3.6.1.4.1.311.20.2.3"

    /**
     * @type {String}
     */
    static szOID_INTERNATIONALIZED_EMAIL_ADDRESS => "1.3.6.1.4.1.311.20.2.4"

    /**
     * @type {String}
     */
    static szOID_PRODUCT_UPDATE => "1.3.6.1.4.1.311.31.1"

    /**
     * @type {String}
     */
    static szOID_ANY_APPLICATION_POLICY => "1.3.6.1.4.1.311.10.12.1"

    /**
     * @type {String}
     */
    static szOID_AUTO_ENROLL_CTL_USAGE => "1.3.6.1.4.1.311.20.1"

    /**
     * @type {String}
     */
    static szOID_ENROLL_CERTTYPE_EXTENSION => "1.3.6.1.4.1.311.20.2"

    /**
     * @type {String}
     */
    static szOID_CERT_MANIFOLD => "1.3.6.1.4.1.311.20.3"

    /**
     * @type {String}
     */
    static szOID_CERTSRV_CA_VERSION => "1.3.6.1.4.1.311.21.1"

    /**
     * @type {String}
     */
    static szOID_CERTSRV_PREVIOUS_CERT_HASH => "1.3.6.1.4.1.311.21.2"

    /**
     * @type {String}
     */
    static szOID_CRL_VIRTUAL_BASE => "1.3.6.1.4.1.311.21.3"

    /**
     * @type {String}
     */
    static szOID_CRL_NEXT_PUBLISH => "1.3.6.1.4.1.311.21.4"

    /**
     * @type {String}
     */
    static szOID_KP_CA_EXCHANGE => "1.3.6.1.4.1.311.21.5"

    /**
     * @type {String}
     */
    static szOID_KP_PRIVACY_CA => "1.3.6.1.4.1.311.21.36"

    /**
     * @type {String}
     */
    static szOID_KP_KEY_RECOVERY_AGENT => "1.3.6.1.4.1.311.21.6"

    /**
     * @type {String}
     */
    static szOID_CERTIFICATE_TEMPLATE => "1.3.6.1.4.1.311.21.7"

    /**
     * @type {String}
     */
    static szOID_ENTERPRISE_OID_ROOT => "1.3.6.1.4.1.311.21.8"

    /**
     * @type {String}
     */
    static szOID_RDN_DUMMY_SIGNER => "1.3.6.1.4.1.311.21.9"

    /**
     * @type {String}
     */
    static szOID_APPLICATION_CERT_POLICIES => "1.3.6.1.4.1.311.21.10"

    /**
     * @type {String}
     */
    static szOID_APPLICATION_POLICY_MAPPINGS => "1.3.6.1.4.1.311.21.11"

    /**
     * @type {String}
     */
    static szOID_APPLICATION_POLICY_CONSTRAINTS => "1.3.6.1.4.1.311.21.12"

    /**
     * @type {String}
     */
    static szOID_ARCHIVED_KEY_ATTR => "1.3.6.1.4.1.311.21.13"

    /**
     * @type {String}
     */
    static szOID_CRL_SELF_CDP => "1.3.6.1.4.1.311.21.14"

    /**
     * @type {String}
     */
    static szOID_REQUIRE_CERT_CHAIN_POLICY => "1.3.6.1.4.1.311.21.15"

    /**
     * @type {String}
     */
    static szOID_ARCHIVED_KEY_CERT_HASH => "1.3.6.1.4.1.311.21.16"

    /**
     * @type {String}
     */
    static szOID_ISSUED_CERT_HASH => "1.3.6.1.4.1.311.21.17"

    /**
     * @type {String}
     */
    static szOID_DS_EMAIL_REPLICATION => "1.3.6.1.4.1.311.21.19"

    /**
     * @type {String}
     */
    static szOID_REQUEST_CLIENT_INFO => "1.3.6.1.4.1.311.21.20"

    /**
     * @type {String}
     */
    static szOID_ENCRYPTED_KEY_HASH => "1.3.6.1.4.1.311.21.21"

    /**
     * @type {String}
     */
    static szOID_CERTSRV_CROSSCA_VERSION => "1.3.6.1.4.1.311.21.22"

    /**
     * @type {String}
     */
    static szOID_NTDS_REPLICATION => "1.3.6.1.4.1.311.25.1"

    /**
     * @type {String}
     */
    static szOID_NTDS_CA_SECURITY_EXT => "1.3.6.1.4.1.311.25.2"

    /**
     * @type {String}
     */
    static szOID_NTDS_OBJECTSID => "1.3.6.1.4.1.311.25.2.1"

    /**
     * @type {String}
     */
    static wszURI_NTDS_OBJECTSID_PREFIX => "tag:microsoft.com,2022-09-14:sid:"

    /**
     * @type {String}
     */
    static szOID_SUBJECT_DIR_ATTRS => "2.5.29.9"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP => "1.3.6.1.5.5.7.3"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_SERVER_AUTH => "1.3.6.1.5.5.7.3.1"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_CLIENT_AUTH => "1.3.6.1.5.5.7.3.2"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_CODE_SIGNING => "1.3.6.1.5.5.7.3.3"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_EMAIL_PROTECTION => "1.3.6.1.5.5.7.3.4"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_IPSEC_END_SYSTEM => "1.3.6.1.5.5.7.3.5"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_IPSEC_TUNNEL => "1.3.6.1.5.5.7.3.6"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_IPSEC_USER => "1.3.6.1.5.5.7.3.7"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_TIMESTAMP_SIGNING => "1.3.6.1.5.5.7.3.8"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_OCSP_SIGNING => "1.3.6.1.5.5.7.3.9"

    /**
     * @type {String}
     */
    static szOID_PKIX_OCSP_NOCHECK => "1.3.6.1.5.5.7.48.1.5"

    /**
     * @type {String}
     */
    static szOID_PKIX_OCSP_NONCE => "1.3.6.1.5.5.7.48.1.2"

    /**
     * @type {String}
     */
    static szOID_IPSEC_KP_IKE_INTERMEDIATE => "1.3.6.1.5.5.8.2.2"

    /**
     * @type {String}
     */
    static szOID_PKINIT_KP_KDC => "1.3.6.1.5.2.3.5"

    /**
     * @type {String}
     */
    static szOID_KP_CTL_USAGE_SIGNING => "1.3.6.1.4.1.311.10.3.1"

    /**
     * @type {String}
     */
    static szOID_KP_TIME_STAMP_SIGNING => "1.3.6.1.4.1.311.10.3.2"

    /**
     * @type {String}
     */
    static szOID_SERVER_GATED_CRYPTO => "1.3.6.1.4.1.311.10.3.3"

    /**
     * @type {String}
     */
    static szOID_SGC_NETSCAPE => "2.16.840.1.113730.4.1"

    /**
     * @type {String}
     */
    static szOID_KP_EFS => "1.3.6.1.4.1.311.10.3.4"

    /**
     * @type {String}
     */
    static szOID_EFS_RECOVERY => "1.3.6.1.4.1.311.10.3.4.1"

    /**
     * @type {String}
     */
    static szOID_WHQL_CRYPTO => "1.3.6.1.4.1.311.10.3.5"

    /**
     * @type {String}
     */
    static szOID_ATTEST_WHQL_CRYPTO => "1.3.6.1.4.1.311.10.3.5.1"

    /**
     * @type {String}
     */
    static szOID_NT5_CRYPTO => "1.3.6.1.4.1.311.10.3.6"

    /**
     * @type {String}
     */
    static szOID_OEM_WHQL_CRYPTO => "1.3.6.1.4.1.311.10.3.7"

    /**
     * @type {String}
     */
    static szOID_EMBEDDED_NT_CRYPTO => "1.3.6.1.4.1.311.10.3.8"

    /**
     * @type {String}
     */
    static szOID_ROOT_LIST_SIGNER => "1.3.6.1.4.1.311.10.3.9"

    /**
     * @type {String}
     */
    static szOID_KP_QUALIFIED_SUBORDINATION => "1.3.6.1.4.1.311.10.3.10"

    /**
     * @type {String}
     */
    static szOID_KP_KEY_RECOVERY => "1.3.6.1.4.1.311.10.3.11"

    /**
     * @type {String}
     */
    static szOID_KP_DOCUMENT_SIGNING => "1.3.6.1.4.1.311.10.3.12"

    /**
     * @type {String}
     */
    static szOID_KP_LIFETIME_SIGNING => "1.3.6.1.4.1.311.10.3.13"

    /**
     * @type {String}
     */
    static szOID_KP_MOBILE_DEVICE_SOFTWARE => "1.3.6.1.4.1.311.10.3.14"

    /**
     * @type {String}
     */
    static szOID_KP_SMART_DISPLAY => "1.3.6.1.4.1.311.10.3.15"

    /**
     * @type {String}
     */
    static szOID_KP_CSP_SIGNATURE => "1.3.6.1.4.1.311.10.3.16"

    /**
     * @type {String}
     */
    static szOID_KP_FLIGHT_SIGNING => "1.3.6.1.4.1.311.10.3.27"

    /**
     * @type {String}
     */
    static szOID_PLATFORM_MANIFEST_BINARY_ID => "1.3.6.1.4.1.311.10.3.28"

    /**
     * @type {String}
     */
    static szOID_DRM => "1.3.6.1.4.1.311.10.5.1"

    /**
     * @type {String}
     */
    static szOID_DRM_INDIVIDUALIZATION => "1.3.6.1.4.1.311.10.5.2"

    /**
     * @type {String}
     */
    static szOID_LICENSES => "1.3.6.1.4.1.311.10.6.1"

    /**
     * @type {String}
     */
    static szOID_LICENSE_SERVER => "1.3.6.1.4.1.311.10.6.2"

    /**
     * @type {String}
     */
    static szOID_KP_SMARTCARD_LOGON => "1.3.6.1.4.1.311.20.2.2"

    /**
     * @type {String}
     */
    static szOID_KP_KERNEL_MODE_CODE_SIGNING => "1.3.6.1.4.1.311.61.1.1"

    /**
     * @type {String}
     */
    static szOID_KP_KERNEL_MODE_TRUSTED_BOOT_SIGNING => "1.3.6.1.4.1.311.61.4.1"

    /**
     * @type {String}
     */
    static szOID_REVOKED_LIST_SIGNER => "1.3.6.1.4.1.311.10.3.19"

    /**
     * @type {String}
     */
    static szOID_WINDOWS_KITS_SIGNER => "1.3.6.1.4.1.311.10.3.20"

    /**
     * @type {String}
     */
    static szOID_WINDOWS_RT_SIGNER => "1.3.6.1.4.1.311.10.3.21"

    /**
     * @type {String}
     */
    static szOID_PROTECTED_PROCESS_LIGHT_SIGNER => "1.3.6.1.4.1.311.10.3.22"

    /**
     * @type {String}
     */
    static szOID_WINDOWS_TCB_SIGNER => "1.3.6.1.4.1.311.10.3.23"

    /**
     * @type {String}
     */
    static szOID_PROTECTED_PROCESS_SIGNER => "1.3.6.1.4.1.311.10.3.24"

    /**
     * @type {String}
     */
    static szOID_WINDOWS_THIRD_PARTY_COMPONENT_SIGNER => "1.3.6.1.4.1.311.10.3.25"

    /**
     * @type {String}
     */
    static szOID_WINDOWS_SOFTWARE_EXTENSION_SIGNER => "1.3.6.1.4.1.311.10.3.26"

    /**
     * @type {String}
     */
    static szOID_DISALLOWED_LIST => "1.3.6.1.4.1.311.10.3.30"

    /**
     * @type {String}
     */
    static szOID_PIN_RULES_SIGNER => "1.3.6.1.4.1.311.10.3.31"

    /**
     * @type {String}
     */
    static szOID_PIN_RULES_CTL => "1.3.6.1.4.1.311.10.3.32"

    /**
     * @type {String}
     */
    static szOID_PIN_RULES_EXT => "1.3.6.1.4.1.311.10.3.33"

    /**
     * @type {String}
     */
    static szOID_PIN_RULES_DOMAIN_NAME => "1.3.6.1.4.1.311.10.3.34"

    /**
     * @type {String}
     */
    static szOID_PIN_RULES_LOG_END_DATE_EXT => "1.3.6.1.4.1.311.10.3.35"

    /**
     * @type {String}
     */
    static szOID_IUM_SIGNING => "1.3.6.1.4.1.311.10.3.37"

    /**
     * @type {String}
     */
    static szOID_EV_WHQL_CRYPTO => "1.3.6.1.4.1.311.10.3.39"

    /**
     * @type {String}
     */
    static szOID_BIOMETRIC_SIGNING => "1.3.6.1.4.1.311.10.3.41"

    /**
     * @type {String}
     */
    static szOID_ENCLAVE_SIGNING => "1.3.6.1.4.1.311.10.3.42"

    /**
     * @type {String}
     */
    static szOID_SYNC_ROOT_CTL_EXT => "1.3.6.1.4.1.311.10.3.50"

    /**
     * @type {String}
     */
    static szOID_FLIGHT_CTL_EXT => "1.3.6.1.4.1.311.10.3.51"

    /**
     * @type {String}
     */
    static szOID_CERT_LOG_LIST_EXT => "1.3.6.1.4.1.311.10.3.52"

    /**
     * @type {String}
     */
    static szOID_HPKP_DOMAIN_NAME_CTL => "1.3.6.1.4.1.311.10.3.60"

    /**
     * @type {String}
     */
    static szOID_HPKP_HEADER_VALUE_CTL => "1.3.6.1.4.1.311.10.3.61"

    /**
     * @type {String}
     */
    static szOID_KP_KERNEL_MODE_HAL_EXTENSION_SIGNING => "1.3.6.1.4.1.311.61.5.1"

    /**
     * @type {String}
     */
    static szOID_WINDOWS_STORE_SIGNER => "1.3.6.1.4.1.311.76.3.1"

    /**
     * @type {String}
     */
    static szOID_DYNAMIC_CODE_GEN_SIGNER => "1.3.6.1.4.1.311.76.5.1"

    /**
     * @type {String}
     */
    static szOID_MICROSOFT_PUBLISHER_SIGNER => "1.3.6.1.4.1.311.76.8.1"

    /**
     * @type {String}
     */
    static szOID_YESNO_TRUST_ATTR => "1.3.6.1.4.1.311.10.4.1"

    /**
     * @type {String}
     */
    static szOID_SITE_PIN_RULES_INDEX_ATTR => "1.3.6.1.4.1.311.10.4.2"

    /**
     * @type {String}
     */
    static szOID_SITE_PIN_RULES_FLAGS_ATTR => "1.3.6.1.4.1.311.10.4.3"

    /**
     * @type {Integer (UInt32)}
     */
    static SITE_PIN_RULES_ALL_SUBDOMAINS_FLAG => 1

    /**
     * @type {String}
     */
    static szOID_PKIX_POLICY_QUALIFIER_CPS => "1.3.6.1.5.5.7.2.1"

    /**
     * @type {String}
     */
    static szOID_PKIX_POLICY_QUALIFIER_USERNOTICE => "1.3.6.1.5.5.7.2.2"

    /**
     * @type {String}
     */
    static szOID_ROOT_PROGRAM_FLAGS => "1.3.6.1.4.1.311.60.1.1"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ROOT_PROGRAM_FLAG_OU => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ROOT_PROGRAM_FLAG_ADDRESS => 8

    /**
     * @type {String}
     */
    static szOID_CERT_POLICIES_95_QUALIFIER1 => "2.16.840.1.113733.1.7.1.1"

    /**
     * @type {String}
     */
    static szOID_RDN_TPM_MANUFACTURER => "2.23.133.2.1"

    /**
     * @type {String}
     */
    static szOID_RDN_TPM_MODEL => "2.23.133.2.2"

    /**
     * @type {String}
     */
    static szOID_RDN_TPM_VERSION => "2.23.133.2.3"

    /**
     * @type {String}
     */
    static szOID_RDN_TCG_PLATFORM_MANUFACTURER => "2.23.133.2.4"

    /**
     * @type {String}
     */
    static szOID_RDN_TCG_PLATFORM_MODEL => "2.23.133.2.5"

    /**
     * @type {String}
     */
    static szOID_RDN_TCG_PLATFORM_VERSION => "2.23.133.2.6"

    /**
     * @type {String}
     */
    static szOID_CT_CERT_SCTLIST => "1.3.6.1.4.1.11129.2.4.2"

    /**
     * @type {String}
     */
    static szOID_ENROLL_EK_INFO => "1.3.6.1.4.1.311.21.23"

    /**
     * @type {String}
     */
    static szOID_ENROLL_AIK_INFO => "1.3.6.1.4.1.311.21.39"

    /**
     * @type {String}
     */
    static szOID_ENROLL_ATTESTATION_STATEMENT => "1.3.6.1.4.1.311.21.24"

    /**
     * @type {String}
     */
    static szOID_ENROLL_KSP_NAME => "1.3.6.1.4.1.311.21.25"

    /**
     * @type {String}
     */
    static szOID_ENROLL_EKPUB_CHALLENGE => "1.3.6.1.4.1.311.21.26"

    /**
     * @type {String}
     */
    static szOID_ENROLL_CAXCHGCERT_HASH => "1.3.6.1.4.1.311.21.27"

    /**
     * @type {String}
     */
    static szOID_ENROLL_ATTESTATION_CHALLENGE => "1.3.6.1.4.1.311.21.28"

    /**
     * @type {String}
     */
    static szOID_ENROLL_ENCRYPTION_ALGORITHM => "1.3.6.1.4.1.311.21.29"

    /**
     * @type {String}
     */
    static szOID_KP_TPM_EK_CERTIFICATE => "2.23.133.8.1"

    /**
     * @type {String}
     */
    static szOID_KP_TPM_PLATFORM_CERTIFICATE => "2.23.133.8.2"

    /**
     * @type {String}
     */
    static szOID_KP_TPM_AIK_CERTIFICATE => "2.23.133.8.3"

    /**
     * @type {String}
     */
    static szOID_ENROLL_EKVERIFYKEY => "1.3.6.1.4.1.311.21.30"

    /**
     * @type {String}
     */
    static szOID_ENROLL_EKVERIFYCERT => "1.3.6.1.4.1.311.21.31"

    /**
     * @type {String}
     */
    static szOID_ENROLL_EKVERIFYCREDS => "1.3.6.1.4.1.311.21.32"

    /**
     * @type {String}
     */
    static szOID_ENROLL_SCEP_ERROR => "1.3.6.1.4.1.311.21.33"

    /**
     * @type {String}
     */
    static szOID_ENROLL_SCEP_SERVER_STATE => "1.3.6.1.4.1.311.21.34"

    /**
     * @type {String}
     */
    static szOID_ENROLL_SCEP_CHALLENGE_ANSWER => "1.3.6.1.4.1.311.21.35"

    /**
     * @type {String}
     */
    static szOID_ENROLL_SCEP_CLIENT_REQUEST => "1.3.6.1.4.1.311.21.37"

    /**
     * @type {String}
     */
    static szOID_ENROLL_SCEP_SERVER_MESSAGE => "1.3.6.1.4.1.311.21.38"

    /**
     * @type {String}
     */
    static szOID_ENROLL_SCEP_SERVER_SECRET => "1.3.6.1.4.1.311.21.40"

    /**
     * @type {String}
     */
    static szOID_ENROLL_KEY_AFFINITY => "1.3.6.1.4.1.311.21.41"

    /**
     * @type {String}
     */
    static szOID_ENROLL_SCEP_SIGNER_HASH => "1.3.6.1.4.1.311.21.42"

    /**
     * @type {String}
     */
    static szOID_ENROLL_EK_CA_KEYID => "1.3.6.1.4.1.311.21.43"

    /**
     * @type {String}
     */
    static szOID_ATTR_SUPPORTED_ALGORITHMS => "2.5.4.52"

    /**
     * @type {String}
     */
    static szOID_ATTR_TPM_SPECIFICATION => "2.23.133.2.16"

    /**
     * @type {String}
     */
    static szOID_ATTR_PLATFORM_SPECIFICATION => "2.23.133.2.17"

    /**
     * @type {String}
     */
    static szOID_ATTR_TPM_SECURITY_ASSERTIONS => "2.23.133.2.18"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_UNICODE_RDN_ERR_INDEX_MASK => 1023

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_UNICODE_RDN_ERR_INDEX_SHIFT => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_UNICODE_ATTR_ERR_INDEX_MASK => 63

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_UNICODE_ATTR_ERR_INDEX_SHIFT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_UNICODE_VALUE_ERR_INDEX_MASK => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_UNICODE_VALUE_ERR_INDEX_SHIFT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DIGITAL_SIGNATURE_KEY_USAGE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NON_REPUDIATION_KEY_USAGE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_ENCIPHERMENT_KEY_USAGE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DATA_ENCIPHERMENT_KEY_USAGE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_AGREEMENT_KEY_USAGE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_CERT_SIGN_KEY_USAGE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_OFFLINE_CRL_SIGN_KEY_USAGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CRL_SIGN_KEY_USAGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ENCIPHER_ONLY_KEY_USAGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DECIPHER_ONLY_KEY_USAGE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ALT_NAME_X400_ADDRESS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ALT_NAME_EDI_PARTY_NAME => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ALT_NAME_ENTRY_ERR_INDEX_MASK => 255

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ALT_NAME_ENTRY_ERR_INDEX_SHIFT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ALT_NAME_VALUE_ERR_INDEX_MASK => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ALT_NAME_VALUE_ERR_INDEX_SHIFT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CA_SUBJECT_FLAG => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_END_ENTITY_SUBJECT_FLAG => 64

    /**
     * @type {String}
     */
    static szOID_PKIX_ACC_DESCR => "1.3.6.1.5.5.7.48"

    /**
     * @type {String}
     */
    static szOID_PKIX_OCSP => "1.3.6.1.5.5.7.48.1"

    /**
     * @type {String}
     */
    static szOID_PKIX_CA_ISSUERS => "1.3.6.1.5.5.7.48.2"

    /**
     * @type {String}
     */
    static szOID_PKIX_TIME_STAMPING => "1.3.6.1.5.5.7.48.3"

    /**
     * @type {String}
     */
    static szOID_PKIX_CA_REPOSITORY => "1.3.6.1.5.5.7.48.5"

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_PRIVILEGE_WITHDRAWN => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_AA_COMPROMISE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_DIST_POINT_NO_NAME => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_DIST_POINT_FULL_NAME => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_DIST_POINT_ISSUER_RDN_NAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_UNUSED_FLAG => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_KEY_COMPROMISE_FLAG => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_CA_COMPROMISE_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_AFFILIATION_CHANGED_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_SUPERSEDED_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_CESSATION_OF_OPERATION_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_CERTIFICATE_HOLD_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_PRIVILEGE_WITHDRAWN_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_AA_COMPROMISE_FLAG => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_DIST_POINT_ERR_INDEX_MASK => 127

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_DIST_POINT_ERR_INDEX_SHIFT => 24

    /**
     * @type {Integer (Int32)}
     */
    static CRL_DIST_POINT_ERR_CRL_ISSUER_BIT => -2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CROSS_CERT_DIST_POINT_ERR_INDEX_MASK => 255

    /**
     * @type {Integer (UInt32)}
     */
    static CROSS_CERT_DIST_POINT_ERR_INDEX_SHIFT => 24

    /**
     * @type {Integer (Int32)}
     */
    static CERT_EXCLUDED_SUBTREE_BIT => -2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static SORTED_CTL_EXT_HASHED_SUBJECT_IDENTIFIER_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DSS_R_LEN => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DSS_S_LEN => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_X942_COUNTER_BYTE_LENGTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_X942_KEY_LENGTH_BYTE_LENGTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ECC_CMS_SHARED_INFO_SUPPPUBINFO_BYTE_LENGTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_RC2_40BIT_VERSION => 160

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_RC2_56BIT_VERSION => 52

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_RC2_64BIT_VERSION => 120

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_RC2_128BIT_VERSION => 58

    /**
     * @type {String}
     */
    static szOID_QC_EU_COMPLIANCE => "0.4.0.1862.1.1"

    /**
     * @type {String}
     */
    static szOID_QC_SSCD => "0.4.0.1862.1.4"

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS_RSA_SSA_PSS_TRAILER_FIELD_BC => 1

    /**
     * @type {String}
     */
    static szOID_VERISIGN_PRIVATE_6_9 => "2.16.840.1.113733.1.6.9"

    /**
     * @type {String}
     */
    static szOID_VERISIGN_ONSITE_JURISDICTION_HASH => "2.16.840.1.113733.1.6.11"

    /**
     * @type {String}
     */
    static szOID_VERISIGN_BITSTRING_6_13 => "2.16.840.1.113733.1.6.13"

    /**
     * @type {String}
     */
    static szOID_VERISIGN_ISS_STRONG_CRYPTO => "2.16.840.1.113733.1.8.1"

    /**
     * @type {String}
     */
    static szOIDVerisign_MessageType => "2.16.840.1.113733.1.9.2"

    /**
     * @type {String}
     */
    static szOIDVerisign_PkiStatus => "2.16.840.1.113733.1.9.3"

    /**
     * @type {String}
     */
    static szOIDVerisign_FailInfo => "2.16.840.1.113733.1.9.4"

    /**
     * @type {String}
     */
    static szOIDVerisign_SenderNonce => "2.16.840.1.113733.1.9.5"

    /**
     * @type {String}
     */
    static szOIDVerisign_RecipientNonce => "2.16.840.1.113733.1.9.6"

    /**
     * @type {String}
     */
    static szOIDVerisign_TransactionID => "2.16.840.1.113733.1.9.7"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE => "2.16.840.1.113730"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_CERT_EXTENSION => "2.16.840.1.113730.1"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_CERT_TYPE => "2.16.840.1.113730.1.1"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_BASE_URL => "2.16.840.1.113730.1.2"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_REVOCATION_URL => "2.16.840.1.113730.1.3"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_CA_REVOCATION_URL => "2.16.840.1.113730.1.4"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_CERT_RENEWAL_URL => "2.16.840.1.113730.1.7"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_CA_POLICY_URL => "2.16.840.1.113730.1.8"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_SSL_SERVER_NAME => "2.16.840.1.113730.1.12"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_COMMENT => "2.16.840.1.113730.1.13"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_DATA_TYPE => "2.16.840.1.113730.2"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_CERT_SEQUENCE => "2.16.840.1.113730.2.5"

    /**
     * @type {Integer (UInt32)}
     */
    static NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static NETSCAPE_SSL_SERVER_AUTH_CERT_TYPE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NETSCAPE_SMIME_CERT_TYPE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NETSCAPE_SIGN_CERT_TYPE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static NETSCAPE_SSL_CA_CERT_TYPE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NETSCAPE_SMIME_CA_CERT_TYPE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NETSCAPE_SIGN_CA_CERT_TYPE => 1

    /**
     * @type {String}
     */
    static szOID_CT_PKI_DATA => "1.3.6.1.5.5.7.12.2"

    /**
     * @type {String}
     */
    static szOID_CT_PKI_RESPONSE => "1.3.6.1.5.5.7.12.3"

    /**
     * @type {String}
     */
    static szOID_PKIX_NO_SIGNATURE => "1.3.6.1.5.5.7.6.2"

    /**
     * @type {String}
     */
    static szOID_CMC => "1.3.6.1.5.5.7.7"

    /**
     * @type {String}
     */
    static szOID_CMC_STATUS_INFO => "1.3.6.1.5.5.7.7.1"

    /**
     * @type {String}
     */
    static szOID_CMC_IDENTIFICATION => "1.3.6.1.5.5.7.7.2"

    /**
     * @type {String}
     */
    static szOID_CMC_IDENTITY_PROOF => "1.3.6.1.5.5.7.7.3"

    /**
     * @type {String}
     */
    static szOID_CMC_DATA_RETURN => "1.3.6.1.5.5.7.7.4"

    /**
     * @type {String}
     */
    static szOID_CMC_TRANSACTION_ID => "1.3.6.1.5.5.7.7.5"

    /**
     * @type {String}
     */
    static szOID_CMC_SENDER_NONCE => "1.3.6.1.5.5.7.7.6"

    /**
     * @type {String}
     */
    static szOID_CMC_RECIPIENT_NONCE => "1.3.6.1.5.5.7.7.7"

    /**
     * @type {String}
     */
    static szOID_CMC_ADD_EXTENSIONS => "1.3.6.1.5.5.7.7.8"

    /**
     * @type {String}
     */
    static szOID_CMC_ENCRYPTED_POP => "1.3.6.1.5.5.7.7.9"

    /**
     * @type {String}
     */
    static szOID_CMC_DECRYPTED_POP => "1.3.6.1.5.5.7.7.10"

    /**
     * @type {String}
     */
    static szOID_CMC_LRA_POP_WITNESS => "1.3.6.1.5.5.7.7.11"

    /**
     * @type {String}
     */
    static szOID_CMC_GET_CERT => "1.3.6.1.5.5.7.7.15"

    /**
     * @type {String}
     */
    static szOID_CMC_GET_CRL => "1.3.6.1.5.5.7.7.16"

    /**
     * @type {String}
     */
    static szOID_CMC_REVOKE_REQUEST => "1.3.6.1.5.5.7.7.17"

    /**
     * @type {String}
     */
    static szOID_CMC_REG_INFO => "1.3.6.1.5.5.7.7.18"

    /**
     * @type {String}
     */
    static szOID_CMC_RESPONSE_INFO => "1.3.6.1.5.5.7.7.19"

    /**
     * @type {String}
     */
    static szOID_CMC_QUERY_PENDING => "1.3.6.1.5.5.7.7.21"

    /**
     * @type {String}
     */
    static szOID_CMC_ID_POP_LINK_RANDOM => "1.3.6.1.5.5.7.7.22"

    /**
     * @type {String}
     */
    static szOID_CMC_ID_POP_LINK_WITNESS => "1.3.6.1.5.5.7.7.23"

    /**
     * @type {String}
     */
    static szOID_CMC_ID_CONFIRM_CERT_ACCEPTANCE => "1.3.6.1.5.5.7.7.24"

    /**
     * @type {String}
     */
    static szOID_CMC_ADD_ATTRIBUTES => "1.3.6.1.4.1.311.10.10.1"

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_TAGGED_CERT_REQUEST_CHOICE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_OTHER_INFO_NO_CHOICE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_OTHER_INFO_FAIL_CHOICE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_OTHER_INFO_PEND_CHOICE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_STATUS_SUCCESS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_STATUS_FAILED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_STATUS_PENDING => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_STATUS_NO_SUPPORT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_STATUS_CONFIRM_REQUIRED => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_BAD_ALG => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_BAD_MESSAGE_CHECK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_BAD_REQUEST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_BAD_TIME => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_BAD_CERT_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_UNSUPORTED_EXT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_MUST_ARCHIVE_KEYS => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_BAD_IDENTITY => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_POP_REQUIRED => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_POP_FAILED => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_NO_KEY_REUSE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_INTERNAL_CA_ERROR => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_TRY_LATER => 12

    /**
     * @type {String}
     */
    static szOID_LOYALTY_OTHER_LOGOTYPE => "1.3.6.1.5.5.7.20.1"

    /**
     * @type {String}
     */
    static szOID_BACKGROUND_OTHER_LOGOTYPE => "1.3.6.1.5.5.7.20.2"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_BIOMETRIC_PICTURE_TYPE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_BIOMETRIC_SIGNATURE_TYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_REQUEST_V1 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_SUCCESSFUL_RESPONSE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_MALFORMED_REQUEST_RESPONSE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_INTERNAL_ERROR_RESPONSE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_TRY_LATER_RESPONSE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_SIG_REQUIRED_RESPONSE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_UNAUTHORIZED_RESPONSE => 6

    /**
     * @type {String}
     */
    static szOID_PKIX_OCSP_BASIC_SIGNED_RESPONSE => "1.3.6.1.5.5.7.48.1.1"

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_BASIC_GOOD_CERT_STATUS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_BASIC_REVOKED_CERT_STATUS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_BASIC_UNKNOWN_CERT_STATUS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_BASIC_RESPONSE_V1 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_BASIC_BY_NAME_RESPONDER_ID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_BASIC_BY_KEY_RESPONDER_ID => 2

    /**
     * @type {String}
     */
    static CRYPT_OID_ENCODE_OBJECT_FUNC => "CryptDllEncodeObject"

    /**
     * @type {String}
     */
    static CRYPT_OID_DECODE_OBJECT_FUNC => "CryptDllDecodeObject"

    /**
     * @type {String}
     */
    static CRYPT_OID_ENCODE_OBJECT_EX_FUNC => "CryptDllEncodeObjectEx"

    /**
     * @type {String}
     */
    static CRYPT_OID_DECODE_OBJECT_EX_FUNC => "CryptDllDecodeObjectEx"

    /**
     * @type {String}
     */
    static CRYPT_OID_CREATE_COM_OBJECT_FUNC => "CryptDllCreateCOMObject"

    /**
     * @type {String}
     */
    static CRYPT_OID_VERIFY_REVOCATION_FUNC => "CertDllVerifyRevocation"

    /**
     * @type {String}
     */
    static CRYPT_OID_VERIFY_CTL_USAGE_FUNC => "CertDllVerifyCTLUsage"

    /**
     * @type {String}
     */
    static CRYPT_OID_FORMAT_OBJECT_FUNC => "CryptDllFormatObject"

    /**
     * @type {String}
     */
    static CRYPT_OID_FIND_OID_INFO_FUNC => "CryptDllFindOIDInfo"

    /**
     * @type {String}
     */
    static CRYPT_OID_FIND_LOCALIZED_NAME_FUNC => "CryptDllFindLocalizedName"

    /**
     * @type {String}
     */
    static CRYPT_OID_REGPATH => "Software\Microsoft\Cryptography\OID"

    /**
     * @type {String}
     */
    static CRYPT_OID_REG_ENCODING_TYPE_PREFIX => "EncodingType "

    /**
     * @type {String}
     */
    static CRYPT_OID_REG_DLL_VALUE_NAME => "Dll"

    /**
     * @type {String}
     */
    static CRYPT_OID_REG_FUNC_NAME_VALUE_NAME => "FuncName"

    /**
     * @type {String}
     */
    static CRYPT_OID_REG_FUNC_NAME_VALUE_NAME_A => "FuncName"

    /**
     * @type {String}
     */
    static CRYPT_OID_REG_FLAGS_VALUE_NAME => "CryptFlags"

    /**
     * @type {String}
     */
    static CRYPT_DEFAULT_OID => "DEFAULT"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_GET_INSTALLED_OID_FUNC_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_REGISTER_FIRST_INDEX => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_REGISTER_LAST_INDEX => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MATCH_ANY_ENCODING_TYPE => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CALG_OID_INFO_CNG_ONLY => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CALG_OID_INFO_PARAMETERS => 4294967294

    /**
     * @type {String}
     */
    static CRYPT_OID_INFO_HASH_PARAMETERS_ALGORITHM => "CryptOIDInfoHashParameters"

    /**
     * @type {String}
     */
    static CRYPT_OID_INFO_ECC_PARAMETERS_ALGORITHM => "CryptOIDInfoECCParameters"

    /**
     * @type {String}
     */
    static CRYPT_OID_INFO_MGF1_PARAMETERS_ALGORITHM => "CryptOIDInfoMgf1Parameters"

    /**
     * @type {String}
     */
    static CRYPT_OID_INFO_NO_SIGN_ALGORITHM => "CryptOIDInfoNoSign"

    /**
     * @type {String}
     */
    static CRYPT_OID_INFO_OAEP_PARAMETERS_ALGORITHM => "CryptOIDInfoOAEPParameters"

    /**
     * @type {String}
     */
    static CRYPT_OID_INFO_ECC_WRAP_PARAMETERS_ALGORITHM => "CryptOIDInfoECCWrapParameters"

    /**
     * @type {String}
     */
    static CRYPT_OID_INFO_NO_PARAMETERS_ALGORITHM => "CryptOIDInfoNoParameters"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_HASH_ALG_OID_GROUP_ID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ENCRYPT_ALG_OID_GROUP_ID => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_PUBKEY_ALG_OID_GROUP_ID => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SIGN_ALG_OID_GROUP_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_RDN_ATTR_OID_GROUP_ID => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_EXT_OR_ATTR_OID_GROUP_ID => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ENHKEY_USAGE_OID_GROUP_ID => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_POLICY_OID_GROUP_ID => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_TEMPLATE_OID_GROUP_ID => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_KDF_OID_GROUP_ID => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_LAST_OID_GROUP_ID => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FIRST_ALG_OID_GROUP_ID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_LAST_ALG_OID_GROUP_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_PUBKEY_SIGN_ONLY_FLAG => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_PUBKEY_ENCRYPT_ONLY_FLAG => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_USE_CURVE_NAME_FOR_ENCODE_FLAG => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_USE_CURVE_PARAMETERS_FOR_ENCODE_FLAG => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_OID_KEY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_NAME_KEY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_ALGID_KEY => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_SIGN_KEY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_CNG_ALGID_KEY => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_CNG_SIGN_KEY => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_OID_KEY_FLAGS_MASK => 4294901760

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_DISABLE_SEARCH_DS_FLAG => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_PREFER_CNG_ALGID_FLAG => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_OID_GROUP_BIT_LEN_MASK => 268369920

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_OID_GROUP_BIT_LEN_SHIFT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_INSTALL_OID_INFO_BEFORE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_LOCALIZED_NAME_ENCODING_TYPE => 0

    /**
     * @type {String}
     */
    static CRYPT_LOCALIZED_NAME_OID => "LocalizedNames"

    /**
     * @type {String}
     */
    static CERT_STRONG_SIGN_ECDSA_ALGORITHM => "ECDSA"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STRONG_SIGN_SERIALIZED_INFO_CHOICE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STRONG_SIGN_OID_INFO_CHOICE => 2

    /**
     * @type {String}
     */
    static szOID_CERT_STRONG_SIGN_OS_PREFIX => "1.3.6.1.4.1.311.72.1."

    /**
     * @type {String}
     */
    static szOID_CERT_STRONG_SIGN_OS_1 => "1.3.6.1.4.1.311.72.1.1"

    /**
     * @type {String}
     */
    static szOID_CERT_STRONG_SIGN_OS_CURRENT => "1.3.6.1.4.1.311.72.1.1"

    /**
     * @type {String}
     */
    static szOID_CERT_STRONG_KEY_OS_PREFIX => "1.3.6.1.4.1.311.72.2."

    /**
     * @type {String}
     */
    static szOID_CERT_STRONG_KEY_OS_1 => "1.3.6.1.4.1.311.72.2.1"

    /**
     * @type {String}
     */
    static szOID_CERT_STRONG_KEY_OS_CURRENT => "1.3.6.1.4.1.311.72.2.1"

    /**
     * @type {String}
     */
    static szOID_PKCS_7_DATA => "1.2.840.113549.1.7.1"

    /**
     * @type {String}
     */
    static szOID_PKCS_7_SIGNED => "1.2.840.113549.1.7.2"

    /**
     * @type {String}
     */
    static szOID_PKCS_7_ENVELOPED => "1.2.840.113549.1.7.3"

    /**
     * @type {String}
     */
    static szOID_PKCS_7_SIGNEDANDENVELOPED => "1.2.840.113549.1.7.4"

    /**
     * @type {String}
     */
    static szOID_PKCS_7_DIGESTED => "1.2.840.113549.1.7.5"

    /**
     * @type {String}
     */
    static szOID_PKCS_7_ENCRYPTED => "1.2.840.113549.1.7.6"

    /**
     * @type {String}
     */
    static szOID_PKCS_9_CONTENT_TYPE => "1.2.840.113549.1.9.3"

    /**
     * @type {String}
     */
    static szOID_PKCS_9_MESSAGE_DIGEST => "1.2.840.113549.1.9.4"

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENCRYPTED => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_MAIL_LIST_HANDLE_KEY_CHOICE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_TRANS_RECIPIENT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_AGREE_RECIPIENT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_MAIL_LIST_RECIPIENT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_RC4_NO_SALT_FLAG => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_INDEFINITE_LENGTH => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_BARE_CONTENT_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_LENGTH_ONLY_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_DETACHED_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_AUTHENTICATED_ATTRIBUTES_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CONTENTS_OCTETS_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_MAX_LENGTH_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CMS_ENCAPSULATED_CONTENT_FLAG => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNED_DATA_NO_SIGN_FLAG => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CRYPT_RELEASE_CONTEXT_FLAG => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_TYPE_PARAM => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CONTENT_PARAM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_BARE_CONTENT_PARAM => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_INNER_CONTENT_TYPE_PARAM => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_COUNT_PARAM => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_INFO_PARAM => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_CERT_INFO_PARAM => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_HASH_ALGORITHM_PARAM => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_AUTH_ATTR_PARAM => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_UNAUTH_ATTR_PARAM => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CERT_COUNT_PARAM => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CERT_PARAM => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CRL_COUNT_PARAM => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CRL_PARAM => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPE_ALGORITHM_PARAM => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_RECIPIENT_COUNT_PARAM => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_RECIPIENT_INDEX_PARAM => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_RECIPIENT_INFO_PARAM => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_HASH_ALGORITHM_PARAM => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_HASH_DATA_PARAM => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_COMPUTED_HASH_PARAM => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENCRYPT_PARAM => 26

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENCRYPTED_DIGEST => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENCODED_SIGNER => 28

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENCODED_MESSAGE => 29

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_VERSION_PARAM => 30

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ATTR_CERT_COUNT_PARAM => 31

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ATTR_CERT_PARAM => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CMS_RECIPIENT_COUNT_PARAM => 33

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CMS_RECIPIENT_INDEX_PARAM => 34

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM => 35

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CMS_RECIPIENT_INFO_PARAM => 36

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_UNPROTECTED_ATTR_PARAM => 37

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_CERT_ID_PARAM => 38

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CMS_SIGNER_INFO_PARAM => 39

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNED_DATA_V1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNED_DATA_V3 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNED_DATA_PKCS_1_5_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNED_DATA_CMS_VERSION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_INFO_V1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_INFO_V3 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_INFO_PKCS_1_5_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_INFO_CMS_VERSION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_HASHED_DATA_V0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_HASHED_DATA_V2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_HASHED_DATA_PKCS_1_5_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_HASHED_DATA_CMS_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPED_DATA_V0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPED_DATA_V2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPED_DATA_CMS_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPED_RECIPIENT_V0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPED_RECIPIENT_V2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPED_RECIPIENT_V3 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPED_RECIPIENT_V4 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_TRANS_PKCS_1_5_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_TRANS_CMS_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_AGREE_VERSION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_MAIL_LIST_VERSION => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_VERIFY_SIGNATURE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_DECRYPT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_VERIFY_HASH => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_ADD_SIGNER => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_DEL_SIGNER => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_ADD_CERT => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_DEL_CERT => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_ADD_CRL => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_DEL_CRL => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_ADD_ATTR_CERT => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_DEL_ATTR_CERT => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_KEY_TRANS_DECRYPT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_KEY_AGREE_DECRYPT => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_MAIL_LIST_DECRYPT => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_VERIFY_SIGNATURE_EX => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_ADD_CMS_SIGNER_INFO => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_ENABLE_STRONG_SIGNATURE => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_VERIFY_SIGNER_PUBKEY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_VERIFY_SIGNER_CERT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_VERIFY_SIGNER_CHAIN => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_VERIFY_SIGNER_NULL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_VERIFY_COUNTER_SIGN_ENABLE_STRONG_FLAG => 1

    /**
     * @type {String}
     */
    static CMSG_OID_GEN_ENCRYPT_KEY_FUNC => "CryptMsgDllGenEncryptKey"

    /**
     * @type {String}
     */
    static CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC => "CryptMsgDllExportEncryptKey"

    /**
     * @type {String}
     */
    static CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC => "CryptMsgDllImportEncryptKey"

    /**
     * @type {Integer (Int32)}
     */
    static CMSG_DEFAULT_INSTALLABLE_FUNC_OID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CONTENT_ENCRYPT_FREE_OBJID_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG => 32768

    /**
     * @type {String}
     */
    static CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC => "CryptMsgDllGenContentEncryptKey"

    /**
     * @type {String}
     */
    static CMSG_OID_CAPI1_GEN_CONTENT_ENCRYPT_KEY_FUNC => "CryptMsgDllGenContentEncryptKey"

    /**
     * @type {String}
     */
    static CMSG_OID_CNG_GEN_CONTENT_ENCRYPT_KEY_FUNC => "CryptMsgDllCNGGenContentEncryptKey"

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_TRANS_ENCRYPT_FREE_PARA_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_TRANS_ENCRYPT_FREE_OBJID_FLAG => 2

    /**
     * @type {String}
     */
    static CMSG_OID_EXPORT_KEY_TRANS_FUNC => "CryptMsgDllExportKeyTrans"

    /**
     * @type {String}
     */
    static CMSG_OID_CAPI1_EXPORT_KEY_TRANS_FUNC => "CryptMsgDllExportKeyTrans"

    /**
     * @type {String}
     */
    static CMSG_OID_CNG_EXPORT_KEY_TRANS_FUNC => "CryptMsgDllCNGExportKeyTrans"

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_AGREE_ENCRYPT_FREE_MATERIAL_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_ALG_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_PARA_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_BITS_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_AGREE_ENCRYPT_FREE_OBJID_FLAG => 32

    /**
     * @type {String}
     */
    static CMSG_OID_EXPORT_KEY_AGREE_FUNC => "CryptMsgDllExportKeyAgree"

    /**
     * @type {String}
     */
    static CMSG_OID_CAPI1_EXPORT_KEY_AGREE_FUNC => "CryptMsgDllExportKeyAgree"

    /**
     * @type {String}
     */
    static CMSG_OID_CNG_EXPORT_KEY_AGREE_FUNC => "CryptMsgDllCNGExportKeyAgree"

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_MAIL_LIST_ENCRYPT_FREE_OBJID_FLAG => 2

    /**
     * @type {String}
     */
    static CMSG_OID_EXPORT_MAIL_LIST_FUNC => "CryptMsgDllExportMailList"

    /**
     * @type {String}
     */
    static CMSG_OID_CAPI1_EXPORT_MAIL_LIST_FUNC => "CryptMsgDllExportMailList"

    /**
     * @type {String}
     */
    static CMSG_OID_IMPORT_KEY_TRANS_FUNC => "CryptMsgDllImportKeyTrans"

    /**
     * @type {String}
     */
    static CMSG_OID_CAPI1_IMPORT_KEY_TRANS_FUNC => "CryptMsgDllImportKeyTrans"

    /**
     * @type {String}
     */
    static CMSG_OID_IMPORT_KEY_AGREE_FUNC => "CryptMsgDllImportKeyAgree"

    /**
     * @type {String}
     */
    static CMSG_OID_CAPI1_IMPORT_KEY_AGREE_FUNC => "CryptMsgDllImportKeyAgree"

    /**
     * @type {String}
     */
    static CMSG_OID_IMPORT_MAIL_LIST_FUNC => "CryptMsgDllImportMailList"

    /**
     * @type {String}
     */
    static CMSG_OID_CAPI1_IMPORT_MAIL_LIST_FUNC => "CryptMsgDllImportMailList"

    /**
     * @type {String}
     */
    static CMSG_OID_CNG_IMPORT_KEY_TRANS_FUNC => "CryptMsgDllCNGImportKeyTrans"

    /**
     * @type {String}
     */
    static CMSG_OID_CNG_IMPORT_KEY_AGREE_FUNC => "CryptMsgDllCNGImportKeyAgree"

    /**
     * @type {String}
     */
    static CMSG_OID_CNG_IMPORT_CONTENT_ENCRYPT_KEY_FUNC => "CryptMsgDllCNGImportContentEncryptKey"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_PROV_HANDLE_PROP_ID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_PROV_INFO_PROP_ID => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SHA1_HASH_PROP_ID => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_MD5_HASH_PROP_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_HASH_PROP_ID => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_CONTEXT_PROP_ID => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_SPEC_PROP_ID => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_IE30_RESERVED_PROP_ID => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PUBKEY_HASH_RESERVED_PROP_ID => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ENHKEY_USAGE_PROP_ID => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CTL_USAGE_PROP_ID => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NEXT_UPDATE_LOCATION_PROP_ID => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_FRIENDLY_NAME_PROP_ID => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PVK_FILE_PROP_ID => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DESCRIPTION_PROP_ID => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ACCESS_STATE_PROP_ID => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SIGNATURE_HASH_PROP_ID => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SMART_CARD_DATA_PROP_ID => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_EFS_PROP_ID => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_FORTEZZA_DATA_PROP_ID => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ARCHIVED_PROP_ID => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_IDENTIFIER_PROP_ID => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_AUTO_ENROLL_PROP_ID => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PUBKEY_ALG_PARA_PROP_ID => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CROSS_CERT_DIST_POINTS_PROP_ID => 23

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID => 24

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID => 25

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ENROLLMENT_PROP_ID => 26

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DATE_STAMP_PROP_ID => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID => 28

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SUBJECT_NAME_MD5_HASH_PROP_ID => 29

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_EXTENDED_ERROR_INFO_PROP_ID => 30

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RENEWAL_PROP_ID => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ARCHIVED_KEY_HASH_PROP_ID => 65

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_AUTO_ENROLL_RETRY_PROP_ID => 66

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_AIA_URL_RETRIEVED_PROP_ID => 67

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_AUTHORITY_INFO_ACCESS_PROP_ID => 68

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_BACKED_UP_PROP_ID => 69

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_OCSP_RESPONSE_PROP_ID => 70

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REQUEST_ORIGINATOR_PROP_ID => 71

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SOURCE_LOCATION_PROP_ID => 72

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SOURCE_URL_PROP_ID => 73

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NEW_KEY_PROP_ID => 74

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_OCSP_CACHE_PREFIX_PROP_ID => 75

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SMART_CARD_ROOT_INFO_PROP_ID => 76

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NO_AUTO_EXPIRE_CHECK_PROP_ID => 77

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NCRYPT_KEY_HANDLE_PROP_ID => 78

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID => 79

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SUBJECT_INFO_ACCESS_PROP_ID => 80

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CA_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID => 81

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CA_DISABLE_CRL_PROP_ID => 82

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ROOT_PROGRAM_CERT_POLICIES_PROP_ID => 83

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID => 84

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SUBJECT_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID => 85

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SUBJECT_DISABLE_CRL_PROP_ID => 86

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CEP_PROP_ID => 87

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SIGN_HASH_CNG_ALG_PROP_ID => 89

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCARD_PIN_ID_PROP_ID => 90

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCARD_PIN_INFO_PROP_ID => 91

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SUBJECT_PUB_KEY_BIT_LENGTH_PROP_ID => 92

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID => 93

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID => 94

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID => 95

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID => 96

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NO_EXPIRE_NOTIFICATION_PROP_ID => 97

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_AUTH_ROOT_SHA256_HASH_PROP_ID => 98

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NCRYPT_KEY_HANDLE_TRANSFER_PROP_ID => 99

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_HCRYPTPROV_TRANSFER_PROP_ID => 100

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SMART_CARD_READER_PROP_ID => 101

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SEND_AS_TRUSTED_ISSUER_PROP_ID => 102

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_REPAIR_ATTEMPTED_PROP_ID => 103

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DISALLOWED_FILETIME_PROP_ID => 104

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ROOT_PROGRAM_CHAIN_POLICIES_PROP_ID => 105

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SMART_CARD_READER_NON_REMOVABLE_PROP_ID => 106

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SHA256_HASH_PROP_ID => 107

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_SERVER_CERTS_PROP_ID => 108

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_RA_SIGNATURE_CERT_PROP_ID => 109

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_RA_ENCRYPTION_CERT_PROP_ID => 110

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_CA_CERT_PROP_ID => 111

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_SIGNER_CERT_PROP_ID => 112

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_NONCE_PROP_ID => 113

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_ENCRYPT_HASH_CNG_ALG_PROP_ID => 114

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_FLAGS_PROP_ID => 115

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_GUID_PROP_ID => 116

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SERIALIZABLE_KEY_CONTEXT_PROP_ID => 117

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ISOLATED_KEY_PROP_ID => 118

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SERIAL_CHAIN_PROP_ID => 119

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_CLASSIFICATION_PROP_ID => 120

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_OCSP_MUST_STAPLE_PROP_ID => 121

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DISALLOWED_ENHKEY_USAGE_PROP_ID => 122

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NONCOMPLIANT_ROOT_URL_PROP_ID => 123

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PIN_SHA256_HASH_PROP_ID => 124

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CLR_DELETE_KEY_PROP_ID => 125

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NOT_BEFORE_FILETIME_PROP_ID => 126

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NOT_BEFORE_ENHKEY_USAGE_PROP_ID => 127

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DISALLOWED_CA_FILETIME_PROP_ID => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SHA1_SHA256_HASH_PROP_ID => 129

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_FIRST_RESERVED_PROP_ID => 130

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_LAST_RESERVED_PROP_ID => 32767

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_FIRST_USER_PROP_ID => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_LAST_USER_PROP_ID => 65535

    /**
     * @type {String}
     */
    static szOID_CERT_PROP_ID_PREFIX => "1.3.6.1.4.1.311.10.11."

    /**
     * @type {String}
     */
    static szOID_CERT_KEY_IDENTIFIER_PROP_ID => "1.3.6.1.4.1.311.10.11.20"

    /**
     * @type {String}
     */
    static szOID_CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID => "1.3.6.1.4.1.311.10.11.28"

    /**
     * @type {String}
     */
    static szOID_CERT_SUBJECT_NAME_MD5_HASH_PROP_ID => "1.3.6.1.4.1.311.10.11.29"

    /**
     * @type {String}
     */
    static szOID_CERT_MD5_HASH_PROP_ID => "1.3.6.1.4.1.311.10.11.4"

    /**
     * @type {String}
     */
    static szOID_CERT_SHA256_HASH_PROP_ID => "1.3.6.1.4.1.311.10.11.107"

    /**
     * @type {String}
     */
    static szOID_CERT_SIGNATURE_HASH_PROP_ID => "1.3.6.1.4.1.311.10.11.15"

    /**
     * @type {String}
     */
    static szOID_DISALLOWED_HASH => "1.3.6.1.4.1.311.10.11.15"

    /**
     * @type {String}
     */
    static szOID_CERT_DISALLOWED_FILETIME_PROP_ID => "1.3.6.1.4.1.311.10.11.104"

    /**
     * @type {String}
     */
    static szOID_CERT_DISALLOWED_CA_FILETIME_PROP_ID => "1.3.6.1.4.1.311.10.11.128"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ACCESS_STATE_WRITE_PERSIST_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ACCESS_STATE_SYSTEM_STORE_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ACCESS_STATE_LM_SYSTEM_STORE_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ACCESS_STATE_GP_SYSTEM_STORE_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ACCESS_STATE_SHARED_USER_FLAG => 16

    /**
     * @type {String}
     */
    static szOID_ROOT_PROGRAM_AUTO_UPDATE_CA_REVOCATION => "1.3.6.1.4.1.311.60.3.1"

    /**
     * @type {String}
     */
    static szOID_ROOT_PROGRAM_AUTO_UPDATE_END_REVOCATION => "1.3.6.1.4.1.311.60.3.2"

    /**
     * @type {String}
     */
    static szOID_ROOT_PROGRAM_NO_OCSP_FAILOVER_TO_CRL => "1.3.6.1.4.1.311.60.3.3"

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_MSG => 1

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_MEMORY => 2

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_FILE => 3

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_REG => 4

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_PKCS7 => 5

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SERIALIZED => 6

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_FILENAME_A => 7

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_FILENAME_W => 8

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_FILENAME => 8

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SYSTEM_A => 9

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SYSTEM_W => 10

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SYSTEM => 10

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_COLLECTION => 11

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SYSTEM_REGISTRY_A => 12

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SYSTEM_REGISTRY_W => 13

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SYSTEM_REGISTRY => 13

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_PHYSICAL_W => 14

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_PHYSICAL => 14

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SMART_CARD_W => 15

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SMART_CARD => 15

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_LDAP_W => 16

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_LDAP => 16

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_PKCS12 => 17

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_MEMORY => "Memory"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_FILENAME_W => "File"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_FILENAME => "File"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_SYSTEM_W => "System"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_SYSTEM => "System"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_PKCS7 => "PKCS7"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_PKCS12 => "PKCS12"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_SERIALIZED => "Serialized"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_COLLECTION => "Collection"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W => "SystemRegistry"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_SYSTEM_REGISTRY => "SystemRegistry"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_PHYSICAL_W => "Physical"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_PHYSICAL => "Physical"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_SMART_CARD_W => "SmartCard"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_SMART_CARD => "SmartCard"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_LDAP_W => "Ldap"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_LDAP => "Ldap"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_SIGNATURE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_TIME_VALIDITY_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_REVOCATION_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_NO_CRL_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_NO_ISSUER_FLAG => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_BASE_CRL_FLAG => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_DELTA_CRL_FLAG => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_UNSAFE_PHYSICAL_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_SHARE_STORE_FLAG => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_MANIFOLD_FLAG => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_MASK => 4294901760

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_UNPROTECTED_FLAG => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_DEFER_READ_FLAG => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_LOCATION_SHIFT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_CURRENT_USER_ID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_LOCAL_MACHINE_ID => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_CURRENT_SERVICE_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_SERVICES_ID => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_USERS_ID => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_LOCAL_MACHINE_WCOS_ID => 10

    /**
     * @type {String}
     */
    static CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH => "Software\Policies\Microsoft\SystemCertificates"

    /**
     * @type {String}
     */
    static CERT_EFSBLOB_VALUE_NAME => "EFSBlob"

    /**
     * @type {String}
     */
    static CERT_PROT_ROOT_FLAGS_VALUE_NAME => "Flags"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PROT_ROOT_INHIBIT_ADD_AT_INIT_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PROT_ROOT_ONLY_LM_GPT_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PROT_ROOT_DISABLE_NOT_DEFINED_NAME_CONSTRAINT_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PROT_ROOT_DISABLE_PEER_TRUST => 65536

    /**
     * @type {String}
     */
    static CERT_PROT_ROOT_PEER_USAGES_VALUE_NAME => "PeerUsages"

    /**
     * @type {String}
     */
    static CERT_PROT_ROOT_PEER_USAGES_VALUE_NAME_A => "PeerUsages"

    /**
     * @type {String}
     */
    static CERT_LOCAL_MACHINE_SYSTEM_STORE_REGPATH => "Software\Microsoft\SystemCertificates"

    /**
     * @type {String}
     */
    static CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME => "AuthenticodeFlags"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_PUB_ALLOW_TRUST_MASK => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_PUB_ALLOW_END_USER_TRUST => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_PUB_CHECK_PUBLISHER_REV_FLAG => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_PUB_CHECK_TIMESTAMP_REV_FLAG => 512

    /**
     * @type {String}
     */
    static CERT_OCM_SUBCOMPONENTS_LOCAL_MACHINE_REGPATH => "SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OC Manager\Subcomponents"

    /**
     * @type {String}
     */
    static CERT_OCM_SUBCOMPONENTS_ROOT_AUTO_UPDATE_VALUE_NAME => "RootAutoUpdate"

    /**
     * @type {String}
     */
    static CERT_DISABLE_ROOT_AUTO_UPDATE_VALUE_NAME => "DisableRootAutoUpdate"

    /**
     * @type {String}
     */
    static CERT_ENABLE_DISALLOWED_CERT_AUTO_UPDATE_VALUE_NAME => "EnableDisallowedCertAutoUpdate"

    /**
     * @type {String}
     */
    static CERT_DISABLE_PIN_RULES_AUTO_UPDATE_VALUE_NAME => "DisablePinRulesAutoUpdate"

    /**
     * @type {String}
     */
    static CERT_AUTO_UPDATE_ROOT_DIR_URL_VALUE_NAME => "RootDirUrl"

    /**
     * @type {String}
     */
    static CERT_AUTO_UPDATE_SYNC_FROM_DIR_URL_VALUE_NAME => "SyncFromDirUrl"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_AUTO_UPDATE_ROOT_DIR_URL_VALUE_NAME => "RootDirUrl"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME => "SyncDeltaTime"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_AUTO_UPDATE_FLAGS_VALUE_NAME => "Flags"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_AUTO_UPDATE_DISABLE_RANDOM_QUERY_STRING_FLAG => 4

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME => "LastSyncTime"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME => "EncodedCtl"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_CTL_FILENAME => "authroot.stl"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_CTL_FILENAME_A => "authroot.stl"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_CAB_FILENAME => "authrootstl.cab"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_SEQ_FILENAME => "authrootseq.txt"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_CERT_EXT => ".crt"

    /**
     * @type {String}
     */
    static CERT_DISALLOWED_CERT_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME => "DisallowedCertSyncDeltaTime"

    /**
     * @type {String}
     */
    static CERT_DISALLOWED_CERT_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME => "DisallowedCertLastSyncTime"

    /**
     * @type {String}
     */
    static CERT_DISALLOWED_CERT_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME => "DisallowedCertEncodedCtl"

    /**
     * @type {String}
     */
    static CERT_DISALLOWED_CERT_CTL_FILENAME => "disallowedcert.stl"

    /**
     * @type {String}
     */
    static CERT_DISALLOWED_CERT_CTL_FILENAME_A => "disallowedcert.stl"

    /**
     * @type {String}
     */
    static CERT_DISALLOWED_CERT_CAB_FILENAME => "disallowedcertstl.cab"

    /**
     * @type {String}
     */
    static CERT_DISALLOWED_CERT_AUTO_UPDATE_LIST_IDENTIFIER => "DisallowedCert_AutoUpdate_1"

    /**
     * @type {String}
     */
    static CERT_PIN_RULES_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME => "PinRulesSyncDeltaTime"

    /**
     * @type {String}
     */
    static CERT_PIN_RULES_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME => "PinRulesLastSyncTime"

    /**
     * @type {String}
     */
    static CERT_PIN_RULES_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME => "PinRulesEncodedCtl"

    /**
     * @type {String}
     */
    static CERT_PIN_RULES_CTL_FILENAME => "pinrules.stl"

    /**
     * @type {String}
     */
    static CERT_PIN_RULES_CTL_FILENAME_A => "pinrules.stl"

    /**
     * @type {String}
     */
    static CERT_PIN_RULES_CAB_FILENAME => "pinrulesstl.cab"

    /**
     * @type {String}
     */
    static CERT_PIN_RULES_AUTO_UPDATE_LIST_IDENTIFIER => "PinRules_AutoUpdate_1"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REGISTRY_STORE_REMOTE_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REGISTRY_STORE_SERIALIZED_FLAG => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REGISTRY_STORE_CLIENT_GPT_FLAG => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REGISTRY_STORE_LM_GPT_FLAG => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REGISTRY_STORE_ROAMING_FLAG => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REGISTRY_STORE_EXTERNAL_FLAG => 1048576

    /**
     * @type {String}
     */
    static CERT_IE_DIRTY_FLAGS_REGPATH => "Software\Microsoft\Cryptography\IEDirtyFlags"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_FILE_STORE_COMMIT_ENABLE_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_LDAP_STORE_SIGN_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_LDAP_STORE_AREC_EXCLUSIVE_FLAG => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_LDAP_STORE_OPENED_FLAG => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_LDAP_STORE_UNBIND_FLAG => 524288

    /**
     * @type {String}
     */
    static CRYPT_OID_OPEN_STORE_PROV_FUNC => "CertDllOpenStoreProv"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_GP_SYSTEM_STORE_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_SHARED_USER_FLAG => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_CLOSE_FUNC => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_READ_CERT_FUNC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_WRITE_CERT_FUNC => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_DELETE_CERT_FUNC => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_READ_CRL_FUNC => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_WRITE_CRL_FUNC => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_DELETE_CRL_FUNC => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_READ_CTL_FUNC => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_WRITE_CTL_FUNC => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_DELETE_CTL_FUNC => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_CONTROL_FUNC => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_FIND_CERT_FUNC => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_FREE_FIND_CERT_FUNC => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_GET_CERT_PROPERTY_FUNC => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_FIND_CRL_FUNC => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_FREE_FIND_CRL_FUNC => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_GET_CRL_PROPERTY_FUNC => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_FIND_CTL_FUNC => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_FREE_FIND_CTL_FUNC => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_GET_CTL_PROPERTY_FUNC => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_WRITE_ADD_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_SAVE_AS_PKCS12 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CLOSE_STORE_FORCE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CLOSE_STORE_CHECK_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_MASK => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_SHA1_HASH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_NAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_ATTR => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_MD5_HASH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_PROPERTY => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_PUBLIC_KEY => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_HASH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_NAME_STR_A => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_NAME_STR_W => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_KEY_SPEC => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_ENHKEY_USAGE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_CTL_USAGE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_SUBJECT_CERT => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_ISSUER_OF => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_EXISTING => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_SIGNATURE_HASH => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_KEY_IDENTIFIER => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_CERT_ID => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_CROSS_CERT_DIST_POINTS => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_PUBKEY_MD5_HASH => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_SUBJECT_INFO_ACCESS => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_HASH_STR => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_HAS_PRIVATE_KEY => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_SHA256_HASH => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_SHA1_SHA256_HASH => 23

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CTL_ENTRY_FROM_PROP_CHAIN_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_ISSUED_BY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_EXISTING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_ISSUED_FOR => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_ISSUED_BY_AKI_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_ISSUED_BY_SIGNATURE_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_ISSUED_BY_DELTA_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_ISSUED_BY_BASE_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_ISSUED_FOR_SET_STRONG_PROPERTIES_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_ADD_NEW => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_ADD_USE_EXISTING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_ADD_REPLACE_EXISTING => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_ADD_ALWAYS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_ADD_NEWER => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_CERTIFICATE_CONTEXT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_CRL_CONTEXT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_CTL_CONTEXT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CTL_ANY_SUBJECT_TYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTL_CERT_SUBJECT_TYPE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CTL_FIND_NO_LIST_ID_CBDATA => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_CTRL_RESYNC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_CTRL_NOTIFY_CHANGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_CTRL_COMMIT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_CTRL_AUTO_RESYNC => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_CTRL_CANCEL_NOTIFY => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_LOCALIZED_NAME_PROP_ID => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CREATE_CONTEXT_NOCOPY_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CREATE_CONTEXT_SORTED_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CREATE_CONTEXT_NO_ENTRY_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG => 1

    /**
     * @type {String}
     */
    static CERT_PHYSICAL_STORE_DEFAULT_NAME => ".Default"

    /**
     * @type {String}
     */
    static CERT_PHYSICAL_STORE_GROUP_POLICY_NAME => ".GroupPolicy"

    /**
     * @type {String}
     */
    static CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME => ".LocalMachine"

    /**
     * @type {String}
     */
    static CERT_PHYSICAL_STORE_DS_USER_CERTIFICATE_NAME => ".UserCertificate"

    /**
     * @type {String}
     */
    static CERT_PHYSICAL_STORE_LOCAL_MACHINE_GROUP_POLICY_NAME => ".LocalMachineGroupPolicy"

    /**
     * @type {String}
     */
    static CERT_PHYSICAL_STORE_ENTERPRISE_NAME => ".Enterprise"

    /**
     * @type {String}
     */
    static CERT_PHYSICAL_STORE_AUTH_ROOT_NAME => ".AuthRoot"

    /**
     * @type {String}
     */
    static CERT_PHYSICAL_STORE_SMART_CARD_NAME => ".SmartCard"

    /**
     * @type {String}
     */
    static CRYPT_OID_OPEN_SYSTEM_STORE_PROV_FUNC => "CertDllOpenSystemStoreProv"

    /**
     * @type {String}
     */
    static CRYPT_OID_REGISTER_SYSTEM_STORE_FUNC => "CertDllRegisterSystemStore"

    /**
     * @type {String}
     */
    static CRYPT_OID_UNREGISTER_SYSTEM_STORE_FUNC => "CertDllUnregisterSystemStore"

    /**
     * @type {String}
     */
    static CRYPT_OID_ENUM_SYSTEM_STORE_FUNC => "CertDllEnumSystemStore"

    /**
     * @type {String}
     */
    static CRYPT_OID_REGISTER_PHYSICAL_STORE_FUNC => "CertDllRegisterPhysicalStore"

    /**
     * @type {String}
     */
    static CRYPT_OID_UNREGISTER_PHYSICAL_STORE_FUNC => "CertDllUnregisterPhysicalStore"

    /**
     * @type {String}
     */
    static CRYPT_OID_ENUM_PHYSICAL_STORE_FUNC => "CertDllEnumPhysicalStore"

    /**
     * @type {String}
     */
    static CRYPT_OID_SYSTEM_STORE_LOCATION_VALUE_NAME => "SystemStoreLocation"

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_TRUSTED_SIGNER_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_ONLY_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_USE_SIGNER_INDEX_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CMS_ENCAPSULATED_CTL_FLAG => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENCODE_SORTED_CTL_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_TRUSTED_SIGNERS_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_NO_TIME_CHECK_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_ALLOW_MORE_USAGE_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_UPDATED_CTL_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CONTEXT_REVOCATION_TYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_REV_CHAIN_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_REV_SERVER_OCSP_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_REV_NO_OCSP_FAILOVER_TO_CRL_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_REV_SERVER_OCSP_WIRE_ONLY_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_UNICODE_IS_RDN_ATTRS_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_SUBJECT_OCSP_BASIC_SIGNED_RESPONSE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_CHECK_WEAK_HASH_FLAG => 8

    /**
     * @type {String}
     */
    static CRYPT_OID_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC => "CryptDllExtractEncodedSignatureParameters"

    /**
     * @type {String}
     */
    static CRYPT_OID_SIGN_AND_ENCODE_HASH_FUNC => "CryptDllSignAndEncodeHash"

    /**
     * @type {String}
     */
    static CRYPT_OID_VERIFY_ENCODED_SIGNATURE_FUNC => "CryptDllVerifyEncodedSignature"

    /**
     * @type {String}
     */
    static CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC => "CryptDllExportPublicKeyInfoEx"

    /**
     * @type {String}
     */
    static CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC => "CryptDllExportPublicKeyInfoEx2"

    /**
     * @type {String}
     */
    static CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC => "CryptDllExportPublicKeyInfoFromBCryptKeyHandle"

    /**
     * @type {String}
     */
    static CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC => "CryptDllImportPublicKeyInfoEx"

    /**
     * @type {String}
     */
    static CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC => "CryptDllImportPublicKeyInfoEx2"

    /**
     * @type {String}
     */
    static CRYPT_OID_IMPORT_PRIVATE_KEY_INFO_FUNC => "CryptDllImportPrivateKeyInfoEx"

    /**
     * @type {String}
     */
    static CRYPT_OID_EXPORT_PRIVATE_KEY_INFO_FUNC => "CryptDllExportPrivateKeyInfoEx"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DELETE_KEYSET => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_XML_NAME_STR => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_SEMICOLON_FLAG => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_NO_PLUS_FLAG => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_NO_QUOTING_FLAG => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_CRLF_FLAG => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_COMMA_FLAG => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_REVERSE_FLAG => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_FORWARD_FLAG => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_DISABLE_UTF8_DIR_STR_FLAG => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_ENABLE_PUNYCODE_FLAG => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_EMAIL_TYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_RDN_TYPE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_ATTR_TYPE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_SIMPLE_DISPLAY_TYPE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_FRIENDLY_DISPLAY_TYPE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_DNS_TYPE => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_URL_TYPE => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_UPN_TYPE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_ISSUER_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_DISABLE_IE4_UTF8_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_SEARCH_ALL_NAMES_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MESSAGE_KEYID_SIGNER_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MESSAGE_SILENT_KEYSET_FLAG => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG => 4

    /**
     * @type {Integer (Int32)}
     */
    static CREDENTIAL_OID_PASSWORD_CREDENTIALS_A => 1

    /**
     * @type {Integer (Int32)}
     */
    static CREDENTIAL_OID_PASSWORD_CREDENTIALS_W => 2

    /**
     * @type {Integer (Int32)}
     */
    static CREDENTIAL_OID_PASSWORD_CREDENTIALS => 2

    /**
     * @type {String}
     */
    static SCHEME_OID_RETRIEVE_ENCODED_OBJECT_FUNC => "SchemeDllRetrieveEncodedObject"

    /**
     * @type {String}
     */
    static SCHEME_OID_RETRIEVE_ENCODED_OBJECTW_FUNC => "SchemeDllRetrieveEncodedObjectW"

    /**
     * @type {String}
     */
    static CONTEXT_OID_CREATE_OBJECT_CONTEXT_FUNC => "ContextDllCreateObjectContext"

    /**
     * @type {Integer (Int32)}
     */
    static CONTEXT_OID_CERTIFICATE => 1

    /**
     * @type {Integer (Int32)}
     */
    static CONTEXT_OID_CRL => 2

    /**
     * @type {Integer (Int32)}
     */
    static CONTEXT_OID_CTL => 3

    /**
     * @type {Integer (Int32)}
     */
    static CONTEXT_OID_PKCS7 => 4

    /**
     * @type {Integer (Int32)}
     */
    static CONTEXT_OID_CAPI2_ANY => 5

    /**
     * @type {Integer (Int32)}
     */
    static CONTEXT_OID_OCSP_RESP => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_RETRIEVE_MULTIPLE_OBJECTS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_CACHE_ONLY_RETRIEVAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_WIRE_ONLY_RETRIEVAL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DONT_CACHE_RESULT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ASYNC_RETRIEVAL => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STICKY_CACHE_RETRIEVAL => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OFFLINE_CHECK_RETRIEVAL => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_LDAP_SIGN_RETRIEVAL => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_NO_AUTH_RETRIEVAL => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_AIA_RETRIEVAL => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_HTTP_POST_RETRIEVAL => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_PROXY_CACHE_RETRIEVAL => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_NOT_MODIFIED_RETRIEVAL => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ENABLE_SSL_REVOCATION_RETRIEVAL => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_RANDOM_QUERY_STRING_RETRIEVAL => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ENABLE_FILE_RETRIEVAL => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_CREATE_NEW_FLUSH_ENTRY => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CONTEXT_SIGNATURE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_DATA_HASH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_KEEP_TIME_VALID => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DONT_VERIFY_SIGNATURE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DONT_CHECK_TIME_VALIDITY => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_CHECK_FRESHNESS_TIME_VALIDITY => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ACCUMULATIVE_TIMEOUT => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OCSP_ONLY_RETRIEVAL => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_NO_OCSP_FAILOVER_TO_CRL_RETRIEVAL => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_PRE_FETCH_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_PRE_FETCH_BLOB => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_PRE_FETCH_CRL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_PRE_FETCH_OCSP => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_PRE_FETCH_AUTOROOT_CAB => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_PRE_FETCH_DISALLOWED_CERT_CAB => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_PRE_FETCH_PIN_RULES_CAB => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_DEFAULT_FLUSH => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_DISABLE_FLUSH => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_RESPONSE_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_RESPONSE_HTTP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_RESPONSE_VALIDATED => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_RETRIEVE_MAX_ERROR_CONTENT_LENGTH => 4096

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_PARAM_ASYNC_RETRIEVAL_COMPLETION => 1

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_PARAM_CANCEL_ASYNC_RETRIEVAL => 2

    /**
     * @type {String}
     */
    static URL_OID_GET_OBJECT_URL_FUNC => "UrlDllGetObjectUrl"

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CERTIFICATE_ISSUER => 1

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CERTIFICATE_CRL_DIST_POINT => 2

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CTL_ISSUER => 3

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CTL_NEXT_UPDATE => 4

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CRL_ISSUER => 5

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CERTIFICATE_FRESHEST_CRL => 6

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CRL_FRESHEST_CRL => 7

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CROSS_CERT_DIST_POINT => 8

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CERTIFICATE_OCSP => 9

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CERTIFICATE_OCSP_AND_CRL_DIST_POINT => 10

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CERTIFICATE_CRL_DIST_POINT_AND_OCSP => 11

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CROSS_CERT_SUBJECT_INFO_ACCESS => 12

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CERTIFICATE_ONLY_OCSP => 13

    /**
     * @type {String}
     */
    static TIME_VALID_OID_GET_OBJECT_FUNC => "TimeValidDllGetObject"

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_GET_CTL => 1

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_GET_CRL => 2

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_GET_CRL_FROM_CERT => 3

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CERT => 4

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CRL => 5

    /**
     * @type {String}
     */
    static TIME_VALID_OID_FLUSH_OBJECT_FUNC => "TimeValidDllFlushObject"

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_FLUSH_CTL => 1

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_FLUSH_CRL => 2

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_FLUSH_CRL_FROM_CERT => 3

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CERT => 4

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CRL => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_KEYID_MACHINE_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_KEYID_ALLOC_FLAG => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_KEYID_DELETE_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_KEYID_SET_NEW_FLAG => 8192

    /**
     * @type {String}
     */
    static CERT_CHAIN_CONFIG_REGPATH => "Software\Microsoft\Cryptography\OID\EncodingType 0\CertDllCreateCertificateChainEngine\Config"

    /**
     * @type {String}
     */
    static CERT_CHAIN_MAX_URL_RETRIEVAL_BYTE_COUNT_VALUE_NAME => "MaxUrlRetrievalByteCount"

    /**
     * @type {String}
     */
    static CERT_CHAIN_CACHE_RESYNC_FILETIME_VALUE_NAME => "ChainCacheResyncFiletime"

    /**
     * @type {String}
     */
    static CERT_CHAIN_DISABLE_MANDATORY_BASIC_CONSTRAINTS_VALUE_NAME => "DisableMandatoryBasicConstraints"

    /**
     * @type {String}
     */
    static CERT_CHAIN_DISABLE_CA_NAME_CONSTRAINTS_VALUE_NAME => "DisableCANameConstraints"

    /**
     * @type {String}
     */
    static CERT_CHAIN_DISABLE_UNSUPPORTED_CRITICAL_EXTENSIONS_VALUE_NAME => "DisableUnsupportedCriticalExtensions"

    /**
     * @type {String}
     */
    static CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_VALUE_NAME => "MaxAIAUrlCountInCert"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_DEFAULT => 5

    /**
     * @type {String}
     */
    static CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_VALUE_NAME => "MaxAIAUrlRetrievalCountPerChain"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_DEFAULT => 3

    /**
     * @type {String}
     */
    static CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_VALUE_NAME => "MaxAIAUrlRetrievalByteCount"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_DEFAULT => 100000

    /**
     * @type {String}
     */
    static CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_VALUE_NAME => "MaxAIAUrlRetrievalCertCount"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_DEFAULT => 10

    /**
     * @type {String}
     */
    static CERT_CHAIN_OCSP_VALIDITY_SECONDS_VALUE_NAME => "OcspValiditySeconds"

    /**
     * @type {String}
     */
    static CERT_CHAIN_DISABLE_SERIAL_CHAIN_VALUE_NAME => "DisableSerialChain"

    /**
     * @type {String}
     */
    static CERT_CHAIN_SERIAL_CHAIN_LOG_FILE_NAME_VALUE_NAME => "SerialChainLogFileName"

    /**
     * @type {String}
     */
    static CERT_CHAIN_DISABLE_SYNC_WITH_SSL_TIME_VALUE_NAME => "DisableSyncWithSslTime"

    /**
     * @type {String}
     */
    static CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_VALUE_NAME => "MaxSslTimeUpdatedEventCount"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DEFAULT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DISABLE => 4294967295

    /**
     * @type {String}
     */
    static CERT_CHAIN_SSL_HANDSHAKE_LOG_FILE_NAME_VALUE_NAME => "SslHandshakeLogFileName"

    /**
     * @type {String}
     */
    static CERT_CHAIN_ENABLE_WEAK_SIGNATURE_FLAGS_VALUE_NAME => "EnableWeakSignatureFlags"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_MD2_MD4_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_WEAK_RSA_ROOT_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_WEAK_LOGGING_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_ONLY_WEAK_LOGGING_FLAG => 8

    /**
     * @type {String}
     */
    static CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_VALUE_NAME => "MinRsaPubKeyBitLength"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_DEFAULT => 1023

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_DISABLE => 4294967295

    /**
     * @type {String}
     */
    static CERT_CHAIN_MIN_WEAK_RSA_PUB_KEY_BIT_LENGTH_VALUE_NAME => "MinWeakRsaPubKeyBitLength"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MIN_WEAK_RSA_PUB_KEY_BIT_LENGTH_DEFAULT => 2047

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MIN_WEAK_RSA_PUB_KEY_BIT_LENGTH_DISABLE => 4294967295

    /**
     * @type {String}
     */
    static CERT_CHAIN_MIN_TELEMETRY_RSA_PUB_KEY_BIT_LENGTH_VALUE_NAME => "MinTelemetryRsaPubKeyBitLength"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MIN_TELEMETRY_RSA_PUB_KEY_BIT_LENGTH_DEFAULT => 2047

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MIN_TELEMETRY_RSA_PUB_KEY_BIT_LENGTH_DISABLE => 4294967295

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_RSA_PUB_KEY_TIME_VALUE_NAME => "WeakRsaPubKeyTime"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_SIGNATURE_LOG_DIR_VALUE_NAME => "WeakSignatureLogDir"

    /**
     * @type {String}
     */
    static CERT_CHAIN_DEFAULT_CONFIG_SUBDIR => "Default"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_PREFIX_NAME => "Weak"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_THIRD_PARTY_CONFIG_NAME => "ThirdParty"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_ALL_CONFIG_NAME => "All"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_FLAGS_NAME => "Flags"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_HYGIENE_NAME => "Hygiene"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_AFTER_TIME_NAME => "AfterTime"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_FILE_HASH_AFTER_TIME_NAME => "FileHashAfterTime"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_TIMESTAMP_HASH_AFTER_TIME_NAME => "TimestampHashAfterTime"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_MIN_BIT_LENGTH_NAME => "MinBitLength"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_SHA256_ALLOW_NAME => "Sha256Allow"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MIN_PUB_KEY_BIT_LENGTH_DISABLE => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_WEAK_SETTINGS_FLAG => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_ECC_PARA_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_ALL_EKU_WEAK_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_ALL_EKU_HYGIENE_FLAG => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_OPT_IN_SERVER_AUTH_WEAK_FLAG => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_SERVER_AUTH_WEAK_FLAG => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_SERVER_AUTH_HYGIENE_FLAG => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_CODE_SIGNING_WEAK_FLAG => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_MOTW_CODE_SIGNING_WEAK_FLAG => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_CODE_SIGNING_HYGIENE_FLAG => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_MOTW_CODE_SIGNING_HYGIENE_FLAG => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_TIMESTAMP_WEAK_FLAG => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_WEAK_FLAG => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_TIMESTAMP_HYGIENE_FLAG => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_MOTW_TIMESTAMP_HYGIENE_FLAG => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MOTW_IGNORE_AFTER_TIME_WEAK_FLAG => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_FILE_HASH_WEAK_FLAG => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_MOTW_FILE_HASH_WEAK_FLAG => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_TIMESTAMP_HASH_WEAK_FLAG => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_HASH_WEAK_FLAG => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_OPT_IN_WEAK_FLAGS => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_CURRENT_USER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_LOCAL_MACHINE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_IMPERSONATED => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_PROCESS_INFO => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_PINRULE_INFO => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_NETWORK_INFO => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_SERIAL_LOCAL_MACHINE => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_HPKP_RULE_INFO => 8

    /**
     * @type {String}
     */
    static CERT_CHAIN_AUTO_FLAGS_VALUE_NAME => "AutoFlags"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_FLUSH_DISABLE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_LOG_CREATE_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_LOG_FREE_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_LOG_FLUSH_FLAG => 8

    /**
     * @type {String}
     */
    static CERT_CHAIN_AUTO_FLUSH_FIRST_DELTA_SECONDS_VALUE_NAME => "AutoFlushFirstDeltaSeconds"

    /**
     * @type {String}
     */
    static CERT_CHAIN_AUTO_FLUSH_NEXT_DELTA_SECONDS_VALUE_NAME => "AutoFlushNextDeltaSeconds"

    /**
     * @type {String}
     */
    static CERT_CHAIN_AUTO_LOG_FILE_NAME_VALUE_NAME => "AutoLogFileName"

    /**
     * @type {String}
     */
    static CERT_CHAIN_DISABLE_AUTO_FLUSH_PROCESS_NAME_LIST_VALUE_NAME => "DisableAutoFlushProcessNameList"

    /**
     * @type {String}
     */
    static CERT_SRV_OCSP_RESP_MIN_VALIDITY_SECONDS_VALUE_NAME => "SrvOcspRespMinValiditySeconds"

    /**
     * @type {String}
     */
    static CERT_SRV_OCSP_RESP_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME => "SrvOcspRespUrlRetrievalTimeoutMilliseconds"

    /**
     * @type {String}
     */
    static CERT_SRV_OCSP_RESP_MAX_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME => "SrvOcspRespMaxBeforeNextUpdateSeconds"

    /**
     * @type {String}
     */
    static CERT_SRV_OCSP_RESP_MIN_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME => "SrvOcspRespMinBeforeNextUpdateSeconds"

    /**
     * @type {String}
     */
    static CERT_SRV_OCSP_RESP_MIN_AFTER_NEXT_UPDATE_SECONDS_VALUE_NAME => "SrvOcspRespMinAfterNextUpdateSeconds"

    /**
     * @type {String}
     */
    static CERT_SRV_OCSP_RESP_MIN_SYNC_CERT_FILE_SECONDS_VALUE_NAME => "SrvOcspRespMinSyncCertFileSeconds"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SRV_OCSP_RESP_MIN_SYNC_CERT_FILE_SECONDS_DEFAULT => 5

    /**
     * @type {String}
     */
    static CERT_SRV_OCSP_RESP_MAX_SYNC_CERT_FILE_SECONDS_VALUE_NAME => "SrvOcspRespMaxSyncCertFileSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_MAX_CACHED_OCSP_PER_CRL_COUNT_VALUE_NAME => "CryptnetMaxCachedOcspPerCrlCount"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_MAX_CACHED_OCSP_PER_CRL_COUNT_DEFAULT => 500

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_OCSP_AFTER_CRL_DISABLE => 4294967295

    /**
     * @type {String}
     */
    static CRYPTNET_URL_CACHE_DEFAULT_FLUSH_EXEMPT_SECONDS_VALUE_NAME => "CryptnetDefaultFlushExemptSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_MIN_MAX_AGE_SECONDS_VALUE_NAME => "CryptnetPreFetchMinMaxAgeSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_MAX_MAX_AGE_SECONDS_VALUE_NAME => "CryptnetPreFetchMaxMaxAgeSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_MIN_OCSP_VALIDITY_PERIOD_SECONDS_VALUE_NAME => "CryptnetPreFetchMinOcspValidityPeriodSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_AFTER_PUBLISH_PRE_FETCH_DIVISOR_VALUE_NAME => "CryptnetPreFetchAfterPublishPreFetchDivisor"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_PRE_FETCH_AFTER_PUBLISH_PRE_FETCH_DIVISOR_DEFAULT => 10

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_BEFORE_NEXT_UPDATE_PRE_FETCH_DIVISOR_VALUE_NAME => "CryptnetPreFetchBeforeNextUpdatePreFetchDivisor"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_PRE_FETCH_BEFORE_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT => 20

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_MIN_BEFORE_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME => "CryptnetPreFetchMinBeforeNextUpdatePreFetchSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_VALIDITY_PERIOD_AFTER_NEXT_UPDATE_PRE_FETCH_DIVISOR_VALUE_NAME => "CryptnetPreFetchValidityPeriodAfterNextUpdatePreFetchDivisor"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_PRE_FETCH_VALIDITY_PERIOD_AFTER_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT => 10

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_MAX_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME => "CryptnetPreFetchMaxAfterNextUpdatePreFetchPeriodSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_MIN_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME => "CryptnetPreFetchMinAfterNextUpdatePreFetchPeriodSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_AFTER_CURRENT_TIME_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME => "CryptnetPreFetchAfterCurrentTimePreFetchPeriodSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_TRIGGER_PERIOD_SECONDS_VALUE_NAME => "CryptnetPreFetchTriggerPeriodSeconds"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_PRE_FETCH_TRIGGER_DISABLE => 4294967295

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_SCAN_AFTER_TRIGGER_DELAY_SECONDS_VALUE_NAME => "CryptnetPreFetchScanAfterTriggerDelaySeconds"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_PRE_FETCH_SCAN_AFTER_TRIGGER_DELAY_SECONDS_DEFAULT => 60

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_RETRIEVAL_TIMEOUT_SECONDS_VALUE_NAME => "CryptnetPreFetchRetrievalTimeoutSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_PROCESS_NAME_LIST_VALUE_NAME => "ProcessNameList"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_URL_LIST_VALUE_NAME => "PreFetchUrlList"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_DISABLE_INFORMATION_EVENTS_VALUE_NAME => "DisableInformationEvents"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_LOG_FILE_NAME_VALUE_NAME => "LogFileName"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_TIMEOUT_SECONDS_VALUE_NAME => "TimeoutSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_MAX_AGE_SECONDS_VALUE_NAME => "MaxAgeSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_PUBLISH_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME => "PublishBeforeNextUpdateSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_PUBLISH_RANDOM_INTERVAL_SECONDS_VALUE_NAME => "PublishRandomIntervalSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_MIN_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME => "MinBeforeNextUpdateSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_MIN_AFTER_NEXT_UPDATE_SECONDS_VALUE_NAME => "MinAfterNextUpdateSeconds"

    /**
     * @type {String}
     */
    static CERT_CHAIN_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME => "ChainUrlRetrievalTimeoutMilliseconds"

    /**
     * @type {String}
     */
    static CERT_CHAIN_REV_ACCUMULATIVE_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME => "ChainRevAccumulativeUrlRetrievalTimeoutMilliseconds"

    /**
     * @type {String}
     */
    static CERT_RETR_BEHAVIOR_INET_AUTH_VALUE_NAME => "EnableInetUnknownAuth"

    /**
     * @type {String}
     */
    static CERT_RETR_BEHAVIOR_INET_STATUS_VALUE_NAME => "EnableInetLocal"

    /**
     * @type {String}
     */
    static CERT_RETR_BEHAVIOR_FILE_VALUE_NAME => "AllowFileUrlScheme"

    /**
     * @type {String}
     */
    static CERT_RETR_BEHAVIOR_LDAP_VALUE_NAME => "DisableLDAPSignAndEncrypt"

    /**
     * @type {String}
     */
    static CRYPTNET_CACHED_OCSP_SWITCH_TO_CRL_COUNT_VALUE_NAME => "CryptnetCachedOcspSwitchToCrlCount"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_CACHED_OCSP_SWITCH_TO_CRL_COUNT_DEFAULT => 50

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_CRL_BEFORE_OCSP_ENABLE => 4294967295

    /**
     * @type {String}
     */
    static CERT_CHAIN_DISABLE_AIA_URL_RETRIEVAL_VALUE_NAME => "DisableAIAUrlRetrieval"

    /**
     * @type {String}
     */
    static CERT_CHAIN_OPTIONS_VALUE_NAME => "Options"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_OPTION_DISABLE_AIA_URL_RETRIEVAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_OPTION_ENABLE_SIA_URL_RETRIEVAL => 4

    /**
     * @type {String}
     */
    static CERT_CHAIN_CROSS_CERT_DOWNLOAD_INTERVAL_HOURS_VALUE_NAME => "CrossCertDownloadIntervalHours"

    /**
     * @type {String}
     */
    static CERT_CHAIN_CRL_VALIDITY_EXT_PERIOD_HOURS_VALUE_NAME => "CRLValidityExtensionPeriod"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_CRL_VALIDITY_EXT_PERIOD_HOURS_DEFAULT => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_CACHE_END_CERT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_THREAD_STORE_SYNC => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_USE_LOCAL_MACHINE_STORE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_SHARE_STORE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_EXCLUSIVE_ENABLE_CA_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_NO_ERROR => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_NOT_TIME_VALID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_NOT_TIME_NESTED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_REVOKED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_NOT_SIGNATURE_VALID => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_NOT_VALID_FOR_USAGE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_UNTRUSTED_ROOT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_REVOCATION_STATUS_UNKNOWN => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_CYCLIC => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_INVALID_EXTENSION => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_INVALID_POLICY_CONSTRAINTS => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_INVALID_BASIC_CONSTRAINTS => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_INVALID_NAME_CONSTRAINTS => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_OFFLINE_REVOCATION => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_EXPLICIT_DISTRUST => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_WEAK_SIGNATURE => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_WEAK_HYGIENE => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_MIN_TELEMETRY_RSA => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_MIN_WEAK_RSA => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_PARTIAL_CHAIN => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_CTL_IS_NOT_TIME_VALID => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_EXACT_MATCH_ISSUER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_KEY_MATCH_ISSUER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_NAME_MATCH_ISSUER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_SELF_SIGNED => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_AUTO_UPDATE_CA_REVOCATION => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_AUTO_UPDATE_END_REVOCATION => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_NO_OCSP_FAILOVER_TO_CRL => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_KEY_ROLLOVER => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_SSL_HANDSHAKE_OCSP => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_SSL_TIME_VALID_OCSP => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_SSL_RECONNECT_OCSP => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_PREFERRED_ISSUER => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_PEER_TRUSTED => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_CRL_VALIDITY_EXTENDED => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_FROM_EXCLUSIVE_TRUST_STORE => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_CA_TRUSTED => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_AUTO_UPDATE_WEAK_SIGNATURE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_ALLOW_WEAK_SIGNATURE => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_BEFORE_DISALLOWED_CA_FILETIME => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_COMPLEX_CHAIN => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_SSL_TIME_VALID => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_NO_TIME_CHECK => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static USAGE_MATCH_TYPE_AND => 0

    /**
     * @type {Integer (UInt32)}
     */
    static USAGE_MATCH_TYPE_OR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_STRONG_SIGN_DISABLE_END_CHECK_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_REVOCATION_CHECK_END_CERT => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_REVOCATION_CHECK_CHAIN => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_REVOCATION_CHECK_OCSP_CERT => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_TIMESTAMP_TIME => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_PEER_TRUST => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_MY_PEER_TRUST => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_MD2_MD4 => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_AIA => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_HAS_MOTW => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ONLY_ADDITIONAL_AND_AUTH_ROOT => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_OPT_IN_WEAK_SIGNATURE => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_DISALLOWED_CA => 131072

    /**
     * @type {Integer (Int32)}
     */
    static REVOCATION_OID_CRL_REVOCATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_FIND_BY_ISSUER => 1

    /**
     * @type {String}
     */
    static CRYPT_OID_VERIFY_CERTIFICATE_CHAIN_POLICY_FUNC => "CertDllVerifyCertificateChainPolicy"

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_BASE => 1

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_AUTHENTICODE => 2

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_AUTHENTICODE_TS => 3

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_SSL => 4

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_BASIC_CONSTRAINTS => 5

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_NT_AUTH => 6

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_MICROSOFT_ROOT => 7

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_EV => 8

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_SSL_F12 => 9

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_SSL_HPKP_HEADER => 10

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_THIRD_PARTY_ROOT => 11

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_SSL_KEY_PIN => 12

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_CT => 13

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_F12_ERROR_TEXT_LENGTH => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_F12_SUCCESS_LEVEL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_F12_WARNING_LEVEL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_F12_ERROR_LEVEL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_F12_NONE_CATEGORY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_F12_WEAK_CRYPTO_CATEGORY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_F12_ROOT_PROGRAM_CATEGORY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_HPKP_PKP_HEADER_INDEX => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_HPKP_PKP_RO_HEADER_INDEX => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_HPKP_HEADER_COUNT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_KEY_PIN_ERROR_TEXT_LENGTH => 512

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_ERROR => -2

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_ERROR => -1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_KEY_PIN_SUCCESS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_WARNING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_WARNING => 2

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_CT_ERROR_UNDECODABLE_SCT_EXTENSION => -112

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_CT_ERROR_UNRETRIEVABLE_SCT_EXTENSION => -111

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_CT_ERROR_MISSING_SCT_EXTENSION => -110

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_CT_ERROR_INVALID_ISSUER_CERT => -101

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_CT_ERROR_INVALID_SUBJECT_CERT => -100

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_CT_ERROR_CANNOT_VALIDATE_SCT => -50

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_CT_ERROR_SCT_VALIDATION_STATUS_INSUFFICIENT => -4

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_CT_ERROR_SCT_VALIDATION_STATUS_UNKNOWN_VERSION => -3

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_CT_ERROR_SCT_VALIDATION_STATUS_UNKNOWN_LOG => -2

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_CT_ERROR_SCT_VALIDATION_STATUS_INVALID => -1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_SUCCESS_SCT_VALIDIDATION_STATUS_VALID => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_OUT_OF_MEMORY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_BEFORE_CODE_SIGNING_CT_LOGGING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_NOT_THIRD_PARTY_CERT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_EXPIRED_ROOT_CTL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_INVALID_CHAIN_CONTEXT => 50

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_NOT_SUPPORTED_CA => 51

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_MISSING_ROOT_CTL => 52

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_MISSING_CT_EXT => 60

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_INVALID_CT_EXT => 61

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_UNABLE_TO_DECODE_EXT => 62

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_UNABLE_TO_DECODE_PARAMETERS => 70

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_INVALID_TEMP_FILE => 80

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_CANNOT_CREATE_TEMP_FILE => 81

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_CANNOT_WRITE_TEMP_FILE => 82

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_CANNOT_LOAD_CTLOG_STORE_FILE => 83

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_FAILED_INIT => 90

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_HASHING_ERROR => 200

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_INVALID_STR => 201

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_CT_WARNING_CANNOT_CREATE_POLICY => 300

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STRING_BASE64URI => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STRING_ENCODEMASK => 255

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STRING_RESERVED100 => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STRING_RESERVED200 => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STRING_PERCENTESCAPE => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STRING_HASHDATA => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STRING_NOCRLF => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STRING_NOCR => 2147483648

    /**
     * @type {String}
     */
    static szOID_PKCS_12_PbeIds => "1.2.840.113549.1.12.1"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_pbeWithSHA1And128BitRC4 => "1.2.840.113549.1.12.1.1"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_pbeWithSHA1And40BitRC4 => "1.2.840.113549.1.12.1.2"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES => "1.2.840.113549.1.12.1.3"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_pbeWithSHA1And2KeyTripleDES => "1.2.840.113549.1.12.1.4"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_pbeWithSHA1And128BitRC2 => "1.2.840.113549.1.12.1.5"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_pbeWithSHA1And40BitRC2 => "1.2.840.113549.1.12.1.6"

    /**
     * @type {String}
     */
    static szOID_PKCS_5_PBKDF2 => "1.2.840.113549.1.5.12"

    /**
     * @type {String}
     */
    static szOID_PKCS_5_PBES2 => "1.2.840.113549.1.5.13"

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_IMPORT_SILENT => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_ONLY_CERTIFICATES => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_ONLY_NOT_ENCRYPTED_CERTIFICATES => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_VIRTUAL_ISOLATION_KEY => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_IMPORT_RESERVED_MASK => 4294901760

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_NAMED_NO_PERSIST_KEY => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_ONLY_CERTIFICATES_PROVIDER_TYPE => 0

    /**
     * @type {String}
     */
    static PKCS12_ONLY_CERTIFICATES_PROVIDER_NAME => "PfxProvider"

    /**
     * @type {String}
     */
    static PKCS12_ONLY_CERTIFICATES_CONTAINER_NAME => "PfxContainer"

    /**
     * @type {Integer (UInt32)}
     */
    static REPORT_NO_PRIVATE_KEY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static EXPORT_PRIVATE_KEYS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_PROTECT_TO_DOMAIN_SIDS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_EXPORT_SILENT => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_EXPORT_PBES2_PARAMS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_DISABLE_ENCRYPT_CERTIFICATES => 256

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_ENCRYPT_CERTIFICATES => 512

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_EXPORT_ECC_CURVE_PARAMETERS => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_EXPORT_ECC_CURVE_OID => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_EXPORT_RESERVED_MASK => 4294901760

    /**
     * @type {String}
     */
    static PKCS12_PBKDF2_ID_HMAC_SHA1 => "1.2.840.113549.2.7"

    /**
     * @type {String}
     */
    static PKCS12_PBKDF2_ID_HMAC_SHA256 => "1.2.840.113549.2.9"

    /**
     * @type {String}
     */
    static PKCS12_PBKDF2_ID_HMAC_SHA384 => "1.2.840.113549.2.10"

    /**
     * @type {String}
     */
    static PKCS12_PBKDF2_ID_HMAC_SHA512 => "1.2.840.113549.2.11"

    /**
     * @type {String}
     */
    static PKCS12_PBES2_ALG_AES256_SHA256 => "AES256-SHA256"

    /**
     * @type {String}
     */
    static PKCS12_CONFIG_REGPATH => "Software\Microsoft\Windows\CurrentVersion\PFX"

    /**
     * @type {String}
     */
    static PKCS12_ENCRYPT_CERTIFICATES_VALUE_NAME => "EncryptCertificates"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_READ_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_WRITE_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SERVER_OCSP_RESPONSE_ASYNC_FLAG => 1

    /**
     * @type {Integer (Int32)}
     */
    static CERT_RETRIEVE_ISSUER_LOGO => 1

    /**
     * @type {Integer (Int32)}
     */
    static CERT_RETRIEVE_SUBJECT_LOGO => 2

    /**
     * @type {Integer (Int32)}
     */
    static CERT_RETRIEVE_COMMUNITY_LOGO => 3

    /**
     * @type {Integer (Int32)}
     */
    static CERT_RETRIEVE_BIOMETRIC_PREDEFINED_BASE_TYPE => 1000

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_MAX_PARA => 500

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_BY_ISSUER_DISPLAYNAME => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_BY_FRIENDLYNAME => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_BY_THUMBPRINT => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_ALLOW_EXPIRED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_TRUSTED_ROOT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_DISALLOW_SELFSIGNED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_HAS_PRIVATE_KEY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_HAS_KEY_FOR_SIGNATURE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_HAS_KEY_FOR_KEY_EXCHANGE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_HARDWARE_ONLY => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_ALLOW_DUPLICATES => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_IGNORE_AUTOSELECT => 256

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_FAILURE_BAD_ALG => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_FAILURE_BAD_REQUEST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_FAILURE_BAD_FORMAT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_FAILURE_TIME_NOT_AVAILABLE => 14

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_FAILURE_POLICY_NOT_SUPPORTED => 15

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_FAILURE_EXTENSION_NOT_SUPPORTED => 16

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_FAILURE_INFO_NOT_AVAILABLE => 17

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_FAILURE_SYSTEM_FAILURE => 25

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_DONT_HASH_DATA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_VERIFY_CONTEXT_SIGNATURE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_NO_AUTH_RETRIEVAL => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OBJECT_LOCATOR_SPN_NAME_TYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OBJECT_LOCATOR_LAST_RESERVED_NAME_TYPE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OBJECT_LOCATOR_FIRST_RESERVED_USER_NAME_TYPE => 33

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OBJECT_LOCATOR_LAST_RESERVED_USER_NAME_TYPE => 65535

    /**
     * @type {String}
     */
    static SSL_OBJECT_LOCATOR_PFX_FUNC => "SslObjectLocatorInitializePfx"

    /**
     * @type {String}
     */
    static SSL_OBJECT_LOCATOR_ISSUER_LIST_FUNC => "SslObjectLocatorInitializeIssuerList"

    /**
     * @type {String}
     */
    static SSL_OBJECT_LOCATOR_CERT_VALIDATION_CONFIG_FUNC => "SslObjectLocatorInitializeCertValidationConfig"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_FILE_HASH_USE_TYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TIMESTAMP_HASH_USE_TYPE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RECIPIENTPOLICYV1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RECIPIENTPOLICYV2 => 2

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_COMMUNICATION => -1073413888

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_DATA_ACCESS => -1073413887

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_EXPORT => -1073413886

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_IDENTITY => -1073413885

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_IMPORT => -1073413884

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_ARGUMENT => -1073413883

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_REQUEST => -1073413882

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_INFORMATIONCARD => -1073413881

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_STOREKEY => -1073413880

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_LOGOVALIDATION => -1073413879

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_PASSWORDVALIDATION => -1073413878

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_POLICY => -1073413877

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_PROCESSDIED => -1073413876

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_SERVICEBUSY => -1073413875

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_SERVICE => -1073413874

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_SHUTTINGDOWN => -1073413873

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_TOKENCREATION => -1073413872

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_TRUSTEXCHANGE => -1073413871

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_UNTRUSTED => -1073413870

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_USERCANCELLED => -1073413869

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_STORE_IMPORT => -1073413868

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_FAIL => -1073413867

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_UI_INITIALIZATION => -1073413862

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_REFRESH_REQUIRED => -1073413760

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_MISSING_APPLIESTO => -1073413759

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_INVALID_PROOF_KEY => -1073413758

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_UNKNOWN_REFERENCE => -1073413757

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_FAILED_REQUIRED_CLAIMS => -1073413756

    /**
     * @type {Integer (Int32)}
     */
    static AUDIT_CARD_WRITTEN => 1074070016

    /**
     * @type {Integer (Int32)}
     */
    static AUDIT_CARD_DELETE => 1074070017

    /**
     * @type {Integer (Int32)}
     */
    static AUDIT_CARD_IMPORT => 1074070018

    /**
     * @type {Integer (Int32)}
     */
    static AUDIT_STORE_IMPORT => 1074070019

    /**
     * @type {Integer (Int32)}
     */
    static AUDIT_STORE_EXPORT => 1074070020

    /**
     * @type {Integer (Int32)}
     */
    static AUDIT_STORE_DELETE => 1074070021

    /**
     * @type {Integer (Int32)}
     */
    static AUDIT_SERVICE_IDLE_STOP => 1074070022

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECC_PARAMETER_HEADER_V1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_COPY_AFTER_PADDING_CHECK_FAILURE_FLAG => 256

    /**
     * @type {String}
     */
    static MS_SCHANNEL_PROVIDER => "Microsoft SSL Protocol Provider"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_CLIENT_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_SERVER_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SSL2_PROTOCOL_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SSL3_PROTOCOL_VERSION => 768

    /**
     * @type {Integer (UInt32)}
     */
    static TLS1_PROTOCOL_VERSION => 769

    /**
     * @type {Integer (UInt32)}
     */
    static TLS1_0_PROTOCOL_VERSION => 769

    /**
     * @type {Integer (UInt32)}
     */
    static TLS1_1_PROTOCOL_VERSION => 770

    /**
     * @type {Integer (UInt32)}
     */
    static TLS1_2_PROTOCOL_VERSION => 771

    /**
     * @type {Integer (UInt32)}
     */
    static TLS1_3_PROTOCOL_VERSION => 772

    /**
     * @type {Integer (UInt32)}
     */
    static DTLS1_0_PROTOCOL_VERSION => 65279

    /**
     * @type {Integer (UInt32)}
     */
    static DTLS1_2_PROTOCOL_VERSION => 65277

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_NULL_MD5 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_NULL_SHA => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_EXPORT_WITH_RC4_40_MD5 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_RC4_128_MD5 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_RC4_128_SHA => 5

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_DES_CBC_SHA => 9

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_3DES_EDE_CBC_SHA => 10

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_DSS_WITH_DES_CBC_SHA => 18

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA => 19

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA => 22

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_AES_128_CBC_SHA => 47

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_DSS_WITH_AES_128_CBC_SHA => 50

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_RSA_WITH_AES_128_CBC_SHA => 51

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_AES_256_CBC_SHA => 53

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_DSS_WITH_AES_256_CBC_SHA => 56

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_RSA_WITH_AES_256_CBC_SHA => 57

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA => 98

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA => 99

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_EXPORT1024_WITH_RC4_56_SHA => 100

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_NULL_SHA256 => 59

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_AES_128_CBC_SHA256 => 60

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_AES_256_CBC_SHA256 => 61

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 => 64

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 => 106

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_AES_128_GCM_SHA256 => 156

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_AES_256_GCM_SHA384 => 157

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 => 158

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 => 159

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_PSK_WITH_AES_128_GCM_SHA256 => 168

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_PSK_WITH_AES_256_GCM_SHA384 => 169

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_PSK_WITH_AES_128_CBC_SHA256 => 174

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_PSK_WITH_AES_256_CBC_SHA384 => 175

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_PSK_WITH_NULL_SHA256 => 176

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_PSK_WITH_NULL_SHA384 => 177

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA => 49161

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA => 49171

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA => 49162

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA => 49172

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 => 49187

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 => 49188

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 => 49195

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 => 49196

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 => 49191

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 => 49192

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 => 49199

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 => 49200

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_AES_128_GCM_SHA256 => 4865

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_AES_256_GCM_SHA384 => 4866

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_CK_RC4_128_WITH_MD5 => 65664

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_CK_RC4_128_EXPORT40_WITH_MD5 => 131200

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_CK_RC2_128_CBC_WITH_MD5 => 196736

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5 => 262272

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_CK_IDEA_128_CBC_WITH_MD5 => 327808

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_CK_DES_64_CBC_WITH_MD5 => 393280

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_CK_DES_192_EDE3_CBC_WITH_MD5 => 458944

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECC_P256_CURVE_KEY_TYPE => 23

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECC_P384_CURVE_KEY_TYPE => 24

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECC_P521_CURVE_KEY_TYPE => 25

    /**
     * @type {String}
     */
    static SSL_ECDSA_ALGORITHM => "ECDSA"

    /**
     * @type {String}
     */
    static TLS_PSK_EXCHANGE => "PSK"

    /**
     * @type {String}
     */
    static TLS_RSA_PSK_EXCHANGE => "RSA_PSK"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_MAX_NAME_SIZE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_CIPHER_SUITE_EX_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_CIPHER_LENGTHS_BLOCK_PADDING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MSCRYPT_ECC_MAX_OID_LENGTH => 255

    /**
     * @type {Integer (UInt32)}
     */
    static MSCRYPT_ECC_MAX_CURVE_NAME_LENGTH => 255

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_EAP_PRF_FIELD => 255

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_EAP_ID => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_EAP_TTLSV0_ID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_EAP_TTLSV0_CHLNG_ID => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_EAP_FAST_ID => 3

    /**
     * @type {String}
     */
    static SSL_KEY_TYPE_PROPERTY => "KEYTYPE"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_SIGN_INCLUDE_HASHOID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_SIGN_USE_PSS_PADDING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_EXTERNAL_PSK_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_RESUMPTION_PSK_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_PROVIDER_IOCTL__GET_SCHANNEL_INTERFACE => 4145180

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_PROVSTRUC_VERSION_V3 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MAX_PROVIDER_ID => 999

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SIG_RESOURCE_VERSION => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_EXTERNAL_SIGNATURE_LENGTH => 136

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SIG_RESOURCE_NUMBER => 666

    /**
     * @type {String}
     */
    static CRYPT_SIG_RESOURCE => "#666"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MAC_RESOURCE_NUMBER => 667

    /**
     * @type {String}
     */
    static CRYPT_MAC_RESOURCE => "#667"

    /**
     * @type {Integer (UInt32)}
     */
    static CUR_OFFLOAD_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ROLE_PIN_ALWAYS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ROLE_PUK => 4

    /**
     * @type {String}
     */
    static CP_PIV_CARD_CAPABILITY_CONTAINER => "PIV CCC"

    /**
     * @type {String}
     */
    static CP_PIV_CARD_HOLDER_UNIQUE_IDENTIFIER => "PIV CHUID"

    /**
     * @type {String}
     */
    static CP_PIV_CARD_HOLDER_UNSIGNED_UNIQUE_IDENTIFIER => "PIV UCHUID"

    /**
     * @type {String}
     */
    static CP_PIV_FINGERPRINT => "PIV Fingerprint"

    /**
     * @type {String}
     */
    static CP_PIV_SECURITY_OBJECT => "PIV Security Object"

    /**
     * @type {String}
     */
    static CP_PIV_FACIAL_IMAGE => "PIV Facial Image"

    /**
     * @type {String}
     */
    static CP_PIV_PRINTED_INFORMATION => "PIV Printed Information"

    /**
     * @type {String}
     */
    static CP_PIV_GENERATE_KEY => "PIV Generate Key"

    /**
     * @type {String}
     */
    static CP_CARD_PIV => "PIV Card"

    /**
     * @type {String}
     */
    static CP_PIV_CERTIFICATE => "PIV Certificate"

    /**
     * @type {String}
     */
    static CP_PIV_PUBLIC_KEY => "PIV Public Key"

    /**
     * @type {String}
     */
    static CP_PIV_KEY_HISTORY_OBJECT => "PIV Key History Object"

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_PIV_CERT_DATA_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_PIV_GENERATE_ASYMMETRIC_KEY_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_PIV_PUBLIC_KEY_DATA_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_PIV_AUTH_CERT => 6275333

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_SIG_CERT => 6275338

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_KEY_MGMT_CERT => 6275339

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_CARD_AUTH_CERT => 6275329

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_CHUID => 6275330

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_CARD_CAPABILITY_CONTAINER => 6275335

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_UNSIGNED_CHUID => 6275332

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_FINGERPRINT => 6275331

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_SECURITY_OBJECT => 6275334

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_FACIAL_IMAGE => 6275336

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_PRINTED_INFORMATION => 6275337

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_KEY_HISTORY => 6275340

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_FIRST_RETIRED_KEY_MGMT_KEY => 6275341

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_LAST_RETIRED_KEY_MGMT_KEY => 6275360

    /**
     * @type {Integer (UInt32)}
     */
    static SCARD_PROVIDER_CARD_MODULE => 2147483649

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DATA_VALUE_UNKNOWN => 4294967295

    /**
     * @type {String}
     */
    static szBASE_CSP_DIR => "mscp"

    /**
     * @type {String}
     */
    static szINTERMEDIATE_CERTS_DIR => "mscerts"

    /**
     * @type {String}
     */
    static szCACHE_FILE => "cardcf"

    /**
     * @type {String}
     */
    static szCARD_IDENTIFIER_FILE => "cardid"

    /**
     * @type {String}
     */
    static szCONTAINER_MAP_FILE => "cmapfile"

    /**
     * @type {String}
     */
    static szROOT_STORE_FILE => "msroots"

    /**
     * @type {String}
     */
    static szUSER_SIGNATURE_CERT_PREFIX => "ksc"

    /**
     * @type {String}
     */
    static szUSER_KEYEXCHANGE_CERT_PREFIX => "kxc"

    /**
     * @type {String}
     */
    static szUSER_SIGNATURE_PRIVATE_KEY_PREFIX => "kss"

    /**
     * @type {String}
     */
    static szUSER_SIGNATURE_PUBLIC_KEY_PREFIX => "ksp"

    /**
     * @type {String}
     */
    static szUSER_KEYEXCHANGE_PRIVATE_KEY_PREFIX => "kxs"

    /**
     * @type {String}
     */
    static szUSER_KEYEXCHANGE_PUBLIC_KEY_PREFIX => "kxp"

    /**
     * @type {String}
     */
    static wszCARD_USER_EVERYONE => "anonymous"

    /**
     * @type {String}
     */
    static wszCARD_USER_USER => "user"

    /**
     * @type {String}
     */
    static wszCARD_USER_ADMIN => "admin"

    /**
     * @type {Integer (UInt32)}
     */
    static AT_ECDSA_P256 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static AT_ECDSA_P384 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static AT_ECDSA_P521 => 5

    /**
     * @type {Integer (UInt32)}
     */
    static AT_ECDHE_P256 => 6

    /**
     * @type {Integer (UInt32)}
     */
    static AT_ECDHE_P384 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static AT_ECDHE_P521 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CACHE_FILE_CURRENT_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_CONTAINER_NAME_LEN => 39

    /**
     * @type {Integer (UInt32)}
     */
    static CONTAINER_MAP_VALID_CONTAINER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CONTAINER_MAP_DEFAULT_CONTAINER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CAPABILITIES_CURRENT_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_PINS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ROLE_EVERYONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ROLE_USER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ROLE_ADMIN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PIN_SET_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PIN_SET_ALL_ROLES => 255

    /**
     * @type {Integer (UInt32)}
     */
    static PIN_CHANGE_FLAG_UNBLOCK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PIN_CHANGE_FLAG_CHANGEPIN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CP_CACHE_MODE_GLOBAL_CACHE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CP_CACHE_MODE_SESSION_ONLY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CP_CACHE_MODE_NO_CACHE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_AUTHENTICATE_GENERATE_SESSION_PIN => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_AUTHENTICATE_SESSION_PIN => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_PIN_STRENGTH_PLAINTEXT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_PIN_STRENGTH_SESSION_PIN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_PIN_SILENT_CONTEXT => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PIN_CACHE_POLICY_CURRENT_VERSION => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PIN_INFO_CURRENT_VERSION => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PIN_INFO_REQUIRE_SECURE_ENTRY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CREATE_CONTAINER_KEY_GEN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CREATE_CONTAINER_KEY_IMPORT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CONTAINER_INFO_CURRENT_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_AUTHENTICATE_PIN_CHALLENGE_RESPONSE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_AUTHENTICATE_PIN_PIN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_FILE_INFO_CURRENT_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_FREE_SPACE_INFO_CURRENT_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_KEY_SIZES_CURRENT_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_RSA_KEY_DECRYPT_INFO_VERSION_ONE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_RSA_KEY_DECRYPT_INFO_VERSION_TWO => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_RSA_KEY_DECRYPT_INFO_CURRENT_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_PADDING_INFO_PRESENT => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_BUFFER_SIZE_ONLY => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_PADDING_NONE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_PADDING_PKCS1 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_PADDING_PSS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_PADDING_OAEP => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_SIGNING_INFO_BASIC_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_SIGNING_INFO_CURRENT_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DH_AGREEMENT_INFO_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DERIVE_KEY_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DERIVE_KEY_VERSION_TWO => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DERIVE_KEY_CURRENT_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_RETURN_KEY_HANDLE => 16777216

    /**
     * @type {String}
     */
    static CCP_CONTAINER_INFO => "Container Info"

    /**
     * @type {String}
     */
    static CCP_PIN_IDENTIFIER => "PIN Identifier"

    /**
     * @type {String}
     */
    static CCP_ASSOCIATED_ECDH_KEY => "Associated ECDH Key"

    /**
     * @type {String}
     */
    static CP_CARD_FREE_SPACE => "Free Space"

    /**
     * @type {String}
     */
    static CP_CARD_CAPABILITIES => "Capabilities"

    /**
     * @type {String}
     */
    static CP_CARD_KEYSIZES => "Key Sizes"

    /**
     * @type {String}
     */
    static CP_CARD_READ_ONLY => "Read Only Mode"

    /**
     * @type {String}
     */
    static CP_CARD_CACHE_MODE => "Cache Mode"

    /**
     * @type {String}
     */
    static CP_SUPPORTS_WIN_X509_ENROLLMENT => "Supports Windows x.509 Enrollment"

    /**
     * @type {String}
     */
    static CP_CARD_GUID => "Card Identifier"

    /**
     * @type {String}
     */
    static CP_CARD_SERIAL_NO => "Card Serial Number"

    /**
     * @type {String}
     */
    static CP_CARD_PIN_INFO => "PIN Information"

    /**
     * @type {String}
     */
    static CP_CARD_LIST_PINS => "PIN List"

    /**
     * @type {String}
     */
    static CP_CARD_AUTHENTICATED_STATE => "Authenticated State"

    /**
     * @type {String}
     */
    static CP_CARD_PIN_STRENGTH_VERIFY => "PIN Strength Verify"

    /**
     * @type {String}
     */
    static CP_CARD_PIN_STRENGTH_CHANGE => "PIN Strength Change"

    /**
     * @type {String}
     */
    static CP_CARD_PIN_STRENGTH_UNBLOCK => "PIN Strength Unblock"

    /**
     * @type {String}
     */
    static CP_PARENT_WINDOW => "Parent Window"

    /**
     * @type {String}
     */
    static CP_PIN_CONTEXT_STRING => "PIN Context String"

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_SECURE_KEY_INJECTION_NO_CARD_MODE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_KEY_IMPORT_PLAIN_TEXT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_KEY_IMPORT_RSA_KEYEST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_KEY_IMPORT_ECC_KEYEST => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_KEY_IMPORT_SHARED_SYMMETRIC => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CIPHER_OPERATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_ASYMMETRIC_OPERATION => 2

    /**
     * @type {String}
     */
    static CARD_3DES_112_ALGORITHM => "3DES_112"

    /**
     * @type {String}
     */
    static CARD_3DES_ALGORITHM => "3DES"

    /**
     * @type {String}
     */
    static CARD_AES_ALGORITHM => "AES"

    /**
     * @type {String}
     */
    static CARD_CHAIN_MODE_CBC => "ChainingModeCBC"

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_IMPORT_KEYPAIR_VERSION_SEVEN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_IMPORT_KEYPAIR_CURRENT_VERSION => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CHANGE_AUTHENTICATOR_VERSION_SEVEN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CHANGE_AUTHENTICATOR_CURRENT_VERSION => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CHANGE_AUTHENTICATOR_RESPONSE_VERSION_SEVEN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CHANGE_AUTHENTICATOR_RESPONSE_CURRENT_VERSION => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_AUTHENTICATE_VERSION_SEVEN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_AUTHENTICATE_CURRENT_VERSION => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_AUTHENTICATE_RESPONSE_VERSION_SEVEN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_AUTHENTICATE_RESPONSE_CURRENT_VERSION => 7

    /**
     * @type {String}
     */
    static CP_KEY_IMPORT_SUPPORT => "Key Import Support"

    /**
     * @type {String}
     */
    static CP_ENUM_ALGORITHMS => "Algorithms"

    /**
     * @type {String}
     */
    static CP_PADDING_SCHEMES => "Padding Schemes"

    /**
     * @type {String}
     */
    static CP_CHAINING_MODES => "Chaining Modes"

    /**
     * @type {String}
     */
    static CSF_IMPORT_KEYPAIR => "Import Key Pair"

    /**
     * @type {String}
     */
    static CSF_CHANGE_AUTHENTICATOR => "Change Authenticator"

    /**
     * @type {String}
     */
    static CSF_AUTHENTICATE => "Authenticate"

    /**
     * @type {String}
     */
    static CKP_CHAINING_MODE => "ChainingMode"

    /**
     * @type {String}
     */
    static CKP_INITIALIZATION_VECTOR => "IV"

    /**
     * @type {String}
     */
    static CKP_BLOCK_LENGTH => "BlockLength"

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DATA_VERSION_SEVEN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DATA_VERSION_SIX => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DATA_VERSION_FIVE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DATA_VERSION_FOUR => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DATA_CURRENT_VERSION => 7
;@endregion Constants

;@region Methods
    /**
     * 
     * @param {Pointer} pbRandomData 
     * @param {Pointer} cbRandomData 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/systemprng
     */
    static SystemPrng(pbRandomData, cbRandomData) {
        result := DllCall("BCryptPrimitives.dll\SystemPrng", "ptr", pbRandomData, "ptr", cbRandomData, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} pbData 
     * @param {Pointer} cbData 
     * @returns {BOOL} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/processprng
     */
    static ProcessPrng(pbData, cbData) {
        result := DllCall("BCryptPrimitives.dll\ProcessPrng", "ptr", pbData, "ptr", cbData, "int")
        return result
    }

    /**
     * Used to acquire a handle to a particular key container within a particular cryptographic service provider (CSP). This returned handle is used in calls to CryptoAPI functions that use the selected CSP.
     * @param {Pointer<Pointer>} phProv A pointer to a handle of a CSP. When you have finished using the CSP, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptreleasecontext">CryptReleaseContext</a> function.
     * @param {PSTR} szContainer The key container name. This is a null-terminated string that identifies the key container to the CSP. This name is independent of the method used to store the keys. Some CSPs store their key containers internally (in hardware), some use the system registry, and others use the file system. In most cases, when <i>dwFlags</i> is set to CRYPT_VERIFYCONTEXT, <i>pszContainer</i> must be set to <b>NULL</b>. However, for hardware-based CSPs, such as a smart card CSP, can be access publically available information in the specfied container.
     * 
     * For more information about the usage of the <i>pszContainer</i> parameter, see Remarks.
     * @param {PSTR} szProvider A null-terminated string that contains the name of the CSP to be used. 
     * 
     * 
     * 
     * 
     * If this parameter is <b>NULL</b>, the user default provider is used. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-service-provider-contexts">Cryptographic Service Provider Contexts</a>. For a list of available cryptographic providers, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-provider-names">Cryptographic Provider Names</a>.
     * 
     * An application can obtain the name of the CSP in use by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetprovparam">CryptGetProvParam</a> function to read the PP_NAME CSP value in the <i>dwParam</i> parameter.
     * 
     * The default CSP can change between operating system releases. To ensure interoperability on different operating system platforms, the CSP should be explicitly set by using this parameter instead of using the default CSP.
     * @param {Integer} dwProvType Specifies the type of provider to acquire. Defined provider types are discussed in 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-provider-types">Cryptographic Provider Types</a>.
     * @param {Integer} dwFlags Flag values. This parameter is usually set to zero, but some applications set one or more of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFYCONTEXT"></a><a id="crypt_verifycontext"></a><dl>
     * <dt><b>CRYPT_VERIFYCONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This option is intended for applications that are using ephemeral keys, or applications that do not require access to persisted private keys, such as applications that perform only <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hashing</a>, <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">encryption</a>, and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">digital signature</a> verification. Only applications that create signatures or decrypt messages need access to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key</a>. In most cases, this flag should be set.
     * 
     * For file-based CSPs, when this flag is set, the <i>pszContainer</i> parameter must be set to <b>NULL</b>. The application has no access to the persisted private keys of public/private key pairs. When this flag is set, temporary <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public/private key pairs</a> can be created, but they are not persisted.
     * 
     * For hardware-based CSPs, such as a smart card CSP, if the <i>pszContainer</i> parameter is <b>NULL</b> or blank, this flag implies that no access to any keys is required, and that no UI should be presented to the user.  This form is used to connect to the CSP to query its capabilities but not to actually use its keys.
     * If the <i>pszContainer</i> parameter is not <b>NULL</b> and not blank, then this flag implies that access to only the publicly available information within the specified container is required.  The CSP should not ask for a PIN.  Attempts to access private information (for example, the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a> function) will fail.
     * 
     * When <b>CryptAcquireContext</b> is called, many CSPs require input from the owning user before granting access to the private keys in the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a>. For example, the private keys can be encrypted, requiring a password from the user before they can be used. However, if the <b>CRYPT_VERIFYCONTEXT</b> flag is specified, access to the private keys is not required and the user interface can be bypassed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NEWKEYSET"></a><a id="crypt_newkeyset"></a><dl>
     * <dt><b>CRYPT_NEWKEYSET</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Creates a new key container with the name specified by <i>pszContainer</i>. If <i>pszContainer</i> is <b>NULL</b>, a key container with the default name is created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_MACHINE_KEYSET"></a><a id="crypt_machine_keyset"></a><dl>
     * <dt><b>CRYPT_MACHINE_KEYSET</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * By default, keys and key containers are stored as user keys. For Base Providers, this means that user key containers are stored in the user's profile. A key container created without this flag by an administrator can be accessed only by the user creating the key container and a user with administration privileges.
     * 
     * 
     * <b>WindowsXP:</b>A key container created without this flag by an administrator can be accessed only by the user creating the key container and the local system account.
     * 
     * 
     * 
     * A key container created without this flag by a user that is not an administrator can be accessed only by the user creating the key container and the local system account.
     * 
     * The CRYPT_MACHINE_KEYSET flag can be combined with all of the other flags to indicate that the key container of interest is a computer key container and the CSP treats it as such. For Base Providers, this means that the keys are stored locally on the computer that created the key container. If a key container is to be a computer container, the CRYPT_MACHINE_KEYSET flag must be used with all calls to <b>CryptAcquireContext</b> that reference the computer container. The key container created with CRYPT_MACHINE_KEYSET by an administrator can be accessed only by its creator and by a user with administrator <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">privileges</a> unless access rights to the container are granted using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>.
     * 
     * 
     * <b>WindowsXP:</b>The key container created with CRYPT_MACHINE_KEYSET by an administrator can be accessed only by its creator and by the local system account unless access rights to the container are granted using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>.
     * 
     * 
     * 
     * The key container created with CRYPT_MACHINE_KEYSET by a user that is not an administrator can be accessed only by its creator and by the local system account unless access rights to the container are granted using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>.
     * 
     * The CRYPT_MACHINE_KEYSET flag is useful when the user is accessing from a service or user account that did not log on interactively. When key containers are created, most CSPs do not automatically create any <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public/private key pairs</a>. These keys must be created as a separate step with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DELETEKEYSET"></a><a id="crypt_deletekeyset"></a><dl>
     * <dt><b>CRYPT_DELETEKEYSET</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Delete the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a> specified by <i>pszContainer</i>. If <i>pszContainer</i> is <b>NULL</b>, the key container with the default name is deleted. All <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key pairs</a> in the key container are also destroyed. 
     * 
     * 
     * 
     * 
     * When this flag is set, the value returned in <i>phProv</i> is undefined, and thus, the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptreleasecontext">CryptReleaseContext</a> function need not be called afterward.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_SILENT"></a><a id="crypt_silent"></a><dl>
     * <dt><b>CRYPT_SILENT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The application requests that the CSP not display any user interface (UI) for this <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a>. If the CSP must display the UI to operate, the call fails and the NTE_SILENT_CONTEXT error code is set as the last error. In addition, if calls are made to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a> with the CRYPT_USER_PROTECTED flag with a context that has been acquired with the CRYPT_SILENT flag, the calls fail and the CSP sets NTE_SILENT_CONTEXT.
     * 
     * CRYPT_SILENT is intended for use with applications for which the UI cannot be displayed by the CSP.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DEFAULT_CONTAINER_OPTIONAL"></a><a id="crypt_default_container_optional"></a><dl>
     * <dt><b>CRYPT_DEFAULT_CONTAINER_OPTIONAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obtains a context for a smart card CSP that can be used for hashing and symmetric key operations but cannot be used for any operation that requires authentication to a smart card using a PIN. This type of context is most often used to perform operations on an empty smart card, such as setting the PIN by using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>. This flag can only be used with smart card CSPs. 
     * 
     * 
     * <b>Windows Server2003 and WindowsXP:</b>This flag is not supported.
     * 
     * 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes defined in Winerror.h follow.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * <dt>107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Some CSPs set this error if the CRYPT_DELETEKEYSET flag value is set and another thread or <a href="/windows/desktop/SecGloss/p-gly">process</a> is using this <a href="/windows/desktop/SecGloss/k-gly">key container</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * <dt>2L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The profile of the user is not loaded and cannot be found. This happens when the application impersonates a user, for example, the IUSR_<i>ComputerName</i> account.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * <dt>87L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * <dt>8L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * <dt>0x80090009L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter has a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY_STATE</b></dt>
     * <dt>0x8009000BL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user password has changed since the private keys were encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEYSET</b></dt>
     * <dt>0x80090016L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key container could not be opened. A common cause of this error is that the key container does not exist. To create a key container, call <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> using the CRYPT_NEWKEYSET flag. This error code can also indicate that access to an existing key container is denied. Access rights to the container can be granted by the key set creator by using 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEYSET_PARAM</b></dt>
     * <dt>0x8009001FL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszContainer</i> or <i>pszProvider</i> parameter is set to a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_PROV_TYPE</b></dt>
     * <dt>0x80090014L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of the <i>dwProvType</i> parameter is out of range. All provider types must be from 1 through 999, inclusive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * <dt>0x80090006L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider DLL signature could not be verified. Either the DLL or the digital signature has been tampered with.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_EXISTS</b></dt>
     * <dt>0x8009000FL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is CRYPT_NEWKEYSET, but the key container already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_KEYSET_ENTRY_BAD</b></dt>
     * <dt>0x8009001AL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszContainer</i> key container was found but is corrupt.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_KEYSET_NOT_DEF</b></dt>
     * <dt>0x80090019L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested provider does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * <dt>0x8009000EL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROV_DLL_NOT_FOUND</b></dt>
     * <dt>0x8009001EL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider DLL file does not exist or is not on the current path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROV_TYPE_ENTRY_BAD</b></dt>
     * <dt>0x80090018L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider type specified by <i>dwProvType</i> is corrupt. This error can relate to either the user default CSP list or the computer default CSP list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROV_TYPE_NO_MATCH</b></dt>
     * <dt>0x8009001BL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider type specified by <i>dwProvType</i> does not match the provider type found. Note that this error can only occur when <i>pszProvider</i> specifies an actual CSP name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROV_TYPE_NOT_DEF</b></dt>
     * <dt>0x80090017L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No entry exists for the provider type specified by <i>dwProvType</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROVIDER_DLL_FAIL</b></dt>
     * <dt>0x8009001DL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider DLL file could not be loaded or failed to initialize.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_SIGNATURE_FILE_BAD</b></dt>
     * <dt>0x8009001CL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error occurred while loading the DLL file image, prior to verifying its signature.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptacquirecontexta
     * @since windows5.1.2600
     */
    static CryptAcquireContextA(phProv, szContainer, szProvider, dwProvType, dwFlags) {
        szContainer := szContainer is String ? StrPtr(szContainer) : szContainer
        szProvider := szProvider is String ? StrPtr(szProvider) : szProvider

        phProvMarshal := phProv is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptAcquireContextA", phProvMarshal, phProv, "ptr", szContainer, "ptr", szProvider, "uint", dwProvType, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Used to acquire a handle to a particular key container within a particular cryptographic service provider (CSP). This returned handle is used in calls to CryptoAPI functions that use the selected CSP.
     * @param {Pointer<Pointer>} phProv A pointer to a handle of a CSP. When you have finished using the CSP, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptreleasecontext">CryptReleaseContext</a> function.
     * @param {PWSTR} szContainer The key container name. This is a null-terminated string that identifies the key container to the CSP. This name is independent of the method used to store the keys. Some CSPs store their key containers internally (in hardware), some use the system registry, and others use the file system. In most cases, when <i>dwFlags</i> is set to CRYPT_VERIFYCONTEXT, <i>pszContainer</i> must be set to <b>NULL</b>. However, for hardware-based CSPs, such as a smart card CSP, can be access publically available information in the specfied container.
     * 
     * For more information about the usage of the <i>pszContainer</i> parameter, see Remarks.
     * @param {PWSTR} szProvider A null-terminated string that contains the name of the CSP to be used. 
     * 
     * 
     * 
     * 
     * If this parameter is <b>NULL</b>, the user default provider is used. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-service-provider-contexts">Cryptographic Service Provider Contexts</a>. For a list of available cryptographic providers, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-provider-names">Cryptographic Provider Names</a>.
     * 
     * An application can obtain the name of the CSP in use by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetprovparam">CryptGetProvParam</a> function to read the PP_NAME CSP value in the <i>dwParam</i> parameter.
     * 
     * The default CSP can change between operating system releases. To ensure interoperability on different operating system platforms, the CSP should be explicitly set by using this parameter instead of using the default CSP.
     * @param {Integer} dwProvType Specifies the type of provider to acquire. Defined provider types are discussed in 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-provider-types">Cryptographic Provider Types</a>.
     * @param {Integer} dwFlags Flag values. This parameter is usually set to zero, but some applications set one or more of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFYCONTEXT"></a><a id="crypt_verifycontext"></a><dl>
     * <dt><b>CRYPT_VERIFYCONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This option is intended for applications that are using ephemeral keys, or applications that do not require access to persisted private keys, such as applications that perform only <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hashing</a>, <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">encryption</a>, and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">digital signature</a> verification. Only applications that create signatures or decrypt messages need access to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key</a>. In most cases, this flag should be set.
     * 
     * For file-based CSPs, when this flag is set, the <i>pszContainer</i> parameter must be set to <b>NULL</b>. The application has no access to the persisted private keys of public/private key pairs. When this flag is set, temporary <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public/private key pairs</a> can be created, but they are not persisted.
     * 
     * For hardware-based CSPs, such as a smart card CSP, if the <i>pszContainer</i> parameter is <b>NULL</b> or blank, this flag implies that no access to any keys is required, and that no UI should be presented to the user.  This form is used to connect to the CSP to query its capabilities but not to actually use its keys.
     * If the <i>pszContainer</i> parameter is not <b>NULL</b> and not blank, then this flag implies that access to only the publicly available information within the specified container is required.  The CSP should not ask for a PIN.  Attempts to access private information (for example, the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a> function) will fail.
     * 
     * When <b>CryptAcquireContext</b> is called, many CSPs require input from the owning user before granting access to the private keys in the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a>. For example, the private keys can be encrypted, requiring a password from the user before they can be used. However, if the <b>CRYPT_VERIFYCONTEXT</b> flag is specified, access to the private keys is not required and the user interface can be bypassed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NEWKEYSET"></a><a id="crypt_newkeyset"></a><dl>
     * <dt><b>CRYPT_NEWKEYSET</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Creates a new key container with the name specified by <i>pszContainer</i>. If <i>pszContainer</i> is <b>NULL</b>, a key container with the default name is created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_MACHINE_KEYSET"></a><a id="crypt_machine_keyset"></a><dl>
     * <dt><b>CRYPT_MACHINE_KEYSET</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * By default, keys and key containers are stored as user keys. For Base Providers, this means that user key containers are stored in the user's profile. A key container created without this flag by an administrator can be accessed only by the user creating the key container and a user with administration privileges.
     * 
     * 
     * <b>WindowsXP:</b>A key container created without this flag by an administrator can be accessed only by the user creating the key container and the local system account.
     * 
     * 
     * 
     * A key container created without this flag by a user that is not an administrator can be accessed only by the user creating the key container and the local system account.
     * 
     * The CRYPT_MACHINE_KEYSET flag can be combined with all of the other flags to indicate that the key container of interest is a computer key container and the CSP treats it as such. For Base Providers, this means that the keys are stored locally on the computer that created the key container. If a key container is to be a computer container, the CRYPT_MACHINE_KEYSET flag must be used with all calls to <b>CryptAcquireContext</b> that reference the computer container. The key container created with CRYPT_MACHINE_KEYSET by an administrator can be accessed only by its creator and by a user with administrator <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">privileges</a> unless access rights to the container are granted using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>.
     * 
     * 
     * <b>WindowsXP:</b>The key container created with CRYPT_MACHINE_KEYSET by an administrator can be accessed only by its creator and by the local system account unless access rights to the container are granted using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>.
     * 
     * 
     * 
     * The key container created with CRYPT_MACHINE_KEYSET by a user that is not an administrator can be accessed only by its creator and by the local system account unless access rights to the container are granted using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>.
     * 
     * The CRYPT_MACHINE_KEYSET flag is useful when the user is accessing from a service or user account that did not log on interactively. When key containers are created, most CSPs do not automatically create any <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public/private key pairs</a>. These keys must be created as a separate step with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DELETEKEYSET"></a><a id="crypt_deletekeyset"></a><dl>
     * <dt><b>CRYPT_DELETEKEYSET</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Delete the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a> specified by <i>pszContainer</i>. If <i>pszContainer</i> is <b>NULL</b>, the key container with the default name is deleted. All <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key pairs</a> in the key container are also destroyed. 
     * 
     * 
     * 
     * 
     * When this flag is set, the value returned in <i>phProv</i> is undefined, and thus, the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptreleasecontext">CryptReleaseContext</a> function need not be called afterward.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_SILENT"></a><a id="crypt_silent"></a><dl>
     * <dt><b>CRYPT_SILENT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The application requests that the CSP not display any user interface (UI) for this <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a>. If the CSP must display the UI to operate, the call fails and the NTE_SILENT_CONTEXT error code is set as the last error. In addition, if calls are made to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a> with the CRYPT_USER_PROTECTED flag with a context that has been acquired with the CRYPT_SILENT flag, the calls fail and the CSP sets NTE_SILENT_CONTEXT.
     * 
     * CRYPT_SILENT is intended for use with applications for which the UI cannot be displayed by the CSP.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DEFAULT_CONTAINER_OPTIONAL"></a><a id="crypt_default_container_optional"></a><dl>
     * <dt><b>CRYPT_DEFAULT_CONTAINER_OPTIONAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obtains a context for a smart card CSP that can be used for hashing and symmetric key operations but cannot be used for any operation that requires authentication to a smart card using a PIN. This type of context is most often used to perform operations on an empty smart card, such as setting the PIN by using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>. This flag can only be used with smart card CSPs. 
     * 
     * 
     * <b>Windows Server2003 and WindowsXP:</b>This flag is not supported.
     * 
     * 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes defined in Winerror.h follow.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * <dt>107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Some CSPs set this error if the CRYPT_DELETEKEYSET flag value is set and another thread or <a href="/windows/desktop/SecGloss/p-gly">process</a> is using this <a href="/windows/desktop/SecGloss/k-gly">key container</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * <dt>2L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The profile of the user is not loaded and cannot be found. This happens when the application impersonates a user, for example, the IUSR_<i>ComputerName</i> account.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * <dt>87L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * <dt>8L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * <dt>0x80090009L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter has a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY_STATE</b></dt>
     * <dt>0x8009000BL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user password has changed since the private keys were encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEYSET</b></dt>
     * <dt>0x80090016L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key container could not be opened. A common cause of this error is that the key container does not exist. To create a key container, call <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> using the CRYPT_NEWKEYSET flag. This error code can also indicate that access to an existing key container is denied. Access rights to the container can be granted by the key set creator by using 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEYSET_PARAM</b></dt>
     * <dt>0x8009001FL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszContainer</i> or <i>pszProvider</i> parameter is set to a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_PROV_TYPE</b></dt>
     * <dt>0x80090014L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of the <i>dwProvType</i> parameter is out of range. All provider types must be from 1 through 999, inclusive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * <dt>0x80090006L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider DLL signature could not be verified. Either the DLL or the digital signature has been tampered with.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_EXISTS</b></dt>
     * <dt>0x8009000FL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is CRYPT_NEWKEYSET, but the key container already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_KEYSET_ENTRY_BAD</b></dt>
     * <dt>0x8009001AL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszContainer</i> key container was found but is corrupt.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_KEYSET_NOT_DEF</b></dt>
     * <dt>0x80090019L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested provider does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * <dt>0x8009000EL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROV_DLL_NOT_FOUND</b></dt>
     * <dt>0x8009001EL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider DLL file does not exist or is not on the current path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROV_TYPE_ENTRY_BAD</b></dt>
     * <dt>0x80090018L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider type specified by <i>dwProvType</i> is corrupt. This error can relate to either the user default CSP list or the computer default CSP list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROV_TYPE_NO_MATCH</b></dt>
     * <dt>0x8009001BL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider type specified by <i>dwProvType</i> does not match the provider type found. Note that this error can only occur when <i>pszProvider</i> specifies an actual CSP name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROV_TYPE_NOT_DEF</b></dt>
     * <dt>0x80090017L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No entry exists for the provider type specified by <i>dwProvType</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROVIDER_DLL_FAIL</b></dt>
     * <dt>0x8009001DL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider DLL file could not be loaded or failed to initialize.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_SIGNATURE_FILE_BAD</b></dt>
     * <dt>0x8009001CL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error occurred while loading the DLL file image, prior to verifying its signature.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptacquirecontextw
     * @since windows5.1.2600
     */
    static CryptAcquireContextW(phProv, szContainer, szProvider, dwProvType, dwFlags) {
        szContainer := szContainer is String ? StrPtr(szContainer) : szContainer
        szProvider := szProvider is String ? StrPtr(szProvider) : szProvider

        phProvMarshal := phProv is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptAcquireContextW", phProvMarshal, phProv, "ptr", szContainer, "ptr", szProvider, "uint", dwProvType, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Releases the handle of a cryptographic service provider (CSP) and a key container.
     * @param {Pointer} hProv Handle of a cryptographic service provider (CSP) created by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} dwFlags Reserved for future use and must be zero. If <i>dwFlags</i> is not set to zero, this function returns <b>FALSE</b> but the CSP is released.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP <a href="/windows/desktop/SecGloss/c-gly">context</a> specified by <i>hProv</i> is currently being used by another <a href="/windows/desktop/SecGloss/p-gly">process</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProv</i> parameter does not contain a valid context handle.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptreleasecontext
     * @since windows5.1.2600
     */
    static CryptReleaseContext(hProv, dwFlags) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptReleaseContext", "ptr", hProv, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Generates a random cryptographic session key or a public/private key pair. A handle to the key or key pair is returned in phKey. This handle can then be used as needed with any CryptoAPI function that requires a key handle.
     * @param {Pointer} hProv A handle to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) created by a call to 
     * 					<a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} Algid An 
     * 						<a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> value that identifies the algorithm for which the key is to be generated. Values for this parameter vary depending on the CSP used.
     * 
     * For <b>ALG_ID</b> values to use with the Microsoft Base Cryptographic Provider, see 
     * 			<a href="https://docs.microsoft.com/windows/desktop/SecCrypto/base-provider-algorithms">Base Provider Algorithms</a>.
     * 
     * For <b>ALG_ID</b> values to use with the Microsoft Strong Cryptographic Provider or the Microsoft Enhanced Cryptographic Provider, see 
     * 			<a href="https://docs.microsoft.com/windows/desktop/SecCrypto/enhanced-provider-algorithms">Enhanced Provider Algorithms</a>.
     * @param {Integer} dwFlags Specifies the type of key generated. The sizes of a session key, RSA signature key, and RSA key <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">exchange keys</a> can be set when the key is generated. The key size, representing the length of the key modulus in bits, is set with the upper 16 bits of this parameter. Thus, if a 2,048-bit RSA signature key is to be generated, the value 0x08000000 is combined with any other <i>dwFlags</i> predefined value with a bitwise-<b>OR</b> operation. The upper 16 bits of 0x08000000 is 0x0800, or decimal 2,048. The <b>RSA1024BIT_KEY</b> value can be used to specify a 1024-bit RSA key.
     * 
     * Due to changing export control restrictions, the default CSP and default <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key length</a> may change between operating system versions. It is important that both the encryption and decryption use the same CSP and that the key length be explicitly set using the <i>dwFlags</i> parameter to ensure interoperability on different operating system platforms.
     * 
     * In particular, the default RSA Full Cryptographic Service Provider is the Microsoft RSA Strong Cryptographic Provider. The default DSS Signature Diffie-Hellman Cryptographic Service Provider is the Microsoft Enhanced DSS Diffie-Hellman Cryptographic Provider. Each of these CSPs has a default 128-bit symmetric key length for RC2 and RC4 and a 1,024-bit default key length for public key algorithms. 
     * 
     * If the upper 16 bits is zero, the default key size is generated. If a key larger than the maximum or smaller than the minimum is specified, the call fails with the ERROR_INVALID_PARAMETER code.
     * 
     * The following table lists minimum, default, and maximum signature and exchange key lengths beginning with WindowsXP.
     * 
     * <table>
     * <tr>
     * <th>Key type and provider</th>
     * <th>Minimum length</th>
     * <th>Default length</th>
     * <th>Maximum length</th>
     * </tr>
     * <tr>
     * <td>
     * RSA Base Provider
     * 
     * Signature and ExchangeKeys
     * 
     * </td>
     * <td>
     * 384
     * 
     * </td>
     * <td>
     * 512
     * 
     * </td>
     * <td>
     * 16,384
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * RSA Strong and Enhanced Providers
     * 
     * Signature and Exchange Keys
     * 
     * </td>
     * <td>
     * 384
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * <td>
     * 16,384
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DSS Base Providers
     * 
     * Signature Keys
     * 
     * </td>
     * <td>
     * 512
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DSS Base Providers
     * 
     * Exchange Keys
     * 
     * </td>
     * <td>
     * Not applicable
     * 
     * </td>
     * <td>
     * Not applicable
     * 
     * </td>
     * <td>
     * Not applicable
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DSS/DH Base Providers
     * 
     * Signature Keys
     * 
     * </td>
     * <td>
     * 512
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DSS/DH Base Providers
     * 
     * Exchange Keys
     * 
     * </td>
     * <td>
     * 512
     * 
     * </td>
     * <td>
     * 512
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DSS/DH Enhanced Providers
     * 
     * Signature Keys
     * 
     * </td>
     * <td>
     * 512
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DSS/DH Enhanced Providers
     * 
     * Exchange Keys
     * 
     * </td>
     * <td>
     * 512
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * <td>
     * 4,096
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * For session key lengths, see <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptderivekey">CryptDeriveKey</a>.
     * 
     * For more information about keys generated using Microsoft providers, see 
     * 			<a href="https://docs.microsoft.com/windows/desktop/SecCrypto/microsoft-cryptographic-service-providers">Microsoft Cryptographic Service Providers</a>.
     * @param {Pointer<Pointer>} phKey Address to which the function copies the handle of the newly generated key. When you have finished  using the key, delete  the handle to the key by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.
     * @returns {BOOL} Returns nonzero if successful or zero otherwise.
     * 
     * For extended error information, call 
     * 			<a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Algid</i> parameter specifies an algorithm that this CSP does not support.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProv</i> parameter does not contain a valid context handle.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_SILENT_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider could not perform the action because the context was acquired as silent.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptgenkey
     * @since windows5.1.2600
     */
    static CryptGenKey(hProv, Algid, dwFlags, phKey) {
        phKeyMarshal := phKey is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptGenKey", "ptr", hProv, "uint", Algid, "uint", dwFlags, phKeyMarshal, phKey, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Generates cryptographic session keys derived from a base data value.
     * @param {Pointer} hProv A <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a> handle of a CSP created by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} Algid An 
     * 						<a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> structure that identifies the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">symmetric encryption</a> algorithm for which the key is to be generated. The algorithms available will most likely be different for each CSP. For more information about which algorithm identifier is used by the different providers for the key specs AT_KEYEXCHANGE and AT_SIGNATURE, see 
     * <b>ALG_ID</b>.
     * 
     * For more information about <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> values to use with the Microsoft Base Cryptographic Provider, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/base-provider-algorithms">Base Provider Algorithms</a>. For more information about <b>ALG_ID</b> values to use with the Microsoft Strong Cryptographic Provider or the Microsoft Enhanced Cryptographic Provider, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/enhanced-provider-algorithms">Enhanced Provider Algorithms</a>.
     * @param {Pointer} hBaseData A handle to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash object</a> that has been fed the exact base data.
     * 
     * To obtain this handle, an application must first create a hash object with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a> and then add the base data to the hash object with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>. This process is described in detail in 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hashes-and-digital-signatures">Hashes and Digital Signatures</a>.
     * @param {Integer} dwFlags Specifies the type of key generated.
     * 
     * The sizes of a session key can be set when the key is generated. The key size, representing the length of the key modulus in bits, is set with the upper 16 bits of this parameter. Thus, if a 128-bit <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">RC4</a> session key is to be generated, the value 0x00800000 is combined with any other <i>dwFlags</i> predefined value with a bitwise-<b>OR</b> operation. Due to changing export control restrictions, the default CSP and default <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key length</a> may change between operating system releases. It is important that both the encryption and decryption use the same CSP and that the key length be explicitly set using the <i>dwFlags</i> parameter to ensure interoperability on different operating system platforms.
     * 
     * The lower 16 bits of this parameter can be zero or you can specify one or more of the following flags by using the bitwise-<b>OR</b> operator to combine them.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_CREATE_SALT"></a><a id="crypt_create_salt"></a><dl>
     * <dt><b>CRYPT_CREATE_SALT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Typically, when a session key is made from a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> value, there are a number of leftover bits. For example, if the hash value is 128 bits and the session key is 40 bits, there will be 88 bits left over.
     * 
     * If this flag is set, then the key is assigned a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">salt value</a> based on the unused hash value bits. You can retrieve this <i>salt value</i> by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetkeyparam">CryptGetKeyParam</a> function with the <i>dwParam</i> parameter set to KP_SALT.
     * 
     * If this flag is not set, then the key is given a salt value of zero.
     * 
     * When keys with nonzero salt values are exported (by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a>), the salt value must also be obtained and kept with the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key BLOB</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_EXPORTABLE"></a><a id="crypt_exportable"></a><dl>
     * <dt><b>CRYPT_EXPORTABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the session key can be transferred out of the CSP into a key BLOB through the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a> function. Because keys generally must be exportable, this flag should usually be set.
     * 
     * If this flag is not set, then the session key is not exportable. This means the key is available only within the current session and only the application that created it is able to use it.
     * 
     * This flag does not apply to <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public/private key pairs</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NO_SALT"></a><a id="crypt_no_salt"></a><dl>
     * <dt><b>CRYPT_NO_SALT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag specifies that a no <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">salt value</a> gets allocated for a 40-bit <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">symmetric key</a>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/salt-value-functionality">Salt Value Functionality</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_UPDATE_KEY"></a><a id="crypt_update_key"></a><dl>
     * <dt><b>CRYPT_UPDATE_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Some CSPs use session keys that are derived from multiple hash values. When this is the case, <b>CryptDeriveKey</b> must be called multiple times.
     * 
     * If this flag is set, a new session key is not generated. Instead, the key specified by <i>phKey</i> is modified. The precise behavior of this flag is dependent on the type of key being generated and on the particular CSP being used.
     * 
     * Microsoft cryptographic service providers ignore this flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_SERVER"></a><a id="crypt_server"></a><dl>
     * <dt><b>CRYPT_SERVER</b></dt>
     * <dt>1024 (0x400)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is used only with <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">Schannel</a> providers. If this flag is set, the key to be generated is a server-write key; otherwise, it is a client-write key.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Pointer>} phKey A pointer to  a <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptkey">HCRYPTKEY</a> variable to receive the address of the handle of the newly generated key. When you have finished using the key, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Algid</i> parameter specifies an algorithm that this CSP does not support.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hBaseData</i> parameter does not contain a valid handle to a <a href="/windows/desktop/SecGloss/h-gly">hash object</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH_STATE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt was made to add data to a hash object that is already marked "finished."
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProv</i> parameter does not contain a valid context handle.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_SILENT_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider could not perform the action because the context was acquired as silent.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptderivekey
     * @since windows5.1.2600
     */
    static CryptDeriveKey(hProv, Algid, hBaseData, dwFlags, phKey) {
        phKeyMarshal := phKey is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptDeriveKey", "ptr", hProv, "uint", Algid, "ptr", hBaseData, "uint", dwFlags, phKeyMarshal, phKey, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Releases the handle referenced by the hKey parameter.
     * @param {Pointer} hKey The handle of the key to be destroyed.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key object specified by <i>hKey</i> is currently being used and cannot be destroyed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter does not contain a valid handle to a key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the key was created cannot be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptdestroykey
     * @since windows5.1.2600
     */
    static CryptDestroyKey(hKey) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptDestroyKey", "ptr", hKey, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Customizes various aspects of a session key's operations.
     * @param {Pointer} hKey A handle to the key for which values are to be set.
     * @param {Integer} dwParam The following tables contain predefined values that can be used.
     * @param {Pointer<Integer>} pbData A pointer to a buffer initialized with the value to be set before calling <b>CryptSetKeyParam</b>. The form of this data varies depending on the value of <i>dwParam</i>.
     * @param {Integer} dwFlags Used only when <i>dwParam</i> is KP_ALGID. The <i>dwFlags</i> parameter is used to pass in flag values for the enabled key. The <i>dwFlags</i> parameter can hold values such as the key size and the other flag values allowed when generating the same type of key with <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a>. For information about allowable flag values, see 
     * <b>CryptGenKey</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context is currently being used by another <a href="/windows/desktop/SecGloss/p-gly">process</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero, or the <i>pbData</i> buffer contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwParam</i> parameter specifies an unknown parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the <i>hKey</i> key was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FIXEDPARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Some CSPs have hard-coded P, Q, and G values. If this is the case, then using KP_P, KP_Q, and KP_G for the value of <i>dwParam</i> causes this error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptsetkeyparam
     * @since windows5.1.2600
     */
    static CryptSetKeyParam(hKey, dwParam, pbData, dwFlags) {
        pbDataMarshal := pbData is VarRef ? "char*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSetKeyParam", "ptr", hKey, "uint", dwParam, pbDataMarshal, pbData, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves data that governs the operations of a key.
     * @param {Pointer} hKey The handle of the key being queried.
     * @param {Integer} dwParam Specifies the type of query being made.
     * @param {Pointer} pbData A pointer to a buffer that receives the data. The form of this data depends on the value of <i>dwParam</i>.
     * 
     * If the size of  this buffer is not known, the required size can be retrieved at run time by passing <b>NULL</b> for this parameter and setting the value pointed to by <i>pdwDataLen</i> to zero. This function will place the required size of the buffer, in bytes, in the value pointed to by <i>pdwDataLen</i>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pdwDataLen A pointer to a <b>DWORD</b> value that, on entry, contains the size, in bytes, of the buffer pointed to by the <i>pbData</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size may be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are sometimes specified large enough to ensure that the largest possible output data fits in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @param {Integer} dwFlags This parameter is reserved for future use and must be set to zero.
     * @returns {BOOL} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. Some possible error codes include the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbData</i> parameter is not large enough to hold the returned data, the function sets the <b>ERROR_MORE_DATA</b> code and stores the required buffer size, in bytes, in the variable pointed to by <i>pdwDataLen</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY or NTE_NO_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key specified by the <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwParam</i> parameter specifies an unknown value number.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP <a href="/windows/desktop/SecGloss/c-gly">context</a> that was specified when the key was created cannot be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptgetkeyparam
     * @since windows5.1.2600
     */
    static CryptGetKeyParam(hKey, dwParam, pbData, pdwDataLen, dwFlags) {
        pdwDataLenMarshal := pdwDataLen is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptGetKeyParam", "ptr", hKey, "uint", dwParam, "ptr", pbData, pdwDataLenMarshal, pdwDataLen, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Customizes the operations of a hash object, including setting up initial hash contents and selecting a specific hashing algorithm.
     * @param {Pointer} hHash A handle to the hash object on which to set parameters.
     * @param {Integer} dwParam 
     * @param {Pointer<Integer>} pbData A value data buffer. Place the value data in this buffer before calling <b>CryptSetHashParam</b>. The form of this data varies, depending on the value number.
     * @param {Integer} dwFlags This parameter is reserved for future use and must be set to zero.
     * @returns {BOOL} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context is currently being used by another <a href="/windows/desktop/SecGloss/p-gly">process</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero or the <i>pbData</i> buffer contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwParam</i> parameter specifies an unknown value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the <i>hKey</i> key was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptsethashparam
     * @since windows5.1.2600
     */
    static CryptSetHashParam(hHash, dwParam, pbData, dwFlags) {
        pbDataMarshal := pbData is VarRef ? "char*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSetHashParam", "ptr", hHash, "uint", dwParam, pbDataMarshal, pbData, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves data that governs the operations of a hash object.
     * @param {Pointer} hHash Handle of the hash object to be queried.
     * @param {Integer} dwParam Query type. This parameter can be set to one of the following queries. 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="HP_ALGID"></a><a id="hp_algid"></a><dl>
     * <dt><b>HP_ALGID</b></dt>
     * <dt>Hash algorithm</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> that indicates the algorithm specified when the hash object was created. For a list of hash algorithms, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="HP_HASHSIZE"></a><a id="hp_hashsize"></a><dl>
     * <dt><b>HP_HASHSIZE</b></dt>
     * <dt>Hash value size</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>DWORD</b> value indicating the number of bytes in the hash value. This value will vary depending on the hash algorithm. Applications must retrieve this value just before the HP_HASHVAL value so the correct amount of memory can be allocated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="HP_HASHVAL"></a><a id="hp_hashval"></a><dl>
     * <dt><b>HP_HASHVAL</b></dt>
     * <dt>Hash value</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash value or message hash for the hash object specified by <i>hHash</i>. This value is generated based on the data supplied to the hash object earlier through the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashsessionkey">CryptHashSessionKey</a> functions.
     * 
     * The <b>CryptGetHashParam</b> function completes the hash. After <b>CryptGetHashParam</b> has been called, no more data can be added to the hash. Additional calls to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> or <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashsessionkey">CryptHashSessionKey</a> fail. After the application is done with the hash, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash">CryptDestroyHash</a> should be called to destroy the hash object.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>CSPs can add more values that this function can query.</div>
     * <div></div>
     * @param {Pointer} pbData A pointer to a buffer that receives the specified value data. The form of this data varies, depending on the value number. 
     * 
     * 
     * This parameter can be <b>NULL</b> to determine the memory size required.
     * @param {Pointer<Integer>} pdwDataLen A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the <i>pbData</i> buffer. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer. 
     * 
     * 
     * If <i>pbData</i> is <b>NULL</b>, set the value of <i>pdwDataLen</i> to zero.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbData</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pdwDataLen</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwParam</i> parameter specifies an unknown value number.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the hash was created cannot be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptgethashparam
     * @since windows5.1.2600
     */
    static CryptGetHashParam(hHash, dwParam, pbData, pdwDataLen, dwFlags) {
        pdwDataLenMarshal := pdwDataLen is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptGetHashParam", "ptr", hHash, "uint", dwParam, "ptr", pbData, pdwDataLenMarshal, pdwDataLen, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Customizes the operations of a cryptographic service provider (CSP). This function is commonly used to set a security descriptor on the key container associated with a CSP to control access to the private keys in that key container.
     * @param {Pointer} hProv The handle of a CSP for which to set values. This handle must have already been created by using 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function.
     * @param {Integer} dwParam 
     * @param {Pointer<Integer>} pbData A pointer to a data buffer that contains the value to be set as a provider parameter. The form of this data varies depending on the <i>dwParam</i> value. If <i>dwParam</i> contains <b>PP_USE_HARDWARE_RNG</b>, this parameter must be <b>NULL</b>.
     * @param {Integer} dwFlags If <i>dwParam</i> contains <b>PP_KEYSET_SEC_DESCR</b>, <i>dwFlags</i> contains the <b>SECURITY_INFORMATION</b> applicable bit flags, as defined in the Platform SDK. Key-container security is handled by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setfilesecuritya">SetFileSecurity</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfilesecuritya">GetFileSecurity</a>.
     * 
     * These bit flags can be combined by using a bitwise-<b>OR</b> operation. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetprovparam">CryptGetProvParam</a>.
     * 
     * If <i>dwParam</i> is <b>PP_USE_HARDWARE_RNG</b> or <b>PP_DELETEKEY</b>, <i>dwFlags</i> must be set to zero.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. Error codes include the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context is currently being used by another <a href="/windows/desktop/SecGloss/p-gly">process</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero or the <i>pbData</i> buffer contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwParam</i> parameter specifies an unknown parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the <i>hKey</i> key was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptsetprovparam
     * @since windows5.1.2600
     */
    static CryptSetProvParam(hProv, dwParam, pbData, dwFlags) {
        pbDataMarshal := pbData is VarRef ? "char*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSetProvParam", "ptr", hProv, "uint", dwParam, pbDataMarshal, pbData, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves parameters that govern the operations of a cryptographic service provider (CSP).
     * @param {Pointer} hProv A handle of the CSP target of the query. This handle must have been created by using 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function.
     * @param {Integer} dwParam The nature of the query. The following queries are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_ADMIN_PIN"></a><a id="pp_admin_pin"></a><dl>
     * <dt><b>PP_ADMIN_PIN</b></dt>
     * <dt>31 (0x1F)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns the administrator personal identification number (PIN) in the <i>pbData</i> parameter as a <b>LPSTR</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_APPLI_CERT"></a><a id="pp_appli_cert"></a><dl>
     * <dt><b>PP_APPLI_CERT</b></dt>
     * <dt>18 (0x12)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This constant is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_CHANGE_PASSWORD"></a><a id="pp_change_password"></a><dl>
     * <dt><b>PP_CHANGE_PASSWORD</b></dt>
     * <dt>7 (0x7)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This constant is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_CERTCHAIN"></a><a id="pp_certchain"></a><dl>
     * <dt><b>PP_CERTCHAIN</b></dt>
     * <dt>9 (0x9)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns the certificate chain associated with the <i>hProv</i> handle. The returned certificate chain is <b>X509_ASN_ENCODING</b> encoded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_CONTAINER"></a><a id="pp_container"></a><dl>
     * <dt><b>PP_CONTAINER</b></dt>
     * <dt>6 (0x6)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name of the current <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a> as a <b>null</b>-terminated <b>CHAR</b> string. This string is exactly the same as the one passed in the <i>pszContainer</i> parameter of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function to specify the key container to use. The <i>pszContainer</i> parameter can be read to determine the name of the default key container.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_CRYPT_COUNT_KEY_USE"></a><a id="pp_crypt_count_key_use"></a><dl>
     * <dt><b>PP_CRYPT_COUNT_KEY_USE</b></dt>
     * <dt>41 (0x29)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not implemented by Microsoft CSPs. This behavior may be implemented by other CSPs.
     * 
     * <b>WindowsXP:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_ENUMALGS"></a><a id="pp_enumalgs"></a><dl>
     * <dt><b>PP_ENUMALGS</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-prov_enumalgs">PROV_ENUMALGS</a> structure that contains information about one algorithm supported by the CSP being queried.
     * 
     * The first time this value is read, the <i>dwFlags</i> parameter must contain the <b>CRYPT_FIRST</b> flag. Doing so causes this function to retrieve the first element in the enumeration. The subsequent elements can then be retrieved by setting the <b>CRYPT_NEXT</b> flag in the <i>dwFlags</i> parameter. When this function fails with the <b>ERROR_NO_MORE_ITEMS</b> error code, the end of the enumeration has been reached.
     * 
     * This function is not thread safe, and all of the available algorithms might not be enumerated if this function is used in a multithreaded context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_ENUMALGS_EX"></a><a id="pp_enumalgs_ex"></a><dl>
     * <dt><b>PP_ENUMALGS_EX</b></dt>
     * <dt>22 (0x16)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 
     * 								<a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-prov_enumalgs_ex">PROV_ENUMALGS_EX</a> structure that contains information about one algorithm supported by the CSP being queried. The structure returned contains more information about the algorithm than the structure returned for PP_ENUMALGS.
     * 
     * The first time this value is read, the <i>dwFlags</i> parameter must contain the <b>CRYPT_FIRST</b> flag. Doing so causes this function to retrieve the first element in the enumeration. The subsequent elements can then be retrieved by setting the <b>CRYPT_NEXT</b> flag in the <i>dwFlags</i> parameter. When this function fails with the <b>ERROR_NO_MORE_ITEMS</b> error code, the end of the enumeration has been reached.
     * 
     * This function is not thread safe and all of the available algorithms might not be enumerated if this function is used in a multithreaded context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_ENUMCONTAINERS"></a><a id="pp_enumcontainers"></a><dl>
     * <dt><b>PP_ENUMCONTAINERS</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name of one of the key containers maintained by the CSP in the form of a <b>null</b>-terminated <b>CHAR</b> string. 
     * 
     * The first time this value is read, the <i>dwFlags</i> parameter must contain the <b>CRYPT_FIRST</b> flag. Doing so causes this function to retrieve the first element in the enumeration. The subsequent elements can then be retrieved by setting the <b>CRYPT_NEXT</b> flag in the <i>dwFlags</i> parameter. When this function fails with the <b>ERROR_NO_MORE_ITEMS</b> error code, the end of the enumeration has been reached.
     * 
     * To enumerate key containers associated with a computer, first call <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> using the <b>CRYPT_MACHINE_KEYSET</b> flag, and then use the handle returned from <b>CryptAcquireContext</b> as the <i>hProv</i> parameter in the call to <b>CryptGetProvParam</b>.
     * 
     * This function is not thread safe and all of the available algorithms might not be enumerated if this function is used in a multithreaded context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_ENUMELECTROOTS"></a><a id="pp_enumelectroots"></a><dl>
     * <dt><b>PP_ENUMELECTROOTS</b></dt>
     * <dt>26 (0x1A)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This constant is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_ENUMEX_SIGNING_PROT"></a><a id="pp_enumex_signing_prot"></a><dl>
     * <dt><b>PP_ENUMEX_SIGNING_PROT</b></dt>
     * <dt>40 (0x28)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the current CSP supports the <b>dwProtocols</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-prov_enumalgs_ex">PROV_ENUMALGS_EX</a> structure. If this function succeeds, the CSP supports the <b>dwProtocols</b> member of the <b>PROV_ENUMALGS_EX</b> structure. If this function fails with an <b>NTE_BAD_TYPE</b> error code, the CSP does not support the <b>dwProtocols</b> member.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_ENUMMANDROOTS"></a><a id="pp_enummandroots"></a><dl>
     * <dt><b>PP_ENUMMANDROOTS</b></dt>
     * <dt>25 (0x19)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This constant is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_IMPTYPE"></a><a id="pp_imptype"></a><dl>
     * <dt><b>PP_IMPTYPE</b></dt>
     * <dt>3 (0x3)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <b>DWORD</b> value that indicates how the CSP is implemented. For a table of possible values, see Remarks.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_KEY_TYPE_SUBTYPE"></a><a id="pp_key_type_subtype"></a><dl>
     * <dt><b>PP_KEY_TYPE_SUBTYPE</b></dt>
     * <dt>10 (0xA)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This query is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_KEYEXCHANGE_PIN"></a><a id="pp_keyexchange_pin"></a><dl>
     * <dt><b>PP_KEYEXCHANGE_PIN</b></dt>
     * <dt>32 (0x20)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies that the key exchange PIN is contained in <i>pbData</i>. The PIN is represented as a <b>null</b>-terminated ASCII string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_KEYSET_SEC_DESCR"></a><a id="pp_keyset_sec_descr"></a><dl>
     * <dt><b>PP_KEYSET_SEC_DESCR</b></dt>
     * <dt>8 (0x8)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">security descriptor</a> for the key storage container. The <i>pbData</i> parameter is the address of a <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> structure that receives the security descriptor for the key storage container. The security descriptor is returned in self-relative format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_KEYSET_TYPE"></a><a id="pp_keyset_type"></a><dl>
     * <dt><b>PP_KEYSET_TYPE</b></dt>
     * <dt>27 (0x1B)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the <i>hProv</i> parameter is a computer key set. The <i>pbData</i> parameter must be a <b>DWORD</b>; the <b>DWORD</b> will be set to the CRYPT_MACHINE_KEYSET flag if that flag was passed to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_KEYSPEC"></a><a id="pp_keyspec"></a><dl>
     * <dt><b>PP_KEYSPEC</b></dt>
     * <dt>39 (0x27)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns information about the key specifier values that the CSP supports. Key specifier values are joined in a logical <b>OR</b> and returned in the <i>pbData</i> parameter of the call as a <b>DWORD</b>. For example, the Microsoft Base Cryptographic Provider version 1.0 returns a <b>DWORD</b> value of AT_SIGNATURE | AT_KEYEXCHANGE.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_KEYSTORAGE"></a><a id="pp_keystorage"></a><dl>
     * <dt><b>PP_KEYSTORAGE</b></dt>
     * <dt>17 (0x11)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns a <b>DWORD</b> value of CRYPT_SEC_DESCR.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_KEYX_KEYSIZE_INC"></a><a id="pp_keyx_keysize_inc"></a><dl>
     * <dt><b>PP_KEYX_KEYSIZE_INC</b></dt>
     * <dt>35 (0x23)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The number of bits for the increment length of AT_KEYEXCHANGE. This information is used with information returned in the PP_ENUMALGS_EX value. With the information returned when using PP_ENUMALGS_EX and PP_KEYX_KEYSIZE_INC, the valid key lengths for AT_KEYEXCHANGE can be determined. These key lengths can then be used with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a>. For example if a CSP enumerates <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CALG_RSA_KEYX</a> (AT_KEYEXCHANGE) with a minimum key length of 512 bits and a maximum of 1024 bits, and returns the increment length as 64 bits, then valid key lengths are 512, 576, 640, 1024.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_NAME"></a><a id="pp_name"></a><dl>
     * <dt><b>PP_NAME</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name of the CSP in the form of a <b>null</b>-terminated <b>CHAR</b> string. This string is identical to the one passed in the <i>pszProvider</i> parameter of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function to specify that the current CSP be used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_PROVTYPE"></a><a id="pp_provtype"></a><dl>
     * <dt><b>PP_PROVTYPE</b></dt>
     * <dt>16 (0x10)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <b>DWORD</b> value that indicates the provider type of the CSP.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_ROOT_CERTSTORE"></a><a id="pp_root_certstore"></a><dl>
     * <dt><b>PP_ROOT_CERTSTORE</b></dt>
     * <dt>46 (0x2E)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obtains the root certificate store for the smart card. This certificate store contains all of the root certificates that are stored on the smart card.
     * 
     * The <i>pbData</i> parameter is the address of an <b>HCERTSTORE</b> variable that receives the handle of the certificate store. When this handle is no longer needed, the caller must close it by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a> function.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_SESSION_KEYSIZE"></a><a id="pp_session_keysize"></a><dl>
     * <dt><b>PP_SESSION_KEYSIZE</b></dt>
     * <dt>20 (0x14)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size, in bits, of the session key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_SGC_INFO"></a><a id="pp_sgc_info"></a><dl>
     * <dt><b>PP_SGC_INFO</b></dt>
     * <dt>37 (0x25)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used with <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">server gated cryptography</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_SIG_KEYSIZE_INC"></a><a id="pp_sig_keysize_inc"></a><dl>
     * <dt><b>PP_SIG_KEYSIZE_INC</b></dt>
     * <dt>34 (0x22)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The number of bits for the increment length of AT_SIGNATURE. This information is used with information returned in the PP_ENUMALGS_EX value. With the information returned when using PP_ENUMALGS_EX and PP_SIG_KEYSIZE_INC, the valid <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key lengths</a> for AT_SIGNATURE can be determined. These key lengths can then be used with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a>.
     * 
     * For example, if a CSP enumerates <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CALG_RSA_SIGN</a> (AT_SIGNATURE) with a minimum <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key length</a> of 512 bits and a maximum of 1024 bits, and returns the increment length as 64 bits, then valid key lengths are 512, 576, 640, 1024.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_SIGNATURE_PIN"></a><a id="pp_signature_pin"></a><dl>
     * <dt><b>PP_SIGNATURE_PIN</b></dt>
     * <dt>33 (0x21)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies that the key signature PIN is contained in <i>pbData</i>. The PIN is represented as a <b>null</b>-terminated ASCII string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_SMARTCARD_GUID"></a><a id="pp_smartcard_guid"></a><dl>
     * <dt><b>PP_SMARTCARD_GUID</b></dt>
     * <dt>45 (0x2D)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obtains the identifier of the smart card. The <i>pbData</i> parameter is the address of a <b>GUID</b> structure that receives the identifier of the smart card.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_SMARTCARD_READER"></a><a id="pp_smartcard_reader"></a><dl>
     * <dt><b>PP_SMARTCARD_READER</b></dt>
     * <dt>43 (0x2B)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obtains the name of the smart card reader. The <i>pbData</i> parameter is the address of an ANSI character array that receives a <b>null</b>-terminated ANSI string that contains the name of the smart card reader. The size of this buffer, contained in the variable pointed to by the <i>pdwDataLen</i> parameter, must include the <b>NULL</b> terminator.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_SYM_KEYSIZE"></a><a id="pp_sym_keysize"></a><dl>
     * <dt><b>PP_SYM_KEYSIZE</b></dt>
     * <dt>19 (0x13)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of the symmetric key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_UI_PROMPT"></a><a id="pp_ui_prompt"></a><dl>
     * <dt><b>PP_UI_PROMPT</b></dt>
     * <dt>21 (0x15)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This query  is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_UNIQUE_CONTAINER"></a><a id="pp_unique_container"></a><dl>
     * <dt><b>PP_UNIQUE_CONTAINER</b></dt>
     * <dt>36 (0x24)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The unique container name of the current key container in the form of a <b>null</b>-terminated <b>CHAR</b> string. For many CSPs, this name is the same name returned when the PP_CONTAINER value is used. The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function must work with this container name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_USE_HARDWARE_RNG"></a><a id="pp_use_hardware_rng"></a><dl>
     * <dt><b>PP_USE_HARDWARE_RNG</b></dt>
     * <dt>38 (0x26)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates whether a hardware random number generator (RNG) is supported. When <b>PP_USE_HARDWARE_RNG</b> is specified, the function succeeds and returns <b>TRUE</b> if a hardware RNG is supported. The function fails and returns <b>FALSE</b> if a hardware RNG is not supported. If a RNG is supported, <b>PP_USE_HARDWARE_RNG</b> can be set in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a> to indicate that the CSP must exclusively use the hardware RNG for this provider context. When <b>PP_USE_HARDWARE_RNG</b> is used, the <i>pbData</i> parameter must be <b>NULL</b> and <i>dwFlags</i> must be zero.
     * 
     * None of the Microsoft CSPs currently support using a hardware RNG.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_USER_CERTSTORE"></a><a id="pp_user_certstore"></a><dl>
     * <dt><b>PP_USER_CERTSTORE</b></dt>
     * <dt>42 (0x2A)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obtains the user certificate store for the smart card. This certificate store contains all of the user certificates that are stored on the smart card. The certificates in this store are encoded by using PKCS_7_ASN_ENCODING or X509_ASN_ENCODING encoding and should contain the <b>CERT_KEY_PROV_INFO_PROP_ID</b> property. 
     * 
     * The <i>pbData</i> parameter is the address of an <b>HCERTSTORE</b> variable that receives the handle of an in-memory certificate store. When this handle is no longer needed, the caller must close it by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a> function.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_VERSION"></a><a id="pp_version"></a><dl>
     * <dt><b>PP_VERSION</b></dt>
     * <dt>5 (0x5)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The version number of the CSP. The least significant byte contains the minor version number and the next most significant byte the major version number. Version 2.0 is represented as 0x00000200. To maintain backward compatibility with earlier versions of the 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/microsoft-base-cryptographic-provider">Microsoft Base Cryptographic Provider</a> and the 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/microsoft-enhanced-cryptographic-provider">Microsoft Enhanced Cryptographic Provider</a>, the provider names retain the "v1.0" designation in later versions.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} pbData A pointer to a buffer to receive the data. The form of this data varies depending on the value of <i>dwParam</i>. When <i>dwParam</i> is set to PP_USE_HARDWARE_RNG, <i>pbData</i> must be set to <b>NULL</b>.
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pdwDataLen A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the buffer pointed to by the <i>pbData</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored or to be stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.
     * 
     * <p class="note">If PP_ENUMALGS, or PP_ENUMALGS_EX is set, the <i>pdwDataLen</i> parameter works somewhat differently. If <i>pbData</i> is <b>NULL</b> or the value pointed to by <i>pdwDataLen</i> is too small, the value returned in this parameter is the size of the largest item in the enumeration list instead of the size of the item currently being read.
     * 
     * <p class="note">If PP_ENUMCONTAINERS is set, the first call to the function returns the size of the maximum key-container allowed by the current provider. This is in contrast to other possible behaviors, like returning the length of the longest existing container, or the length of the current container. Subsequent enumerating calls will not change the <i>dwLen</i> parameter. For each enumerated container, the caller can determine the length of the <b>null</b>-terminated string programmatically, if desired. If one of the enumeration values is read and the <i>pbData</i> parameter is <b>NULL</b>, the CRYPT_FIRST flag must be specified for the size information to be correctly retrieved.
     * 
     * </div>
     * <div></div>
     * @param {Integer} dwFlags If <i>dwParam</i> is <b>PP_KEYSET_SEC_DESCR</b>, the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">security descriptor</a> on the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a> where the keys are stored is retrieved. For this case, <i>dwFlags</i> is used to pass in the <b>SECURITY_INFORMATION</b> bit flags that indicate the requested security information, as defined in the Platform SDK. <b>SECURITY_INFORMATION</b> bit flags can be combined with a bitwise-<b>OR</b> operation.
     * 						
     * 					
     * 
     * 
     * The following values are defined for use with <b>PP_KEYSET_SEC_DESCR</b>.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="OWNER_SECURITY_INFORMATION"></a><a id="owner_security_information"></a><dl>
     * <dt><b>OWNER_SECURITY_INFORMATION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Owner identifier of the object is being referenced.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GROUP_SECURITY_INFORMATION"></a><a id="group_security_information"></a><dl>
     * <dt><b>GROUP_SECURITY_INFORMATION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Primary group identifier of the object is being referenced.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="DACL_SECURITY_INFORMATION"></a><a id="dacl_security_information"></a><dl>
     * <dt><b>DACL_SECURITY_INFORMATION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Discretionary ACL of the object is being referenced.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SACL_SECURITY_INFORMATION"></a><a id="sacl_security_information"></a><dl>
     * <dt><b>SACL_SECURITY_INFORMATION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * System ACL of the object is being referenced.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * The following values are defined for use with <b>PP_ENUMALGS</b>, <b>PP_ENUMALGS_EX</b>, and <b>PP_ENUMCONTAINERS</b>.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_FIRST"></a><a id="crypt_first"></a><dl>
     * <dt><b>CRYPT_FIRST</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the first element in the enumeration. This has the same effect as resetting the enumerator.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NEXT"></a><a id="crypt_next"></a><dl>
     * <dt><b>CRYPT_NEXT</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the next element in the enumeration. When there are no more elements to retrieve, this function will fail and set the last error to <b>ERROR_NO_MORE_ITEMS</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_SGC_ENUM"></a><a id="crypt_sgc_enum"></a><dl>
     * <dt><b>CRYPT_SGC_ENUM</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">server-gated cryptography</a> (SGC) enabled certificates. SGC enabled certificates are no longer supported. For more information, see <a href="https://support.microsoft.com/kb/875450">Microsoft Support Article 875450</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_SGC"></a><a id="crypt_sgc"></a><dl>
     * <dt><b>CRYPT_SGC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_FASTSGC"></a><a id="crypt_fastsgc"></a><dl>
     * <dt><b>CRYPT_FASTSGC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not used.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbData</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pdwDataLen</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end of the enumeration list has been reached. No valid data has been placed in the <i>pbData</i> buffer. This error code is returned only when <i>dwParam</i> equals PP_ENUMALGS or PP_ENUMCONTAINERS.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter specifies a flag that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwParam</i> parameter specifies an unknown value number.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP <a href="/windows/desktop/SecGloss/c-gly">context</a> specified by <i>hProv</i> is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptgetprovparam
     * @since windows5.1.2600
     */
    static CryptGetProvParam(hProv, dwParam, pbData, pdwDataLen, dwFlags) {
        pdwDataLenMarshal := pdwDataLen is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptGetProvParam", "ptr", hProv, "uint", dwParam, "ptr", pbData, pdwDataLenMarshal, pdwDataLen, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Fills a buffer with cryptographically random bytes.
     * @param {Pointer} hProv Handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) created by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} dwLen Number of bytes of random data to be generated.
     * @param {Pointer} pbBuffer Buffer to receive the returned data. This buffer must be at least <i>dwLen</i> bytes in length. 
     * 
     * 
     * 
     * 
     * Optionally, the application can fill this buffer with data to use as an auxiliary random seed.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProv</i> parameter does not contain a valid context handle.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptgenrandom
     * @since windows5.1.2600
     */
    static CryptGenRandom(hProv, dwLen, pbBuffer) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptGenRandom", "ptr", hProv, "uint", dwLen, "ptr", pbBuffer, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves a handle of one of a user's two public/private key pairs.
     * @param {Pointer} hProv <b>HCRYPTPROV</b> handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) created by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} dwKeySpec Identifies the private key to use from the key container. It can be AT_KEYEXCHANGE or AT_SIGNATURE. 
     * 
     * 
     * 
     * 
     * Additionally, some providers allow access to other user-specific keys through this function. For details, see the documentation on the specific provider.
     * @param {Pointer<Pointer>} phUserKey A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptkey">HCRYPTKEY</a> handle of the retrieved keys. When you have finished using the key, delete the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwKeySpec</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProv</i> parameter does not contain a valid context handle.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key requested by the <i>dwKeySpec</i> parameter does not exist.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptgetuserkey
     * @since windows5.1.2600
     */
    static CryptGetUserKey(hProv, dwKeySpec, phUserKey) {
        phUserKeyMarshal := phUserKey is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptGetUserKey", "ptr", hProv, "uint", dwKeySpec, phUserKeyMarshal, phUserKey, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Exports a cryptographic key or a key pair from a cryptographic service provider (CSP) in a secure manner.
     * @param {Pointer} hKey A handle to the key to be exported.
     * @param {Pointer} hExpKey A handle to a cryptographic key of the destination user. The key data within the exported <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key BLOB</a> is encrypted using this key. This ensures that only the destination user is able to make use of the key BLOB.  Both <i>hExpKey</i> and <i>hKey</i> must come from the same CSP.
     * 
     * 
     * Most often, this is the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key exchange public key</a> of the destination user. However, certain protocols in some CSPs require that a session key belonging to the destination user be used for this purpose.
     * 
     * If the key BLOB type specified by <i>dwBlobType</i> is <b>PUBLICKEYBLOB</b>, this parameter is unused and must be set to zero.
     * 
     * If the key BLOB type specified by <i>dwBlobType</i> is <b>PRIVATEKEYBLOB</b>, this is typically a handle to a session key that is to be used to encrypt the key BLOB. Some CSPs allow this parameter to be zero, in which case the application must encrypt the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key BLOB</a> manually so as to protect it.
     * 
     * To determine how Microsoft <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service providers</a> respond to this parameter, see the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key BLOB</a> sections of 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/microsoft-cryptographic-service-providers">Microsoft Cryptographic Service Providers</a>.
     * 
     * <div class="alert"><b>Note</b>Some CSPs may modify this parameter as a result of the operation. Applications that subsequently use this key for other purposes should call the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptduplicatekey">CryptDuplicateKey</a> function to create a duplicate key handle. When the application has finished using the handle, release it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.</div>
     * <div></div>
     * @param {Integer} dwBlobType Specifies the type of <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key BLOB</a> to be exported in <i>pbData</i>. This must be one of the following constants as discussed in 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-key-storage-and-exchange">Cryptographic Key Storage and Exchange</a>.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="OPAQUEKEYBLOB"></a><a id="opaquekeyblob"></a><dl>
     * <dt><b>OPAQUEKEYBLOB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used to store session keys in an Schannel CSP or any other vendor-specific format. OPAQUEKEYBLOBs are nontransferable and must be used within the CSP that generated the BLOB.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PRIVATEKEYBLOB"></a><a id="privatekeyblob"></a><dl>
     * <dt><b>PRIVATEKEYBLOB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used to transport <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public/private key pairs</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PUBLICKEYBLOB"></a><a id="publickeyblob"></a><dl>
     * <dt><b>PUBLICKEYBLOB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used to transport public keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SIMPLEBLOB"></a><a id="simpleblob"></a><dl>
     * <dt><b>SIMPLEBLOB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used to transport session keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PLAINTEXTKEYBLOB"></a><a id="plaintextkeyblob"></a><dl>
     * <dt><b>PLAINTEXTKEYBLOB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/jj650836(v=vs.85)">PLAINTEXTKEYBLOB</a> used to export any key supported by the CSP in use. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SYMMETRICWRAPKEYBLOB"></a><a id="symmetricwrapkeyblob"></a><dl>
     * <dt><b>SYMMETRICWRAPKEYBLOB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used to export and import a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">symmetric key</a> wrapped with another symmetric key. The actual wrapped key is in the format specified in the IETF <a href="https://www.ietf.org/rfc/rfc3217.txt">RFC 3217</a> standard.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags 
     * @param {Pointer} pbData A pointer to a buffer that receives the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key BLOB</a> data. The format of this BLOB varies depending on the BLOB type requested in the <i>dwBlobType</i> parameter. For the format for PRIVATEKEYBLOBs, PUBLICKEYBLOBs, and SIMPLEBLOBs, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/base-provider-key-blobs">Base Provider Key BLOBs</a>.
     * 
     * If this parameter is <b>NULL</b>, the required buffer size is placed in the value pointed to by the <i>pdwDataLen</i> parameter. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pdwDataLen A pointer to a <b>DWORD</b> value that, on entry, contains the size, in bytes, of the buffer pointed to by the <i>pbData</i> parameter. When the function returns, this value contains the number of bytes stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * To retrieve the required size of the <i>pbData</i> buffer, pass <b>NULL</b> for <i>pbData</i>. The required buffer size will be placed in the value pointed to by this parameter.
     * @returns {BOOL} If the function succeeds, the function returns  nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. The following table shows some of the possible error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbData</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pdwDataLen</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either the algorithm that works with the public key to be exported is not supported by this CSP, or an attempt was made to export a session key that was encrypted with something other than one of your public keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or both of the keys specified by <i>hKey</i> and <i>hExpKey</i> are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY_STATE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * You do not have permission to export the key. That is, when the <i>hKey</i> key was created, the CRYPT_EXPORTABLE flag was not specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_PUBLIC_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="/windows/desktop/SecGloss/k-gly">key BLOB</a> type specified by <i>dwBlobType</i> is PUBLICKEYBLOB, but <i>hExpKey</i> does not contain a public key handle.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwBlobType</i> parameter specifies an unknown BLOB type.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the <i>hKey</i> key was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A session key is being exported, and the <i>hExpKey</i> parameter does not specify a public key.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptexportkey
     * @since windows5.1.2600
     */
    static CryptExportKey(hKey, hExpKey, dwBlobType, dwFlags, pbData, pdwDataLen) {
        pdwDataLenMarshal := pdwDataLen is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptExportKey", "ptr", hKey, "ptr", hExpKey, "uint", dwBlobType, "uint", dwFlags, "ptr", pbData, pdwDataLenMarshal, pdwDataLen, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Transfers a cryptographic key from a key BLOB into a cryptographic service provider (CSP).
     * @param {Pointer} hProv The handle of a CSP obtained with the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function.
     * @param {Pointer} pbData A <b>BYTE</b> array that contains a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-publickeystruc">PUBLICKEYSTRUC</a> BLOB header followed by the encrypted key. This key BLOB is created by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a> function, either in this application or by another application possibly running on a different computer.
     * @param {Integer} dwDataLen Contains the length, in bytes, of the key BLOB.
     * @param {Pointer} hPubKey A handle to the cryptographic key that decrypts the key stored in <i>pbData</i>.  This key must come from the same CSP to which <i>hProv</i> refers. The meaning of this parameter differs depending on the CSP type and the type of key BLOB being imported:
     * 
     * <ul>
     * <li>If the key BLOB is encrypted with the key <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">exchange key pair</a>, for example, a <b>SIMPLEBLOB</b>, this parameter can be the handle to the key exchange key.</li>
     * <li>If the key BLOB is encrypted with a session key, for example, an encrypted <b>PRIVATEKEYBLOB</b>, this parameter contains the handle of this session key.</li>
     * <li>If the key BLOB is not encrypted, for example, a <b>PUBLICKEYBLOB</b>, this parameter is not used and must be zero.</li>
     * <li>If the key BLOB is encrypted with a session key in an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">Schannel</a> CSP, for example, an encrypted <b>OPAQUEKEYBLOB</b> or any other vendor-specific <b>OPAQUEKEYBLOB</b>, this parameter is not used and must be set to zero.</li>
     * </ul>
     * <div class="alert"><b>Note</b>Some CSPs may modify this parameter as a result of the operation. Applications that subsequently use this key for other purposes should call the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptduplicatekey">CryptDuplicateKey</a> function to create a duplicate key handle.  When the application has finished using the handle, release it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.</div>
     * <div></div>
     * @param {Integer} dwFlags Currently used only when a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public/private key pair</a> in the form of a <b>PRIVATEKEYBLOB</b> is imported into the CSP.
     * @param {Pointer<Pointer>} phKey A pointer to a <b>HCRYPTKEY</b> value that receives the handle of the imported key. When you have finished using the key, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.
     * @returns {BOOL} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * Error codes prefaced by "NTE" are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Some CSPs set this error if a private key is imported into a container while another thread or <a href="/windows/desktop/SecGloss/p-gly">process</a> is using this key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="/windows/desktop/SecGloss/s-gly">simple key BLOB</a> to be imported is not encrypted with the expected <a href="/windows/desktop/SecGloss/k-gly">key exchange algorithm</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either the algorithm that works with the public key to be imported is not supported by this CSP, or an attempt was made to import a session key that was encrypted with something other than one of your public keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter specified is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key BLOB type is not supported by this CSP and is possibly not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProv</i> parameter does not contain a valid context handle.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_VER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The version number of the key BLOB does not match the CSP version. This usually indicates that the CSP needs to be upgraded.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptimportkey
     * @since windows5.1.2600
     */
    static CryptImportKey(hProv, pbData, dwDataLen, hPubKey, dwFlags, phKey) {
        phKeyMarshal := phKey is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptImportKey", "ptr", hProv, "ptr", pbData, "uint", dwDataLen, "ptr", hPubKey, "uint", dwFlags, phKeyMarshal, phKey, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Encrypts data. The algorithm used to encrypt the data is designated by the key held by the CSP module and is referenced by the hKey parameter.
     * @param {Pointer} hKey A handle to the encryption key. An application obtains this handle by using either the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a> or the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a> function.
     * 
     * The key specifies the encryption algorithm used.
     * @param {Pointer} hHash A handle to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash object</a>. If data is to be hashed and encrypted simultaneously, a handle to a hash object can be passed in the <i>hHash</i> parameter. The hash value is updated with the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">plaintext</a> passed in. This option is useful when generating signed and encrypted text.
     * 
     * Before calling <b>CryptEncrypt</b>, the application must obtain a handle to the hash object by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a> function. After the encryption is complete, the hash value can be obtained by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a> function, or the hash can be signed by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a> function.
     * 
     * If no hash is to be done, this parameter must be <b>NULL</b>.
     * @param {BOOL} Final A Boolean value that specifies whether this is the last section in a series being encrypted. <i>Final</i> is set to <b>TRUE</b> for the last or only block and to <b>FALSE</b> if there are more blocks to be encrypted. For more information, see  Remarks.
     * @param {Integer} dwFlags The following <i>dwFlags</i> value is defined but reserved for future use.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_OAEP"></a><a id="crypt_oaep"></a><dl>
     * <dt><b>CRYPT_OAEP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use Optimal Asymmetric Encryption Padding (OAEP)  (PKCS #1 version 2). This flag is only supported by the <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/microsoft-enhanced-cryptographic-provider">Microsoft Enhanced Cryptographic Provider</a> with RSA encryption/decryption.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} pbData A pointer to a buffer that contains the plaintext to be encrypted.  The plaintext in this buffer is overwritten with the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">ciphertext</a> created by this function.
     * 
     * The <i>pdwDataLen</i> parameter points to a variable that contains the length, in bytes, of the plaintext. The <i>dwBufLen</i> parameter contains the total size, in bytes, of this buffer.
     * 
     * If this parameter contains <b>NULL</b>, this function will calculate the required size for the ciphertext and place that in the value pointed to by the <i>pdwDataLen</i> parameter.
     * @param {Pointer<Integer>} pdwDataLen A pointer to a <b>DWORD</b> value that , on entry, contains the length, in bytes, of the plaintext in the <i>pbData</i> buffer. On exit, this <b>DWORD</b> contains the length, in bytes, of the ciphertext written to the <i>pbData</i> buffer.
     * 
     * If the buffer allocated for <i>pbData</i> is not large enough to hold the encrypted data, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_MORE_DATA</b> and stores the required buffer size, in bytes, in the <b>DWORD</b> value pointed to by <i>pdwDataLen</i>.
     * 
     * If <i>pbData</i> is <b>NULL</b>, no error is returned, and the function stores the size of the encrypted data, in bytes, in the <b>DWORD</b> value pointed to by <i>pdwDataLen</i>. This allows an application to determine the correct buffer size.
     * 
     * When a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">block cipher</a> is used, this data length must be a multiple of the block size unless this is the final section of data to be encrypted and the <i>Final</i> parameter is <b>TRUE</b>.
     * @param {Integer} dwBufLen Specifies the total size, in bytes, of the input <i>pbData</i> buffer.
     * 
     * Note that, depending on the algorithm used, the encrypted text can be larger than the original plaintext. In this case, the <i>pbData</i> buffer needs to be large enough to contain the encrypted text and any padding.
     * 
     * As a rule, if a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">stream cipher</a> is used, the ciphertext is the same size as the plaintext. If a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">block cipher</a> is used, the ciphertext is up to a block length larger than the plaintext.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 						
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> <a href="/windows/desktop/SecGloss/s-gly">session key</a> specifies an algorithm that this CSP does not support.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data to be encrypted is not valid. For example, when a block cipher is used and the <i>Final</i> flag is <b>FALSE</b>, the value specified by <i>pdwDataLen</i> must be a multiple of the block size.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> parameter contains a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH_STATE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt was made to add data to a hash object that is already marked "finished."
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter does not contain a valid handle to a key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_LEN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of the output buffer is too small to hold the generated ciphertext.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the key was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_DOUBLE_ENCRYPT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The application attempted to encrypt the same data twice.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptencrypt
     * @since windows5.1.2600
     */
    static CryptEncrypt(hKey, hHash, Final, dwFlags, pbData, pdwDataLen, dwBufLen) {
        pdwDataLenMarshal := pdwDataLen is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptEncrypt", "ptr", hKey, "ptr", hHash, "int", Final, "uint", dwFlags, "ptr", pbData, pdwDataLenMarshal, pdwDataLen, "uint", dwBufLen, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Decrypts data previously encrypted by using the CryptEncrypt function.
     * @param {Pointer} hKey A handle to the key to use for the decryption. An application obtains this handle by using either the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a> function. 
     * 
     * 
     * 
     * 
     * This key specifies the decryption algorithm to be used.
     * @param {Pointer} hHash A handle to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash object</a>. If data is to be decrypted and hashed simultaneously, a handle to a hash object is passed in this parameter. The hash value is updated with the decrypted <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">plaintext</a>. This option is useful when simultaneously decrypting and verifying a signature. 
     * 
     * 
     * 
     * 
     * Before calling <b>CryptDecrypt</b>, the application must obtain a handle to the hash object by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a> function. After the decryption is complete, the hash value can be obtained by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a> function, it can also be signed by using 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a> function, or it can be used to verify a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">digital signature</a> by using 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea">CryptVerifySignature</a> function.
     * 
     * If no hash is to be done, this parameter must be zero.
     * @param {BOOL} Final A Boolean value that specifies whether this is the last section in a series being decrypted. This value is <b>TRUE</b> if this is the last or only block. If this is not the last block, this value is <b>FALSE</b>. For more information, see  Remarks.
     * @param {Integer} dwFlags The following flag values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_OAEP"></a><a id="crypt_oaep"></a><dl>
     * <dt><b>CRYPT_OAEP</b></dt>
     * <dt>0x00000040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use Optimal Asymmetric Encryption Padding (OAEP)  (PKCS #1 version 2). This flag is only supported by the <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/microsoft-enhanced-cryptographic-provider">Microsoft Enhanced Cryptographic Provider</a> with RSA encryption/decryption. This flag cannot be combined with the <b>CRYPT_DECRYPT_RSA_NO_PADDING_CHECK</b> flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECRYPT_RSA_NO_PADDING_CHECK"></a><a id="crypt_decrypt_rsa_no_padding_check"></a><dl>
     * <dt><b>CRYPT_DECRYPT_RSA_NO_PADDING_CHECK</b></dt>
     * <dt>0x00000020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Perform the decryption on the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a> without checking the padding. This flag is only supported by the <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/microsoft-enhanced-cryptographic-provider">Microsoft Enhanced Cryptographic Provider</a> with RSA encryption/decryption. This flag cannot be combined with the <b>CRYPT_OAEP</b> flag.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} pbData A pointer to a buffer that contains the data to be decrypted. After the decryption has been performed, the plaintext is placed back into this same buffer. 
     * 
     * 
     * 
     * 
     * The number of encrypted bytes in this buffer is specified by <i>pdwDataLen</i>.
     * @param {Pointer<Integer>} pdwDataLen A pointer to a <b>DWORD</b> value that indicates the length of the <i>pbData</i> buffer. Before calling this function, the calling application sets the <b>DWORD</b> value to the number of bytes to be decrypted. Upon return, the <b>DWORD</b> value contains the number of bytes of the decrypted plaintext. 
     * 
     * 
     * 
     * 
     * When a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">block cipher</a> is used, this data length must be a multiple of the block size unless this is the final section of data to be decrypted and the <i>Final</i> parameter is <b>TRUE</b>.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 						
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> <a href="/windows/desktop/SecGloss/s-gly">session key</a> specifies an algorithm that this CSP does not support.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data to be decrypted is not valid. For example, when a block cipher is used and the <i>Final</i> flag is <b>FALSE</b>, the value specified by <i>pdwDataLen</i> must be a multiple of the block size. This error can also be returned when the <a href="/windows/desktop/SecGloss/p-gly">padding</a> is found to be not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> parameter contains a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter does not contain a valid handle to a key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_LEN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of the output buffer is too small to hold the generated plaintext.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the key was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_DOUBLE_ENCRYPT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The application attempted to decrypt the same data twice.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptdecrypt
     * @since windows5.1.2600
     */
    static CryptDecrypt(hKey, hHash, Final, dwFlags, pbData, pdwDataLen) {
        pdwDataLenMarshal := pdwDataLen is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptDecrypt", "ptr", hKey, "ptr", hHash, "int", Final, "uint", dwFlags, "ptr", pbData, pdwDataLenMarshal, pdwDataLen, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Initiates the hashing of a stream of data. It creates and returns to the calling application a handle to a cryptographic service provider (CSP) hash object.
     * @param {Pointer} hProv A handle to a CSP created by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} Algid An <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> value that identifies  the hash algorithm to use.
     * 
     * Valid values for this parameter vary, depending on the CSP that is used. For a list of default algorithms, see  Remarks.
     * @param {Pointer} hKey If the type of hash algorithm is a keyed hash, such as the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">Hash-Based Message Authentication Code</a> (HMAC) or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">Message Authentication Code</a> (MAC) algorithm, the key for the hash is passed in this parameter. For nonkeyed algorithms, this parameter must be set to zero.
     * 
     * For keyed algorithms, the key must be to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">block cipher</a> key, such as RC2, that has a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cipher mode</a> of <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">Cipher Block Chaining</a> (CBC).
     * @param {Integer} dwFlags The following flag value is defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_SECRETDIGEST"></a><a id="crypt_secretdigest"></a><dl>
     * <dt><b>CRYPT_SECRETDIGEST</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not used.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Pointer>} phHash The address to which the function copies a handle to the new hash object. When you have finished using the hash object, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash">CryptDestroyHash</a> function.
     * @returns {BOOL} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP you are using. The following table shows some of the possible error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Algid</i> parameter specifies an algorithm that this CSP does not support.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A keyed <a href="/windows/desktop/SecGloss/h-gly">hash</a> algorithm, such as <a href="/windows/desktop/SecGloss/c-gly">CALG_MAC</a>, is specified by <i>Algid</i>, and the <i>hKey</i> parameter is either zero or it specifies a key handle that is not valid. This error code is also returned if the key is to a <a href="/windows/desktop/SecGloss/s-gly">stream cipher</a> or if the cipher mode is anything other than CBC.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptcreatehash
     * @since windows5.1.2600
     */
    static CryptCreateHash(hProv, Algid, hKey, dwFlags, phHash) {
        phHashMarshal := phHash is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptCreateHash", "ptr", hProv, "uint", Algid, "ptr", hKey, "uint", dwFlags, phHashMarshal, phHash, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Adds data to a specified hash object.
     * @param {Pointer} hHash Handle of the hash object.
     * @param {Pointer} pbData A pointer to a buffer that contains the data to be added to the hash object.
     * @param {Integer} dwDataLen Number of bytes of data to be added. This must be zero if the CRYPT_USERDATA flag is set.
     * @param {Integer} dwFlags The following flag values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_OWF_REPL_LM_HASH"></a><a id="crypt_owf_repl_lm_hash"></a><dl>
     * <dt><b>CRYPT_OWF_REPL_LM_HASH</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_USERDATA"></a><a id="crypt_userdata"></a><dl>
     * <dt><b>CRYPT_USERDATA</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * All Microsoft Cryptographic Providers ignore this parameter. For any CSP that does not ignore this parameter, if this flag is set, the CSP prompts the user to input data directly. This data is added to the hash. The application is not allowed access to the data. This flag can be used to allow the user to enter a PIN into the system.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> handle specifies an algorithm that this CSP does not support.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH_STATE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt was made to add data to a hash object that is already marked "finished."
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A keyed hash algorithm is being used, but the session key is no longer valid. This error is generated if the session key is destroyed before the hashing operation is complete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_LEN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP does not ignore the CRYPT_USERDATA flag, the flag is set, and the <i>dwDataLen</i> parameter has a nonzero value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the hash object was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-crypthashdata
     * @since windows5.1.2600
     */
    static CryptHashData(hHash, pbData, dwDataLen, dwFlags) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptHashData", "ptr", hHash, "ptr", pbData, "uint", dwDataLen, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Computes the cryptographic hash of a session key object.
     * @param {Pointer} hHash A handle to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash object</a>.
     * @param {Pointer} hKey A handle to the key object to be hashed.
     * @param {Integer} dwFlags The following flag value is defined. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LITTLE_ENDIAN"></a><a id="crypt_little_endian"></a><dl>
     * <dt><b>CRYPT_LITTLE_ENDIAN</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When this flag is set, the bytes of the key are hashed in <a href="https://docs.microsoft.com/windows/desktop/SecGloss/l-gly">little-endian</a> form. Note that by default (when <i>dwFlags</i> is zero), the bytes of the key are hashed in <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">big-endian</a> form.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> handle specifies an algorithm that this CSP does not support.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH_STATE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt was made to add data to a hash object that is already marked "finished."
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A keyed hash algorithm is being used, but the session key is no longer valid. This error is generated if the session key is destroyed before the hashing operation is complete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the hash object was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-crypthashsessionkey
     * @since windows5.1.2600
     */
    static CryptHashSessionKey(hHash, hKey, dwFlags) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptHashSessionKey", "ptr", hHash, "ptr", hKey, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Destroys the hash object referenced by the hHash parameter.
     * @param {Pointer} hHash The handle of the hash object to be destroyed.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular <a href="/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by <i>hHash</i> is currently being used and cannot be destroyed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> parameter specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> handle specifies an algorithm that this CSP does not support.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the hash object was created cannot be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptdestroyhash
     * @since windows5.1.2600
     */
    static CryptDestroyHash(hHash) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptDestroyHash", "ptr", hHash, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Signs data.
     * @param {Pointer} hHash Handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash object</a> to be signed.
     * @param {Integer} dwKeySpec Identifies the private key to use from the provider's container. It can be AT_KEYEXCHANGE or AT_SIGNATURE. 
     * 
     * 
     * 
     * 
     * The signature algorithm used is specified when the key pair is originally created.
     * 
     * The only signature algorithm that the Microsoft Base Cryptographic Provider supports is the RSA Public Key algorithm.
     * @param {PSTR} szDescription This parameter is no longer used and must be set to <b>NULL</b> to prevent security vulnerabilities. However, it is still supported for backward compatibility in the Microsoft Base Cryptographic Provider.
     * @param {Integer} dwFlags The following flag values are defined. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NOHASHOID"></a><a id="crypt_nohashoid"></a><dl>
     * <dt><b>CRYPT_NOHASHOID</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used with RSA providers. The hash <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) is not placed in the RSA public key encryption. If this flag is not set, the hash OID in the default signature is as specified in the definition of DigestInfo in PKCS #1. 
     * 
     * 
     * 
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_TYPE2_FORMAT"></a><a id="crypt_type2_format"></a><dl>
     * <dt><b>CRYPT_TYPE2_FORMAT</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_X931_FORMAT"></a><a id="crypt_x931_format"></a><dl>
     * <dt><b>CRYPT_X931_FORMAT</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the RSA signature padding method specified in the ANSI X9.31 standard.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} pbSignature A pointer to a buffer receiving the signature data. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the buffer size for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pdwSigLen A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the <i>pbSignature</i> buffer. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer specified by the <i>pbSignature</i> parameter is not large enough to hold the returned data. The required buffer size, in bytes, is in the <i>pdwSigLen</i><b>DWORD</b> value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> handle specifies an algorithm that this CSP does not support, or the <i>dwKeySpec</i> parameter has an incorrect value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the hash object was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The private key specified by <i>dwKeySpec</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptsignhasha
     * @since windows5.1.2600
     */
    static CryptSignHashA(hHash, dwKeySpec, szDescription, dwFlags, pbSignature, pdwSigLen) {
        szDescription := szDescription is String ? StrPtr(szDescription) : szDescription

        pdwSigLenMarshal := pdwSigLen is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSignHashA", "ptr", hHash, "uint", dwKeySpec, "ptr", szDescription, "uint", dwFlags, "ptr", pbSignature, pdwSigLenMarshal, pdwSigLen, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Signs data.
     * @param {Pointer} hHash Handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash object</a> to be signed.
     * @param {Integer} dwKeySpec Identifies the private key to use from the provider's container. It can be AT_KEYEXCHANGE or AT_SIGNATURE. 
     * 
     * 
     * 
     * 
     * The signature algorithm used is specified when the key pair is originally created.
     * 
     * The only signature algorithm that the Microsoft Base Cryptographic Provider supports is the RSA Public Key algorithm.
     * @param {PWSTR} szDescription This parameter is no longer used and must be set to <b>NULL</b> to prevent security vulnerabilities. However, it is still supported for backward compatibility in the Microsoft Base Cryptographic Provider.
     * @param {Integer} dwFlags The following flag values are defined. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NOHASHOID"></a><a id="crypt_nohashoid"></a><dl>
     * <dt><b>CRYPT_NOHASHOID</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used with RSA providers. The hash <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) is not placed in the RSA public key encryption. If this flag is not set, the hash OID in the default signature is as specified in the definition of DigestInfo in PKCS #1. 
     * 
     * 
     * 
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_TYPE2_FORMAT"></a><a id="crypt_type2_format"></a><dl>
     * <dt><b>CRYPT_TYPE2_FORMAT</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_X931_FORMAT"></a><a id="crypt_x931_format"></a><dl>
     * <dt><b>CRYPT_X931_FORMAT</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the RSA signature padding method specified in the ANSI X9.31 standard.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} pbSignature A pointer to a buffer receiving the signature data. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the buffer size for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pdwSigLen A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the <i>pbSignature</i> buffer. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer specified by the <i>pbSignature</i> parameter is not large enough to hold the returned data. The required buffer size, in bytes, is in the <i>pdwSigLen</i><b>DWORD</b> value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> handle specifies an algorithm that this CSP does not support, or the <i>dwKeySpec</i> parameter has an incorrect value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the hash object was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The private key specified by <i>dwKeySpec</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptsignhashw
     * @since windows5.1.2600
     */
    static CryptSignHashW(hHash, dwKeySpec, szDescription, dwFlags, pbSignature, pdwSigLen) {
        szDescription := szDescription is String ? StrPtr(szDescription) : szDescription

        pdwSigLenMarshal := pdwSigLen is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSignHashW", "ptr", hHash, "uint", dwKeySpec, "ptr", szDescription, "uint", dwFlags, "ptr", pbSignature, pdwSigLenMarshal, pdwSigLen, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Verifies the signature of a hash object.
     * @param {Pointer} hHash A handle to the hash object to verify.
     * @param {Pointer} pbSignature The address of the signature data to be verified.
     * @param {Integer} dwSigLen The number of bytes in the <i>pbSignature</i> signature data.
     * @param {Pointer} hPubKey A handle to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key</a> to use to authenticate the signature. This public key must belong to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key pair</a> that was originally used to create the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">digital signature</a>.
     * @param {PSTR} szDescription This parameter should no longer be used and must be set to <b>NULL</b> to prevent security vulnerabilities. However, it is still supported for backward compatibility in the Microsoft Base Cryptographic Provider.
     * @param {Integer} dwFlags The following flag values are defined. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NOHASHOID"></a><a id="crypt_nohashoid"></a><dl>
     * <dt><b>CRYPT_NOHASHOID</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is used with RSA providers. When verifying the signature, the hash <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) is not expected to be present or checked. If this flag is not set, the hash OID in the default signature is verified as specified in the definition of DigestInfo in PKCS #7. 
     * 
     * 
     * 
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_TYPE2_FORMAT"></a><a id="crypt_type2_format"></a><dl>
     * <dt><b>CRYPT_TYPE2_FORMAT</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_X931_FORMAT"></a><a id="crypt_x931_format"></a><dl>
     * <dt><b>CRYPT_X931_FORMAT</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use X.931 support for the FIPS186-2compliant version of RSA (rDSA).
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hPubKey</i> parameter does not contain a handle to a valid <a href="/windows/desktop/SecGloss/p-gly">public key</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature was not valid. This might be because the data itself has changed, the description string did not match, or the wrong public key was specified by <i>hPubKey</i>.
     * 
     * This error can also be returned if the hashing or signature algorithms do not match the ones used to create the signature.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) context that was specified when the hash object was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptverifysignaturea
     * @since windows5.1.2600
     */
    static CryptVerifySignatureA(hHash, pbSignature, dwSigLen, hPubKey, szDescription, dwFlags) {
        szDescription := szDescription is String ? StrPtr(szDescription) : szDescription

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptVerifySignatureA", "ptr", hHash, "ptr", pbSignature, "uint", dwSigLen, "ptr", hPubKey, "ptr", szDescription, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Verifies the signature of a hash object.
     * @param {Pointer} hHash A handle to the hash object to verify.
     * @param {Pointer} pbSignature The address of the signature data to be verified.
     * @param {Integer} dwSigLen The number of bytes in the <i>pbSignature</i> signature data.
     * @param {Pointer} hPubKey A handle to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key</a> to use to authenticate the signature. This public key must belong to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key pair</a> that was originally used to create the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">digital signature</a>.
     * @param {PWSTR} szDescription This parameter should no longer be used and must be set to <b>NULL</b> to prevent security vulnerabilities. However, it is still supported for backward compatibility in the Microsoft Base Cryptographic Provider.
     * @param {Integer} dwFlags The following flag values are defined. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NOHASHOID"></a><a id="crypt_nohashoid"></a><dl>
     * <dt><b>CRYPT_NOHASHOID</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is used with RSA providers. When verifying the signature, the hash <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) is not expected to be present or checked. If this flag is not set, the hash OID in the default signature is verified as specified in the definition of DigestInfo in PKCS #7. 
     * 
     * 
     * 
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_TYPE2_FORMAT"></a><a id="crypt_type2_format"></a><dl>
     * <dt><b>CRYPT_TYPE2_FORMAT</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_X931_FORMAT"></a><a id="crypt_x931_format"></a><dl>
     * <dt><b>CRYPT_X931_FORMAT</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use X.931 support for the FIPS186-2compliant version of RSA (rDSA).
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hPubKey</i> parameter does not contain a handle to a valid <a href="/windows/desktop/SecGloss/p-gly">public key</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature was not valid. This might be because the data itself has changed, the description string did not match, or the wrong public key was specified by <i>hPubKey</i>.
     * 
     * This error can also be returned if the hashing or signature algorithms do not match the ones used to create the signature.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) context that was specified when the hash object was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptverifysignaturew
     * @since windows5.1.2600
     */
    static CryptVerifySignatureW(hHash, pbSignature, dwSigLen, hPubKey, szDescription, dwFlags) {
        szDescription := szDescription is String ? StrPtr(szDescription) : szDescription

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptVerifySignatureW", "ptr", hHash, "ptr", pbSignature, "uint", dwSigLen, "ptr", hPubKey, "ptr", szDescription, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Specifies the current user's default cryptographic service provider (CSP).
     * @param {PSTR} pszProvName Name of the new default CSP. The named CSP must be installed on the computer. For a list of available cryptographic providers, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-provider-names">Cryptographic Provider Names</a>.
     * @param {Integer} dwProvType Provider type of the CSP specified by <i>pszProvName</i>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Errors can also be propagated from internal calls to <a href="/windows/desktop/api/winreg/nf-winreg-regcreatekeyexa">RegCreateKeyEx</a> and <a href="/windows/desktop/api/winreg/nf-winreg-regsetvalueexa">RegSetValueEx</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptsetprovidera
     * @since windows5.1.2600
     */
    static CryptSetProviderA(pszProvName, dwProvType) {
        pszProvName := pszProvName is String ? StrPtr(pszProvName) : pszProvName

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSetProviderA", "ptr", pszProvName, "uint", dwProvType, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Specifies the current user's default cryptographic service provider (CSP).
     * @param {PWSTR} pszProvName Name of the new default CSP. The named CSP must be installed on the computer. For a list of available cryptographic providers, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-provider-names">Cryptographic Provider Names</a>.
     * @param {Integer} dwProvType Provider type of the CSP specified by <i>pszProvName</i>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Errors can also be propagated from internal calls to <a href="/windows/desktop/api/winreg/nf-winreg-regcreatekeyexa">RegCreateKeyEx</a> and <a href="/windows/desktop/api/winreg/nf-winreg-regsetvalueexa">RegSetValueEx</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptsetproviderw
     * @since windows5.1.2600
     */
    static CryptSetProviderW(pszProvName, dwProvType) {
        pszProvName := pszProvName is String ? StrPtr(pszProvName) : pszProvName

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSetProviderW", "ptr", pszProvName, "uint", dwProvType, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Specifies the default cryptographic service provider (CSP) of a specified provider type for the local computer or current user.
     * @param {PSTR} pszProvName The name of the new default CSP. This must be a CSP installed on the computer. For a list of available cryptographic providers, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-provider-names">Cryptographic Provider Names</a>.
     * @param {Integer} dwProvType The provider type of the CSP specified by <i>pszProvName</i>.
     * @param {Integer} dwFlags The following flag values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DELETE_DEFAULT"></a><a id="crypt_delete_default"></a><dl>
     * <dt><b>CRYPT_DELETE_DEFAULT</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Can be used in conjunction with CRYPT_MACHINE_DEFAULT or CRYPT_USER_DEFAULT to delete the default.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_USER_DEFAULT"></a><a id="crypt_user_default"></a><dl>
     * <dt><b>CRYPT_USER_DEFAULT</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Causes the user-context default CSP of the specified type to be set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_MACHINE_DEFAULT"></a><a id="crypt_machine_default"></a><dl>
     * <dt><b>CRYPT_MACHINE_DEFAULT</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Causes the computer default CSP of the specified type to be set.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes include those shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptsetproviderexa
     * @since windows5.1.2600
     */
    static CryptSetProviderExA(pszProvName, dwProvType, dwFlags) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        pszProvName := pszProvName is String ? StrPtr(pszProvName) : pszProvName

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSetProviderExA", "ptr", pszProvName, "uint", dwProvType, "uint*", pdwReserved, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Specifies the default cryptographic service provider (CSP) of a specified provider type for the local computer or current user.
     * @param {PWSTR} pszProvName The name of the new default CSP. This must be a CSP installed on the computer. For a list of available cryptographic providers, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-provider-names">Cryptographic Provider Names</a>.
     * @param {Integer} dwProvType The provider type of the CSP specified by <i>pszProvName</i>.
     * @param {Integer} dwFlags The following flag values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DELETE_DEFAULT"></a><a id="crypt_delete_default"></a><dl>
     * <dt><b>CRYPT_DELETE_DEFAULT</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Can be used in conjunction with CRYPT_MACHINE_DEFAULT or CRYPT_USER_DEFAULT to delete the default.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_USER_DEFAULT"></a><a id="crypt_user_default"></a><dl>
     * <dt><b>CRYPT_USER_DEFAULT</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Causes the user-context default CSP of the specified type to be set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_MACHINE_DEFAULT"></a><a id="crypt_machine_default"></a><dl>
     * <dt><b>CRYPT_MACHINE_DEFAULT</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Causes the computer default CSP of the specified type to be set.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes include those shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptsetproviderexw
     * @since windows5.1.2600
     */
    static CryptSetProviderExW(pszProvName, dwProvType, dwFlags) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        pszProvName := pszProvName is String ? StrPtr(pszProvName) : pszProvName

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSetProviderExW", "ptr", pszProvName, "uint", dwProvType, "uint*", pdwReserved, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Finds the default cryptographic service provider (CSP) of a specified provider type for the local computer or current user.
     * @param {Integer} dwProvType The provider type for which the default CSP name is to be found. 
     * 
     * Defined provider types are  as follows:
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-rsa-full">PROV_RSA_FULL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-rsa-sig">PROV_RSA_SIG</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-dss">PROV_DSS</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-dss-dh">PROV_DSS_DH</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-dh-schannel">PROV_DH_SCHANNEL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-fortezza">PROV_FORTEZZA</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-ms-exchange">PROV_MS_EXCHANGE</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-rsa-schannel">PROV_RSA_SCHANNEL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-ssl">PROV_SSL</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags The following flag values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_USER_DEFAULT"></a><a id="crypt_user_default"></a><dl>
     * <dt><b>CRYPT_USER_DEFAULT</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns the user-context default CSP of the specified type.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_MACHINE_DEFAULT"></a><a id="crypt_machine_default"></a><dl>
     * <dt><b>CRYPT_MACHINE_DEFAULT</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns the computer default CSP of the specified type.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} pszProvName A pointer to a null-terminated character string buffer to receive the name of the default CSP.
     * 
     * To find the size of the buffer for memory allocation purposes, this parameter can be <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbProvName A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the buffer pointed to by the <i>pszProvName</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored or to be stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 						
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error code prefaced by NTE is generated by the particular CSP being used. Possible error codes include the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer for the name is not large enough.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter has an unrecognized value.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptgetdefaultprovidera
     * @since windows5.1.2600
     */
    static CryptGetDefaultProviderA(dwProvType, dwFlags, pszProvName, pcbProvName) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        pcbProvNameMarshal := pcbProvName is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptGetDefaultProviderA", "uint", dwProvType, "uint*", pdwReserved, "uint", dwFlags, "ptr", pszProvName, pcbProvNameMarshal, pcbProvName, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Finds the default cryptographic service provider (CSP) of a specified provider type for the local computer or current user.
     * @param {Integer} dwProvType The provider type for which the default CSP name is to be found. 
     * 
     * Defined provider types are  as follows:
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-rsa-full">PROV_RSA_FULL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-rsa-sig">PROV_RSA_SIG</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-dss">PROV_DSS</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-dss-dh">PROV_DSS_DH</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-dh-schannel">PROV_DH_SCHANNEL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-fortezza">PROV_FORTEZZA</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-ms-exchange">PROV_MS_EXCHANGE</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-rsa-schannel">PROV_RSA_SCHANNEL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-ssl">PROV_SSL</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags The following flag values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_USER_DEFAULT"></a><a id="crypt_user_default"></a><dl>
     * <dt><b>CRYPT_USER_DEFAULT</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns the user-context default CSP of the specified type.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_MACHINE_DEFAULT"></a><a id="crypt_machine_default"></a><dl>
     * <dt><b>CRYPT_MACHINE_DEFAULT</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns the computer default CSP of the specified type.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} pszProvName A pointer to a null-terminated character string buffer to receive the name of the default CSP.
     * 
     * To find the size of the buffer for memory allocation purposes, this parameter can be <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbProvName A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the buffer pointed to by the <i>pszProvName</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored or to be stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 						
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error code prefaced by NTE is generated by the particular CSP being used. Possible error codes include the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer for the name is not large enough.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter has an unrecognized value.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptgetdefaultproviderw
     * @since windows5.1.2600
     */
    static CryptGetDefaultProviderW(dwProvType, dwFlags, pszProvName, pcbProvName) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        pcbProvNameMarshal := pcbProvName is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptGetDefaultProviderW", "uint", dwProvType, "uint*", pdwReserved, "uint", dwFlags, "ptr", pszProvName, pcbProvNameMarshal, pcbProvName, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the first or next types of cryptographic service provider (CSP) supported on the computer.
     * @param {Integer} dwIndex Index of the next provider type to be enumerated.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Integer>} pdwProvType Address of the <b>DWORD</b> value designating the enumerated provider type.
     * @param {Pointer} szTypeName A pointer to a buffer that receives the data from the enumerated provider type. This is a string including the terminating <b>NULL</b> character. Some provider types do not have display names, and in this case no name is returned and the returned value pointed to by <i>pcbTypeName</i> is zero. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to get the size of the name for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbTypeName A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pszTypeName</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored or to be stored in the buffer. Some provider types do not have display names, and in this case no name is returned and the returned value pointed to by <i>pcbTypeName</i> is zero. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There are no more items to enumerate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter has an unrecognized value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Something was wrong with the type registration.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptenumprovidertypesa
     * @since windows5.1.2600
     */
    static CryptEnumProviderTypesA(dwIndex, dwFlags, pdwProvType, szTypeName, pcbTypeName) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        pdwProvTypeMarshal := pdwProvType is VarRef ? "uint*" : "ptr"
        pcbTypeNameMarshal := pcbTypeName is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptEnumProviderTypesA", "uint", dwIndex, "uint*", pdwReserved, "uint", dwFlags, pdwProvTypeMarshal, pdwProvType, "ptr", szTypeName, pcbTypeNameMarshal, pcbTypeName, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the first or next types of cryptographic service provider (CSP) supported on the computer.
     * @param {Integer} dwIndex Index of the next provider type to be enumerated.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Integer>} pdwProvType Address of the <b>DWORD</b> value designating the enumerated provider type.
     * @param {Pointer} szTypeName A pointer to a buffer that receives the data from the enumerated provider type. This is a string including the terminating <b>NULL</b> character. Some provider types do not have display names, and in this case no name is returned and the returned value pointed to by <i>pcbTypeName</i> is zero. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to get the size of the name for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbTypeName A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pszTypeName</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored or to be stored in the buffer. Some provider types do not have display names, and in this case no name is returned and the returned value pointed to by <i>pcbTypeName</i> is zero. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There are no more items to enumerate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter has an unrecognized value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Something was wrong with the type registration.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptenumprovidertypesw
     * @since windows5.1.2600
     */
    static CryptEnumProviderTypesW(dwIndex, dwFlags, pdwProvType, szTypeName, pcbTypeName) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        pdwProvTypeMarshal := pdwProvType is VarRef ? "uint*" : "ptr"
        pcbTypeNameMarshal := pcbTypeName is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptEnumProviderTypesW", "uint", dwIndex, "uint*", pdwReserved, "uint", dwFlags, pdwProvTypeMarshal, pdwProvType, "ptr", szTypeName, pcbTypeNameMarshal, pcbTypeName, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * ImportantThis API is deprecated.
     * @param {Integer} dwIndex Index of the next provider to be enumerated.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Integer>} pdwProvType Address of the <b>DWORD</b> value designating the type of the enumerated provider.
     * @param {Pointer} szProvName A pointer to a buffer that receives the data from the enumerated provider. This is a string including the terminating null character.
     * 
     * This parameter can be <b>NULL</b> to set the size of the name for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbProvName A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pszProvName</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszProvName</i> buffer was not large enough to hold the provider name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There are no more items to enumerate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter has an unrecognized value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Something was wrong with the type registration.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptenumprovidersa
     * @since windows5.1.2600
     */
    static CryptEnumProvidersA(dwIndex, dwFlags, pdwProvType, szProvName, pcbProvName) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        pdwProvTypeMarshal := pdwProvType is VarRef ? "uint*" : "ptr"
        pcbProvNameMarshal := pcbProvName is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptEnumProvidersA", "uint", dwIndex, "uint*", pdwReserved, "uint", dwFlags, pdwProvTypeMarshal, pdwProvType, "ptr", szProvName, pcbProvNameMarshal, pcbProvName, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * ImportantThis API is deprecated.
     * @param {Integer} dwIndex Index of the next provider to be enumerated.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Integer>} pdwProvType Address of the <b>DWORD</b> value designating the type of the enumerated provider.
     * @param {Pointer} szProvName A pointer to a buffer that receives the data from the enumerated provider. This is a string including the terminating null character.
     * 
     * This parameter can be <b>NULL</b> to set the size of the name for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbProvName A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pszProvName</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszProvName</i> buffer was not large enough to hold the provider name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There are no more items to enumerate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter has an unrecognized value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Something was wrong with the type registration.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptenumprovidersw
     * @since windows5.1.2600
     */
    static CryptEnumProvidersW(dwIndex, dwFlags, pdwProvType, szProvName, pcbProvName) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        pdwProvTypeMarshal := pdwProvType is VarRef ? "uint*" : "ptr"
        pcbProvNameMarshal := pcbProvName is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptEnumProvidersW", "uint", dwIndex, "uint*", pdwReserved, "uint", dwFlags, pdwProvTypeMarshal, pdwProvType, "ptr", szProvName, pcbProvNameMarshal, pcbProvName, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Adds one to the reference count of an HCRYPTPROV cryptographic service provider (CSP) handle.
     * @param {Pointer} hProv <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a> handle for which the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> is being incremented. This handle must have already been created using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptcontextaddref
     * @since windows5.1.2600
     */
    static CryptContextAddRef(hProv, dwFlags) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptContextAddRef", "ptr", hProv, "uint*", pdwReserved, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Makes an exact copy of a key and the state of the key.
     * @param {Pointer} hKey A handle to the key to be duplicated.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Pointer>} phKey Address of the handle to the duplicated key. When you have finished using the key, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error code prefaced by "NTE" is generated by the particular CSP being used. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Because this is a new function, existing CSPs might not implement it. This error is returned if the CSP does not support this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A handle to the original key is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptduplicatekey
     * @since windows5.1.2600
     */
    static CryptDuplicateKey(hKey, dwFlags, phKey) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        phKeyMarshal := phKey is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptDuplicateKey", "ptr", hKey, "uint*", pdwReserved, "uint", dwFlags, phKeyMarshal, phKey, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Makes an exact copy of a hash to the point when the duplication is done.
     * @param {Pointer} hHash Handle of the hash to be duplicated.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Pointer>} phHash Address of the handle of the duplicated hash. When you have finished using the hash, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash">CryptDestroyHash</a> function.
     * @returns {BOOL} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error code prefaced by "NTE" is generated by the particular <a href="/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) that you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Because this is a new function, existing CSPs cannot implement it. This error is returned if the CSP does not support this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A handle to the original hash is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptduplicatehash
     * @since windows5.1.2600
     */
    static CryptDuplicateHash(hHash, dwFlags, phHash) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        phHashMarshal := phHash is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptDuplicateHash", "ptr", hHash, "uint*", pdwReserved, "uint", dwFlags, phHashMarshal, phHash, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Loads and initializes a CNG provider.
     * @param {Pointer<BCRYPT_ALG_HANDLE>} phAlgorithm A pointer to a <b>BCRYPT_ALG_HANDLE</b> variable that receives the CNG provider handle. When you have finished using this handle, release it by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptclosealgorithmprovider">BCryptCloseAlgorithmProvider</a> function.
     * @param {PWSTR} pszAlgId A pointer to a null-terminated Unicode string that identifies the requested cryptographic algorithm. This can be one of the standard <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-algorithm-identifiers">CNG Algorithm Identifiers</a> or the identifier for another registered algorithm.
     * @param {PWSTR} pszImplementation A pointer to a null-terminated Unicode string that identifies the specific provider to load. This is the registered alias of the cryptographic primitive provider. This parameter is optional and can be <b>NULL</b> if it is not needed. If this parameter is <b>NULL</b>, the default provider for the specified algorithm will be loaded.
     * 
     * 
     * <div class="alert"><b>Note</b>If the <i>pszImplementation</i> parameter value  is <b>NULL</b>, CNG attempts to open each registered provider, in order of priority, for the algorithm specified by the <i>pszAlgId</i> parameter and returns the handle of the first  provider that is successfully opened. For the lifetime of the handle, any BCrypt*** cryptographic APIs will use the provider that was successfully opened.</div>
     * <div></div>
     * <b>Windows Server2008 and WindowsVista:</b>CNG attempts to fall back to the Microsoft CNG provider.
     * 
     * 
     * 
     * 
     * The following are the predefined provider names.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MS_PRIMITIVE_PROVIDER"></a><a id="ms_primitive_provider"></a><dl>
     * <dt><b>MS_PRIMITIVE_PROVIDER</b></dt>
     * <dt>"Microsoft Primitive Provider"</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Identifies the basic Microsoft CNG provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MS_PLATFORM_CRYPTO_PROVIDER"></a><a id="ms_platform_crypto_provider"></a><dl>
     * <dt><b>MS_PLATFORM_CRYPTO_PROVIDER</b></dt>
     * <dt>L"Microsoft Platform Crypto Provider"</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Identifies the TPM key storage provider that is provided by Microsoft.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags 
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No provider was found for the specified algorithm ID.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptopenalgorithmprovider
     * @since windows6.0.6000
     */
    static BCryptOpenAlgorithmProvider(phAlgorithm, pszAlgId, pszImplementation, dwFlags) {
        pszAlgId := pszAlgId is String ? StrPtr(pszAlgId) : pszAlgId
        pszImplementation := pszImplementation is String ? StrPtr(pszImplementation) : pszImplementation

        result := DllCall("bcrypt.dll\BCryptOpenAlgorithmProvider", "ptr", phAlgorithm, "ptr", pszAlgId, "ptr", pszImplementation, "uint", dwFlags, "int")
        return result
    }

    /**
     * Gets a list of the registered algorithm identifiers.
     * @param {Integer} dwAlgOperations 
     * @param {Pointer<Integer>} pAlgCount A pointer to a <b>ULONG</b> variable to receive the number of elements in the <i>ppAlgList</i> array.
     * @param {Pointer<Pointer<BCRYPT_ALGORITHM_IDENTIFIER>>} ppAlgList The address of a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-bcrypt_algorithm_identifier">BCRYPT_ALGORITHM_IDENTIFIER</a> structure pointer to receive the array of registered algorithm identifiers. This pointer must be passed to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function when it is no longer needed.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are defined for this function.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptenumalgorithms
     * @since windows6.0.6000
     */
    static BCryptEnumAlgorithms(dwAlgOperations, pAlgCount, ppAlgList, dwFlags) {
        pAlgCountMarshal := pAlgCount is VarRef ? "uint*" : "ptr"
        ppAlgListMarshal := ppAlgList is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptEnumAlgorithms", "uint", dwAlgOperations, pAlgCountMarshal, pAlgCount, ppAlgListMarshal, ppAlgList, "uint", dwFlags, "int")
        return result
    }

    /**
     * Obtains all of the CNG providers that support a specified algorithm.
     * @param {PWSTR} pszAlgId A pointer to a null-terminated Unicode string that identifies the algorithm to obtain the providers for. This can be one of the predefined <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-algorithm-identifiers">CNG Algorithm Identifiers</a> or another algorithm identifier.
     * @param {Pointer<Integer>} pImplCount A pointer to a <b>ULONG</b> variable to receive the number of elements in the <i>ppImplList</i> array.
     * @param {Pointer<Pointer<BCRYPT_PROVIDER_NAME>>} ppImplList The address of an array of <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-bcrypt_provider_name">BCRYPT_PROVIDER_NAME</a> structures to receive the collection of providers that support the specified algorithm. The <i>pImplCount</i> parameter receives the number of elements in this array. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * @param {Integer} dwFlags A set of flags that modifies the behavior of this function. There are currently no flags defined, so this parameter must be zero.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptenumproviders
     * @since windows6.0.6000
     */
    static BCryptEnumProviders(pszAlgId, pImplCount, ppImplList, dwFlags) {
        pszAlgId := pszAlgId is String ? StrPtr(pszAlgId) : pszAlgId

        pImplCountMarshal := pImplCount is VarRef ? "uint*" : "ptr"
        ppImplListMarshal := ppImplList is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptEnumProviders", "ptr", pszAlgId, pImplCountMarshal, pImplCount, ppImplListMarshal, ppImplList, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves the value of a named property for a CNG object.
     * @param {BCRYPT_HANDLE} hObject A handle that represents the CNG object to obtain the property value for.
     * @param {PWSTR} pszProperty A pointer to a null-terminated Unicode string that contains the name of the property to retrieve. This can be one of the predefined <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-property-identifiers">Cryptography Primitive Property Identifiers</a> or a custom property identifier.
     * @param {Pointer} pbOutput The address of a buffer that receives the property value. The <i>cbOutput</i> parameter contains the size of this buffer.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer.
     * @param {Pointer<Integer>} pcbResult A pointer to a <b>ULONG</b> variable that receives the number of bytes that were copied to the <i>pbOutput</i> buffer. If the <i>pbOutput</i> parameter is <b>NULL</b>, this function will place the required size, in bytes, in the location pointed to by this parameter.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are defined for this function.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer size specified by the <i>cbOutput</i> parameter is not large enough to hold the property value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hObject</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The named property specified by the <i>pszProperty</i> parameter is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptgetproperty
     * @since windows6.0.6000
     */
    static BCryptGetProperty(hObject, pszProperty, pbOutput, cbOutput, pcbResult, dwFlags) {
        hObject := hObject is Win32Handle ? NumGet(hObject, "ptr") : hObject
        pszProperty := pszProperty is String ? StrPtr(pszProperty) : pszProperty

        pcbResultMarshal := pcbResult is VarRef ? "uint*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptGetProperty", "ptr", hObject, "ptr", pszProperty, "ptr", pbOutput, "uint", cbOutput, pcbResultMarshal, pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Sets the value of a named property for a CNG object.
     * @param {BCRYPT_HANDLE} hObject A handle that represents the CNG object to set the property value for.
     * @param {PWSTR} pszProperty A pointer to a null-terminated Unicode string that contains the name of the property to set. This can be one of the predefined <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-property-identifiers">Cryptography Primitive Property Identifiers</a> or a custom property identifier.
     * @param {Pointer} pbInput The address of a buffer that contains the new property value. The <i>cbInput</i> parameter contains the size of this buffer.
     * @param {Integer} cbInput The size, in bytes, of the <i>pbInput</i> buffer.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are defined for this function.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hObject</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The named property specified by the <i>pszProperty</i> parameter is not supported or is read-only.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptsetproperty
     * @since windows6.0.6000
     */
    static BCryptSetProperty(hObject, pszProperty, pbInput, cbInput, dwFlags) {
        hObject := hObject is Win32Handle ? NumGet(hObject, "ptr") : hObject
        pszProperty := pszProperty is String ? StrPtr(pszProperty) : pszProperty

        result := DllCall("bcrypt.dll\BCryptSetProperty", "ptr", hObject, "ptr", pszProperty, "ptr", pbInput, "uint", cbInput, "uint", dwFlags, "int")
        return result
    }

    /**
     * Closes an algorithm provider.
     * @param {BCRYPT_ALG_HANDLE} hAlgorithm A handle that represents the algorithm provider to close. This handle is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are defined for this function.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm handle in the <i>hAlgorithm</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptclosealgorithmprovider
     * @since windows6.0.6000
     */
    static BCryptCloseAlgorithmProvider(hAlgorithm, dwFlags) {
        hAlgorithm := hAlgorithm is Win32Handle ? NumGet(hAlgorithm, "ptr") : hAlgorithm

        result := DllCall("bcrypt.dll\BCryptCloseAlgorithmProvider", "ptr", hAlgorithm, "uint", dwFlags, "int")
        return result
    }

    /**
     * Used to free memory that was allocated by one of the CNG functions.
     * @remarks
     * 
     * <b>BCryptFreeBuffer</b> must be called in the same processor mode as the BCrypt API function that allocated the buffer. In addition, if the buffer was allocated at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a>, it must be freed at that <i>IRQL</i>. If the buffer was allocated at <b>DISPATCH_LEVEL</b> <i>IRQL</i>, it can be freed at either <b>DISPATCH_LEVEL</b> <i>IRQL</i> or <b>PASSIVE_LEVEL</b> <i>IRQL</i>.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server2008 and WindowsVista:</b>To call this function in kernel mode, use Ksecdd.lib.
     * 
     * 
     * @param {Pointer<Void>} pvBuffer A pointer to the memory buffer to be freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptfreebuffer
     * @since windows6.0.6000
     */
    static BCryptFreeBuffer(pvBuffer) {
        pvBufferMarshal := pvBuffer is VarRef ? "ptr" : "ptr"

        DllCall("bcrypt.dll\BCryptFreeBuffer", pvBufferMarshal, pvBuffer)
    }

    /**
     * Creates a key object for use with a symmetrical key encryption algorithm from a supplied key.
     * @param {BCRYPT_ALG_HANDLE} hAlgorithm The handle of an algorithm provider created with the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function. The algorithm specified when the provider was created must support symmetric key encryption.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} phKey A pointer to a <b>BCRYPT_KEY_HANDLE</b> that receives the handle of the key. This handle is used in subsequent functions that require a key, such as <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptencrypt">BCryptEncrypt</a>. This handle must be released when it is no longer needed by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroykey">BCryptDestroyKey</a> function.
     * @param {Pointer} pbKeyObject A pointer to a buffer that receives the key object. The <i>cbKeyObject</i> parameter contains the size of this buffer. The required size of this buffer can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_OBJECT_LENGTH</b> property. This will provide the size of the key object for the specified algorithm.
     * 
     * This memory can only be freed after the <i>phKey</i> key handle is destroyed.
     * 
     * If the value of this parameter is <b>NULL</b> and the value of the <i>cbKeyObject</i> parameter is zero, the memory for the key object is allocated and freed by this function.<b>Windows7:</b>This memory management functionality is available beginning with Windows7.
     * @param {Integer} cbKeyObject The size, in bytes, of the <i>pbKeyObject</i> buffer.
     * 
     * If the value of this parameter is zero and the value of the <i>pbKeyObject</i> parameter is <b>NULL</b>, the memory for the key object is allocated and freed by this function.<b>Windows7:</b>This memory management functionality is available beginning with Windows7.
     * @param {Pointer} pbSecret Pointer to a buffer that contains the key from which to create the key object. The <i>cbSecret</i> parameter contains the size of this buffer. This is normally a hash of a password or some other reproducible data. If the data passed in exceeds the target key size, the data will be truncated and the excess will be ignored.
     * 
     * <div class="alert"><b>Note</b>We strongly recommended that applications pass in the exact number of bytes required by the target key.</div>
     * <div></div>
     * @param {Integer} cbSecret The size, in bytes, of the <i>pbSecret</i> buffer.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are currently defined, so this parameter should be zero.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of the key object specified by the <i>cbKeyObject</i> parameter is not large enough to hold the key object.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm handle in the <i>hAlgorithm</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptgeneratesymmetrickey
     * @since windows6.0.6000
     */
    static BCryptGenerateSymmetricKey(hAlgorithm, phKey, pbKeyObject, cbKeyObject, pbSecret, cbSecret, dwFlags) {
        hAlgorithm := hAlgorithm is Win32Handle ? NumGet(hAlgorithm, "ptr") : hAlgorithm

        result := DllCall("bcrypt.dll\BCryptGenerateSymmetricKey", "ptr", hAlgorithm, "ptr", phKey, "ptr", pbKeyObject, "uint", cbKeyObject, "ptr", pbSecret, "uint", cbSecret, "uint", dwFlags, "int")
        return result
    }

    /**
     * Creates an empty public/private key pair.
     * @param {BCRYPT_ALG_HANDLE} hAlgorithm Handle of an algorithm provider that supports signing, asymmetric encryption, or key agreement. This handle must have been created by using the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} phKey A pointer to a <b>BCRYPT_KEY_HANDLE</b> that receives the handle of the key. This handle is used in subsequent functions that require a key, such as <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptencrypt">BCryptEncrypt</a>. This handle must be released when it is no longer needed by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroykey">BCryptDestroyKey</a> function.
     * @param {Integer} dwLength The length, in bits, of the key. Algorithm providers have different key size restrictions for each standard asymmetric algorithm.
     * 
     * <table>
     * <tr>
     * <th>Algorithm identifier</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_DH_ALGORITHM"></a><a id="bcrypt_dh_algorithm"></a><dl>
     * <dt><b>BCRYPT_DH_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key size must be greater than or equal to 512 bits, less than or equal to 4096 bits, and must be a multiple of 64.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_DSA_ALGORITHM"></a><a id="bcrypt_dsa_algorithm"></a><dl>
     * <dt><b>BCRYPT_DSA_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Prior to Windows8, the key size must be greater than or equal to 512 bits, less than or equal to 1024 bits, and must be a multiple of 64.
     * 
     * Beginning with Windows8, the key size must be greater than or equal to 512 bits, less than or equal to 3072 bits, and must be a multiple of 64. Processing for key sizes less than or equal to 1024 bits adheres to FIPS 186-2. Processing for key sizes greater than 1024 and less than or equal to 3072 adheres to FIPS 186-3.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_ECDH_P256_ALGORITHM"></a><a id="bcrypt_ecdh_p256_algorithm"></a><dl>
     * <dt><b>BCRYPT_ECDH_P256_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key size must be 256 bits.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_ECDH_P384_ALGORITHM"></a><a id="bcrypt_ecdh_p384_algorithm"></a><dl>
     * <dt><b>BCRYPT_ECDH_P384_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key size must be 384 bits.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_ECDH_P521_ALGORITHM"></a><a id="bcrypt_ecdh_p521_algorithm"></a><dl>
     * <dt><b>BCRYPT_ECDH_P521_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key size must be 521 bits.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_ECDSA_P256_ALGORITHM"></a><a id="bcrypt_ecdsa_p256_algorithm"></a><dl>
     * <dt><b>BCRYPT_ECDSA_P256_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key size must be 256 bits.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_ECDSA_P384_ALGORITHM"></a><a id="bcrypt_ecdsa_p384_algorithm"></a><dl>
     * <dt><b>BCRYPT_ECDSA_P384_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key size must be 384 bits.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_ECDSA_P521_ALGORITHM"></a><a id="bcrypt_ecdsa_p521_algorithm"></a><dl>
     * <dt><b>BCRYPT_ECDSA_P521_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key size must be 521 bits.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_RSA_ALGORITHM"></a><a id="bcrypt_rsa_algorithm"></a><dl>
     * <dt><b>BCRYPT_RSA_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key size must be greater than or equal to 512 bits, less than or equal to 16384 bits, and must be a multiple of 64.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are currently defined, so this parameter should be zero.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm handle in the <i>hAlgorithm</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified provider does not support asymmetric key encryption.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptgeneratekeypair
     * @since windows6.0.6000
     */
    static BCryptGenerateKeyPair(hAlgorithm, phKey, dwLength, dwFlags) {
        hAlgorithm := hAlgorithm is Win32Handle ? NumGet(hAlgorithm, "ptr") : hAlgorithm

        result := DllCall("bcrypt.dll\BCryptGenerateKeyPair", "ptr", hAlgorithm, "ptr", phKey, "uint", dwLength, "uint", dwFlags, "int")
        return result
    }

    /**
     * Encrypts a block of data.
     * @param {BCRYPT_KEY_HANDLE} hKey The handle of the key to use to encrypt the data. This handle is obtained from one of the key creation functions, such as <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgeneratesymmetrickey">BCryptGenerateSymmetricKey</a>, <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgeneratekeypair">BCryptGenerateKeyPair</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptimportkey">BCryptImportKey</a>.
     * @param {Pointer} pbInput The address of a buffer that contains the plaintext to be encrypted. The <i>cbInput</i> parameter contains the size of the plaintext to encrypt. For more information, see Remarks.
     * @param {Integer} cbInput The number of bytes in the <i>pbInput</i> buffer to encrypt.
     * @param {Pointer<Void>} pPaddingInfo A pointer to a structure that contains padding information. This parameter is only used with asymmetric keys and authenticated encryption modes. If an  authenticated encryption mode is used, this parameter must point to a <a href="https://docs.microsoft.com/windows/win32/api/bcrypt/ns-bcrypt-bcrypt_authenticated_cipher_mode_info">BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO</a> structure. If asymmetric keys are used, the type of structure this parameter points to is determined by the value of the <i>dwFlags</i> parameter. Otherwise, the parameter  must be set to <b>NULL</b>.
     * @param {Pointer} pbIV The address of a buffer that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">initialization vector</a> (IV) to use during encryption. The <i>cbIV</i> parameter contains the size of this buffer. This function will modify the contents of this buffer. If you need to reuse the IV later, make sure you make a copy of this buffer before calling this function.
     * 
     * This parameter is optional and can be <b>NULL</b> if no IV is used.
     * 
     *  The required size of the IV can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_BLOCK_LENGTH</b> property. This will provide the size of a block for the algorithm, which is also the size of the IV.
     * @param {Integer} cbIV The size, in bytes, of the <i>pbIV</i> buffer.
     * @param {Pointer} pbOutput The address of the buffer that receives the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">ciphertext</a> produced by this function. The <i>cbOutput</i> parameter contains the size of this buffer. For more information, see Remarks.
     * 
     * If this parameter is <b>NULL</b>, the <b>BCryptEncrypt</b> function calculates the size needed for the ciphertext of the data passed in the <i>pbInput</i> parameter. In this case, the location pointed to by the <i>pcbResult</i> parameter contains this size, and the  function returns <b>STATUS_SUCCESS</b>. The <i>pPaddingInfo</i> parameter is not modified.
     * 
     * If the values of both the <i>pbOutput</i> and <i>pbInput</i> parameters are <b>NULL</b>, an error is returned unless  an authenticated encryption algorithm is in use. In the latter case, the call is treated as an authenticated encryption call with zero length data, and the authentication tag is returned in the <i>pPaddingInfo</i> parameter.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer. This parameter is ignored if the <i>pbOutput</i> parameter is <b>NULL</b>.
     * @param {Pointer<Integer>} pcbResult A pointer to a <b>ULONG</b> variable that receives the number of bytes copied to the <i>pbOutput</i> buffer. If <i>pbOutput</i> is <b>NULL</b>, this receives the size, in bytes, required for the ciphertext.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. The allowed set of flags depends on the type of key specified by the <i>hKey</i> parameter.
     * 
     * 
     * If the key is a symmetric key, this can be zero or the following value. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_BLOCK_PADDING"></a><a id="bcrypt_block_padding"></a><dl>
     * <dt><b>BCRYPT_BLOCK_PADDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Allows the encryption algorithm to pad the data to the next block size. If this flag is not specified, the size of the plaintext specified in the <i>cbInput</i> parameter must be a multiple of the algorithm's block size.
     * 
     *  The block size can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_BLOCK_LENGTH</b> property for the key. This will provide the size of a block for the algorithm.
     * 
     * This flag must not be used with the authenticated encryption modes (AES-CCM and AES-GCM).
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size specified by the <i>cbOutput</i> parameter is not large enough to hold the ciphertext.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_BUFFER_SIZE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>cbInput</i> parameter is not a multiple of the algorithm's block size and the <b>BCRYPT_BLOCK_PADDING</b> or the <b>BCRYPT_PAD_NONE</b> flag was not specified in the <i>dwFlags</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle in the <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm does not support encryption.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptencrypt
     * @since windows6.0.6000
     */
    static BCryptEncrypt(hKey, pbInput, cbInput, pPaddingInfo, pbIV, cbIV, pbOutput, cbOutput, pcbResult, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        pPaddingInfoMarshal := pPaddingInfo is VarRef ? "ptr" : "ptr"
        pcbResultMarshal := pcbResult is VarRef ? "uint*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptEncrypt", "ptr", hKey, "ptr", pbInput, "uint", cbInput, pPaddingInfoMarshal, pPaddingInfo, "ptr", pbIV, "uint", cbIV, "ptr", pbOutput, "uint", cbOutput, pcbResultMarshal, pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Decrypts a block of data.
     * @param {BCRYPT_KEY_HANDLE} hKey The handle of the key to use to decrypt the data. This handle is obtained from one of the key creation functions, such as <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgeneratesymmetrickey">BCryptGenerateSymmetricKey</a>, <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgeneratekeypair">BCryptGenerateKeyPair</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptimportkey">BCryptImportKey</a>.
     * @param {Pointer} pbInput The address of a buffer that contains the ciphertext to be decrypted. The <i>cbInput</i> parameter contains the size of the ciphertext to decrypt. For more information, see Remarks.
     * @param {Integer} cbInput The number of bytes in the <i>pbInput</i> buffer to decrypt.
     * @param {Pointer<Void>} pPaddingInfo A pointer to a structure that contains padding information. This parameter is only used with asymmetric keys and authenticated encryption modes. If an  authenticated encryption mode is used, this parameter must point to a <a href="https://docs.microsoft.com/windows/win32/api/bcrypt/ns-bcrypt-bcrypt_authenticated_cipher_mode_info">BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO</a> structure. If asymmetric keys are used, the type of structure this parameter points to is determined by the value of the <i>dwFlags</i> parameter. Otherwise, the parameter  must be set to <b>NULL</b>.
     * @param {Pointer} pbIV The address of a buffer that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">initialization vector</a> (IV) to use during decryption. The <i>cbIV</i> parameter contains the size of this buffer. This function will modify the contents of this buffer. If you need to reuse the IV later, make sure you make a copy of this buffer before calling this function.
     * 
     * This parameter is optional and can be <b>NULL</b> if no IV is used.
     * 
     *  The required size of the IV can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_BLOCK_LENGTH</b> property. This will provide the size of a block for the algorithm, which is also the size of the IV.
     * @param {Integer} cbIV The size, in bytes, of the <i>pbIV</i> buffer.
     * @param {Pointer} pbOutput The address of a buffer to receive the plaintext produced by this function. The <i>cbOutput</i> parameter contains the size of this buffer. For more information, see Remarks.
     * 
     * If this parameter is <b>NULL</b>, the <b>BCryptDecrypt</b>  function calculates the size required for the plaintext of the encrypted data passed in the <i>pbInput</i> parameter. In this case, the location pointed to by the <i>pcbResult</i> parameter contains this size, and the function returns <b>STATUS_SUCCESS</b>.
     * 
     * If the values of both the <i>pbOutput</i> and <i>pbInput</i> parameters are <b>NULL</b>, an error is returned unless  an authenticated encryption algorithm is in use. In the latter case, the call is treated as an authenticated encryption call with zero length data, and the authentication tag, passed in the <i>pPaddingInfo</i> parameter, is verified.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer. This parameter is ignored if the <i>pbOutput</i> parameter is <b>NULL</b>.
     * @param {Pointer<Integer>} pcbResult A pointer to a <b>ULONG</b> variable to receive the number of bytes copied to the <i>pbOutput</i> buffer. If <i>pbOutput</i> is <b>NULL</b>, this receives the size, in bytes, required for the plaintext.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. The allowed set of flags depends on the type of key specified by the <i>hKey</i> parameter.
     * 
     * 
     * If the key is a symmetric key, this can be zero or the following value. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_BLOCK_PADDING"></a><a id="bcrypt_block_padding"></a><dl>
     * <dt><b>BCRYPT_BLOCK_PADDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data was padded to the next block size when it was encrypted. If this flag was used with the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptencrypt">BCryptEncrypt</a> function, it must also be specified in this function. This flag must not be used with the authenticated encryption modes (AES-CCM and AES-GCM).
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_AUTH_TAG_MISMATCH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The computed authentication tag did not match the value supplied in the <i>pPaddingInfo</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size specified by the <i>cbOutput</i> parameter is not large enough to hold the ciphertext.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_BUFFER_SIZE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>cbInput</i> parameter is not a multiple of the algorithm's block size, and the <b>BCRYPT_BLOCK_PADDING</b> flag was not specified in the <i>dwFlags</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle in the <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm does not support decryption.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptdecrypt
     * @since windows6.0.6000
     */
    static BCryptDecrypt(hKey, pbInput, cbInput, pPaddingInfo, pbIV, cbIV, pbOutput, cbOutput, pcbResult, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        pPaddingInfoMarshal := pPaddingInfo is VarRef ? "ptr" : "ptr"
        pcbResultMarshal := pcbResult is VarRef ? "uint*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptDecrypt", "ptr", hKey, "ptr", pbInput, "uint", cbInput, pPaddingInfoMarshal, pPaddingInfo, "ptr", pbIV, "uint", cbIV, "ptr", pbOutput, "uint", cbOutput, pcbResultMarshal, pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Exports a key to a memory BLOB that can be persisted for later use.
     * @param {BCRYPT_KEY_HANDLE} hKey The handle of the key to export.
     * @param {BCRYPT_KEY_HANDLE} hExportKey The handle of the key with which to wrap the exported key. Use this parameter when exporting BLOBs of type <b>BCRYPT_AES_WRAP_KEY_BLOB</b>; otherwise, set it to <b>NULL</b>.<div class="alert"><b>Note</b>The <i>hExportKey</i> handle must be supplied by the same provider that supplied the <i>hKey</i> handle, and <i>hExportKey</i> must be a handle to a symmetric key that can be used in the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Advanced Encryption Standard</a> (AES) key wrap algorithm. When the <i>hKey</i> handle is from the Microsoft provider, <i>hExportKey</i> must be an AES key handle.</div>
     * <div></div>
     * 
     * 
     * <b>Windows Server2008 and WindowsVista:</b>This parameter is not used and should be set to <b>NULL</b>.
     * @param {PWSTR} pszBlobType 
     * @param {Pointer} pbOutput The address of a buffer that receives the key BLOB. The <i>cbOutput</i> parameter contains the size of this buffer. If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the <b>ULONG</b> pointed to by the <i>pcbResult</i> parameter.
     * @param {Integer} cbOutput Contains the size, in bytes, of the <i>pbOutput</i> buffer.
     * @param {Pointer<Integer>} pcbResult A pointer to a <b>ULONG</b> that receives the number of bytes that were copied to the <i>pbOutput</i> buffer. If the <i>pbOutput</i> parameter is <b>NULL</b>, this function will place the required size, in bytes, in the <b>ULONG</b> pointed to by this parameter.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are defined for this function.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size specified by the <i>cbOutput</i> parameter is not large enough to hold the ciphertext.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle in the <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified BLOB type is not supported by the provider.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptexportkey
     * @since windows6.0.6000
     */
    static BCryptExportKey(hKey, hExportKey, pszBlobType, pbOutput, cbOutput, pcbResult, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey
        hExportKey := hExportKey is Win32Handle ? NumGet(hExportKey, "ptr") : hExportKey
        pszBlobType := pszBlobType is String ? StrPtr(pszBlobType) : pszBlobType

        pcbResultMarshal := pcbResult is VarRef ? "uint*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptExportKey", "ptr", hKey, "ptr", hExportKey, "ptr", pszBlobType, "ptr", pbOutput, "uint", cbOutput, pcbResultMarshal, pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Imports a symmetric key from a key BLOB.
     * @param {BCRYPT_ALG_HANDLE} hAlgorithm The handle of the algorithm provider to import the key. This handle is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function.
     * @param {BCRYPT_KEY_HANDLE} hImportKey The handle of the key encryption key needed to unwrap the key BLOB in the <i>pbInput</i> parameter.<div class="alert"><b>Note</b>The handle must be supplied by the same provider that supplied the key that is being imported.</div>
     * <div></div>
     * 
     * 
     * <b>Windows Server2008 and WindowsVista:</b>This parameter is not used and should be set to <b>NULL</b>.
     * @param {PWSTR} pszBlobType 
     * @param {Pointer<BCRYPT_KEY_HANDLE>} phKey A pointer to a <b>BCRYPT_KEY_HANDLE</b> that receives the handle of the imported key. This handle is used in subsequent functions that require a key, such as <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptencrypt">BCryptEncrypt</a>. This handle must be released when it is no longer needed by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroykey">BCryptDestroyKey</a> function.
     * @param {Pointer} pbKeyObject A pointer to a buffer that receives the imported key object. The <i>cbKeyObject</i> parameter contains the size of this buffer. The required size of this buffer can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_OBJECT_LENGTH</b> property. This will provide the size of the key object for the specified algorithm.
     * 
     * This memory can only be freed after the <i>phKey</i> key handle is destroyed.
     * @param {Integer} cbKeyObject The size, in bytes, of the <i>pbKeyObject</i> buffer.
     * @param {Pointer} pbInput The address of a buffer that contains the key BLOB to import. The <i>cbInput</i> parameter contains the size of this buffer. The <i>pszBlobType</i> parameter specifies the type of key BLOB this buffer contains.
     * @param {Integer} cbInput The size, in bytes, of the <i>pbInput</i> buffer.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are currently defined, so this parameter should be zero.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of the key object specified by the <i>cbKeyObject</i> parameter is not large enough to hold the key object.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm handle in the <i>hAlgorithm</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm provider specified by the <i>hAlgorithm</i> parameter does not support the BLOB type specified by the <i>pszBlobType</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptimportkey
     * @since windows6.0.6000
     */
    static BCryptImportKey(hAlgorithm, hImportKey, pszBlobType, phKey, pbKeyObject, cbKeyObject, pbInput, cbInput, dwFlags) {
        hAlgorithm := hAlgorithm is Win32Handle ? NumGet(hAlgorithm, "ptr") : hAlgorithm
        hImportKey := hImportKey is Win32Handle ? NumGet(hImportKey, "ptr") : hImportKey
        pszBlobType := pszBlobType is String ? StrPtr(pszBlobType) : pszBlobType

        result := DllCall("bcrypt.dll\BCryptImportKey", "ptr", hAlgorithm, "ptr", hImportKey, "ptr", pszBlobType, "ptr", phKey, "ptr", pbKeyObject, "uint", cbKeyObject, "ptr", pbInput, "uint", cbInput, "uint", dwFlags, "int")
        return result
    }

    /**
     * Imports a public/private key pair from a key BLOB.
     * @param {BCRYPT_ALG_HANDLE} hAlgorithm The handle of the algorithm provider to import the key. This handle is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function.
     * @param {BCRYPT_KEY_HANDLE} hImportKey This parameter is not currently used and should be <b>NULL</b>.
     * @param {PWSTR} pszBlobType 
     * @param {Pointer<BCRYPT_KEY_HANDLE>} phKey A pointer to a <b>BCRYPT_KEY_HANDLE</b> that receives the handle of the imported key. This handle is used in subsequent functions that require a key, such as <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptsignhash">BCryptSignHash</a>. This handle must be released when it is no longer needed by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroykey">BCryptDestroyKey</a> function.
     * @param {Pointer} pbInput The address of a buffer that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key BLOB</a> to import. The <i>cbInput</i> parameter contains the size of this buffer. The <i>pszBlobType</i> parameter specifies the type of key BLOB this buffer contains.
     * @param {Integer} cbInput The size, in bytes, of the <i>pbInput</i> buffer.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. This can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_NO_KEY_VALIDATION"></a><a id="bcrypt_no_key_validation"></a><dl>
     * <dt><b>BCRYPT_NO_KEY_VALIDATION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not validate the public portion of the key pair.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm handle in the <i>hAlgorithm</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm provider specified by the <i>hAlgorithm</i> parameter does not support the BLOB type specified by the <i>pszBlobType</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptimportkeypair
     * @since windows6.0.6000
     */
    static BCryptImportKeyPair(hAlgorithm, hImportKey, pszBlobType, phKey, pbInput, cbInput, dwFlags) {
        hAlgorithm := hAlgorithm is Win32Handle ? NumGet(hAlgorithm, "ptr") : hAlgorithm
        hImportKey := hImportKey is Win32Handle ? NumGet(hImportKey, "ptr") : hImportKey
        pszBlobType := pszBlobType is String ? StrPtr(pszBlobType) : pszBlobType

        result := DllCall("bcrypt.dll\BCryptImportKeyPair", "ptr", hAlgorithm, "ptr", hImportKey, "ptr", pszBlobType, "ptr", phKey, "ptr", pbInput, "uint", cbInput, "uint", dwFlags, "int")
        return result
    }

    /**
     * Creates a duplicate of a symmetric key.
     * @param {BCRYPT_KEY_HANDLE} hKey The handle of the key to duplicate. This must be a handle to a symmetric key.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} phNewKey A pointer to a <b>BCRYPT_KEY_HANDLE</b> variable that receives the handle of the duplicate key. This handle is used in subsequent functions that require a key, such as <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptencrypt">BCryptEncrypt</a>. This handle must be released when it is no longer needed by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroykey">BCryptDestroyKey</a> function.
     * @param {Pointer} pbKeyObject A pointer to a buffer that receives the duplicate key object. The <i>cbKeyObject</i> parameter contains the size of this buffer. The required size of this buffer can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_OBJECT_LENGTH</b> property. This will provide the size of the key object for the specified algorithm.
     * 
     * This memory can only be freed after the <i>phNewKey</i> key handle is destroyed.
     * @param {Integer} cbKeyObject The size, in bytes, of the <i>pbKeyObject</i> buffer.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are currently defined, so this parameter should be zero.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of the key object specified by the <i>cbKeyObject</i> parameter is not large enough to hold the key object.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle in the <i>hKey</i> parameter is not valid. This value is also returned if the key to duplicate is not a symmetric key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptduplicatekey
     * @since windows6.0.6000
     */
    static BCryptDuplicateKey(hKey, phNewKey, pbKeyObject, cbKeyObject, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        result := DllCall("bcrypt.dll\BCryptDuplicateKey", "ptr", hKey, "ptr", phNewKey, "ptr", pbKeyObject, "uint", cbKeyObject, "uint", dwFlags, "int")
        return result
    }

    /**
     * Completes a public/private key pair.
     * @param {BCRYPT_KEY_HANDLE} hKey The handle of the key to complete. This handle is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgeneratekeypair">BCryptGenerateKeyPair</a> function.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are currently defined, so this parameter should be zero.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle in the <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified provider does not support asymmetric key encryption.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptfinalizekeypair
     * @since windows6.0.6000
     */
    static BCryptFinalizeKeyPair(hKey, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        result := DllCall("bcrypt.dll\BCryptFinalizeKeyPair", "ptr", hKey, "uint", dwFlags, "int")
        return result
    }

    /**
     * Destroys a key.
     * @param {BCRYPT_KEY_HANDLE} hKey The handle of the key to destroy.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle in the <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptdestroykey
     * @since windows6.0.6000
     */
    static BCryptDestroyKey(hKey) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        result := DllCall("bcrypt.dll\BCryptDestroyKey", "ptr", hKey, "int")
        return result
    }

    /**
     * Destroys a secret agreement handle that was created by using the BCryptSecretAgreement function.
     * @param {BCRYPT_SECRET_HANDLE} hSecret The <b>BCRYPT_SECRET_HANDLE</b> to be destroyed.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hSecret</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptdestroysecret
     * @since windows6.0.6000
     */
    static BCryptDestroySecret(hSecret) {
        hSecret := hSecret is Win32Handle ? NumGet(hSecret, "ptr") : hSecret

        result := DllCall("bcrypt.dll\BCryptDestroySecret", "ptr", hSecret, "int")
        return result
    }

    /**
     * Creates a signature of a hash value.
     * @param {BCRYPT_KEY_HANDLE} hKey The handle of the key to use to sign the hash.
     * @param {Pointer<Void>} pPaddingInfo A pointer to a structure that contains padding information. The actual type of structure this parameter points to depends on the value of the <i>dwFlags</i> parameter. This parameter is only used with asymmetric keys and must be <b>NULL</b> otherwise.
     * @param {Pointer} pbInput A pointer to a buffer that contains the hash value to sign. The <i>cbInput</i> parameter contains the size of this buffer.
     * @param {Integer} cbInput The number of bytes in the <i>pbInput</i> buffer to sign.
     * @param {Pointer} pbOutput The address of a buffer to receive the signature produced by this function. The <i>cbOutput</i> parameter contains the size of this buffer.
     * 
     * If this parameter is <b>NULL</b>, this function will calculate the size required for the signature and return the size in the location pointed to by the <i>pcbResult</i> parameter.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer. This parameter is ignored if the <i>pbOutput</i> parameter is <b>NULL</b>.
     * @param {Pointer<Integer>} pcbResult A pointer to a <b>ULONG</b> variable that receives the number of bytes copied to the <i>pbOutput</i> buffer. 
     * 
     * If <i>pbOutput</i> is <b>NULL</b>, this receives the size, in bytes, required for the signature.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. The allowed set of flags depends on the type of key specified by the <i>hKey</i> parameter.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle specified by the <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm provider used to create the key handle specified by the <i>hKey</i> parameter is not a signing algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The memory size specified by the <i>cbOutput</i> parameter is not large enough to hold the signature.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptsignhash
     * @since windows6.0.6000
     */
    static BCryptSignHash(hKey, pPaddingInfo, pbInput, cbInput, pbOutput, cbOutput, pcbResult, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        pPaddingInfoMarshal := pPaddingInfo is VarRef ? "ptr" : "ptr"
        pcbResultMarshal := pcbResult is VarRef ? "uint*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptSignHash", "ptr", hKey, pPaddingInfoMarshal, pPaddingInfo, "ptr", pbInput, "uint", cbInput, "ptr", pbOutput, "uint", cbOutput, pcbResultMarshal, pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Verifies that the specified signature matches the specified hash.
     * @param {BCRYPT_KEY_HANDLE} hKey The handle of the key to use to decrypt the signature. This must be an identical key or the public key portion of the key pair used to sign the data with the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptsignhash">BCryptSignHash</a> function.
     * @param {Pointer<Void>} pPaddingInfo A pointer to a structure that contains padding information. The actual type of structure this parameter points to depends on the value of the <i>dwFlags</i> parameter. This parameter is only used with asymmetric keys and must be <b>NULL</b> otherwise.
     * @param {Pointer} pbHash The address of a buffer that contains the hash of the data. The <i>cbHash</i> parameter contains the size of this buffer.
     * @param {Integer} cbHash The size, in bytes, of the <i>pbHash</i> buffer.
     * @param {Pointer} pbSignature The address of a buffer that contains the signed hash of the data. The <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptsignhash">BCryptSignHash</a> function is used to create the signature. The <i>cbSignature</i> parameter contains the size of this buffer.
     * @param {Integer} cbSignature The size, in bytes, of the <i>pbSignature</i> buffer. The <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptsignhash">BCryptSignHash</a> function is used to create the signature.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. The allowed set of flags depends on the type of key specified by the <i>hKey</i> parameter.
     * 
     * If the key is a symmetric key, this parameter is not used and should be zero.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature was not verified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle specified by the <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm provider used to create the key handle specified by the <i>hKey</i> parameter is not a signing algorithm.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptverifysignature
     * @since windows6.0.6000
     */
    static BCryptVerifySignature(hKey, pPaddingInfo, pbHash, cbHash, pbSignature, cbSignature, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        pPaddingInfoMarshal := pPaddingInfo is VarRef ? "ptr" : "ptr"

        result := DllCall("bcrypt.dll\BCryptVerifySignature", "ptr", hKey, pPaddingInfoMarshal, pPaddingInfo, "ptr", pbHash, "uint", cbHash, "ptr", pbSignature, "uint", cbSignature, "uint", dwFlags, "int")
        return result
    }

    /**
     * Creates a secret agreement value from a private and a public key.
     * @param {BCRYPT_KEY_HANDLE} hPrivKey The handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key</a> to use to create the secret agreement value. This key and the <i>hPubKey</i> key must come from the same CNG cryptographic algorithm provider.
     * @param {BCRYPT_KEY_HANDLE} hPubKey The handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key</a> to use to create the secret agreement value. This key and the <i>hPrivKey</i> key must come from the same CNG cryptographic algorithm provider.
     * @param {Pointer<BCRYPT_SECRET_HANDLE>} phAgreedSecret A pointer to a <b>BCRYPT_SECRET_HANDLE</b> that receives a handle that represents the secret agreement value. This handle must be released by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroysecret">BCryptDestroySecret</a> function when it is no longer needed.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are defined for this function.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle in the <i>hPrivKey</i> or <i>hPubKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle in the <i>hPrivKey</i> parameter is not a Diffie-Hellman key.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptsecretagreement
     * @since windows6.0.6000
     */
    static BCryptSecretAgreement(hPrivKey, hPubKey, phAgreedSecret, dwFlags) {
        hPrivKey := hPrivKey is Win32Handle ? NumGet(hPrivKey, "ptr") : hPrivKey
        hPubKey := hPubKey is Win32Handle ? NumGet(hPubKey, "ptr") : hPubKey

        result := DllCall("bcrypt.dll\BCryptSecretAgreement", "ptr", hPrivKey, "ptr", hPubKey, "ptr", phAgreedSecret, "uint", dwFlags, "int")
        return result
    }

    /**
     * Derives a key from a secret agreement value.
     * @param {BCRYPT_SECRET_HANDLE} hSharedSecret The secret agreement handle to create the key from. This handle is obtained from the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptsecretagreement">BCryptSecretAgreement</a> function.
     * @param {PWSTR} pwszKDF A pointer to a null-terminated Unicode string that identifies the <i>key derivation function</i> (KDF) to use to derive the key. This can be one of the following strings.
     * @param {Pointer<BCryptBufferDesc>} pParameterList The address of a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa375370(v=vs.85)">BCryptBufferDesc</a> structure that contains the KDF parameters. This parameter is optional and can be <b>NULL</b> if it is not needed.
     * @param {Pointer} pbDerivedKey The address of a buffer that receives the key. The <i>cbDerivedKey</i> parameter contains the size of this buffer. If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the <b>ULONG</b> pointed to by the <i>pcbResult</i> parameter.
     * @param {Integer} cbDerivedKey The size, in bytes, of the <i>pbDerivedKey</i> buffer.
     * @param {Pointer<Integer>} pcbResult A pointer to a <b>ULONG</b> that receives the number of bytes that were copied to the <i>pbDerivedKey</i> buffer. If the <i>pbDerivedKey</i> parameter is <b>NULL</b>, this function will place the required size, in bytes, in the <b>ULONG</b> pointed to by this parameter.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. This can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="KDF_USE_SECRET_AS_HMAC_KEY_FLAG"></a><a id="kdf_use_secret_as_hmac_key_flag"></a><dl>
     * <dt><b>KDF_USE_SECRET_AS_HMAC_KEY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The secret agreement value will also serve as the HMAC key. If this flag is specified, the <b>KDF_HMAC_KEY</b> parameter should not be included in the set of parameters in the <i>pParameterList</i> parameter. This flag is only used by the <b>BCRYPT_KDF_HMAC</b> key derivation function.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INTERNAL_ERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal error occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hSharedSecret</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptderivekey
     * @since windows6.0.6000
     */
    static BCryptDeriveKey(hSharedSecret, pwszKDF, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags) {
        hSharedSecret := hSharedSecret is Win32Handle ? NumGet(hSharedSecret, "ptr") : hSharedSecret
        pwszKDF := pwszKDF is String ? StrPtr(pwszKDF) : pwszKDF

        pcbResultMarshal := pcbResult is VarRef ? "uint*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptDeriveKey", "ptr", hSharedSecret, "ptr", pwszKDF, "ptr", pParameterList, "ptr", pbDerivedKey, "uint", cbDerivedKey, pcbResultMarshal, pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Derives a key without requiring a secret agreement.
     * @param {BCRYPT_KEY_HANDLE} hKey Handle of the input key.
     * @param {Pointer<BCryptBufferDesc>} pParameterList Pointer to a  <b>BCryptBufferDesc</b> structure that contains the KDF parameters. This parameter is optional and can be <b>NULL</b> if it is not needed. 
     * The parameters can be specific to a key derivation function (KDF) or generic. The following table shows the required and optional parameters for specific KDFs implemented by the Microsoft Primitive provider.
     * 
     * <table>
     * <tr>
     * <th>KDF</th>
     * <th>Parameter</th>
     * <th>Required</th>
     * </tr>
     * <tr>
     * <td>SP800-108 HMAC in counter mode</td>
     * <td>KDF_LABEL</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_CONTEXT</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_HASH_ALGORITHM</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td>SP800-56A</td>
     * <td>KDF_ALGORITHMID</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_PARTYUINFO</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_PARTYVINFO</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_HASH_ALGORITHM</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_SUPPPUBINFO</td>
     * <td>no</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_SUPPPRIVINFO</td>
     * <td>no</td>
     * </tr>
     * <tr>
     * <td>PBKDF2</td>
     * <td>KDF_HASH_ALGORITHM</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_SALT</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_ITERATION_COUNT</td>
     * <td>no</td>
     * </tr>
     * <tr>
     * <td>CAPI_KDF</td>
     * <td>KDF_HASH_ALGORITHM</td>
     * <td>yes</td>
     * </tr>
     * </table>
     * 
     * 
     * The following generic parameter can be used:<ul>
     * <li>KDF_GENERIC_PARAMETER</li>
     * </ul>Generic parameters map to KDF specific parameters in the following manner:
     * 
     * SP800-108 HMAC in counter mode:<ul>
     * <li>KDF_GENERIC_PARAMETER = KDF_LABEL||0x00||KDF_CONTEXT</li>
     * </ul>
     * 
     * 
     * SP800-56A<ul>
     * <li>KDF_GENERIC_PARAMETER = KDF_ALGORITHMID || KDF_PARTYUINFO || KDF_PARTYVINFO {|| KDF_SUPPPUBINFO } {|| KDF_SUPPPRIVINFO }</li>
     * </ul>
     * 
     * 
     * PBKDF2<ul>
     * <li>KDF_GENERIC_PARAMETER = KDF_SALT </li>
     * <li>KDF_ITERATION_COUNT  defaults to 10000</li>
     * </ul>
     * 
     * 
     * CAPI_KDF<ul>
     * <li>KDF_GENERIC_PARAMETER = Not Used </li>
     * </ul>
     * @param {Pointer} pbDerivedKey Address of a buffer that receives the key. The <i>cbDerivedKey</i> parameter contains the size of this buffer.
     * @param {Integer} cbDerivedKey Size, in bytes, of the buffer pointed to by the <i>pbDerivedKey</i> parameter.
     * @param {Pointer<Integer>} pcbResult Pointer to a variable that receives the number of bytes that were copied to the buffer pointed to by the <i>pbDerivedKey</i> parameter.
     * @param {Integer} dwFlags Flags that modify the behavior of this function. The following value can be used with the Microsoft Primitive provider.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>BCRYPT_CAPI_AES_FLAG</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies that the target algorithm is AES and that the key therefore must be double expanded.
     * This flag is only valid with the CAPI_KDF algorithm.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptkeyderivation
     * @since windows8.0
     */
    static BCryptKeyDerivation(hKey, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        pcbResultMarshal := pcbResult is VarRef ? "uint*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptKeyDerivation", "ptr", hKey, "ptr", pParameterList, "ptr", pbDerivedKey, "uint", cbDerivedKey, pcbResultMarshal, pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Called to create a hash or Message Authentication Code (MAC) object.
     * @param {BCRYPT_ALG_HANDLE} hAlgorithm The handle of an algorithm provider created by using the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function. The algorithm that was specified when the provider was created must support the hash interface.
     * @param {Pointer<BCRYPT_HASH_HANDLE>} phHash A pointer to a <b>BCRYPT_HASH_HANDLE</b> value that receives a handle that represents the hash or MAC object. This handle is used in subsequent hashing or MAC functions, such as the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcrypthashdata">BCryptHashData</a> function. When you have finished using this handle, release it by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroyhash">BCryptDestroyHash</a> function.
     * @param {Pointer} pbHashObject A pointer to a buffer that receives the hash or MAC object. The <i>cbHashObject</i> parameter contains the size of this buffer. The required size of this buffer can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_OBJECT_LENGTH</b> property. This will provide the size of the hash or MAC object for the specified algorithm.
     * 
     * This memory can only be freed after the handle pointed to by the <i>phHash</i> parameter is destroyed.
     * 
     * If the value of this parameter is <b>NULL</b> and the value of the <i>cbHashObject</i> parameter is zero, the memory for the hash object is allocated and freed by this function.<b>Windows7:</b>This memory management functionality is available beginning with Windows7.
     * @param {Integer} cbHashObject The size, in bytes, of the <i>pbHashObject</i> buffer.
     * 
     * If the value of this parameter is zero and the value of the <i>pbHashObject</i> parameter is <b>NULL</b>, the memory for the key object is allocated and freed by this function.<b>Windows7:</b>This memory management functionality is available beginning with Windows7.</p>c
     * @param {Pointer} pbSecret A pointer to a buffer that contains the key to use for the hash or MAC. The <i>cbSecret</i> parameter contains the size of this buffer. This key only applies to hash algorithms opened by the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function by using the <b>BCRYPT_ALG_HANDLE_HMAC</b> flag.  Otherwise, set this parameter to <b>NULL</b>.
     * @param {Integer} cbSecret The size, in bytes, of the <i>pbSecret</i> buffer. If no key is used, set this parameter to zero.
     * @param {Integer} dwFlags Flags that modify the behavior of the function. This can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_HASH_REUSABLE_FLAG"></a><a id="bcrypt_hash_reusable_flag"></a><dl>
     * <dt><b>BCRYPT_HASH_REUSABLE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Creates a reusable hashing object. The object can be used for a new hashing operation immediately after calling <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfinishhash">BCryptFinishHash</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecCNG/creating-a-hash-with-cng">Creating a Hash with CNG</a>.
     * 
     * <b>Windows Server2008R2, Windows7, Windows Server2008 and WindowsVista:</b>This flag is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of the hash object specified by the <i>cbHashObject</i> parameter is not large enough to hold the hash object.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm handle in the <i>hAlgorithm</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm provider specified by the <i>hAlgorithm</i> parameter does not support the hash interface.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptcreatehash
     * @since windows6.0.6000
     */
    static BCryptCreateHash(hAlgorithm, phHash, pbHashObject, cbHashObject, pbSecret, cbSecret, dwFlags) {
        hAlgorithm := hAlgorithm is Win32Handle ? NumGet(hAlgorithm, "ptr") : hAlgorithm

        result := DllCall("bcrypt.dll\BCryptCreateHash", "ptr", hAlgorithm, "ptr", phHash, "ptr", pbHashObject, "uint", cbHashObject, "ptr", pbSecret, "uint", cbSecret, "uint", dwFlags, "int")
        return result
    }

    /**
     * Performs a one way hash or Message Authentication Code (MAC) on a data buffer.
     * @param {BCRYPT_HASH_HANDLE} hHash The handle of the hash or MAC object to use to perform the operation. This handle is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptcreatehash">BCryptCreateHash</a> function.
     * @param {Pointer} pbInput A pointer to a buffer that contains the data to process. The <i>cbInput</i> parameter contains the number of bytes in this buffer. This function does not modify the contents of this buffer.
     * @param {Integer} cbInput The number of bytes in the <i>pbInput</i> buffer.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are currently defined, so this parameter should be zero.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash handle in the <i>hHash</i> parameter is not valid. After the <a href="/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfinishhash">BCryptFinishHash</a> function has been called for a hash  handle, that handle cannot be reused.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcrypthashdata
     * @since windows6.0.6000
     */
    static BCryptHashData(hHash, pbInput, cbInput, dwFlags) {
        hHash := hHash is Win32Handle ? NumGet(hHash, "ptr") : hHash

        result := DllCall("bcrypt.dll\BCryptHashData", "ptr", hHash, "ptr", pbInput, "uint", cbInput, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves the hash or Message Authentication Code (MAC) value for the data accumulated from prior calls to BCryptHashData.
     * @param {BCRYPT_HASH_HANDLE} hHash The handle of the hash or MAC object to use to compute the hash or MAC. This handle is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptcreatehash">BCryptCreateHash</a> function. After this function has been called, the hash handle passed to this function cannot be used again except in a call to <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroyhash">BCryptDestroyHash</a>.
     * @param {Pointer} pbOutput A pointer to a buffer that receives the hash or MAC value. The <i>cbOutput</i> parameter contains the size of this buffer.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer. This size must exactly match the size of the hash or MAC value.
     * 
     * The size can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_HASH_LENGTH</b> property. This will provide the size of the hash or MAC value for the specified algorithm.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are currently defined, so this parameter should be zero.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash handle in the <i>hHash</i> parameter is not valid. After the <a href="/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfinishhash">BCryptFinishHash</a> function has been called for a hash  handle, that handle cannot be reused.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid. This includes the case where <i>cbOutput</i> is not the same size as the hash.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptfinishhash
     * @since windows6.0.6000
     */
    static BCryptFinishHash(hHash, pbOutput, cbOutput, dwFlags) {
        hHash := hHash is Win32Handle ? NumGet(hHash, "ptr") : hHash

        result := DllCall("bcrypt.dll\BCryptFinishHash", "ptr", hHash, "ptr", pbOutput, "uint", cbOutput, "uint", dwFlags, "int")
        return result
    }

    /**
     * The BCryptCreateMultiHash function creates a multi-hash state that allows for the parallel computation of multiple hash operations.
     * @remarks
     * 
     *  Internally, parallel hash computations are done using single-instruction multiple-data (SIMD) instructions with up to 8 parallel computations at a time, depending on the hash algorithm and the CPU features available. To maximize performance, we recommend that the caller provide at least eight computations that can be processed in parallel. 
     * 
     * For computations of unequal length, providing more computations in parallel allows the implementation to schedule the computations better across the CPU registers. This can provide a throughput benefit. For optimal throughput, we recommend that the caller provide between eight and 100 computations. Select a lower value in that range only if all the hash computations are the same length.
     * 
     * Multi-hashing is not supported for HMAC-MD2, HMAC-MD4, and GMAC.
     * 
     * 
     * @param {BCRYPT_ALG_HANDLE} hAlgorithm The algorithm handle used for all of the hash states in the multi-hash array. The algorithm handle must have been opened with the <b>BCYRPT_MULTI_FLAG</b> passed to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function. Alternatively, the caller can use the pseudo-handles.
     * @param {Pointer<BCRYPT_HASH_HANDLE>} phHash A pointer to a <b>BCRYPT_HASH_HANDLE</b> value that receives a handle that represents the multi-hash state. This handle is used in subsequent operations such as <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptprocessmultioperations">BCryptProcessMultiOperations</a>. When you have finished using this handle, release it by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroyhash">BCryptDestroyHash</a> function.
     * @param {Integer} nHashes The number of elements in the array. The multi-hash state that this function creates is able to perform parallel computations on <i>nHashes</i> different hash states.
     * @param {Pointer} pbHashObject A pointer to a buffer that receives the multi-hash state. 
     * 
     * The size can be calculated from the <b>cbPerObject</b>  and <b>cbPerElement</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-bcrypt_multi_object_length_struct">BCRYPT_MULTI_OBJECT_LENGTH_STRUCT</a> structure. The value is the following: <c>cbPerObject + (number of hash states) * cbPerElement</c>.
     * 
     * If <i>pbHashObject</i> is <b>NULL</b> and <i>cbHashObject</i> has a value of zero (0), the object buffer is automatically allocated.
     * @param {Integer} cbHashObject The size of the <i>pbHashObject</i> buffer, or zero if <i>pbHashObject</i> is <b>NULL</b>.
     * @param {Pointer} pbSecret A pointer to a buffer that contains the key to use for the hash or MAC. The <i>cbSecret</i> parameter contains the size of this buffer. This key only applies to hash algorithms opened by the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function by using the <b>BCRYPT_ALG_HANDLE_HMAC</b> flag.  Otherwise, set this parameter to <b>NULL</b>. 
     * 
     * The same key is used for all elements of the array.
     * @param {Integer} cbSecret The size, in bytes, of the <i>pbSecret</i> buffer. If no key is used, set this parameter to zero.
     * @param {Integer} dwFlags Flags that modify the behavior of the function. This can be zero or the values below. Multi-hash objects are always reusable and always behave as if the <b>BCRYPT_HASH_REUSABLE_FLAG</b> was passed. This flag is supported here for consistency.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_HASH_REUSABLE_FLAG"></a><a id="bcrypt_hash_reusable_flag"></a><dl>
     * <dt><b>BCRYPT_HASH_REUSABLE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Creates a reusable hashing object. The object can be used for a new hashing operation immediately after calling <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfinishhash">BCryptFinishHash</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecCNG/creating-a-hash-with-cng">Creating a Hash with CNG</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {NTSTATUS} 
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptcreatemultihash
     * @since windows8.1
     */
    static BCryptCreateMultiHash(hAlgorithm, phHash, nHashes, pbHashObject, cbHashObject, pbSecret, cbSecret, dwFlags) {
        hAlgorithm := hAlgorithm is Win32Handle ? NumGet(hAlgorithm, "ptr") : hAlgorithm

        result := DllCall("bcrypt.dll\BCryptCreateMultiHash", "ptr", hAlgorithm, "ptr", phHash, "uint", nHashes, "ptr", pbHashObject, "uint", cbHashObject, "ptr", pbSecret, "uint", cbSecret, "uint", dwFlags, "int")
        return result
    }

    /**
     * The BCryptProcessMultiOperations function processes a sequence of operations on a multi-object state.
     * @remarks
     * 
     * Each element of the <i>pOperations</i> array contains instructions for a particular computation to be performed on a single element of the multi-object state. The functional behavior of <b>BCryptProcessMultiOperations</b> is equivalent to performing, for each element in the multi-object state, the computations specified in the operations array for that element, one at a time, in order. 
     * 
     * The relative order of two operations that operate on different elements of the array is not guaranteed. If an output buffer overlaps an input or output buffer the result is not deterministic.
     * 
     * 
     * @param {BCRYPT_HANDLE} hObject A handle to a multi-object state, such as one created by the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptcreatemultihash">BCryptCreateMultiHash</a> function.
     * @param {Integer} operationType A <b>BCRYPT_OPERATION_TYPE_*</b> value. Currently the only defined value is <b>BCRYPT_OPERATION_TYPE_HASH</b>. This value identifies the <i>hObject</i> parameter as a multi-hash object and the <i>pOperations</i> pointer as pointing to an array of <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-bcrypt_multi_hash_operation">BCRYPT_MULTI_HASH_OPERATION</a> elements.
     * @param {Pointer} pOperations A pointer to an array of operation command structures. For hashing, it is a pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-bcrypt_multi_hash_operation">BCRYPT_MULTI_HASH_OPERATION</a> structures.
     * @param {Integer} cbOperations The size, in bytes, of the <i>pOperations</i> array.
     * @param {Integer} dwFlags Specify a value of zero (0).
     * @returns {NTSTATUS} 
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptprocessmultioperations
     * @since windows8.1
     */
    static BCryptProcessMultiOperations(hObject, operationType, pOperations, cbOperations, dwFlags) {
        hObject := hObject is Win32Handle ? NumGet(hObject, "ptr") : hObject

        result := DllCall("bcrypt.dll\BCryptProcessMultiOperations", "ptr", hObject, "int", operationType, "ptr", pOperations, "uint", cbOperations, "uint", dwFlags, "int")
        return result
    }

    /**
     * Duplicates an existing hash or Message Authentication Code (MAC) object.
     * @param {BCRYPT_HASH_HANDLE} hHash The handle of the hash or MAC object to duplicate.
     * @param {Pointer<BCRYPT_HASH_HANDLE>} phNewHash A pointer to a <b>BCRYPT_HASH_HANDLE</b> value that receives the handle that represents the duplicate hash or MAC object.
     * @param {Pointer} pbHashObject A pointer to a buffer that receives the duplicate hash or MAC object. The <i>cbHashObject</i> parameter contains the size of this buffer. The required size of this buffer can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_OBJECT_LENGTH</b> property. This will provide the size of the hash object for the specified algorithm.
     * 
     * When the duplicate hash handle is released, free this memory.
     * @param {Integer} cbHashObject The size, in bytes, of the <i>pbHashObject</i> buffer.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are currently defined, so this parameter should be zero.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of the hash object specified by the <i>cbHashObject</i> parameter is not large enough to hold the hash object.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash handle in the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptduplicatehash
     * @since windows6.0.6000
     */
    static BCryptDuplicateHash(hHash, phNewHash, pbHashObject, cbHashObject, dwFlags) {
        hHash := hHash is Win32Handle ? NumGet(hHash, "ptr") : hHash

        result := DllCall("bcrypt.dll\BCryptDuplicateHash", "ptr", hHash, "ptr", phNewHash, "ptr", pbHashObject, "uint", cbHashObject, "uint", dwFlags, "int")
        return result
    }

    /**
     * Destroys a hash or Message Authentication Code (MAC) object.
     * @param {BCRYPT_HASH_HANDLE} hHash The handle of the hash or MAC object to destroy. This handle is obtained by using the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptcreatehash">BCryptCreateHash</a> function.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm handle in the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptdestroyhash
     * @since windows6.0.6000
     */
    static BCryptDestroyHash(hHash) {
        hHash := hHash is Win32Handle ? NumGet(hHash, "ptr") : hHash

        result := DllCall("bcrypt.dll\BCryptDestroyHash", "ptr", hHash, "int")
        return result
    }

    /**
     * Performs a single hash computation. This is a convenience function that wraps calls to BCryptCreateHash, BCryptHashData, BCryptFinishHash, and BCryptDestroyHash.
     * @param {BCRYPT_ALG_HANDLE} hAlgorithm The handle of an algorithm provider created by using the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function. The algorithm that was specified when the provider was created must support the hash interface.
     * @param {Pointer} pbSecret A pointer to a buffer that contains the key to use for the hash or MAC. The <i>cbSecret</i> parameter contains the size of this buffer. This key only applies to hash algorithms opened by the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function by using the <b>BCRYPT_ALG_HANDLE_HMAC</b> flag.  Otherwise, set this parameter to <b>NULL</b>
     * @param {Integer} cbSecret The size, in bytes, of the <i>pbSecret</i> buffer. If no key is used, set this parameter to zero.
     * @param {Pointer} pbInput A pointer to a buffer that contains the data to process. The <i>cbInput</i> parameter contains the number of bytes in this buffer. This function does not modify the contents of this buffer.
     * @param {Integer} cbInput The number of bytes in the <i>pbInput</i> buffer.
     * @param {Pointer} pbOutput A pointer to a buffer that receives the hash or MAC value. The <i>cbOutput</i> parameter contains the size of this buffer.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer. This size must exactly match the size of the hash or MAC value.
     * 
     * The size can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_HASH_LENGTH</b> property. This will provide the size of the hash or MAC value for the specified algorithm.
     * @returns {NTSTATUS} A status code indicating success or failure.
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcrypthash
     * @since windows10.0.10240
     */
    static BCryptHash(hAlgorithm, pbSecret, cbSecret, pbInput, cbInput, pbOutput, cbOutput) {
        hAlgorithm := hAlgorithm is Win32Handle ? NumGet(hAlgorithm, "ptr") : hAlgorithm

        result := DllCall("bcrypt.dll\BCryptHash", "ptr", hAlgorithm, "ptr", pbSecret, "uint", cbSecret, "ptr", pbInput, "uint", cbInput, "ptr", pbOutput, "uint", cbOutput, "int")
        return result
    }

    /**
     * Generates a random number.
     * @param {BCRYPT_ALG_HANDLE} hAlgorithm The handle of an algorithm provider created by using the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function. The algorithm that was specified when the provider was created must support the random number generator interface.
     * @param {Pointer} pbBuffer The address of a buffer that receives the random number. The size of this buffer is specified by the <i>cbBuffer</i> parameter.
     * @param {Integer} cbBuffer The size, in bytes, of the <i>pbBuffer</i> buffer.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. This parameter can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_RNG_USE_ENTROPY_IN_BUFFER"></a><a id="bcrypt_rng_use_entropy_in_buffer"></a><dl>
     * <dt><b>BCRYPT_RNG_USE_ENTROPY_IN_BUFFER</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This function will use the number in the <i>pbBuffer</i> buffer as additional entropy for the random number. If this flag is not specified, this function will use a random number for the entropy.
     * 
     * <b>Windows8 and later:</b>This flag is ignored in  Windows8 and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_USE_SYSTEM_PREFERRED_RNG"></a><a id="bcrypt_use_system_preferred_rng"></a><dl>
     * <dt><b>BCRYPT_USE_SYSTEM_PREFERRED_RNG</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system-preferred random number generator algorithm. The <i>hAlgorithm</i> parameter must be <b>NULL</b>.
     * 
     * BCRYPT_USE_SYSTEM_PREFERRED_RNG is only supported at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a>. For more information, see Remarks.
     * 
     * <b>WindowsVista:</b>This flag is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hAlgorithm</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptgenrandom
     * @since windows6.0.6000
     */
    static BCryptGenRandom(hAlgorithm, pbBuffer, cbBuffer, dwFlags) {
        hAlgorithm := hAlgorithm is Win32Handle ? NumGet(hAlgorithm, "ptr") : hAlgorithm

        result := DllCall("bcrypt.dll\BCryptGenRandom", "ptr", hAlgorithm, "ptr", pbBuffer, "uint", cbBuffer, "uint", dwFlags, "int")
        return result
    }

    /**
     * Derives a key from a hash value.
     * @param {BCRYPT_HASH_HANDLE} hHash The handle of the hash object. The handle is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptcreatehash">BCryptCreateHash</a> function. When you have finished using the handle, you must free it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroyhash">BCryptDestroyHash</a> function.
     * @param {BCRYPT_ALG_HANDLE} hTargetAlg The handle of the algorithm object.  This can be an <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> value that is compatible with the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptderivekey">CryptDeriveKey</a> function.
     * 
     * <div class="alert"><b>Note</b>Limitations in CAPI and key expansion prevent the use of any hash algorithm that generates an output that is larger than 512 bits.</div>
     * <div></div>
     * @param {Pointer} pbDerivedKey A pointer to the buffer that receives the derived key.
     * @param {Integer} cbDerivedKey The size, in characters, of the derived key pointed to by the <i>pbDerivedKey</i> parameter.
     * @param {Integer} dwFlags This parameter is reserved and must be set to zero.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hHash</i> or  <i>hTargetAlg</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value in  the <i>cbDerivedKey</i> parameter is larger than twice the output size of the hash function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     *  
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptderivekeycapi
     * @since windows6.1
     */
    static BCryptDeriveKeyCapi(hHash, hTargetAlg, pbDerivedKey, cbDerivedKey, dwFlags) {
        hHash := hHash is Win32Handle ? NumGet(hHash, "ptr") : hHash
        hTargetAlg := hTargetAlg is Win32Handle ? NumGet(hTargetAlg, "ptr") : hTargetAlg

        result := DllCall("bcrypt.dll\BCryptDeriveKeyCapi", "ptr", hHash, "ptr", hTargetAlg, "ptr", pbDerivedKey, "uint", cbDerivedKey, "uint", dwFlags, "int")
        return result
    }

    /**
     * Derives a key from a hash value by using the PBKDF2 key derivation algorithm as defined by RFC 2898.
     * @param {BCRYPT_ALG_HANDLE} hPrf The handle of an algorithm provider that provides the pseudo-random function. This should be an algorithm provider that performs a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">Message Authentication Code</a> computation. When you use the default Microsoft algorithm provider, any <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hashing algorithm</a> opened by using the  <b>BCRYPT_ALG_HANDLE_HMAC_FLAG</b> flag can be used.
     * 
     * <div class="alert"><b>Note</b>Only algorithms that implement the BCRYPT_IS_KEYED_HASH  property can be used to populate this parameter.</div>
     * <div></div>
     * @param {Pointer} pbPassword A pointer to a buffer that contains the password parameter for the PBKDF2 key derivation algorithm. <div class="alert"><b>Note</b>Any secret information used in the key derivation should be passed in this buffer.</div>
     * <div></div>
     * @param {Integer} cbPassword The length, in bytes, of the data in the buffer pointed to by the <i>pbPassword</i> parameter.
     * @param {Pointer} pbSalt A pointer to a buffer that contains the salt argument  for the PBKDF2 key derivation algorithm.
     * 
     * <div class="alert"><b>Note</b>Any information that is not secret and that is used in the key derivation should be passed in this buffer.</div>
     * <div></div>
     * @param {Integer} cbSalt The length, in bytes, of the salt argument pointed to by the <i>pbSalt</i> parameter.
     * @param {Integer} cIterations The iteration count for the PBKDF2 key derivation algorithm.
     * @param {Pointer} pbDerivedKey A pointer to a buffer that receives the derived key.
     * @param {Integer} cbDerivedKey The length, in bytes, of the derived key returned in the buffer pointed to by the <i>pbDerivedKey</i> parameter.
     * @param {Integer} dwFlags This parameter is reserved and must be set to zero.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hPrf</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     *  
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptderivekeypbkdf2
     * @since windows6.1
     */
    static BCryptDeriveKeyPBKDF2(hPrf, pbPassword, cbPassword, pbSalt, cbSalt, cIterations, pbDerivedKey, cbDerivedKey, dwFlags) {
        hPrf := hPrf is Win32Handle ? NumGet(hPrf, "ptr") : hPrf

        result := DllCall("bcrypt.dll\BCryptDeriveKeyPBKDF2", "ptr", hPrf, "ptr", pbPassword, "uint", cbPassword, "ptr", pbSalt, "uint", cbSalt, "uint", cIterations, "ptr", pbDerivedKey, "uint", cbDerivedKey, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves information about a CNG provider.
     * @param {PWSTR} pszProvider A pointer to a null-terminated Unicode string that contains the name of the provider to obtain information about.
     * @param {Integer} dwMode 
     * @param {Integer} dwInterface 
     * @param {Pointer<Integer>} pcbBuffer A pointer to a <b>ULONG</b> value that, on entry, contains the size, in bytes, of the buffer pointed to by the <i>ppBuffer</i> parameter. On exit, this value receives either the number of bytes copied to the buffer or the required size, in bytes, of the buffer.
     * 
     * 
     * <div class="alert"><b>Note</b>This is the total size, in bytes, of the entire buffer, not just the size of the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_provider_reg">CRYPT_PROVIDER_REG</a> structure. The buffer must be able to hold other data for the providers in addition to the <b>CRYPT_PROVIDER_REG</b> structure.</div>
     * <div></div>
     * @param {Pointer<Pointer<CRYPT_PROVIDER_REG>>} ppBuffer A pointer to a buffer pointer that receives a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_provider_reg">CRYPT_PROVIDER_REG</a> structure and other data that describes the provider.
     * 
     * If this parameter is <b>NULL</b>, this function will return <b>STATUS_BUFFER_TOO_SMALL</b> and place in the value pointed to by the <i>pcbBuffer</i> parameter, the required size, in bytes, of all data.
     * 
     * If this parameter is the address of a <b>NULL</b> pointer, this function will allocate the required memory, fill it in with the provider information, and place a pointer to this memory in this parameter. When you have finished using this memory, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is the address of a non-<b>NULL</b> pointer, this function will copy the provider information into this buffer. The <i>pcbBuffer</i> parameter must contain the size, in bytes, of the entire buffer. If the buffer is not large enough to hold all of the provider information, this function will return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size specified by the <i>pcbBuffer</i> parameter is not large enough to hold all of the data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No provider could be found that matches the specified criteria.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptqueryproviderregistration
     * @since windows6.0.6000
     */
    static BCryptQueryProviderRegistration(pszProvider, dwMode, dwInterface, pcbBuffer, ppBuffer) {
        pszProvider := pszProvider is String ? StrPtr(pszProvider) : pszProvider

        pcbBufferMarshal := pcbBuffer is VarRef ? "uint*" : "ptr"
        ppBufferMarshal := ppBuffer is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptQueryProviderRegistration", "ptr", pszProvider, "uint", dwMode, "uint", dwInterface, pcbBufferMarshal, pcbBuffer, ppBufferMarshal, ppBuffer, "int")
        return result
    }

    /**
     * Retrieves information about the registered providers.
     * @param {Pointer<Integer>} pcbBuffer A pointer to a <b>ULONG</b> value that, on entry, contains the size, in bytes, of the buffer pointed to by the <i>ppBuffer</i> parameter. On exit, this value receives either the number of bytes copied to the buffer or the required size, in bytes, of the buffer.
     * 
     * <div class="alert"><b>Note</b>This is the total size, in bytes, of the entire buffer, not just the size of the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_providers">CRYPT_PROVIDERS</a> structure. The buffer must be able to hold other data for the providers in addition to the <b>CRYPT_PROVIDERS</b> structure.</div>
     * <div></div>
     * @param {Pointer<Pointer<CRYPT_PROVIDERS>>} ppBuffer A pointer to a buffer pointer that receives a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_providers">CRYPT_PROVIDERS</a> structure and other data that describes the collection of registered providers.
     * 
     * If this parameter is <b>NULL</b>, this function will return <b>STATUS_BUFFER_TOO_SMALL</b> and place in the value pointed to by the <i>pcbBuffer</i> parameter, the required size, in bytes, of all the data.
     * 
     * If this parameter is the address of a <b>NULL</b> pointer, this function will allocate the required memory, fill the memory with the information about the providers, and place the pointer to this memory in this parameter. When you have finished using this memory,  free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is the address of a non-<b>NULL</b> pointer, this function will copy the provider information into this buffer. The <i>pcbBuffer</i> parameter must contain the size, in bytes, of the entire buffer. If the buffer is not large enough to hold all of the provider information, this function will return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size specified by the <i>pcbBuffer</i> parameter is not large enough to hold all of the data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptenumregisteredproviders
     * @since windows6.0.6000
     */
    static BCryptEnumRegisteredProviders(pcbBuffer, ppBuffer) {
        pcbBufferMarshal := pcbBuffer is VarRef ? "uint*" : "ptr"
        ppBufferMarshal := ppBuffer is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptEnumRegisteredProviders", pcbBufferMarshal, pcbBuffer, ppBufferMarshal, ppBuffer, "int")
        return result
    }

    /**
     * Creates a new CNG configuration context.
     * @param {Integer} dwTable 
     * @param {PWSTR} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to create.
     * @param {Pointer<CRYPT_CONTEXT_CONFIG>} pConfig A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_context_config">CRYPT_CONTEXT_CONFIG</a> structure that contains additional configuration data for the new context. This parameter can be <b>NULL</b> if it is not needed.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptcreatecontext
     * @since windows6.0.6000
     */
    static BCryptCreateContext(dwTable, pszContext, pConfig) {
        pszContext := pszContext is String ? StrPtr(pszContext) : pszContext

        result := DllCall("bcrypt.dll\BCryptCreateContext", "uint", dwTable, "ptr", pszContext, "ptr", pConfig, "int")
        return result
    }

    /**
     * Deletes an existing CNG configuration context.
     * @param {Integer} dwTable 
     * @param {PWSTR} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to delete.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptdeletecontext
     * @since windows6.0.6000
     */
    static BCryptDeleteContext(dwTable, pszContext) {
        pszContext := pszContext is String ? StrPtr(pszContext) : pszContext

        result := DllCall("bcrypt.dll\BCryptDeleteContext", "uint", dwTable, "ptr", pszContext, "int")
        return result
    }

    /**
     * Obtains the identifiers of the contexts in the specified configuration table.
     * @param {Integer} dwTable 
     * @param {Pointer<Integer>} pcbBuffer The address of a <b>ULONG</b> variable that, on entry, contains the size, in bytes, of the buffer pointed to by <i>ppBuffer</i>. If this size is not large enough to hold the set of context identifiers, this function will fail with <b>STATUS_BUFFER_TOO_SMALL</b>.
     * 
     * After this function returns, this value contains the number of bytes that were copied to the <i>ppBuffer</i> buffer.
     * @param {Pointer<Pointer<CRYPT_CONTEXTS>>} ppBuffer The address of a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_contexts">CRYPT_CONTEXTS</a> structure that receives the set of contexts retrieved by this function. The value pointed to by the <i>pcbBuffer</i> parameter contains the size of this buffer.
     * 
     * If the value pointed to by this parameter is <b>NULL</b>, this function will allocate the required memory. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the variable pointed to by the <i>pcbBuffer</i> parameter and return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>ppBuffer</i> parameter is not <b>NULL</b>, and the value pointed to by the <i>pcbBuffer</i> parameter is not large enough to hold the set of contexts.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptenumcontexts
     * @since windows6.0.6000
     */
    static BCryptEnumContexts(dwTable, pcbBuffer, ppBuffer) {
        pcbBufferMarshal := pcbBuffer is VarRef ? "uint*" : "ptr"
        ppBufferMarshal := ppBuffer is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptEnumContexts", "uint", dwTable, pcbBufferMarshal, pcbBuffer, ppBufferMarshal, ppBuffer, "int")
        return result
    }

    /**
     * Sets the configuration information for an existing CNG context.
     * @param {Integer} dwTable 
     * @param {PWSTR} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to set the configuration information for.
     * @param {Pointer<CRYPT_CONTEXT_CONFIG>} pConfig The address of a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_context_config">CRYPT_CONTEXT_CONFIG</a> structure that contains the new context configuration information.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptconfigurecontext
     * @since windows6.0.6000
     */
    static BCryptConfigureContext(dwTable, pszContext, pConfig) {
        pszContext := pszContext is String ? StrPtr(pszContext) : pszContext

        result := DllCall("bcrypt.dll\BCryptConfigureContext", "uint", dwTable, "ptr", pszContext, "ptr", pConfig, "int")
        return result
    }

    /**
     * Retrieves the current configuration for the specified CNG context.
     * @param {Integer} dwTable 
     * @param {PWSTR} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to obtain the configuration information for.
     * @param {Pointer<Integer>} pcbBuffer The address of a <b>ULONG</b> variable that, on entry, contains the size, in bytes, of the buffer pointed to by <i>ppBuffer</i>. If this size is not large enough to hold the context information, this function will fail with <b>STATUS_BUFFER_TOO_SMALL</b>.
     * 
     * After this function returns, this variable contains the number of bytes that were copied to the <i>ppBuffer</i> buffer.
     * @param {Pointer<Pointer<CRYPT_CONTEXT_CONFIG>>} ppBuffer The address of a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_context_config">CRYPT_CONTEXT_CONFIG</a> structure that receives the context configuration information retrieved by this function. The value pointed to by the <i>pcbBuffer</i> parameter contains the size of this buffer.
     * 
     * If the value pointed to by this parameter is <b>NULL</b>, this function will allocate the required memory. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the variable pointed to by the <i>pcbBuffer</i> parameter and return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * 
     * For more information on the usage of this parameter, see Remarks.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>ppBuffer</i> parameter is not <b>NULL</b>, and the value pointed to by the <i>pcbBuffer</i> parameter is not large enough to hold the set of contexts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified context could not be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptquerycontextconfiguration
     * @since windows6.0.6000
     */
    static BCryptQueryContextConfiguration(dwTable, pszContext, pcbBuffer, ppBuffer) {
        pszContext := pszContext is String ? StrPtr(pszContext) : pszContext

        pcbBufferMarshal := pcbBuffer is VarRef ? "uint*" : "ptr"
        ppBufferMarshal := ppBuffer is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptQueryContextConfiguration", "uint", dwTable, "ptr", pszContext, pcbBufferMarshal, pcbBuffer, ppBufferMarshal, ppBuffer, "int")
        return result
    }

    /**
     * Adds a cryptographic function to the list of functions that are supported by an existing CNG context.
     * @param {Integer} dwTable 
     * @param {PWSTR} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to add the function to.
     * @param {Integer} dwInterface 
     * @param {PWSTR} pszFunction A pointer to a null-terminated Unicode string that contains the identifier of the cryptographic function to add.
     * @param {Integer} dwPosition Specifies the position in the list at which to insert this function. The function is inserted at this position ahead of any existing functions. The <b>CRYPT_PRIORITY_TOP</b> value is used to insert the function at the top of the list. The <b>CRYPT_PRIORITY_BOTTOM</b> value is used to insert the function at the end of the list.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The context could not be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptaddcontextfunction
     * @since windows6.0.6000
     */
    static BCryptAddContextFunction(dwTable, pszContext, dwInterface, pszFunction, dwPosition) {
        pszContext := pszContext is String ? StrPtr(pszContext) : pszContext
        pszFunction := pszFunction is String ? StrPtr(pszFunction) : pszFunction

        result := DllCall("bcrypt.dll\BCryptAddContextFunction", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "uint", dwPosition, "int")
        return result
    }

    /**
     * Removes a cryptographic function from the list of functions that are supported by an existing CNG context.
     * @param {Integer} dwTable 
     * @param {PWSTR} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to remove the function from.
     * @param {Integer} dwInterface 
     * @param {PWSTR} pszFunction A pointer to a null-terminated Unicode string that contains the identifier of the cryptographic function to remove.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified context or function could not be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptremovecontextfunction
     * @since windows6.0.6000
     */
    static BCryptRemoveContextFunction(dwTable, pszContext, dwInterface, pszFunction) {
        pszContext := pszContext is String ? StrPtr(pszContext) : pszContext
        pszFunction := pszFunction is String ? StrPtr(pszFunction) : pszFunction

        result := DllCall("bcrypt.dll\BCryptRemoveContextFunction", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "int")
        return result
    }

    /**
     * Obtains the cryptographic functions for a context in the specified configuration table.
     * @param {Integer} dwTable 
     * @param {PWSTR} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to enumerate the functions for.
     * @param {Integer} dwInterface 
     * @param {Pointer<Integer>} pcbBuffer The address of a <b>ULONG</b> variable that, on entry, contains the size, in bytes, of the buffer pointed to by <i>ppBuffer</i>. If this size is not large enough to hold the set of context identifiers, this function will fail with <b>STATUS_BUFFER_TOO_SMALL</b>.
     * 
     * After this function returns, this value contains the number of bytes that were copied to the <i>ppBuffer</i> buffer.
     * @param {Pointer<Pointer<CRYPT_CONTEXT_FUNCTIONS>>} ppBuffer The address of a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_context_functions">CRYPT_CONTEXT_FUNCTIONS</a> structure that receives the set of context functions retrieved by this function. The value pointed to by the <i>pcbBuffer</i> parameter contains the size of this buffer.
     * 
     * If the value pointed to by this parameter is <b>NULL</b>, this function will allocate the required memory. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the variable pointed to by the <i>pcbBuffer</i> parameter and return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>ppBuffer</i> parameter is not <b>NULL</b>, and the value pointed to by the <i>pcbBuffer</i> parameter is not large enough to hold the set of contexts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No context functions that match the specified criteria were found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptenumcontextfunctions
     * @since windows6.0.6000
     */
    static BCryptEnumContextFunctions(dwTable, pszContext, dwInterface, pcbBuffer, ppBuffer) {
        pszContext := pszContext is String ? StrPtr(pszContext) : pszContext

        pcbBufferMarshal := pcbBuffer is VarRef ? "uint*" : "ptr"
        ppBufferMarshal := ppBuffer is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptEnumContextFunctions", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, pcbBufferMarshal, pcbBuffer, ppBufferMarshal, ppBuffer, "int")
        return result
    }

    /**
     * Sets the configuration information for the cryptographic function of an existing CNG context.
     * @param {Integer} dwTable 
     * @param {PWSTR} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to set the cryptographic function configuration information for.
     * @param {Integer} dwInterface 
     * @param {PWSTR} pszFunction A pointer to a null-terminated Unicode string that contains the identifier of the cryptographic function to set the configuration information for.
     * @param {Pointer<CRYPT_CONTEXT_FUNCTION_CONFIG>} pConfig The address of a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_context_function_config">CRYPT_CONTEXT_FUNCTION_CONFIG</a> structure that contains the new function configuration information.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptconfigurecontextfunction
     * @since windows6.0.6000
     */
    static BCryptConfigureContextFunction(dwTable, pszContext, dwInterface, pszFunction, pConfig) {
        pszContext := pszContext is String ? StrPtr(pszContext) : pszContext
        pszFunction := pszFunction is String ? StrPtr(pszFunction) : pszFunction

        result := DllCall("bcrypt.dll\BCryptConfigureContextFunction", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "ptr", pConfig, "int")
        return result
    }

    /**
     * Obtains the cryptographic function configuration information for an existing CNG context.
     * @param {Integer} dwTable 
     * @param {PWSTR} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to obtain the function configuration information for.
     * @param {Integer} dwInterface 
     * @param {PWSTR} pszFunction A pointer to a null-terminated Unicode string that contains the identifier of the cryptographic function to obtain the configuration information for.
     * @param {Pointer<Integer>} pcbBuffer The address of a <b>ULONG</b> variable that, on entry, contains the size, in bytes, of the buffer pointed to by <i>ppBuffer</i>. If this size is not large enough to hold the context information, this function will fail with <b>STATUS_BUFFER_TOO_SMALL</b>.
     * 
     * After this function returns, this variable contains the number of bytes that were copied to the <i>ppBuffer</i> buffer.
     * @param {Pointer<Pointer<CRYPT_CONTEXT_FUNCTION_CONFIG>>} ppBuffer The address of a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_context_function_config">CRYPT_CONTEXT_FUNCTION_CONFIG</a> structure that receives the function configuration information retrieved by this function. The value pointed to by the <i>pcbBuffer</i> parameter contains the size of this buffer.
     * 
     * If the value pointed to by this parameter is <b>NULL</b>, this function will allocate the required memory. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the variable pointed to by the <i>pcbBuffer</i> parameter and return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * 
     * For more information about the usage of this parameter, see Remarks.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>ppBuffer</i> parameter is not <b>NULL</b>, and the value pointed to by the <i>pcbBuffer</i> parameter is not large enough to hold the set of contexts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified context or function could not be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptquerycontextfunctionconfiguration
     * @since windows6.0.6000
     */
    static BCryptQueryContextFunctionConfiguration(dwTable, pszContext, dwInterface, pszFunction, pcbBuffer, ppBuffer) {
        pszContext := pszContext is String ? StrPtr(pszContext) : pszContext
        pszFunction := pszFunction is String ? StrPtr(pszFunction) : pszFunction

        pcbBufferMarshal := pcbBuffer is VarRef ? "uint*" : "ptr"
        ppBufferMarshal := ppBuffer is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptQueryContextFunctionConfiguration", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, pcbBufferMarshal, pcbBuffer, ppBufferMarshal, ppBuffer, "int")
        return result
    }

    /**
     * Obtains the providers for the cryptographic functions for a context in the specified configuration table.
     * @param {Integer} dwTable 
     * @param {PWSTR} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to enumerate the function providers for.
     * @param {Integer} dwInterface 
     * @param {PWSTR} pszFunction A pointer to a null-terminated Unicode string that contains the identifier of the function to enumerate the providers for.
     * @param {Pointer<Integer>} pcbBuffer The address of a <b>ULONG</b> variable that, on entry, contains the size, in bytes, of the buffer pointed to by <i>ppBuffer</i>. If this size is not large enough to hold the set of context identifiers, this function will fail with <b>STATUS_BUFFER_TOO_SMALL</b>.
     * 
     * After this function returns, this value contains the number of bytes that were copied to the <i>ppBuffer</i> buffer.
     * @param {Pointer<Pointer<CRYPT_CONTEXT_FUNCTION_PROVIDERS>>} ppBuffer The address of a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_context_function_providers">CRYPT_CONTEXT_FUNCTION_PROVIDERS</a> structure that receives the set of context function providers retrieved by this function. The value pointed to by the <i>pcbBuffer</i> parameter contains the size of this buffer.
     * 
     * If the value pointed to by this parameter is <b>NULL</b>, this function will allocate the required memory. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the variable pointed to by the <i>pcbBuffer</i> parameter and return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>ppBuffer</i> parameter is not <b>NULL</b>, and the value pointed to by the <i>pcbBuffer</i> parameter is not large enough to hold the set of contexts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No context function providers that match the specified criteria were found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptenumcontextfunctionproviders
     * @since windows6.0.6000
     */
    static BCryptEnumContextFunctionProviders(dwTable, pszContext, dwInterface, pszFunction, pcbBuffer, ppBuffer) {
        pszContext := pszContext is String ? StrPtr(pszContext) : pszContext
        pszFunction := pszFunction is String ? StrPtr(pszFunction) : pszFunction

        pcbBufferMarshal := pcbBuffer is VarRef ? "uint*" : "ptr"
        ppBufferMarshal := ppBuffer is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptEnumContextFunctionProviders", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, pcbBufferMarshal, pcbBuffer, ppBufferMarshal, ppBuffer, "int")
        return result
    }

    /**
     * Sets the value of a named property for a cryptographic function in an existing CNG context.
     * @param {Integer} dwTable 
     * @param {PWSTR} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to set the function property in.
     * @param {Integer} dwInterface 
     * @param {PWSTR} pszFunction A pointer to a null-terminated Unicode string that contains the identifier of the cryptographic function to set the property for.
     * @param {PWSTR} pszProperty A pointer to a null-terminated Unicode string that contains the identifier of the property to set.
     * @param {Integer} cbValue Contains the size, in bytes, of the <i>pbValue</i> buffer. This is the exact number of bytes that will be stored. If the property value is a string, you should add the size of one character to also store the terminating null character, if needed.
     * @param {Pointer} pbValue The address of a buffer that contains the new property value.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have write access to the properties for the function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified context or function could not be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptsetcontextfunctionproperty
     * @since windows6.0.6000
     */
    static BCryptSetContextFunctionProperty(dwTable, pszContext, dwInterface, pszFunction, pszProperty, cbValue, pbValue) {
        pszContext := pszContext is String ? StrPtr(pszContext) : pszContext
        pszFunction := pszFunction is String ? StrPtr(pszFunction) : pszFunction
        pszProperty := pszProperty is String ? StrPtr(pszProperty) : pszProperty

        result := DllCall("bcrypt.dll\BCryptSetContextFunctionProperty", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "ptr", pszProperty, "uint", cbValue, "ptr", pbValue, "int")
        return result
    }

    /**
     * Obtains the value of a named property for a cryptographic function in an existing CNG context.
     * @param {Integer} dwTable 
     * @param {PWSTR} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to obtain the function property from.
     * @param {Integer} dwInterface 
     * @param {PWSTR} pszFunction A pointer to a null-terminated Unicode string that contains the identifier of the cryptographic function to obtain the property for.
     * @param {PWSTR} pszProperty A pointer to a null-terminated Unicode string that contains the identifier of the property to obtain.
     * @param {Pointer<Integer>} pcbValue The address of a <b>ULONG</b> variable that, on entry, contains the size, in bytes, of the buffer pointed to by <i>ppbValue</i>. If this size is not large enough to hold the property value, this function will fail with <b>STATUS_BUFFER_TOO_SMALL</b>.
     * 
     * After this function returns, this variable contains the number of bytes that were copied to the <i>ppbValue</i> buffer.
     * @param {Pointer<Pointer<Integer>>} ppbValue The address of a pointer to a buffer that receives the property data. The size and format of this buffer depends on the format of the property being retrieved. The value pointed to by the <i>pcbValue</i> parameter contains the size of this buffer.
     * 
     * If the value pointed to by this parameter is <b>NULL</b>, this function will allocate the required memory. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the variable pointed to by the <i>pcbValue</i> parameter and return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>ppbValue</i> parameter is not <b>NULL</b>, and the value pointed to by the <i>pcbValue</i> parameter is not large enough to hold the set of contexts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified context, function, or property could not be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptquerycontextfunctionproperty
     * @since windows6.0.6000
     */
    static BCryptQueryContextFunctionProperty(dwTable, pszContext, dwInterface, pszFunction, pszProperty, pcbValue, ppbValue) {
        pszContext := pszContext is String ? StrPtr(pszContext) : pszContext
        pszFunction := pszFunction is String ? StrPtr(pszFunction) : pszFunction
        pszProperty := pszProperty is String ? StrPtr(pszProperty) : pszProperty

        pcbValueMarshal := pcbValue is VarRef ? "uint*" : "ptr"
        ppbValueMarshal := ppbValue is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptQueryContextFunctionProperty", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "ptr", pszProperty, pcbValueMarshal, pcbValue, ppbValueMarshal, ppbValue, "int")
        return result
    }

    /**
     * Creates a user mode CNG configuration change event handler.
     * @param {Pointer<HANDLE>} phEvent 
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>phEvent</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptregisterconfigchangenotify
     * @since windows6.0.6000
     */
    static BCryptRegisterConfigChangeNotify(phEvent) {
        result := DllCall("bcrypt.dll\BCryptRegisterConfigChangeNotify", "ptr", phEvent, "int")
        return result
    }

    /**
     * Removes a user mode CNG configuration change event handler that was created by using the BCryptRegisterConfigChangeNotify(HANDLE*) function.
     * @param {HANDLE} hEvent 
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hEvent</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptunregisterconfigchangenotify
     * @since windows6.0.6000
     */
    static BCryptUnregisterConfigChangeNotify(hEvent) {
        hEvent := hEvent is Win32Handle ? NumGet(hEvent, "ptr") : hEvent

        result := DllCall("bcrypt.dll\BCryptUnregisterConfigChangeNotify", "ptr", hEvent, "int")
        return result
    }

    /**
     * Obtains a collection of all of the providers that meet the specified criteria.
     * @param {PWSTR} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context for which to obtain the providers.  If this is set to <b>NULL</b> or to an empty string, the default context is assumed.
     * @param {Integer} dwInterface The identifier of an interface that the provider must support. This must be one of the <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-interface-identifiers">CNG Interface Identifiers</a>. If the <i>pszFunction</i> parameter is not <b>NULL</b> or an empty string, you can set <i>dwInterface</i> to zero to force the function to infer the interface.
     * @param {PWSTR} pszFunction A pointer to a null-terminated Unicode string that contains the algorithm or function identifier that the provider must support. This can be one of the standard <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-algorithm-identifiers">CNG Algorithm Identifiers</a> or the identifier for another registered algorithm.  If <i>dwInterface</i> is set to a nonzero value, then <i>pszFunction</i> can be <b>NULL</b> to include all algorithms and functions.
     * @param {PWSTR} pszProvider A pointer to a null-terminated Unicode string that contains the name of the provider to retrieve. If this parameter is <b>NULL</b>, then all providers will be included.
     * 
     * This parameter allows you to specify a specific provider to retrieve in the event that more than one provider meets the other criteria.
     * @param {Integer} dwMode 
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function.
     * @param {Pointer<Integer>} pcbBuffer A pointer to a <b>DWORD</b> value that, on entry, contains the size, in bytes, of the buffer pointed to by the <i>ppBuffer</i> parameter. On exit, this value receives either the number of bytes copied to the buffer or the required size, in bytes, of the buffer.
     * @param {Pointer<Pointer<CRYPT_PROVIDER_REFS>>} ppBuffer The address of a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_provider_refs">CRYPT_PROVIDER_REFS</a> pointer that receives the collection of providers that meet the specified criteria.
     * 
     * If this parameter is <b>NULL</b>, this function will return <b>STATUS_SUCCESS</b> and place in the value pointed to by the <i>pcbBuffer</i> parameter, the required size, in bytes, of all the data.
     * 
     * If this parameter is the address of a <b>NULL</b> pointer, this function will allocate the required memory, fill the memory with the information about the providers, and place the pointer to this memory in this parameter. When you have finished using this memory,  free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is the address of a non-<b>NULL</b> pointer, this function will copy the provider information into this buffer. The <i>pcbBuffer</i> parameter must contain the size, in bytes, of the entire buffer. If the buffer is not large enough to hold all of the provider information, this function will return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size specified by the <i>pcbBuffer</i> parameter is not large enough to hold all of the data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No provider could be found that meets all of the specified criteria.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptresolveproviders
     * @since windows6.0.6000
     */
    static BCryptResolveProviders(pszContext, dwInterface, pszFunction, pszProvider, dwMode, dwFlags, pcbBuffer, ppBuffer) {
        pszContext := pszContext is String ? StrPtr(pszContext) : pszContext
        pszFunction := pszFunction is String ? StrPtr(pszFunction) : pszFunction
        pszProvider := pszProvider is String ? StrPtr(pszProvider) : pszProvider

        pcbBufferMarshal := pcbBuffer is VarRef ? "uint*" : "ptr"
        ppBufferMarshal := ppBuffer is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptResolveProviders", "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "ptr", pszProvider, "uint", dwMode, "uint", dwFlags, pcbBufferMarshal, pcbBuffer, ppBufferMarshal, ppBuffer, "int")
        return result
    }

    /**
     * Determines whether Federal Information Processing Standard (FIPS) compliance is enabled.
     * @param {Pointer<Integer>} pfEnabled The address of a <b>BOOLEAN</b> variable that receives zero if FIPS compliance is not enabled, or a nonzero value if FIPS compliance is enabled.
     * @returns {NTSTATUS} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pfEnabled</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//bcrypt/nf-bcrypt-bcryptgetfipsalgorithmmode
     * @since windows6.0.6000
     */
    static BCryptGetFipsAlgorithmMode(pfEnabled) {
        pfEnabledMarshal := pfEnabled is VarRef ? "char*" : "ptr"

        result := DllCall("bcrypt.dll\BCryptGetFipsAlgorithmMode", pfEnabledMarshal, pfEnabled, "int")
        return result
    }

    /**
     * Loads and initializes a CNG key storage provider.
     * @param {PWSTR} pszProviderName A pointer to a null-terminated Unicode string that identifies the key storage provider to load. This is the registered alias of the key storage provider. This parameter is optional and can be <b>NULL</b>. If this parameter is <b>NULL</b>, the default key storage provider is loaded. The following values identify the built-in key storage providers.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MS_KEY_STORAGE_PROVIDER"></a><a id="ms_key_storage_provider"></a><dl>
     * <dt><b>MS_KEY_STORAGE_PROVIDER</b></dt>
     * <dt>L"Microsoft Software Key Storage Provider"</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Identifies the software key storage provider that is provided by Microsoft.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MS_SMART_CARD_KEY_STORAGE_PROVIDER"></a><a id="ms_smart_card_key_storage_provider"></a><dl>
     * <dt><b>MS_SMART_CARD_KEY_STORAGE_PROVIDER</b></dt>
     * <dt>L"Microsoft Smart Card Key Storage Provider"</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Identifies the smart card key storage provider that is provided by Microsoft.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MS_PLATFORM_CRYPTO_PROVIDER"></a><a id="ms_platform_crypto_provider"></a><dl>
     * <dt><b>MS_PLATFORM_CRYPTO_PROVIDER</b></dt>
     * <dt>L"Microsoft Platform Crypto Provider"</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Identifies the TPM key storage provider that is provided by Microsoft.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags Flags that modify the behavior of the function. No flags are defined for this function.
     * @returns {NCRYPT_PROV_HANDLE} A pointer to a <b>NCRYPT_PROV_HANDLE</b> variable that receives the provider handle. When you have finished using this handle, release it by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreeobject">NCryptFreeObject</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptopenstorageprovider
     * @since windows6.0.6000
     */
    static NCryptOpenStorageProvider(pszProviderName, dwFlags) {
        pszProviderName := pszProviderName is String ? StrPtr(pszProviderName) : pszProviderName

        phProvider := NCRYPT_PROV_HANDLE()
        result := DllCall("ncrypt.dll\NCryptOpenStorageProvider", "ptr", phProvider, "ptr", pszProviderName, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phProvider
    }

    /**
     * Obtains the names of the algorithms that are supported by the specified key storage provider.
     * @param {NCRYPT_PROV_HANDLE} hProvider The handle of the key storage provider to enumerate the algorithms for. This handle is obtained with the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenstorageprovider">NCryptOpenStorageProvider</a> function.
     * @param {Integer} dwAlgOperations 
     * @param {Pointer<Integer>} pdwAlgCount The address of a <b>DWORD</b> that receives the number of elements in the <i>ppAlgList</i> array.
     * @param {Pointer<Pointer<NCryptAlgorithmName>>} ppAlgList The address of an <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/ns-ncrypt-ncryptalgorithmname">NCryptAlgorithmName</a> structure pointer that receives an array of the registered algorithm names. The variable pointed to by the <i>pdwAlgCount</i> parameter receives the number of elements in this array.
     * 
     * When this memory is no longer needed, it must be freed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreebuffer">NCryptFreeBuffer</a> function.
     * @param {Integer} dwFlags Flags that modify function behavior. This can be zero (0) or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider (KSP) not display any user interface. If the provider must display the UI to operate, the call fails and the KSP should set the <b>NTE_SILENT_CONTEXT</b> error code as the last error.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProvider</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptenumalgorithms
     * @since windows6.0.6000
     */
    static NCryptEnumAlgorithms(hProvider, dwAlgOperations, pdwAlgCount, ppAlgList, dwFlags) {
        hProvider := hProvider is Win32Handle ? NumGet(hProvider, "ptr") : hProvider

        pdwAlgCountMarshal := pdwAlgCount is VarRef ? "uint*" : "ptr"
        ppAlgListMarshal := ppAlgList is VarRef ? "ptr*" : "ptr"

        result := DllCall("ncrypt.dll\NCryptEnumAlgorithms", "ptr", hProvider, "uint", dwAlgOperations, pdwAlgCountMarshal, pdwAlgCount, ppAlgListMarshal, ppAlgList, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines if a CNG key storage provider supports a specific cryptographic algorithm.
     * @param {NCRYPT_PROV_HANDLE} hProvider The handle of the key storage provider. This handle is obtained with the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenstorageprovider">NCryptOpenStorageProvider</a> function.
     * @param {PWSTR} pszAlgId A pointer to a null-terminated Unicode string that identifies the cryptographic algorithm in question. This can be one of the standard <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-algorithm-identifiers">CNG Algorithm Identifiers</a> or the identifier for another registered algorithm.
     * @param {Integer} dwFlags Flags that modify function behavior. This can be zero (0) or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider (KSP) not display any user interface. If the provider must display the UI to operate, the call fails and the KSP should set the <b>NTE_SILENT_CONTEXT</b> error code as the last error.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider supports the specified algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains one or more flags that are not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle specified by the <i>hProvider</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider does not support the specified algorithm.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptisalgsupported
     * @since windows6.0.6000
     */
    static NCryptIsAlgSupported(hProvider, pszAlgId, dwFlags) {
        hProvider := hProvider is Win32Handle ? NumGet(hProvider, "ptr") : hProvider
        pszAlgId := pszAlgId is String ? StrPtr(pszAlgId) : pszAlgId

        result := DllCall("ncrypt.dll\NCryptIsAlgSupported", "ptr", hProvider, "ptr", pszAlgId, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Obtains the names of the keys that are stored by the provider.
     * @param {NCRYPT_PROV_HANDLE} hProvider The handle of the key storage provider to enumerate the keys for. This handle is obtained with the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenstorageprovider">NCryptOpenStorageProvider</a> function.
     * @param {PWSTR} pszScope This parameter is not currently used and must be <b>NULL</b>.
     * @param {Pointer<Pointer<Void>>} ppEnumState The address of a <b>VOID</b> pointer that receives enumeration state information that is used in subsequent calls to this function. This information only has meaning to the key storage provider and is opaque to the caller. The key storage provider uses this information to determine which item is next in the enumeration. If the variable pointed to by this parameter contains <b>NULL</b>, the enumeration is started from the beginning.
     * 
     * When this memory is no longer needed, it must be freed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreebuffer">NCryptFreeBuffer</a> function.
     * @param {Integer} dwFlags 
     * @returns {Pointer<NCryptKeyName>} The address of a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/ns-ncrypt-ncryptkeyname">NCryptKeyName</a> structure that receives the name of the retrieved key. When the application has finished using this memory, free it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreebuffer">NCryptFreeBuffer</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptenumkeys
     * @since windows6.0.6000
     */
    static NCryptEnumKeys(hProvider, pszScope, ppEnumState, dwFlags) {
        hProvider := hProvider is Win32Handle ? NumGet(hProvider, "ptr") : hProvider
        pszScope := pszScope is String ? StrPtr(pszScope) : pszScope

        ppEnumStateMarshal := ppEnumState is VarRef ? "ptr*" : "ptr"

        result := DllCall("ncrypt.dll\NCryptEnumKeys", "ptr", hProvider, "ptr", pszScope, "ptr*", &ppKeyName := 0, ppEnumStateMarshal, ppEnumState, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppKeyName
    }

    /**
     * Obtains the names of the registered key storage providers.
     * @param {Pointer<Integer>} pdwProviderCount The address of a <b>DWORD</b> to receive the number of elements in the <i>ppProviderList</i> array.
     * @param {Pointer<Pointer<NCryptProviderName>>} ppProviderList The address of an <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/ns-ncrypt-ncryptprovidername">NCryptProviderName</a> structure pointer to receive an array of the registered key storage provider names. The variable pointed to by the <i>pdwProviderCount</i> parameter receives the number of elements in this array.
     * 
     * When this memory is no longer needed, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreebuffer">NCryptFreeBuffer</a> function.
     * @param {Integer} dwFlags Flags that modify function behavior. This can be zero (0) or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider (KSP) not display any user interface. If the provider must display the UI to operate, the call fails and the KSP should set the <b>NTE_SILENT_CONTEXT</b> error code as the last error.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptenumstorageproviders
     * @since windows6.0.6000
     */
    static NCryptEnumStorageProviders(pdwProviderCount, ppProviderList, dwFlags) {
        pdwProviderCountMarshal := pdwProviderCount is VarRef ? "uint*" : "ptr"
        ppProviderListMarshal := ppProviderList is VarRef ? "ptr*" : "ptr"

        result := DllCall("ncrypt.dll\NCryptEnumStorageProviders", pdwProviderCountMarshal, pdwProviderCount, ppProviderListMarshal, ppProviderList, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Releases a block of memory allocated by a CNG key storage provider.
     * @param {Pointer<Void>} pvInput The address of the memory to be released.
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pvInput</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptfreebuffer
     * @since windows6.0.6000
     */
    static NCryptFreeBuffer(pvInput) {
        pvInputMarshal := pvInput is VarRef ? "ptr" : "ptr"

        result := DllCall("ncrypt.dll\NCryptFreeBuffer", pvInputMarshal, pvInput, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Opens a key that exists in the specified CNG key storage provider.
     * @param {NCRYPT_PROV_HANDLE} hProvider The handle of the key storage provider to open the key from.
     * @param {PWSTR} pszKeyName A pointer to a null-terminated Unicode string that contains the name of the key to retrieve.
     * @param {Integer} dwLegacyKeySpec 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_KEY_HANDLE} A pointer to a <b>NCRYPT_KEY_HANDLE</b> variable that receives the key handle. When you have finished using this handle, release it by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreeobject">NCryptFreeObject</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptopenkey
     * @since windows6.0.6000
     */
    static NCryptOpenKey(hProvider, pszKeyName, dwLegacyKeySpec, dwFlags) {
        hProvider := hProvider is Win32Handle ? NumGet(hProvider, "ptr") : hProvider
        pszKeyName := pszKeyName is String ? StrPtr(pszKeyName) : pszKeyName

        phKey := NCRYPT_KEY_HANDLE()
        result := DllCall("ncrypt.dll\NCryptOpenKey", "ptr", hProvider, "ptr", phKey, "ptr", pszKeyName, "uint", dwLegacyKeySpec, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phKey
    }

    /**
     * Creates a new key and stores it in the specified key storage provider.
     * @param {NCRYPT_PROV_HANDLE} hProvider The handle of the key storage provider to create the key in. This handle is obtained by using the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenstorageprovider">NCryptOpenStorageProvider</a> function.
     * @param {PWSTR} pszAlgId A pointer to a null-terminated Unicode string that contains the identifier of the cryptographic algorithm to create the key. This can be one of the standard <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-algorithm-identifiers">CNG Algorithm Identifiers</a> or the identifier for another registered algorithm.
     * @param {PWSTR} pszKeyName A pointer to a null-terminated Unicode string that contains the name of the key. If this parameter is <b>NULL</b>, this function will create an ephemeral key that is not persisted.
     * @param {Integer} dwLegacyKeySpec 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_KEY_HANDLE} The address of an <b>NCRYPT_KEY_HANDLE</b> variable that receives the handle of the key. When you have finished using this handle, release it by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreeobject">NCryptFreeObject</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptcreatepersistedkey
     * @since windows6.0.6000
     */
    static NCryptCreatePersistedKey(hProvider, pszAlgId, pszKeyName, dwLegacyKeySpec, dwFlags) {
        hProvider := hProvider is Win32Handle ? NumGet(hProvider, "ptr") : hProvider
        pszAlgId := pszAlgId is String ? StrPtr(pszAlgId) : pszAlgId
        pszKeyName := pszKeyName is String ? StrPtr(pszKeyName) : pszKeyName

        phKey := NCRYPT_KEY_HANDLE()
        result := DllCall("ncrypt.dll\NCryptCreatePersistedKey", "ptr", hProvider, "ptr", phKey, "ptr", pszAlgId, "ptr", pszKeyName, "uint", dwLegacyKeySpec, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phKey
    }

    /**
     * Retrieves the value of a named property for a key storage object.
     * @param {NCRYPT_HANDLE} hObject The handle of the object to get the property for. This can be a provider handle (<b>NCRYPT_PROV_HANDLE</b>) or a key handle (<b>NCRYPT_KEY_HANDLE</b>).
     * @param {PWSTR} pszProperty A pointer to a null-terminated Unicode string that contains the name of the property to retrieve. This can be one of the predefined <a href="https://docs.microsoft.com/windows/desktop/SecCNG/key-storage-property-identifiers">Key Storage Property Identifiers</a> or a custom property identifier.
     * @param {Pointer} pbOutput The address of a buffer that receives the property value. The <i>cbOutput</i> parameter contains the size of this buffer.
     * 
     *  To calculate the size required for the buffer, set this parameter to <b>NULL</b>. The size, in bytes, required is returned in the location pointed to by the <i>pcbResult</i> parameter.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer.
     * @param {Integer} dwFlags Flags that modify function behavior. This can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_PERSIST_ONLY_FLAG"></a><a id="ncrypt_persist_only_flag"></a><dl>
     * <dt><b>NCRYPT_PERSIST_ONLY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore any built in values for this property and only retrieve the user-persisted properties of the key.  The maximum size of the data for any persisted property is <b>NCRYPT_MAX_PROPERTY_DATA</b> bytes.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider (KSP) not display any user interface. If the provider must display the UI to operate, the call fails and the KSP should set the <b>NTE_SILENT_CONTEXT</b> error code as the last error.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} A pointer to a <b>DWORD</b> variable that receives the number of bytes that were copied to the <i>pbOutput</i> buffer.
     * 
     * If the <i>pbOutput</i> parameter is <b>NULL</b>, the size, in bytes, required for the buffer is placed in the location pointed to by this parameter.
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptgetproperty
     * @since windows6.0.6000
     */
    static NCryptGetProperty(hObject, pszProperty, pbOutput, cbOutput, dwFlags) {
        hObject := hObject is Win32Handle ? NumGet(hObject, "ptr") : hObject
        pszProperty := pszProperty is String ? StrPtr(pszProperty) : pszProperty

        result := DllCall("ncrypt.dll\NCryptGetProperty", "ptr", hObject, "ptr", pszProperty, "ptr", pbOutput, "uint", cbOutput, "uint*", &pcbResult := 0, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbResult
    }

    /**
     * Sets the value for a named property for a CNG key storage object.
     * @param {NCRYPT_HANDLE} hObject The handle of the key storage object to set the property for.
     * @param {PWSTR} pszProperty A pointer to a null-terminated Unicode string that contains the name of the property to set. This can be one of the predefined <a href="https://docs.microsoft.com/windows/desktop/SecCNG/key-storage-property-identifiers">Key Storage Property Identifiers</a> or a custom property identifier.
     * @param {Pointer} pbInput The address of a buffer that contains the new property value. The <i>cbInput</i> parameter contains the size of this buffer.
     * @param {Integer} cbInput The size, in bytes, of the <i>pbInput</i> buffer.
     * @param {Integer} dwFlags 
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hObject</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified property is not supported for the object.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptsetproperty
     * @since windows6.0.6000
     */
    static NCryptSetProperty(hObject, pszProperty, pbInput, cbInput, dwFlags) {
        hObject := hObject is Win32Handle ? NumGet(hObject, "ptr") : hObject
        pszProperty := pszProperty is String ? StrPtr(pszProperty) : pszProperty

        result := DllCall("ncrypt.dll\NCryptSetProperty", "ptr", hObject, "ptr", pszProperty, "ptr", pbInput, "uint", cbInput, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Completes a CNG key storage key.
     * @param {NCRYPT_KEY_HANDLE} hKey The handle of the key to complete. This handle is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptcreatepersistedkey">NCryptCreatePersistedKey</a> function.
     * @param {Integer} dwFlags 
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptfinalizekey
     * @since windows6.0.6000
     */
    static NCryptFinalizeKey(hKey, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        result := DllCall("ncrypt.dll\NCryptFinalizeKey", "ptr", hKey, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Encrypts a block of data.
     * @param {NCRYPT_KEY_HANDLE} hKey The handle of the key to use to encrypt the data.
     * @param {Pointer} pbInput The address of a buffer that contains the data to be encrypted. The <i>cbInput</i> parameter contains the size of the data to encrypt. For more information, see Remarks.
     * @param {Integer} cbInput The number of bytes in the <i>pbInput</i> buffer to encrypt.
     * @param {Pointer<Void>} pPaddingInfo A pointer to a structure that contains padding information. The actual type of structure this parameter points to depends on the value of the <i>dwFlags</i> parameter. This parameter is only used with asymmetric keys and must be <b>NULL</b> otherwise.
     * @param {Pointer} pbOutput The address of a buffer that will receive the encrypted data produced by this function. The <i>cbOutput</i> parameter contains the size of this buffer. For more information, see Remarks.
     * 
     * If this parameter is <b>NULL</b>, this function will calculate the size needed for the encrypted data and return the size in the location pointed to by the <i>pcbResult</i> parameter.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer. This parameter is ignored if the <i>pbOutput</i> parameter is <b>NULL</b>.
     * @param {Integer} dwFlags Flags that modify function behavior. The allowed set of flags depends on the type of key specified by the <i>hKey</i> parameter.
     * @returns {Integer} A pointer to a <b>DWORD</b> variable that receives the number of bytes copied to the <i>pbOutput</i> buffer. If <i>pbOutput</i> is <b>NULL</b>, this receives the size, in bytes, required for the ciphertext.
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptencrypt
     * @since windows6.0.6000
     */
    static NCryptEncrypt(hKey, pbInput, cbInput, pPaddingInfo, pbOutput, cbOutput, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        pPaddingInfoMarshal := pPaddingInfo is VarRef ? "ptr" : "ptr"

        result := DllCall("ncrypt.dll\NCryptEncrypt", "ptr", hKey, "ptr", pbInput, "uint", cbInput, pPaddingInfoMarshal, pPaddingInfo, "ptr", pbOutput, "uint", cbOutput, "uint*", &pcbResult := 0, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbResult
    }

    /**
     * Decrypts a block of encrypted data.
     * @param {NCRYPT_KEY_HANDLE} hKey The handle of the key to use to decrypt the data.
     * @param {Pointer} pbInput The address of a buffer that contains the data to be decrypted. The <i>cbInput</i> parameter contains the size of the data to decrypt. For more information, see Remarks.
     * @param {Integer} cbInput The number of bytes in the <i>pbInput</i> buffer to decrypt.
     * @param {Pointer<Void>} pPaddingInfo A pointer to a structure that contains padding information. The actual type of structure this parameter points to depends on the value of the <i>dwFlags</i> parameter. This parameter is only used with asymmetric keys and must be <b>NULL</b> otherwise.
     * @param {Pointer} pbOutput The address of a buffer that will receive the decrypted data produced by this function. The <i>cbOutput</i> parameter contains the size of this buffer. For more information, see Remarks.
     * 
     * If this parameter is <b>NULL</b>, this function will calculate the size needed for the decrypted data and return the size in the location pointed to by the <i>pcbResult</i> parameter.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer. This parameter is ignored if the <i>pbOutput</i> parameter is <b>NULL</b>.
     * @param {Integer} dwFlags Flags that modify function behavior. The allowed set of flags depends on the type of key specified by the <i>hKey</i> parameter.
     * @returns {Integer} A pointer to a <b>DWORD</b> variable that receives the number of bytes copied to the <i>pbOutput</i> buffer. If <i>pbOutput</i> is <b>NULL</b>, this receives the size, in bytes, required for the decrypted data.
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptdecrypt
     * @since windows6.0.6000
     */
    static NCryptDecrypt(hKey, pbInput, cbInput, pPaddingInfo, pbOutput, cbOutput, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        pPaddingInfoMarshal := pPaddingInfo is VarRef ? "ptr" : "ptr"

        result := DllCall("ncrypt.dll\NCryptDecrypt", "ptr", hKey, "ptr", pbInput, "uint", cbInput, pPaddingInfoMarshal, pPaddingInfo, "ptr", pbOutput, "uint", cbOutput, "uint*", &pcbResult := 0, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbResult
    }

    /**
     * Imports a Cryptography API:\_Next Generation (CNG) key from a memory BLOB.
     * @param {NCRYPT_PROV_HANDLE} hProvider The handle of the key storage provider.
     * @param {NCRYPT_KEY_HANDLE} hImportKey The handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic key</a> with which the key data within the imported <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key BLOB</a> was encrypted. This must be a handle to the same key that was passed in the <i>hExportKey</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptexportkey">NCryptExportKey</a> function. If this parameter is <b>NULL</b>, the key BLOB is assumed to not be encrypted.
     * @param {PWSTR} pszBlobType A null-terminated Unicode string that contains an identifier that specifies the format of the key BLOB. These formats are specific to a particular key storage provider. For the BLOB formats supported by Microsoft providers, see Remarks.
     * @param {Pointer<BCryptBufferDesc>} pParameterList The address of an <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-_bcryptbufferdesc">NCryptBufferDesc</a> structure that points to an array of buffers that contain parameter information for the key.
     * @param {Pointer} pbData The address of a buffer that contains the key BLOB to be imported. The <i>cbData</i> parameter contains the size of this buffer.
     * @param {Integer} cbData The size, in bytes, of the <i>pbData</i> buffer.
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_KEY_HANDLE} The address of an <b>NCRYPT_KEY_HANDLE</b> variable that receives the handle of the key. When you have finished using this handle, release it by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreeobject">NCryptFreeObject</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptimportkey
     * @since windows6.0.6000
     */
    static NCryptImportKey(hProvider, hImportKey, pszBlobType, pParameterList, pbData, cbData, dwFlags) {
        hProvider := hProvider is Win32Handle ? NumGet(hProvider, "ptr") : hProvider
        hImportKey := hImportKey is Win32Handle ? NumGet(hImportKey, "ptr") : hImportKey
        pszBlobType := pszBlobType is String ? StrPtr(pszBlobType) : pszBlobType

        phKey := NCRYPT_KEY_HANDLE()
        result := DllCall("ncrypt.dll\NCryptImportKey", "ptr", hProvider, "ptr", hImportKey, "ptr", pszBlobType, "ptr", pParameterList, "ptr", phKey, "ptr", pbData, "uint", cbData, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phKey
    }

    /**
     * Exports a CNG key to a memory BLOB.
     * @param {NCRYPT_KEY_HANDLE} hKey A handle of the key to export.
     * @param {NCRYPT_KEY_HANDLE} hExportKey A handle to a cryptographic key of the destination user. The key data within the exported key BLOB is encrypted by using this key. This ensures that only the destination user is able to make use of the key BLOB.
     * @param {PWSTR} pszBlobType 
     * @param {Pointer<BCryptBufferDesc>} pParameterList The address of an <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-_bcryptbufferdesc">NCryptBufferDesc</a> structure that receives parameter information for the key. This parameter can be <b>NULL</b> if this information is not needed.
     * @param {Pointer} pbOutput The address of a buffer that receives the key BLOB. The <i>cbOutput</i> parameter contains the size of this buffer. If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the <b>DWORD</b> pointed to by the <i>pcbResult</i> parameter.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer.
     * @param {Integer} dwFlags 
     * @returns {Integer} The address of a <b>DWORD</b> variable that receives the number of bytes copied to the <i>pbOutput</i> buffer. If the <i>pbOutput</i> parameter is <b>NULL</b>, this function will place the required size, in bytes, in the <b>DWORD</b> pointed to by this parameter.
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptexportkey
     * @since windows6.0.6000
     */
    static NCryptExportKey(hKey, hExportKey, pszBlobType, pParameterList, pbOutput, cbOutput, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey
        hExportKey := hExportKey is Win32Handle ? NumGet(hExportKey, "ptr") : hExportKey
        pszBlobType := pszBlobType is String ? StrPtr(pszBlobType) : pszBlobType

        result := DllCall("ncrypt.dll\NCryptExportKey", "ptr", hKey, "ptr", hExportKey, "ptr", pszBlobType, "ptr", pParameterList, "ptr", pbOutput, "uint", cbOutput, "uint*", &pcbResult := 0, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbResult
    }

    /**
     * Creates a signature of a hash value.
     * @param {NCRYPT_KEY_HANDLE} hKey The handle of the key to use to sign the hash.
     * @param {Pointer<Void>} pPaddingInfo A pointer to a structure that contains padding information. The actual type of structure this parameter points to depends on the value of the <i>dwFlags</i> parameter. This parameter is only used with asymmetric keys and must be <b>NULL</b> otherwise.
     * @param {Pointer} pbHashValue A pointer to a buffer that contains the hash value to sign. The <i>cbInput</i> parameter contains the size of this buffer.
     * @param {Integer} cbHashValue The number of bytes in the <i>pbHashValue</i> buffer to sign.
     * @param {Pointer} pbSignature The address of a buffer to receive the signature produced by this function. The <i>cbSignature</i> parameter contains the size of this buffer.
     * 
     * If this parameter is <b>NULL</b>, this function will calculate the size required for the signature and return the size in the location pointed to by the <i>pcbResult</i> parameter.
     * @param {Integer} cbSignature The size, in bytes, of the <i>pbSignature</i> buffer. This parameter is ignored if the <i>pbSignature</i> parameter is <b>NULL</b>.
     * @param {Integer} dwFlags Flags that modify function behavior. The allowed set of flags depends on the type of key specified by the <i>hKey</i> parameter.
     * 
     * If the key is a symmetric key, this parameter is not used and should be set to zero.
     * @returns {Integer} A pointer to a <b>DWORD</b> variable that receives the number of bytes copied to the <i>pbSignature</i> buffer. 
     * 
     * If <i>pbSignature</i> is <b>NULL</b>, this receives the size, in bytes, required for the signature.
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptsignhash
     * @since windows6.0.6000
     */
    static NCryptSignHash(hKey, pPaddingInfo, pbHashValue, cbHashValue, pbSignature, cbSignature, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        pPaddingInfoMarshal := pPaddingInfo is VarRef ? "ptr" : "ptr"

        result := DllCall("ncrypt.dll\NCryptSignHash", "ptr", hKey, pPaddingInfoMarshal, pPaddingInfo, "ptr", pbHashValue, "uint", cbHashValue, "ptr", pbSignature, "uint", cbSignature, "uint*", &pcbResult := 0, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbResult
    }

    /**
     * Verifies that the specified signature matches the specified hash.
     * @param {NCRYPT_KEY_HANDLE} hKey The handle of the key to use to decrypt the signature. This must be an identical key or the public key portion of the key pair used to sign the data with the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptsignhash">NCryptSignHash</a> function.
     * @param {Pointer<Void>} pPaddingInfo A pointer to a structure that contains padding information. The actual type of structure this parameter points to depends on the value of the <i>dwFlags</i> parameter. This parameter is only used with asymmetric keys and must be <b>NULL</b> otherwise.
     * @param {Pointer} pbHashValue The address of a buffer that contains the hash of the data. The <i>cbHash</i> parameter contains the size of this buffer.
     * @param {Integer} cbHashValue The size, in bytes, of the <i>pbHash</i> buffer.
     * @param {Pointer} pbSignature The address of a buffer that contains the signed hash of the data. The <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptsignhash">NCryptSignHash</a> function is used to create the signature. The <i>cbSignature</i> parameter contains the size of this buffer.
     * @param {Integer} cbSignature The size, in bytes, of the <i>pbSignature</i> buffer. The <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptsignhash">NCryptSignHash</a> function is used to create the signature.
     * @param {Integer} dwFlags Flags that modify function behavior. The allowed set of flags depends on the type of key specified by the <i>hKey</i> parameter.
     * 
     * If the key is a symmetric key, this parameter is not used and should be zero.
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature was not verified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm provider used to create the key handle specified by the <i>hKey</i> parameter is not a signing algorithm.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptverifysignature
     * @since windows6.0.6000
     */
    static NCryptVerifySignature(hKey, pPaddingInfo, pbHashValue, cbHashValue, pbSignature, cbSignature, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        pPaddingInfoMarshal := pPaddingInfo is VarRef ? "ptr" : "ptr"

        result := DllCall("ncrypt.dll\NCryptVerifySignature", "ptr", hKey, pPaddingInfoMarshal, pPaddingInfo, "ptr", pbHashValue, "uint", cbHashValue, "ptr", pbSignature, "uint", cbSignature, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Deletes a CNG key.
     * @param {NCRYPT_KEY_HANDLE} hKey The handle of the key to delete. This handle is obtained by using the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenkey">NCryptOpenKey</a> function.
     * 
     * <div class="alert"><b>Note</b>The <b>NCryptDeleteKey</b> function frees the handle. Applications must not use the handle or attempt to call the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreeobject">NCryptFreeObject</a> function on it after calling the <b>NCryptDeleteKey</b> function.</div>
     * <div></div>
     * @param {Integer} dwFlags Flags that modify function behavior. This can be zero or a combination of values that is specific to each key storage provider.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider (KSP) not display any user interface. If the provider must display the UI to operate, the call fails and the KSP should set the <b>NTE_SILENT_CONTEXT</b> error code as the last error.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptdeletekey
     * @since windows6.0.6000
     */
    static NCryptDeleteKey(hKey, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        result := DllCall("ncrypt.dll\NCryptDeleteKey", "ptr", hKey, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Frees a CNG key storage object.
     * @param {NCRYPT_HANDLE} hObject The handle of the object to free. This can be either a provider handle (<b>NCRYPT_PROV_HANDLE</b>) or a key handle (<b>NCRYPT_KEY_HANDLE</b>).
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hObject</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptfreeobject
     * @since windows6.0.6000
     */
    static NCryptFreeObject(hObject) {
        hObject := hObject is Win32Handle ? NumGet(hObject, "ptr") : hObject

        result := DllCall("ncrypt.dll\NCryptFreeObject", "ptr", hObject, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines if the specified handle is a CNG key handle.
     * @param {NCRYPT_KEY_HANDLE} hKey The handle of the key to test.
     * @returns {BOOL} Returns a nonzero value if the handle is a key handle or zero otherwise.
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptiskeyhandle
     * @since windows6.0.6000
     */
    static NCryptIsKeyHandle(hKey) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        result := DllCall("ncrypt.dll\NCryptIsKeyHandle", "ptr", hKey, "int")
        return result
    }

    /**
     * Translates a CryptoAPI handle into a CNG key handle.
     * @param {Pointer<NCRYPT_PROV_HANDLE>} phProvider A pointer to an <b>NCRYPT_PROV_HANDLE</b> variable that receives the handle of the CNG key storage provider that owns the CNG key placed in the <i>phKey</i> parameter. This parameter can be <b>NULL</b> if this handle is not needed.
     * @param {Pointer<NCRYPT_KEY_HANDLE>} phKey A pointer to a <b>NCRYPT_KEY_HANDLE</b> variable that receives the CNG key handle.
     * @param {Pointer} hLegacyProv The handle of the CryptoAPI provider that contains the key to translate. This function will translate the CryptoAPI key that is in the container in this provider.
     * @param {Pointer} hLegacyKey The handle of a CryptoAPI key to use to help determine the key specification for the returned key. This parameter is ignored if the <i>dwLegacyKeySpec</i> parameter contains a value other than zero.
     * 
     * If <i>hLegacyKey</i> is <b>NULL</b> and <i>dwLegacyKeySpec</i> is zero, this function will attempt to determine the key specification from the <i>hLegacyProv</i> handle.
     * @param {Integer} dwLegacyKeySpec 
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are defined for this function.
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncrypttranslatehandle
     * @since windows6.0.6000
     */
    static NCryptTranslateHandle(phProvider, phKey, hLegacyProv, hLegacyKey, dwLegacyKeySpec, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptTranslateHandle", "ptr", phProvider, "ptr", phKey, "ptr", hLegacyProv, "ptr", hLegacyKey, "uint", dwLegacyKeySpec, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Creates or removes a key change notification.
     * @param {NCRYPT_PROV_HANDLE} hProvider The handle of the key storage provider. This handle is obtained by using the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenstorageprovider">NCryptOpenStorageProvider</a> function.
     * @param {Pointer<HANDLE>} phEvent The address of a <b>HANDLE</b> variable that either receives or contains the key change notification event handle. This is the same handle that is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstchangenotificationa">FindFirstChangeNotification</a> function. For more information, see the <i>dwFlags</i> parameter description.
     * @param {Integer} dwFlags 
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProvider</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptnotifychangekey
     * @since windows6.0.6000
     */
    static NCryptNotifyChangeKey(hProvider, phEvent, dwFlags) {
        hProvider := hProvider is Win32Handle ? NumGet(hProvider, "ptr") : hProvider

        result := DllCall("ncrypt.dll\NCryptNotifyChangeKey", "ptr", hProvider, "ptr", phEvent, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Creates a secret agreement value from a private and a public key.
     * @param {NCRYPT_KEY_HANDLE} hPrivKey The handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key</a> to use to create the secret agreement value. This key and the <i>hPubKey</i> key must come from the same key storage provider.
     * @param {NCRYPT_KEY_HANDLE} hPubKey The handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key</a> to use to create the secret agreement value. This key and the <i>hPrivKey</i> key must come from the same key storage provider.
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_SECRET_HANDLE} A pointer to an <b>NCRYPT_SECRET_HANDLE</b> variable that receives a handle that represents the secret agreement value. When this handle is no longer needed, release it by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreeobject">NCryptFreeObject</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptsecretagreement
     * @since windows6.0.6000
     */
    static NCryptSecretAgreement(hPrivKey, hPubKey, dwFlags) {
        hPrivKey := hPrivKey is Win32Handle ? NumGet(hPrivKey, "ptr") : hPrivKey
        hPubKey := hPubKey is Win32Handle ? NumGet(hPubKey, "ptr") : hPubKey

        phAgreedSecret := NCRYPT_SECRET_HANDLE()
        result := DllCall("ncrypt.dll\NCryptSecretAgreement", "ptr", hPrivKey, "ptr", hPubKey, "ptr", phAgreedSecret, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phAgreedSecret
    }

    /**
     * Derives a key from a secret agreement value.
     * @param {NCRYPT_SECRET_HANDLE} hSharedSecret The secret agreement handle to create the key from. This handle is obtained from the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptsecretagreement">NCryptSecretAgreement</a> function.
     * @param {PWSTR} pwszKDF A pointer to a null-terminated Unicode string that identifies the <i>key derivation function</i> (KDF) to use to derive the key. This can be one of the following strings.
     * @param {Pointer<BCryptBufferDesc>} pParameterList The address of a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-_bcryptbufferdesc">NCryptBufferDesc</a> structure that contains the KDF parameters. This parameter is optional and can be <b>NULL</b> if it is not needed.
     * @param {Pointer} pbDerivedKey The address of a buffer that receives the key. The <i>cbDerivedKey</i> parameter contains the size of this buffer. If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the <b>DWORD</b> pointed to by the <i>pcbResult</i> parameter.
     * @param {Integer} cbDerivedKey The size, in bytes, of the <i>pbDerivedKey</i> buffer.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. This can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="KDF_USE_SECRET_AS_HMAC_KEY_FLAG"></a><a id="kdf_use_secret_as_hmac_key_flag"></a><dl>
     * <dt><b>KDF_USE_SECRET_AS_HMAC_KEY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The secret agreement value will also serve as the HMAC key. If this flag is specified, the <b>KDF_HMAC_KEY</b> parameter should not be included in the set of parameters in the <i>pParameterList</i> parameter. This flag is only used by the <b>BCRYPT_KDF_HMAC</b> key derivation function.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} A pointer to a <b>DWORD</b> that receives the number of bytes that were copied to the <i>pbDerivedKey</i> buffer. If the <i>pbDerivedKey</i> parameter is <b>NULL</b>, this function will place the required size, in bytes, in the <b>DWORD</b> pointed to by this parameter.
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptderivekey
     * @since windows6.0.6000
     */
    static NCryptDeriveKey(hSharedSecret, pwszKDF, pParameterList, pbDerivedKey, cbDerivedKey, dwFlags) {
        hSharedSecret := hSharedSecret is Win32Handle ? NumGet(hSharedSecret, "ptr") : hSharedSecret
        pwszKDF := pwszKDF is String ? StrPtr(pwszKDF) : pwszKDF

        result := DllCall("ncrypt.dll\NCryptDeriveKey", "ptr", hSharedSecret, "ptr", pwszKDF, "ptr", pParameterList, "ptr", pbDerivedKey, "uint", cbDerivedKey, "uint*", &pcbResult := 0, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbResult
    }

    /**
     * Creates a key from another key by using the specified key derivation function.
     * @param {NCRYPT_KEY_HANDLE} hKey Handle of the key derivation function (KDF) key.
     * @param {Pointer<BCryptBufferDesc>} pParameterList The address of a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-_bcryptbufferdesc">NCryptBufferDesc</a> structure that contains the KDF parameters. The parameters can be specific to a KDF or generic. The following table shows the required and optional parameters for specific KDFs implemented by the Microsoft software key storage provider.
     * 
     * <table>
     * <tr>
     * <th>KDF</th>
     * <th>Parameter</th>
     * <th>Required</th>
     * </tr>
     * <tr>
     * <td>SP800-108 HMAC in counter mode</td>
     * <td>KDF_LABEL</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_CONTEXT</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_HASH_ALGORITHM</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td>SP800-56A</td>
     * <td>KDF_ALGORITHMID</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_PARTYUINFO</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_PARTYVINFO</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_HASH_ALGORITHM</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_SUPPPUBINFO</td>
     * <td>no</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_SUPPPRIVINFO</td>
     * <td>no</td>
     * </tr>
     * <tr>
     * <td>PBKDF2</td>
     * <td>KDF_HASH_ALGORITHM</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_SALT</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_ITERATION_COUNT</td>
     * <td>no</td>
     * </tr>
     * <tr>
     * <td>CAPI_KDF</td>
     * <td>KDF_HASH_ALGORITHM</td>
     * <td>yes</td>
     * </tr>
     * </table>
     * 
     * 
     * The following generic parameter can be used:<ul>
     * <li>KDF_GENERIC_PARAMETER</li>
     * </ul>Generic parameters map to KDF specific parameters in the following manner:
     * 
     * SP800-108 HMAC in counter mode:<ul>
     * <li>KDF_GENERIC_PARAMETER = KDF_LABEL||0x00||KDF_CONTEXT</li>
     * </ul>
     * 
     * 
     * SP800-56A<ul>
     * <li>KDF_GENERIC_PARAMETER = KDF_ALGORITHMID || KDF_PARTYUINFO || KDF_PARTYVINFO {|| KDF_SUPPPUBINFO } {|| KDF_SUPPPRIVINFO }</li>
     * </ul>
     * 
     * 
     * PBKDF2<ul>
     * <li>KDF_GENERIC_PARAMETER = KDF_SALT </li>
     * <li>KDF_ITERATION_COUNT  defaults to 10000</li>
     * </ul>
     * 
     * 
     * CAPI_KDF<ul>
     * <li>KDF_GENERIC_PARAMETER = Not Used </li>
     * </ul>
     * @param {Pointer} pbDerivedKey Address of a buffer that receives the key. The <i>cbDerivedKey</i> parameter contains the size, in bytes, of the key buffer.
     * @param {Integer} cbDerivedKey Size, in bytes, of the buffer pointed to by the <i>pbDerivedKey</i> parameter.
     * @param {Integer} dwFlags Flags that modify function behavior. The following value can be used with the Microsoft software key storage provider.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_CAPI_AES_FLAG"></a><a id="bcrypt_capi_aes_flag"></a><dl>
     * <dt><b>BCRYPT_CAPI_AES_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies that the target algorithm is AES and that the key therefore must be double expanded.
     * This flag is only valid with the CAPI_KDF algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider (KSP) not display any user interface. If the provider must display the UI to operate, the call fails and the KSP should set the <b>NTE_SILENT_CONTEXT</b> error code as the last error.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Pointer to a <b>DWORD</b> that receives the number of bytes copied to the buffer pointed to by the <i>pbDerivedKey</i> parameter.
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptkeyderivation
     * @since windows8.0
     */
    static NCryptKeyDerivation(hKey, pParameterList, pbDerivedKey, cbDerivedKey, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        result := DllCall("ncrypt.dll\NCryptKeyDerivation", "ptr", hKey, "ptr", pParameterList, "ptr", pbDerivedKey, "uint", cbDerivedKey, "uint*", &pcbResult := 0, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbResult
    }

    /**
     * Creates a key attestation claim.
     * @param {NCRYPT_KEY_HANDLE} hSubjectKey The subject key handle that the claim is created for.
     * @param {NCRYPT_KEY_HANDLE} hAuthorityKey The authority key handle that the claim is based on.
     * @param {Integer} dwClaimType The type of claim.
     * @param {Pointer<BCryptBufferDesc>} pParameterList An optional parameter list.
     * @param {Pointer} pbClaimBlob Output of the created claim blob.
     * @param {Integer} cbClaimBlob 
     * @param {Integer} dwFlags As of Windows10, no  flags are defined. This parameter should be set to 0.
     * @returns {Integer} The output of the created claim blob.
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptcreateclaim
     * @since windows10.0.10240
     */
    static NCryptCreateClaim(hSubjectKey, hAuthorityKey, dwClaimType, pParameterList, pbClaimBlob, cbClaimBlob, dwFlags) {
        hSubjectKey := hSubjectKey is Win32Handle ? NumGet(hSubjectKey, "ptr") : hSubjectKey
        hAuthorityKey := hAuthorityKey is Win32Handle ? NumGet(hAuthorityKey, "ptr") : hAuthorityKey

        result := DllCall("ncrypt.dll\NCryptCreateClaim", "ptr", hSubjectKey, "ptr", hAuthorityKey, "uint", dwClaimType, "ptr", pParameterList, "ptr", pbClaimBlob, "uint", cbClaimBlob, "uint*", &pcbResult := 0, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbResult
    }

    /**
     * Verifies a key attestation claim.
     * @param {NCRYPT_KEY_HANDLE} hSubjectKey The subject key handle for the claim.
     * @param {NCRYPT_KEY_HANDLE} hAuthorityKey The authority key handle to use when verifying the claim. This parameter is optional because the authority key is self-contained for certain claim types.
     * @param {Integer} dwClaimType The type of claim.
     * @param {Pointer<BCryptBufferDesc>} pParameterList An optional parameter list.
     * @param {Pointer} pbClaimBlob The input claim blob.
     * @param {Integer} cbClaimBlob 
     * @param {Pointer<BCryptBufferDesc>} pOutput The output blob.
     * @param {Integer} dwFlags As of Windows10, no  flags are defined. This parameter should be set to 0.
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function.
     * @see https://docs.microsoft.com/windows/win32/api//ncrypt/nf-ncrypt-ncryptverifyclaim
     * @since windows10.0.10240
     */
    static NCryptVerifyClaim(hSubjectKey, hAuthorityKey, dwClaimType, pParameterList, pbClaimBlob, cbClaimBlob, pOutput, dwFlags) {
        hSubjectKey := hSubjectKey is Win32Handle ? NumGet(hSubjectKey, "ptr") : hSubjectKey
        hAuthorityKey := hAuthorityKey is Win32Handle ? NumGet(hAuthorityKey, "ptr") : hAuthorityKey

        result := DllCall("ncrypt.dll\NCryptVerifyClaim", "ptr", hSubjectKey, "ptr", hAuthorityKey, "uint", dwClaimType, "ptr", pParameterList, "ptr", pbClaimBlob, "uint", cbClaimBlob, "ptr", pOutput, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptFormatObject function formats the encoded data and returns a Unicode string in the allocated buffer according to the certificate encoding type.
     * @param {Integer} dwCertEncodingType Type of encoding used on the certificate. The currently defined certificate encoding type used is X509_ASN_ENCODING.
     * @param {Integer} dwFormatType Format type values. Not used. Set to zero.
     * @param {Integer} dwFormatStrType Structure format type values. This parameter can be zero, or you can specify one or more of the following flags by using the bitwise-<b>OR</b> operator to combine them.
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="0"></a><dl>
     * <dt><b>0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Display the data in a single line. Each subfield is concatenated with a comma (,). For more information, see Remarks.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_FORMAT_STR_MULTI_LINE"></a><a id="crypt_format_str_multi_line"></a><dl>
     * <dt><b>CRYPT_FORMAT_STR_MULTI_LINE</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Display the data in multiple lines rather than single line (the default). For more information, see Remarks.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_FORMAT_STR_NO_HEX"></a><a id="crypt_format_str_no_hex"></a><dl>
     * <dt><b>CRYPT_FORMAT_STR_NO_HEX</b></dt>
     * <dt>0x0010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Disables the hexadecimal dump. For more information, see Remarks.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pFormatStruct A pointer to the format of the structure. Not used. Set to <b>NULL</b>.
     * @param {PSTR} lpszStructType A pointer to an OID that defines the encoded data. If the high-order word of the <i>lpszStructType</i> parameter is zero, the low-order word specifies the integer identifier for the type of the given structure. Otherwise, this parameter is a long pointer to a <b>null</b>-terminated string. 
     * 
     * 
     * 
     * 
     * The following table lists supported OIDs with their associated OID extension.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPC_FINANCIAL_CRITERIA_OBJID"></a><a id="spc_financial_criteria_objid"></a><dl>
     * <dt><b>SPC_FINANCIAL_CRITERIA_OBJID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 1.3.6.1.4.1.311.2.1.27
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPC_SP_AGENCY_INFO_OBJID"></a><a id="spc_sp_agency_info_objid"></a><dl>
     * <dt><b>SPC_SP_AGENCY_INFO_OBJID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 1.3.6.1.4.1.311.2.1.10
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_AUTHORITY_INFO_ACCESS"></a><a id="szoid_authority_info_access"></a><a id="SZOID_AUTHORITY_INFO_ACCESS"></a><dl>
     * <dt><b>szOID_AUTHORITY_INFO_ACCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 1.3.6.1.5.5.7.1.1
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_AUTHORITY_KEY_IDENTIFIER2"></a><a id="szoid_authority_key_identifier2"></a><a id="SZOID_AUTHORITY_KEY_IDENTIFIER2"></a><dl>
     * <dt><b>szOID_AUTHORITY_KEY_IDENTIFIER2</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.35
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_BASIC_CONSTRAINTS2"></a><a id="szoid_basic_constraints2"></a><a id="SZOID_BASIC_CONSTRAINTS2"></a><dl>
     * <dt><b>szOID_BASIC_CONSTRAINTS2</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.19
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_CERT_POLICIES"></a><a id="szoid_cert_policies"></a><a id="SZOID_CERT_POLICIES"></a><dl>
     * <dt><b>szOID_CERT_POLICIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.32
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_CRL_DIST_POINTS"></a><a id="szoid_crl_dist_points"></a><a id="SZOID_CRL_DIST_POINTS"></a><dl>
     * <dt><b>szOID_CRL_DIST_POINTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.31
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_CRL_REASON_CODE"></a><a id="szoid_crl_reason_code"></a><a id="SZOID_CRL_REASON_CODE"></a><dl>
     * <dt><b>szOID_CRL_REASON_CODE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.21
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_ENHANCED_KEY_USAGE"></a><a id="szoid_enhanced_key_usage"></a><a id="SZOID_ENHANCED_KEY_USAGE"></a><dl>
     * <dt><b>szOID_ENHANCED_KEY_USAGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.37
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_ISSUER_ALT_NAME2"></a><a id="szoid_issuer_alt_name2"></a><a id="SZOID_ISSUER_ALT_NAME2"></a><dl>
     * <dt><b>szOID_ISSUER_ALT_NAME2</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.18
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_KEY_ATTRIBUTES"></a><a id="szoid_key_attributes"></a><a id="SZOID_KEY_ATTRIBUTES"></a><dl>
     * <dt><b>szOID_KEY_ATTRIBUTES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.2
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_KEY_USAGE"></a><a id="szoid_key_usage"></a><a id="SZOID_KEY_USAGE"></a><dl>
     * <dt><b>szOID_KEY_USAGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.15
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_KEY_USAGE_RESTRICTION"></a><a id="szoid_key_usage_restriction"></a><a id="SZOID_KEY_USAGE_RESTRICTION"></a><dl>
     * <dt><b>szOID_KEY_USAGE_RESTRICTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.4
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_NEXT_UPDATE_LOCATION"></a><a id="szoid_next_update_location"></a><a id="SZOID_NEXT_UPDATE_LOCATION"></a><dl>
     * <dt><b>szOID_NEXT_UPDATE_LOCATION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 1.3.6.1.4.1.311.10.2
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_RSA_SMIMECapabilities"></a><a id="szoid_rsa_smimecapabilities"></a><a id="SZOID_RSA_SMIMECAPABILITIES"></a><dl>
     * <dt><b>szOID_RSA_SMIMECapabilities</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 1.2.840.113549.1.9.15
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_SUBJECT_ALT_NAME2"></a><a id="szoid_subject_alt_name2"></a><a id="SZOID_SUBJECT_ALT_NAME2"></a><dl>
     * <dt><b>szOID_SUBJECT_ALT_NAME2</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.17
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_SUBJECT_KEY_IDENTIFIER"></a><a id="szoid_subject_key_identifier"></a><a id="SZOID_SUBJECT_KEY_IDENTIFIER"></a><dl>
     * <dt><b>szOID_SUBJECT_KEY_IDENTIFIER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.14
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} pbEncoded A pointer to the encoded data to be formatted. If <i>lpszStructType</i> is one of the OIDs listed above, the <i>pbEncoded</i> is the encoded extension.
     * @param {Integer} cbEncoded The size, in bytes, of the <i>pbEncoded</i> structure.
     * @param {Pointer} pbFormat A pointer to a buffer that receives the formatted string. When the buffer that is specified is not large enough to receive the decoded structure, the function sets ERROR_MORE_DATA and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbFormat</i>. This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbFormat A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pbFormat</i> parameter. When the function returns, the variable pointed to by the <i>pcbFormat</i> parameter contains the number of bytes stored in the buffer. This parameter can be <b>NULL</b>, only if <i>pbFormat</i> is <b>NULL</b>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size may be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit into the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>. If it does not succeed, the return value is <b>FALSE</b>. To retrieve extended error information, use the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptformatobject
     * @since windows5.1.2600
     */
    static CryptFormatObject(dwCertEncodingType, dwFormatType, dwFormatStrType, pFormatStruct, lpszStructType, pbEncoded, cbEncoded, pbFormat, pcbFormat) {
        lpszStructType := lpszStructType is String ? StrPtr(lpszStructType) : lpszStructType

        pFormatStructMarshal := pFormatStruct is VarRef ? "ptr" : "ptr"
        pcbFormatMarshal := pcbFormat is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptFormatObject", "uint", dwCertEncodingType, "uint", dwFormatType, "uint", dwFormatStrType, pFormatStructMarshal, pFormatStruct, "ptr", lpszStructType, "ptr", pbEncoded, "uint", cbEncoded, "ptr", pbFormat, pcbFormatMarshal, pcbFormat, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Encodes a structure of the type indicated by the value of the lpszStructType parameter.
     * @param {Integer} dwCertEncodingType 
     * @param {PSTR} lpszStructType A pointer to an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) that defines the structure type. If the high-order word of the <i>lpszStructType</i> parameter is zero, the low-order word specifies an integer identifier for the type of the specified structure. Otherwise, this parameter is a pointer to a null-terminated string that contains the string representation of the OID.
     * 
     * For more information about object identifier strings, their predefined constants and corresponding structures, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/constants-for-cryptencodeobject-and-cryptdecodeobject">Constants for CryptEncodeObject and CryptDecodeObject</a>.
     * @param {Pointer<Void>} pvStructInfo A pointer to the structure to be encoded. The structure must be of the type specified by <i>lpszStructType</i>.
     * @param {Integer} dwFlags 
     * @param {Pointer<CRYPT_ENCODE_PARA>} pEncodePara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_encode_para">CRYPT_ENCODE_PARA</a> structure that contains encoding information. This parameter can be <b>NULL</b>.
     * 
     * If either <i>pEncodePara</i> or the <b>pfnAlloc</b> member of <i>pEncodePara</i> is <b>NULL</b>, then <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> is used for the allocation and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> must be called to free the memory.
     * 
     * If both <i>pEncodePara</i> and the <b>pfnAlloc</b> member of <i>pEncodePara</i> are not <b>NULL</b>, then the function pointed to by the <b>pfnAlloc</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_encode_para">CRYPT_ENCODE_PARA</a> structure pointed to by <i>pEncodePara</i> is called for the allocation. The function pointed to by the <b>pfnFree</b> member of <i>pEncodePara</i> must be called to free the memory.
     * @param {Pointer<Void>} pvEncoded A pointer to a buffer to receive the encoded structure. The size of this buffer is specified in the <i>pcbEncoded</i> parameter. When the buffer that is specified is not large enough to receive the decoded structure, the function sets the <b>ERROR_MORE_DATA</b> code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbEncoded</i>.
     * 
     * This parameter can be <b>NULL</b> to retrieve the size of the buffer for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * 
     * If <i>dwFlags</i> contains the <b>CRYPT_ENCODE_ALLOC_FLAG</b> flag, <i>pvEncoded</i> is not a pointer to a buffer but is the address of a pointer to the buffer. Because memory is allocated inside the function and the pointer is stored in <i>pvEncoded</i>, <i>pvEncoded</i> cannot be <b>NULL</b>.
     * @param {Pointer<Integer>} pcbEncoded A pointer to a <b>DWORD</b> variable that contains the size, in bytes, of the buffer pointed to by the <i>pvEncoded</i> parameter. When the function returns, the variable pointed to by the <i>pcbEncoded</i> parameter contains the number of allocated, encoded bytes stored in the buffer.
     * 
     * When <i>dwFlags</i> contains the <b>CRYPT_ENCODE_ALLOC_FLAG</b> flag, <i>pcbEncoded</i> is the address of a pointer to the <b>DWORD</b> value that is updated.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} Returns nonzero if successful or zero otherwise.
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following table shows some possible error codes that can be returned from <b>GetLastError</b> when <b>CryptEncodeObjectEx</b> fails.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_BAD_ENCODE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error was encountered while encoding.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An encoding function could not be found for the specified <i>dwCertEncodingType</i> and <i>lpszStructType</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pvEncoded</i> parameter is not large enough to hold the returned data, the function sets the <b>ERROR_MORE_DATA</b> code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbEncoded</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptencodeobjectex
     * @since windows5.1.2600
     */
    static CryptEncodeObjectEx(dwCertEncodingType, lpszStructType, pvStructInfo, dwFlags, pEncodePara, pvEncoded, pcbEncoded) {
        lpszStructType := lpszStructType is String ? StrPtr(lpszStructType) : lpszStructType

        pvStructInfoMarshal := pvStructInfo is VarRef ? "ptr" : "ptr"
        pvEncodedMarshal := pvEncoded is VarRef ? "ptr" : "ptr"
        pcbEncodedMarshal := pcbEncoded is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptEncodeObjectEx", "uint", dwCertEncodingType, "ptr", lpszStructType, pvStructInfoMarshal, pvStructInfo, "uint", dwFlags, "ptr", pEncodePara, pvEncodedMarshal, pvEncoded, pcbEncodedMarshal, pcbEncoded, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptEncodeObject function encodes a structure of the type indicated by the value of the lpszStructType parameter. The use of CryptEncodeObjectEx is recommended as an API that performs the same function with significant performance improvements.
     * @param {Integer} dwCertEncodingType Type of encoding used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * <div class="alert"><b>Note</b>Either a certificate or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> is required. X509_ASN_ENCODING is the default. If that type is indicated, it is used. Otherwise, if the PKCS7_ASN_ENCODING type is indicated, it is used.</div>
     * <div></div>
     * @param {PSTR} lpszStructType A pointer to an OID defining the structure type. If the high-order word of the <i>lpszStructType</i> parameter is zero, the low-order word specifies the integer identifier for the type of the specified structure. Otherwise, this parameter is a long pointer to a null-terminated string.
     * 
     * For more information about object identifier strings, their predefined constants and corresponding structures, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/constants-for-cryptencodeobject-and-cryptdecodeobject">Constants for CryptEncodeObject and CryptDecodeObject</a>.
     * @param {Pointer<Void>} pvStructInfo A pointer to the structure to be encoded. The structure must be of a type specified by <i>lpszStructType</i>.
     * @param {Pointer} pbEncoded A pointer to a buffer to receive the encoded structure. When the buffer that is specified is not large enough to receive the decoded structure, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbEncoded</i>.
     * 
     * This parameter can be <b>NULL</b> to retrieve the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbEncoded A pointer to a <b>DWORD</b> variable that contains the size, in bytes, of the buffer pointed to by the <i>pbEncoded</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of allocated encoded bytes stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_BAD_ENCODE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error was encountered while encoding.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An encoding function could not be found for the specified <i>dwCertEncodingType</i> and <i>lpszStructType</i>.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbEncoded</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbEncoded</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails,<a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptencodeobject
     * @since windows5.1.2600
     */
    static CryptEncodeObject(dwCertEncodingType, lpszStructType, pvStructInfo, pbEncoded, pcbEncoded) {
        lpszStructType := lpszStructType is String ? StrPtr(lpszStructType) : lpszStructType

        pvStructInfoMarshal := pvStructInfo is VarRef ? "ptr" : "ptr"
        pcbEncodedMarshal := pcbEncoded is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptEncodeObject", "uint", dwCertEncodingType, "ptr", lpszStructType, pvStructInfoMarshal, pvStructInfo, "ptr", pbEncoded, pcbEncodedMarshal, pcbEncoded, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Decodes a structure of the type indicated by the lpszStructType parameter.
     * @param {Integer} dwCertEncodingType The type of encoding used. It is always acceptable to specify both the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a> and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * <div class="alert"><b>Note</b>Either a certificate or message encoding type is required. X509_ASN_ENCODING is the default. If that type is indicated, it is used. Otherwise, if the PKCS7_ASN_ENCODING type is indicated, it is used.</div>
     * <div></div>
     * @param {PSTR} lpszStructType A pointer to an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) that defines the structure type. If the high-order word of the <i>lpszStructType</i> parameter is zero, the low-order word specifies the integer identifier for the type of the specified structure. Otherwise, this parameter is a long pointer to a null-terminated string.
     * 
     * For more information about object identifier strings, their predefined constants, and corresponding structures, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/constants-for-cryptencodeobject-and-cryptdecodeobject">Constants for CryptEncodeObject and CryptDecodeObject</a>.
     * @param {Pointer} pbEncoded A pointer to the data to be decoded. The structure must be of the type specified by <i>lpszStructType</i>.
     * @param {Integer} cbEncoded The number of bytes pointed to by <i>pbEncoded</i>. This is the number of bytes to be decoded.
     * @param {Integer} dwFlags This parameter can be one or more of the following flags. The flags can be combined by using a bitwise-<b>OR</b> operation.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_ALLOC_FLAG"></a><a id="crypt_decode_alloc_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_ALLOC_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The called decoding function allocates memory for the decoded structure. A pointer to the allocated structure is returned in <i>pvStructInfo</i>.
     * 
     * If <i>pDecodePara</i> or the <b>pfnAlloc</b>  member of <i>pDecodePara</i> is <b>NULL</b>, then <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> is called for the allocation and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> must be called to free the memory.
     * 
     * If <i>pDecodePara</i> and the <b>pfnAlloc</b>  member of <i>pDecodePara</i> are not <b>NULL</b>, then the function pointed to by <b>pfnAlloc</b> is called for the allocation and the function pointed to by the <b>pfnFree</b>  member of <i>pDecodePara</i> must be called to free the memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_ENABLE_PUNYCODE_FLAG"></a><a id="crypt_decode_enable_punycode_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_ENABLE_PUNYCODE_FLAG</b></dt>
     * <dt>33554432 (0x2000000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is applicable for enabling Punycode decoding of Unicode string values. For more information, see Remarks.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP:</b>This flag is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_NOCOPY_FLAG"></a><a id="crypt_decode_nocopy_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_NOCOPY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag can be set to enable a "no copy" optimization. This optimization updates the <i>pvStructInfo</i> members to point to content that resides within <i>pbEncoded</i> instead of making a copy of the content and appending it to <i>pvStructInfo</i>. The calling application needs to allocate less memory and execution is faster because a copy is not made. Note that when performing "no copy" decoding, <i>pbEncoded</i> cannot be freed until <i>pvStructInfo</i> is freed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG"></a><a id="crypt_unicode_name_decode_disable_ie4_utf8_flag"></a><dl>
     * <dt><b>CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is applicable when decoding X509_UNICODE_NAME, X509_UNICODE_NAME_VALUE, or X509_UNICODE_ANY_STRING. By default, CERT_RDN_T61_STRING encoded values are initially decoded as UTF8. If the UTF8 decoding fails, then the value is decoded as eight-bit characters. If this flag is set, it skips the initial attempt to decode the value as UTF8 and decodes the value as eight-bit characters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_TO_BE_SIGNED_FLAG"></a><a id="crypt_decode_to_be_signed_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_TO_BE_SIGNED_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * By default, the contents of the buffer pointed to by <i>pbEncoded</i> included the signed content and the signature. If this flag is set, the buffer includes only the "to be signed" content. This flag is applicable to X509_CERT_TO_BE_SIGNED, X509_CERT_CRL_TO_BE_SIGNED, X509_CRT_REQUEST_TO_BE_SIGNED, and X509_KEYGEN_REQUEST_TO_BE_SIGNED objects.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_SHARE_OID_STRING_FLAG"></a><a id="crypt_decode_share_oid_string_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_SHARE_OID_STRING_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When this flag is set, the OID strings are allocated in Crypt32.dll and shared instead of being copied into the returned data structure. This flag can be set if Crypt32.dll is not unloaded before the caller is unloaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG"></a><a id="crypt_decode_no_signature_byte_reversal_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * By default, the signature bytes are reversed. If this flag is set, this byte reversal is inhibited.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CRYPT_DECODE_PARA>} pDecodePara A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_decode_para">CRYPT_DECODE_PARA</a> structure that contains decoding paragraph information. If <i>pDecodePara</i> is set to <b>NULL</b>, then <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> are used to allocate and free memory. If <i>pDecodePara</i> points to a <b>CRYPT_DECODE_PARA</b> structure, that structure passes in callback functions to allocate and free memory. These callback functions override the default memory allocation of <b>LocalAlloc</b> and <b>LocalFree</b>.
     * @param {Pointer<Void>} pvStructInfo If the <i>dwFlags</i> CRYPT_ENCODE_ALLOC_FLAG is set, <i>pvStructInfo</i> is not a pointer to a buffer but is the address of a pointer to the buffer. Because memory is allocated inside the function and the pointer is stored at *<i>pvStructInfo</i>, <i>pvStructInfo</i> must never be <b>NULL</b>.
     * 
     * If CRYPT_ENCODE_ALLOC_FLAG is not set, <i>pvStructInfo</i> is a pointer to a buffer that receives the decoded structure. When the buffer that is specified is not large enough to receive the decoded structure, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbStructInfo</i>.
     * 
     * This parameter can be <b>NULL</b> to retrieve the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbStructInfo A pointer to a <b>DWORD</b> variable that contains the size, in bytes, of the buffer pointed to by the <i>pvStructInfo</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer. The size contained in the variable pointed to by <i>pcbStructInfo</i> can indicate a size larger than the decoded structure because the decoded structure can include pointers to auxiliary data. This size is the sum of the size needed by the decoded structure and the auxiliary data.
     * 
     * When CRYPT_DECODE_ALLOC_FLAG is set, the initial value of *<i>pcbStructInfo</i> is not used by the function, and on return, *<i>pcbStructInfo</i> contains the number of bytes allocated for <i>pvStructInfo</i>.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following table shows some possible error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_BAD_ENCODE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error was encountered while decoding.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A decoding function could not be found for the specified <i>dwCertEncodingType</i> and <i>lpszStructType</i>.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pvStructInfo</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbStructInfo</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptdecodeobjectex
     * @since windows5.1.2600
     */
    static CryptDecodeObjectEx(dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pDecodePara, pvStructInfo, pcbStructInfo) {
        lpszStructType := lpszStructType is String ? StrPtr(lpszStructType) : lpszStructType

        pvStructInfoMarshal := pvStructInfo is VarRef ? "ptr" : "ptr"
        pcbStructInfoMarshal := pcbStructInfo is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptDecodeObjectEx", "uint", dwCertEncodingType, "ptr", lpszStructType, "ptr", pbEncoded, "uint", cbEncoded, "uint", dwFlags, "ptr", pDecodePara, pvStructInfoMarshal, pvStructInfo, pcbStructInfoMarshal, pcbStructInfo, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptDecodeObject function decodes a structure of the type indicated by the lpszStructType parameter. The use of CryptDecodeObjectEx is recommended as an API that performs the same function with significant performance improvements.
     * @param {Integer} dwCertEncodingType Type of encoding used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * <div class="alert"><b>Note</b>Either a certificate or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> is required. X509_ASN_ENCODING is the default. If that type is indicated, it is used. Otherwise, if the PKCS7_ASN_ENCODING type is indicated, it is used.</div>
     * <div></div>
     * @param {PSTR} lpszStructType A pointer to an OID defining the structure type. If the high-order word of the <i>lpszStructType</i> parameter is zero, the low-order word specifies the integer identifier for the type of the specified structure. Otherwise, this parameter is a long pointer to a null-terminated string.
     * 
     * For more information about object identifier strings, their predefined constants and corresponding structures, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/constants-for-cryptencodeobject-and-cryptdecodeobject">Constants for CryptEncodeObject and CryptDecodeObject</a>.
     * @param {Pointer} pbEncoded A pointer to the encoded structure to be decoded.
     * @param {Integer} cbEncoded Number of bytes pointed to by <i>pbEncoded</i>.
     * @param {Integer} dwFlags The following flags are defined. They can be combined with a bitwise-<b>OR</b> operation.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_NOCOPY_FLAG"></a><a id="crypt_decode_nocopy_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_NOCOPY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag can be set to indicate that "no copy" optimization is enabled. This optimization, where applicable, updates the <i>pvStructInfo</i> parameter to point to content residing within <i>pbEncoded</i> instead of making a copy of the content and appending it to <i>pvStructInfo</i>. For applicable cases, less memory needs to be allocated by the calling application and execution is faster because a copy is not being made. Note that the trade-off when performing a "no copy" decoding is that <i>pbEncoded</i> cannot be freed until <i>pvStructInfo</i> is freed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG"></a><a id="crypt_unicode_name_decode_disable_ie4_utf8_flag"></a><dl>
     * <dt><b>CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is applicable when decoding X509_UNICODE_NAME, X509_UNICODE_NAME_VALUE, or X509_UNICODE_ANY_STRING. By default, CERT_RDN_T61_STRING encoded values are initially decoded as UTF8. If the UTF8 decoding fails, then the value is decoded as eight-bit characters. If this flag is set, it skips the initial attempt to decode the value as UTF8 and decodes the value as eight-bit characters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_TO_BE_SIGNED_FLAG"></a><a id="crypt_decode_to_be_signed_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_TO_BE_SIGNED_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * By default, the contents of the buffer pointed to by <i>pbEncoded</i> included the signed content and the signature. If this flag is set, the buffer includes only the "to be signed" content. This flag is applicable to X509_CERT_TO_BE_SIGNED, X509_CERT_CRL_TO_BE_SIGNED, X509_CRT_REQUEST_TO_BE_SIGNED, and X509_KEYGEN_REQUEST_TO_BE_SIGNED objects.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_SHARE_OID_STRING_FLAG"></a><a id="crypt_decode_share_oid_string_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_SHARE_OID_STRING_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When this flag is set, the OID stings are allocated in Crypt32.dll and shared instead of being copied into the returned data structure. This flag can be set if Crypt32.dll is not unloaded before the caller is unloaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG"></a><a id="crypt_decode_no_signature_byte_reversal_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * By default, the signature bytes are reversed. If this flag is set, this byte reversal is inhibited.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} pvStructInfo A pointer to a buffer to receive the decoded structure. When the buffer that is specified is not large enough to receive the decoded structure, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbStructInfo</i>.
     * 
     * This parameter can be <b>NULL</b> to retrieve the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbStructInfo A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pvStructInfo</i> parameter. When the function returns, this <b>DWORD</b> value contains the size of the decoded data copied to <i>pvStructInfo</i>. The size contained in the variable pointed to by <i>pcbStructInfo</i> can indicate a size larger than the decoded structure, as the decoded structure can include pointers to other structures. This size is the sum of the size needed by the decoded structure and other structures pointed to. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_BAD_ENCODE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error was encountered while decoding.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A decoding function could not be found for the specified <i>dwCertEncodingType</i> and <i>lpszStructType</i>
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pvStructInfo</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbStructInfo</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails,<a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptdecodeobject
     * @since windows5.1.2600
     */
    static CryptDecodeObject(dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pvStructInfo, pcbStructInfo) {
        lpszStructType := lpszStructType is String ? StrPtr(lpszStructType) : lpszStructType

        pcbStructInfoMarshal := pcbStructInfo is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptDecodeObject", "uint", dwCertEncodingType, "ptr", lpszStructType, "ptr", pbEncoded, "uint", cbEncoded, "uint", dwFlags, "ptr", pvStructInfo, pcbStructInfoMarshal, pcbStructInfo, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptInstallOIDFunctionAddress function installs a set of callable object identifier (OID) function addresses.
     * @param {HMODULE} hModule This parameter is updated with the <i>hModule</i> parameter passed to <b>DllMain</b> to prevent the DLL that contains the function addresses from being unloaded by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetoidfunctionaddress">CryptGetOIDFunctionAddress</a> or
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptfreeoidfunctionaddress">CryptFreeOIDFunctionAddress</a>. This would be the case when the DLL has also registered OID functions through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptregisteroidfunction">CryptRegisterOIDFunction</a>.
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. To match both current encoding types, use:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * @param {PSTR} pszFuncName Name of the function set being installed.
     * @param {Integer} cFuncEntry Number of array elements in <i>rgFuncEntry</i>[].
     * @param {Pointer<CRYPT_OID_FUNC_ENTRY>} rgFuncEntry Array of <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_oid_func_entry">CRYPT_OID_FUNC_ENTRY</a> structures, each containing an OID and the starting address of its correlated routine. 
     * 					
     * 
     * Default functions are installed by setting the <b>pszOID</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_oid_func_entry">CRYPT_OID_FUNC_ENTRY</a> structure for their array element to CRYPT_DEFAULT_OID.
     * @param {Integer} dwFlags By default, a new function set is installed at the end of the list of function sets. Setting the CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG flag installs the function set at the beginning of the list.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptinstalloidfunctionaddress
     * @since windows5.1.2600
     */
    static CryptInstallOIDFunctionAddress(hModule, dwEncodingType, pszFuncName, cFuncEntry, rgFuncEntry, dwFlags) {
        hModule := hModule is Win32Handle ? NumGet(hModule, "ptr") : hModule
        pszFuncName := pszFuncName is String ? StrPtr(pszFuncName) : pszFuncName

        result := DllCall("CRYPT32.dll\CryptInstallOIDFunctionAddress", "ptr", hModule, "uint", dwEncodingType, "ptr", pszFuncName, "uint", cFuncEntry, "ptr", rgFuncEntry, "uint", dwFlags, "int")
        return result
    }

    /**
     * The CryptInitOIDFunctionSet initializes and returns the handle of the OID function set identified by a supplied function set name.
     * @param {PSTR} pszFuncName Name of the OID function set.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @returns {Pointer<Void>} Returns the handle of the OID function set identified by <i>pszFuncName</i>, or <b>NULL</b> if the function fails.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptinitoidfunctionset
     * @since windows5.1.2600
     */
    static CryptInitOIDFunctionSet(pszFuncName, dwFlags) {
        pszFuncName := pszFuncName is String ? StrPtr(pszFuncName) : pszFuncName

        result := DllCall("CRYPT32.dll\CryptInitOIDFunctionSet", "ptr", pszFuncName, "uint", dwFlags, "ptr")
        return result
    }

    /**
     * Searches the list of registered and installed functions for an encoding type and object identifier (OID) match.
     * @param {Pointer<Void>} hFuncSet The function set handle previously obtained from a call to 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptinitoidfunctionset">CryptInitOIDFunctionSet</a> function.
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are used; however, additional encoding types can be added in the future. To match both current encoding types, use:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * For functions that do not use an encoding type, set this parameter to zero.
     * @param {PSTR} pszOID If the high-order word of the OID is nonzero, <i>pszOID</i> is a pointer to either an OID string such as "2.5.29.1" or an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">ASCII</a> string such as "file". If the high-order word of the OID is zero, the low-order word specifies the numeric identifier to be used as the object identifier. This resulting OID maps to the function that was either installed or registered with the same OID.
     * @param {Integer} dwFlags This parameter can be the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_GET_INSTALLED_OID_FUNC_FLAG"></a><a id="crypt_get_installed_oid_func_flag"></a><dl>
     * <dt><b>CRYPT_GET_INSTALLED_OID_FUNC_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches only the installed list of functions.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Pointer<Void>>} ppvFuncAddr A pointer to a pointer to a function address. If a match is found, <i>ppvFuncAddr</i> points to the function address.
     * @param {Pointer<Pointer<Void>>} phFuncAddr If a match is found, <i>phFuncAddr</i> points to the function handle. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> for the handle is incremented. 
     * When you have finished using the handle, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptfreeoidfunctionaddress">CryptFreeOIDFunctionAddress</a> function. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>By default, both the registered and installed function lists are searched. To search only the installed list of functions, set CRYPT_GET_INSTALLED_OID_FUNC_FLAG. This flag would be set by a registered function to get the address of a preinstalled function it was replacing. For example, the registered function might handle a new special case and call the preinstalled function to handle the remaining cases.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds and a match is found, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails or no match is found, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptgetoidfunctionaddress
     * @since windows5.1.2600
     */
    static CryptGetOIDFunctionAddress(hFuncSet, dwEncodingType, pszOID, dwFlags, ppvFuncAddr, phFuncAddr) {
        pszOID := pszOID is String ? StrPtr(pszOID) : pszOID

        hFuncSetMarshal := hFuncSet is VarRef ? "ptr" : "ptr"
        ppvFuncAddrMarshal := ppvFuncAddr is VarRef ? "ptr*" : "ptr"
        phFuncAddrMarshal := phFuncAddr is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptGetOIDFunctionAddress", hFuncSetMarshal, hFuncSet, "uint", dwEncodingType, "ptr", pszOID, "uint", dwFlags, ppvFuncAddrMarshal, ppvFuncAddr, phFuncAddrMarshal, phFuncAddr, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptGetDefaultOIDDllList function acquires the list of the names of DLL files that contain registered default object identifier (OID) functions for a specified function set and encoding type.
     * @param {Pointer<Void>} hFuncSet Function set handle previously obtained by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptinitoidfunctionset">CryptInitOIDFunctionSet</a>.
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. To match both current encoding types, use:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * <div class="alert"><b>Note</b>Either a certificate or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> is required. X509_ASN_ENCODING is the default. If that type is indicated, it is used; otherwise, if the PKCS7_ASN_ENCODING type is indicated, it is used.</div>
     * <div></div>
     * @param {PWSTR} pwszDllList A pointer to a buffer to receive the list of zero or more null-terminated file names. The returned list is terminated with a terminating <b>NULL</b> character. For example, a list of two names could be: 
     * 
     * 
     * 
     * 
     * L"<i>first</i>.dll\0" L"<i>second</i>.dll\0" L"\0"
     * 
     * To retrieve the number of wide characters the buffer must hold, this parameter can be <b>NULL</b>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcchDllList A pointer to a <b>DWORD</b> that specifies the size, in wide characters, of the returned list pointed to by the <i>pwszDllList</i> parameter. When the function returns, the variable pointed to by the <i>pcchDllList</i> parameter contains the number of wide characters stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * This function has the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pwszDllList</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in wide characters, in the variable pointed to by <i>pcchDllList</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptgetdefaultoiddlllist
     * @since windows5.1.2600
     */
    static CryptGetDefaultOIDDllList(hFuncSet, dwEncodingType, pwszDllList, pcchDllList) {
        pwszDllList := pwszDllList is String ? StrPtr(pwszDllList) : pwszDllList

        hFuncSetMarshal := hFuncSet is VarRef ? "ptr" : "ptr"
        pcchDllListMarshal := pcchDllList is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptGetDefaultOIDDllList", hFuncSetMarshal, hFuncSet, "uint", dwEncodingType, "ptr", pwszDllList, pcchDllListMarshal, pcchDllList, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptGetDefaultOIDFunctionAddress function loads the DLL that contains a default function address.
     * @param {Pointer<Void>} hFuncSet Function set handle previously obtained from a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptinitoidfunctionset">CryptInitOIDFunctionSet</a>.
     * @param {Integer} dwEncodingType Encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. To match both current encoding types, use:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * @param {PWSTR} pwszDll Name of the DLL to load. Normally, the DLL name is obtained from the list returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetdefaultoiddlllist">CryptGetDefaultOIDDllList</a>. If <i>pwszDll</i> is <b>NULL</b>, a search is performed on the list of installed default functions.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Pointer<Void>>} ppvFuncAddr A pointer to the address of the return function. If the function fails, a <b>NULL</b> is returned in <i>ppvFuncAddr</i>.
     * @param {Pointer<Pointer<Void>>} phFuncAddr Used only if <i>pwszDll</i> is <b>NULL</b>. On the first call to the function, *<i>phFuncAddr</i> must be <b>NULL</b> to acquire the first installed function. 
     * 
     * 
     * 
     * 
     * When this function is successful, *<i>phFuncAddr</i> is set to a function handle. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> for the function handle is incremented.
     * 
     * After the first call to the function, <i>phFuncAddr</i> is set to the pointer returned by the previous call. This input pointer is always freed within the function through a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptfreeoidfunctionaddress">CryptFreeOIDFunctionAddress</a> by this function. The call to free the pointer is always made even when the main function returns an error.
     * 
     * A non-<b>NULL</b><i>phFuncAddr</i> must be released either through a call to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptfreeoidfunctionaddress">CryptFreeOIDFunctionAddress</a> or by being passed back as input to this function or as input to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetoidfunctionaddress">CryptGetOIDFunctionAddress</a>.
     * 
     * If <i>pwszDll</i> is not <b>NULL</b>, the value of this parameter is ignored and a non-<b>NULL</b> pointer is not freed.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptgetdefaultoidfunctionaddress
     * @since windows5.1.2600
     */
    static CryptGetDefaultOIDFunctionAddress(hFuncSet, dwEncodingType, pwszDll, dwFlags, ppvFuncAddr, phFuncAddr) {
        pwszDll := pwszDll is String ? StrPtr(pwszDll) : pwszDll

        hFuncSetMarshal := hFuncSet is VarRef ? "ptr" : "ptr"
        ppvFuncAddrMarshal := ppvFuncAddr is VarRef ? "ptr*" : "ptr"
        phFuncAddrMarshal := phFuncAddr is VarRef ? "ptr*" : "ptr"

        result := DllCall("CRYPT32.dll\CryptGetDefaultOIDFunctionAddress", hFuncSetMarshal, hFuncSet, "uint", dwEncodingType, "ptr", pwszDll, "uint", dwFlags, ppvFuncAddrMarshal, ppvFuncAddr, phFuncAddrMarshal, phFuncAddr, "int")
        return result
    }

    /**
     * The CryptFreeOIDFunctionAddress function releases a handle returned by CryptGetOIDFunctionAddress or CryptGetDefaultOIDFunctionAddress by decrementing the reference count on the function handle.
     * @param {Pointer<Void>} hFuncAddr Handle of the function previously obtained from a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetoidfunctionaddress">CryptGetOIDFunctionAddress</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetdefaultoidfunctionaddress">CryptGetDefaultOIDFunctionAddress</a>.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptfreeoidfunctionaddress
     * @since windows5.1.2600
     */
    static CryptFreeOIDFunctionAddress(hFuncAddr, dwFlags) {
        hFuncAddrMarshal := hFuncAddr is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPT32.dll\CryptFreeOIDFunctionAddress", hFuncAddrMarshal, hFuncAddr, "uint", dwFlags, "int")
        return result
    }

    /**
     * Registers a DLL that contains the function to be called for the specified encoding type, function name, and object identifier (OID).
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. To match both current encoding types, use: 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {PSTR} pszFuncName Name of the function being registered.
     * @param {PSTR} pszOID OID of the function to be registered. If the high-order word of the OID is nonzero, <i>pszOID</i> is a pointer to either an OID string such as "2.5.29.1" or an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">ASCII</a> string such as "file." If the high-order word of the OID is zero, the low-order word specifies the numeric identifier to be used as the object identifier.
     * @param {PWSTR} pwszDll Name of the DLL file to be registered. It can contain environment-variable strings to be expanded by using the <a href="https://docs.microsoft.com/windows/desktop/api/rrascfg/nn-rrascfg-ieapproviderconfig">ExpandEnvironmentStrings</a> function before loading the DLL.
     * @param {PSTR} pszOverrideFuncName String that specifies a name for the function exported in the DLL. If <i>pszOverrideFuncName</i> is <b>NULL</b>, the function name specified by <i>pszFuncName</i> is used.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptregisteroidfunction
     * @since windows5.1.2600
     */
    static CryptRegisterOIDFunction(dwEncodingType, pszFuncName, pszOID, pwszDll, pszOverrideFuncName) {
        pszFuncName := pszFuncName is String ? StrPtr(pszFuncName) : pszFuncName
        pszOID := pszOID is String ? StrPtr(pszOID) : pszOID
        pwszDll := pwszDll is String ? StrPtr(pwszDll) : pwszDll
        pszOverrideFuncName := pszOverrideFuncName is String ? StrPtr(pszOverrideFuncName) : pszOverrideFuncName

        result := DllCall("CRYPT32.dll\CryptRegisterOIDFunction", "uint", dwEncodingType, "ptr", pszFuncName, "ptr", pszOID, "ptr", pwszDll, "ptr", pszOverrideFuncName, "int")
        return result
    }

    /**
     * Removes the registration of a DLL that contains the function to be called for the specified encoding type, function name, and OID.
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are used; however, additional encoding types may be added in the future. To match both current encoding types, use: 
     * 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * For functions that do not use an encoding type, set this parameter to zero.
     * @param {PSTR} pszFuncName Name of the function being unregistered.
     * @param {PSTR} pszOID A pointer to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) that corresponds to the name of the function being unregistered. If the high order word of the OID is nonzero, <i>pszOID</i> is a pointer to either an OID string such as "2.5.29.1" or an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">ASCII</a> string such as "file." If the high order word of the OID is zero, the low order word specifies the integer identifier to be used as the object identifier.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptunregisteroidfunction
     * @since windows5.1.2600
     */
    static CryptUnregisterOIDFunction(dwEncodingType, pszFuncName, pszOID) {
        pszFuncName := pszFuncName is String ? StrPtr(pszFuncName) : pszFuncName
        pszOID := pszOID is String ? StrPtr(pszOID) : pszOID

        result := DllCall("CRYPT32.dll\CryptUnregisterOIDFunction", "uint", dwEncodingType, "ptr", pszFuncName, "ptr", pszOID, "int")
        return result
    }

    /**
     * The CryptRegisterDefaultOIDFunction registers a DLL containing the default function to be called for the specified encoding type and function name. Unlike CryptRegisterOIDFunction, the function name to be exported by the DLL cannot be overridden.
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. To match both current encoding types, use: 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {PSTR} pszFuncName Name of the function being registered.
     * @param {Integer} dwIndex Index location for the insertion of the DLL in the list of DLLs. If <i>dwIndex</i> is zero, the DLL is inserted at the beginning of the list. If it is CRYPT_REGISTER_LAST_INDEX, the DLL is appended at the end of the list.
     * @param {PWSTR} pwszDll Optional environment-variable string to be expanded using <a href="https://docs.microsoft.com/windows/desktop/api/rrascfg/nn-rrascfg-ieapproviderconfig">ExpandEnvironmentStrings</a> function before loading the DLL.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptregisterdefaultoidfunction
     * @since windows5.1.2600
     */
    static CryptRegisterDefaultOIDFunction(dwEncodingType, pszFuncName, dwIndex, pwszDll) {
        pszFuncName := pszFuncName is String ? StrPtr(pszFuncName) : pszFuncName
        pwszDll := pwszDll is String ? StrPtr(pwszDll) : pwszDll

        result := DllCall("CRYPT32.dll\CryptRegisterDefaultOIDFunction", "uint", dwEncodingType, "ptr", pszFuncName, "uint", dwIndex, "ptr", pwszDll, "int")
        return result
    }

    /**
     * The CryptUnregisterDefaultOIDFunction removes the registration of a DLL containing the default function to be called for the specified encoding type and function name.
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. To match both current encoding types, use: 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {PSTR} pszFuncName Name of the function being unregistered.
     * @param {PWSTR} pwszDll Name of the DLL where the function is located.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptunregisterdefaultoidfunction
     * @since windows5.1.2600
     */
    static CryptUnregisterDefaultOIDFunction(dwEncodingType, pszFuncName, pwszDll) {
        pszFuncName := pszFuncName is String ? StrPtr(pszFuncName) : pszFuncName
        pwszDll := pwszDll is String ? StrPtr(pwszDll) : pwszDll

        result := DllCall("CRYPT32.dll\CryptUnregisterDefaultOIDFunction", "uint", dwEncodingType, "ptr", pszFuncName, "ptr", pwszDll, "int")
        return result
    }

    /**
     * The CryptSetOIDFunctionValue function sets a value for the specified encoding type, function name, OID, and value name.
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. To match both current encoding types, use: 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {PSTR} pszFuncName Name of the function for which the encoding type, OID, and value name is being updated.
     * @param {PSTR} pszOID If the high-order word of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) is nonzero, <i>pszOID</i> is a pointer to either an OID string such as "2.5.29.1" or an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">ASCII</a> string such as "file". If the high-order word of the OID is zero, the low-order word specifies the integer identifier to be used as the object identifier.
     * @param {PWSTR} pwszValueName A pointer to a Unicode string containing the name of the value to set. If a value with this name is not already present, the function creates it.
     * @param {Integer} dwValueType 
     * @param {Pointer} pbValueData Points to a buffer containing the data to be stored for the specified value name.
     * @param {Integer} cbValueData Specifies the size, in bytes, of the information pointed to by the <i>pbValueData</i> parameter. If the data is of type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, the size must include the terminating <b>NULL</b> wide character.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptsetoidfunctionvalue
     * @since windows5.1.2600
     */
    static CryptSetOIDFunctionValue(dwEncodingType, pszFuncName, pszOID, pwszValueName, dwValueType, pbValueData, cbValueData) {
        pszFuncName := pszFuncName is String ? StrPtr(pszFuncName) : pszFuncName
        pszOID := pszOID is String ? StrPtr(pszOID) : pszOID
        pwszValueName := pwszValueName is String ? StrPtr(pwszValueName) : pwszValueName

        result := DllCall("CRYPT32.dll\CryptSetOIDFunctionValue", "uint", dwEncodingType, "ptr", pszFuncName, "ptr", pszOID, "ptr", pwszValueName, "uint", dwValueType, "ptr", pbValueData, "uint", cbValueData, "int")
        return result
    }

    /**
     * The CryptGetOIDFunctionValue function queries a value associated with an OID.
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. To match both current encoding types, use    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {PSTR} pszFuncName A pointer to the null-terminated string that contains the name of the OID function set.
     * @param {PSTR} pszOID If the high-order word of the OID is nonzero, <i>pszOID</i> is a pointer to either a  null-terminated OID string such as "2.5.29.1" or a null-terminated <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">ASCII</a> string such as "file." If the high-order word of the OID is zero, the low-order word specifies the numeric identifier to be used as the object identifier.
     * @param {PWSTR} pwszValueName A pointer to a null-terminated Unicode string that contains the name of the value to be queried.
     * @param {Pointer<Integer>} pdwValueType A pointer to a variable to receive the value's type. The type returned through this parameter will be one of the following.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="REG_DWORD"></a><a id="reg_dword"></a><dl>
     * <dt><b>REG_DWORD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 32-bit number.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="REG_EXPAND_SZ"></a><a id="reg_expand_sz"></a><dl>
     * <dt><b>REG_EXPAND_SZ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A Unicode string that contains unexpanded references to environment variables such as "%PATH%". Applications should ensure that the string has a terminating null character before using it. For details about when the string does not have a terminating null character, see <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regqueryvalueexa">RegQueryValueEx</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="REG_MULTI_SZ"></a><a id="reg_multi_sz"></a><dl>
     * <dt><b>REG_MULTI_SZ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An array of null-terminated Unicode strings. Applications should ensure that the array is properly terminated by two null characters before using it. For details about when the array is not  terminated by two null characters, see <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regqueryvalueexa">RegQueryValueEx</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="REG_SZ"></a><a id="reg_sz"></a><dl>
     * <dt><b>REG_SZ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A Unicode string. Applications should ensure that the string has a terminating null character before using it. For details about when the string does not have a terminating null character, see <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regqueryvalueexa">RegQueryValueEx</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The <i>pdwValueType</i> parameter can be <b>NULL</b> if a returned type is not required.
     * @param {Pointer} pbValueData A pointer to a buffer to receive the value associated with the <i>pwszValueName</i> parameter. The buffer must be big enough to contain the terminating <b>NULL</b> character. This parameter can be <b>NULL</b> if returned data is not required.
     * 
     * This parameter can also be <b>NULL</b> to find the size of the buffer for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbValueData A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pbValueData</i>.
     * 
     * In most cases the value returned in *<i>pcbValueData</i> includes the size of the terminating <b>NULL</b> character in the string.  For information about situations where the <b>NULL</b> character is not included, see the Remarks section of <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regqueryvalueexa">RegQueryValueEx</a>.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * This function has the following error code.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbValueData</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbValueData</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptgetoidfunctionvalue
     * @since windows5.1.2600
     */
    static CryptGetOIDFunctionValue(dwEncodingType, pszFuncName, pszOID, pwszValueName, pdwValueType, pbValueData, pcbValueData) {
        pszFuncName := pszFuncName is String ? StrPtr(pszFuncName) : pszFuncName
        pszOID := pszOID is String ? StrPtr(pszOID) : pszOID
        pwszValueName := pwszValueName is String ? StrPtr(pwszValueName) : pwszValueName

        pdwValueTypeMarshal := pdwValueType is VarRef ? "uint*" : "ptr"
        pcbValueDataMarshal := pcbValueData is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptGetOIDFunctionValue", "uint", dwEncodingType, "ptr", pszFuncName, "ptr", pszOID, "ptr", pwszValueName, pdwValueTypeMarshal, pdwValueType, "ptr", pbValueData, pcbValueDataMarshal, pcbValueData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptEnumOIDFunction function enumerates the registered object identifier (OID) functions.
     * @param {Integer} dwEncodingType Specifies the encoding type to match. Setting this parameter to CRYPT_MATCH_ANY_ENCODING_TYPE matches any encoding type. Note that if CRYPT_MATCH_ANY_ENCODING_TYPE is not specified, either a certificate or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> is required. If the low-order word that contains the certificate encoding type is nonzero, it is used; otherwise, the high-order word that contains the message encoding type is used. If both are specified, the certificate encoding type in the low-order word is used. 
     * 
     * 
     * 
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>CRYPT_ASN_ENCODING</li>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * <li>CRYPT_MATCH_ANY_ENCODING_TYPE</li>
     * </ul>
     * @param {PSTR} pszFuncName Name of a function for which a case insensitive match search is performed. Setting this parameter to <b>NULL</b> results in a match being found for any function name.
     * @param {PSTR} pszOID If the high-order word of <i>pszOID</i> is nonzero, <i>pszOID</i> specifies the object identifier for which a case insensitive match search is performed. If the high-order word of <i>pszOID</i> is zero, <i>pszOID</i> is used to match a numeric object identifier. Setting this parameter to <b>NULL</b> matches any object identifier. Setting this parameter to CRYPT_DEFAULT_OID restricts the enumeration to only the default functions.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Void>} pvArg A pointer to arguments to be passed through to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nc-wincrypt-pfn_crypt_enum_oid_func">CRYPT_ENUM_OID_FUNCTION</a> callback function.
     * @param {Pointer<PFN_CRYPT_ENUM_OID_FUNC>} pfnEnumOIDFunc A pointer to the callback function that is executed for each OID function that matches the input parameters. For details, see <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nc-wincrypt-pfn_crypt_enum_oid_func">CRYPT_ENUM_OID_FUNCTION</a>.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptenumoidfunction
     * @since windows5.1.2600
     */
    static CryptEnumOIDFunction(dwEncodingType, pszFuncName, pszOID, dwFlags, pvArg, pfnEnumOIDFunc) {
        pszFuncName := pszFuncName is String ? StrPtr(pszFuncName) : pszFuncName
        pszOID := pszOID is String ? StrPtr(pszOID) : pszOID

        pvArgMarshal := pvArg is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptEnumOIDFunction", "uint", dwEncodingType, "ptr", pszFuncName, "ptr", pszOID, "uint", dwFlags, pvArgMarshal, pvArg, "ptr", pfnEnumOIDFunc, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the first predefined or registered CRYPT_OID_INFO structure that matches a specified key type and key. The search can be limited to object identifiers (OIDs) within a specified OID group.
     * @param {Integer} dwKeyType Specifies the key type to use when finding OID information. 
     * 
     * 
     * This parameter can be one of the following key types.
     * @param {Pointer<Void>} pvKey The address of a buffer that contains additional search information. This parameter depends on the value of the <i>dwKeyType</i> parameter. For more information, see the table under <i>dwKeyType</i>.
     * @param {Integer} dwGroupId The group identifier to use when finding OID information. Setting this parameter to zero searches all groups according to the <i>dwKeyType</i> parameter. Otherwise, only the indicated <i>dwGroupId</i> is searched.
     * 
     * For information about code that lists the OID information by group identifier, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptenumoidinfo">CryptEnumOIDInfo</a>.
     * 
     * 
     * Optionally, the following flag can be specified in the <i>dwGroupId</i> parameter by using the logical <b>OR</b> operator (|).
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_OID_DISABLE_SEARCH_DS_FLAG"></a><a id="crypt_oid_disable_search_ds_flag"></a><dl>
     * <dt><b>CRYPT_OID_DISABLE_SEARCH_DS_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Disables searching the directory server.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The bit length shifted left 16 bits can be specified in the <i>dwGroupId</i> parameter by using the logical <b>OR</b> operator (|). For more information, see Remarks.
     * @returns {Pointer<CRYPT_OID_INFO>} Returns a pointer to a constant structure of type <a href="/windows/desktop/api/wincrypt/ns-wincrypt-crypt_oid_info">CRYPT_OID_INFO</a>. The returned pointer must not be freed. When the specified key and group is not found, <b>NULL</b> is returned.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptfindoidinfo
     * @since windows5.1.2600
     */
    static CryptFindOIDInfo(dwKeyType, pvKey, dwGroupId) {
        pvKeyMarshal := pvKey is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPT32.dll\CryptFindOIDInfo", "uint", dwKeyType, pvKeyMarshal, pvKey, "uint", dwGroupId, "ptr")
        return result
    }

    /**
     * The CryptRegisterOIDInfo function registers the OID information specified in the CRYPT_OID_INFO structure, persisting it to the registry.
     * @param {Pointer<CRYPT_OID_INFO>} pInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_oid_info">CRYPT_OID_INFO</a> structure with the OID information to register. Specify the group that the OID information is to be registered for by setting the <b>dwGroupId</b> member of the structure.
     * 
     * <div class="alert"><b>Note</b><p class="note">When registering OID information for <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">Suite B</a> algorithms implemented with <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-portal">Cryptography API: Next Generation</a> (CNG), you must set the <b>Algid</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_oid_info">CRYPT_OID_INFO</a> structure to <b>CALG_OID_INFO_CNG_ONLY</b> (0xFFFFFFFF).
     * 
     * </div>
     * <div></div>
     * @param {Integer} dwFlags By default, the registered OID information is installed after Crypt32.dll's OID entries. If CRYPT_INSTALL_OID_INFO_BEFORE_FLAG is set, new OID information is install before Crypt32.dll's entries.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptregisteroidinfo
     * @since windows5.1.2600
     */
    static CryptRegisterOIDInfo(pInfo, dwFlags) {
        result := DllCall("CRYPT32.dll\CryptRegisterOIDInfo", "ptr", pInfo, "uint", dwFlags, "int")
        return result
    }

    /**
     * The CryptUnregisterOIDInfo function removes the registration of a specified CRYPT_OID_INFO OID information structure. The structure to be unregistered is identified by the structure's pszOID and dwGroupId members.
     * @param {Pointer<CRYPT_OID_INFO>} pInfo Specifies the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) information for which the registration is to be removed. The group that the registration is removed for is specified by the <b>dwGroupId</b> member in the <i>pInfo</i>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptunregisteroidinfo
     * @since windows5.1.2600
     */
    static CryptUnregisterOIDInfo(pInfo) {
        result := DllCall("CRYPT32.dll\CryptUnregisterOIDInfo", "ptr", pInfo, "int")
        return result
    }

    /**
     * Enumerates predefined and registered object identifier (OID) CRYPT_OID_INFO structures. This function enumerates either all of the predefined and registered structures or only structures identified by a selected OID group.
     * @param {Integer} dwGroupId Indicates which OID groups to be matched. Setting <i>dwGroupId</i> to zero matches all groups. If <i>dwGroupId</i> is greater than zero, only the OID entries in the specified group are enumerated. 
     * 
     * 
     * 
     * 
     * The currently defined OID group IDs are:
     * 
     * <ul>
     * <li>CRYPT_HASH_ALG_OID_GROUP_ID</li>
     * <li>CRYPT_ENCRYPT_ALG_OID_GROUP_ID</li>
     * <li>CRYPT_PUBKEY_ALG_OID_GROUP_ID</li>
     * <li>CRYPT_SIGN_ALG_OID_GROUP_ID</li>
     * <li>CRYPT_RDN_ATTR_OID_GROUP_ID</li>
     * <li>CRYPT_EXT_OR_ATTR_OID_GROUP_ID</li>
     * <li>CRYPT_ENHKEY_USAGE_OID_GROUP_ID</li>
     * <li>CRYPT_POLICY_OID_GROUP_ID</li>
     * <li>CRYPT_TEMPLATE_OID_GROUP_ID</li>
     * <li>CRYPT_KDF_OID_GROUP_ID<b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP:</b>The CRYPT_KDF_OID_GROUP_ID value is not supported.
     * 
     * </li>
     * <li>CRYPT_LAST_OID_GROUP_ID</li>
     * <li>CRYPT_FIRST_ALG_OID_GROUP_ID</li>
     * <li>CRYPT_LAST_ALG_OID_GROUP_ID</li>
     * </ul>
     * @param {Integer} dwFlags This parameter is reserved for future use. It must be zero.
     * @param {Pointer<Void>} pvArg A pointer to arguments to be passed through to the callback function.
     * @param {Pointer<PFN_CRYPT_ENUM_OID_INFO>} pfnEnumOIDInfo A pointer to the callback function that is executed for each OID information entry enumerated. For information about the callback parameters, see <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nc-wincrypt-pfn_crypt_enum_oid_info">CRYPT_ENUM_OID_INFO</a>.
     * @returns {BOOL} If the callback function  completes the enumeration, this function returns <b>TRUE</b>. 
     * 
     * If the callback function has stopped the enumeration, this function returns <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptenumoidinfo
     * @since windows5.1.2600
     */
    static CryptEnumOIDInfo(dwGroupId, dwFlags, pvArg, pfnEnumOIDInfo) {
        pvArgMarshal := pvArg is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPT32.dll\CryptEnumOIDInfo", "uint", dwGroupId, "uint", dwFlags, pvArgMarshal, pvArg, "ptr", pfnEnumOIDInfo, "int")
        return result
    }

    /**
     * Finds the localized name for the specified name, such as the localize name of the &quot;Root&quot; system store.
     * @param {PWSTR} pwszCryptName A pointer to a specified name. An internal table is searched to compare a predefined localized name to the specified name. The search matches the localized name by using a case insensitive string comparison. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>Localized names for the predefined system stores ("Root", "My") and predefined physical stores (".Default", ".LocalMachine") are preinstalled as resource strings in Crypt32.dll.</div>
     * <div></div>
     * @returns {PWSTR} If the specified name is found, a pointer to the localized name is returned. The returned pointer must not be freed.
     * 						
     * 
     * If the specified name is not found, <b>NULL</b> is returned.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptfindlocalizedname
     * @since windows5.1.2600
     */
    static CryptFindLocalizedName(pwszCryptName) {
        pwszCryptName := pwszCryptName is String ? StrPtr(pwszCryptName) : pwszCryptName

        result := DllCall("CRYPT32.dll\CryptFindLocalizedName", "ptr", pwszCryptName, "ptr")
        return result
    }

    /**
     * Opens a cryptographic message for encoding and returns a handle of the opened message.
     * @param {Integer} dwMsgEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Integer} dwFlags Currently defined <i>dwFlags</i> are shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_BARE_CONTENT_FLAG"></a><a id="cmsg_bare_content_flag"></a><dl>
     * <dt><b>CMSG_BARE_CONTENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The streamed output will not have an outer ContentInfo wrapper (as defined by PKCS #7). This makes it suitable to be streamed into an enclosing message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_DETACHED_FLAG"></a><a id="cmsg_detached_flag"></a><dl>
     * <dt><b>CMSG_DETACHED_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is detached data being supplied for the subsequent calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_AUTHENTICATED_ATTRIBUTES_FLAG"></a><a id="cmsg_authenticated_attributes_flag"></a><dl>
     * <dt><b>CMSG_AUTHENTICATED_ATTRIBUTES_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authenticated attributes are forced to be included in the SignerInfo (as defined by PKCS #7) in cases where they would not otherwise be required.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CONTENTS_OCTETS_FLAG"></a><a id="cmsg_contents_octets_flag"></a><dl>
     * <dt><b>CMSG_CONTENTS_OCTETS_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used when calculating the size of a message that has been encoded by using <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">Distinguished Encoding Rules</a> (DER) and that is nested inside an enveloped message. This is particularly useful when performing streaming.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CMS_ENCAPSULATED_CONTENT_FLAG"></a><a id="cmsg_cms_encapsulated_content_flag"></a><dl>
     * <dt><b>CMSG_CMS_ENCAPSULATED_CONTENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When set, non-data type-<a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">inner content</a> is encapsulated within an OCTET STRING. Applicable to both signed and enveloped messages.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CRYPT_RELEASE_CONTEXT_FLAG"></a><a id="cmsg_crypt_release_context_flag"></a><dl>
     * <dt><b>CMSG_CRYPT_RELEASE_CONTEXT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If set, the <b>hCryptProv</b> that is passed to this function is released on the final <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a>. The handle is not released if the function fails.
     * 
     * 
     * <div class="alert"><b>Note</b>The <b>hCryptProv</b>s of the envelope recipients are not released.</div>
     * <div></div>
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwMsgType 
     * @param {Pointer<Void>} pvMsgEncodeInfo The address of a structure that contains the encoding information. The type of data depends on the value of the <i>dwMsgType</i> parameter. For details, see <i>dwMsgType</i>.
     * @param {PSTR} pszInnerContentObjID If <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcalculateencodedlength">CryptMsgCalculateEncodedLength</a> is called and the data for 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a> has already been message encoded, the appropriate <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) is passed in <i>pszInnerContentObjID</i>. If <i>pszInnerContentObjID</i> is <b>NULL</b>, then the inner content type is assumed not to have been previously encoded and is therefore encoded as an octet string and given the type CMSG_DATA.
     * 
     * <div class="alert"><b>Note</b>When streaming is being used, <i>pszInnerContentObjID</i> must be either <b>NULL</b> or szOID_RSA_data.</div>
     * <div></div>
     * The following algorithm OIDs are commonly used. A user can define new inner content usage by ensuring that the sender and receiver of the message agree upon the semantics associated with the OID.
     * 
     * <ul>
     * <li>szOID_RSA_data</li>
     * <li>szOID_RSA_signedData</li>
     * <li>szOID_RSA_envelopedData</li>
     * <li>szOID_RSA_signEnvData</li>
     * <li>szOID_RSA_digestedData</li>
     * <li>szOID_RSA_encryptedData</li>
     * <li>SPC_INDIRECT_DATA_OBJID</li>
     * </ul>
     * @param {Pointer<CMSG_STREAM_INFO>} pStreamInfo When streaming is being used, this parameter is the address of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_stream_info">CMSG_STREAM_INFO</a> structure. The callback function specified by the <b>pfnStreamOutput</b> member of the <b>CMSG_STREAM_INFO</b> structure is called when 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a> is executed. The callback is passed the encoded bytes that result from the encoding. For more information about how to use the callback, see 
     * <b>CMSG_STREAM_INFO</b>.
     * 
     * <div class="alert"><b>Note</b>When streaming is being used, the application must not release any data handles that are passed in the <i>pvMsgEncodeInfo</i> parameter, such as the provider handle in the <b>hCryptProv</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signer_encode_info">CMSG_SIGNER_ENCODE_INFO</a> structure, until after the message handle returned by this function is closed by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgclose">CryptMsgClose</a> function.</div>
     * <div></div>
     * When streaming is not being used, this parameter is set to <b>NULL</b>.
     * 
     * Streaming is not used with the <b>CMSG_HASHED</b> message type. When dealing with hashed data, this parameter must be set to <b>NULL</b>.
     * 
     * Consider the case of a signed message being enclosed in an enveloped message. The encoded output from the streamed encoding of the signed message feeds into another streaming encoding of the enveloped message. The callback for the streaming encoding calls <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a> to encode the enveloped message. The callback for the enveloped message receives the encoded bytes of the nested signed message.
     * @returns {Pointer<Void>} If the function succeeds, it returns a handle to the opened message. This handle must be closed when it is no longer needed by passing it to the <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgclose">CryptMsgClose</a> function.
     * 
     * If this function fails, <b>NULL</b> is returned.
     * 
     * To retrieve extended error information, use the 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following table lists the error codes most commonly returned by the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_INVALID_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message type is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_OID_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The OID is badly formatted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNKNOWN_ALGO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The cryptographic algorithm is unknown.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is not enough memory.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * In addition, if <i>dwMsgType</i> is CMSG_SIGNED, errors can be propagated from 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>.
     * 
     * If <i>dwMsgType</i> is CMSG_ENVELOPED, errors can be propagated from 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a>, and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a>.
     * 
     * If <i>dwMsgType</i> is CMSG_HASHED, errors can be propagated from 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmsgopentoencode
     * @since windows5.1.2600
     */
    static CryptMsgOpenToEncode(dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, pStreamInfo) {
        pszInnerContentObjID := pszInnerContentObjID is String ? StrPtr(pszInnerContentObjID) : pszInnerContentObjID

        pvMsgEncodeInfoMarshal := pvMsgEncodeInfo is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgOpenToEncode", "uint", dwMsgEncodingType, "uint", dwFlags, "uint", dwMsgType, pvMsgEncodeInfoMarshal, pvMsgEncodeInfo, "ptr", pszInnerContentObjID, "ptr", pStreamInfo, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Calculates the maximum number of bytes needed for an encoded cryptographic message given the message type, encoding parameters, and total length of the data to be encoded.
     * @param {Integer} dwMsgEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Integer} dwFlags Currently defined flags are shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_BARE_CONTENT_FLAG"></a><a id="cmsg_bare_content_flag"></a><dl>
     * <dt><b>CMSG_BARE_CONTENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that streamed output will not have an outer ContentInfo wrapper (as defined by PKCS #7). This makes it suitable to be streamed into an enclosing message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_DETACHED_FLAG"></a><a id="cmsg_detached_flag"></a><dl>
     * <dt><b>CMSG_DETACHED_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that there is detached data being supplied for the subsequent calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CONTENTS_OCTETS_FLAG"></a><a id="cmsg_contents_octets_flag"></a><dl>
     * <dt><b>CMSG_CONTENTS_OCTETS_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used to calculate the size of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">DER</a> encoding of a message to be nested inside an enveloped message. This is particularly useful when streaming is being performed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CMS_ENCAPSULATED_CONTENT_FLAG"></a><a id="cmsg_cms_encapsulated_content_flag"></a><dl>
     * <dt><b>CMSG_CMS_ENCAPSULATED_CONTENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Non-Data type <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">inner content</a> is encapsulated within an OCTET STRING. This flag is applicable for both Signed and Enveloped messages.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwMsgType Currently defined message types are shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_DATA"></a><a id="cmsg_data"></a><dl>
     * <dt><b>CMSG_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An octet (BYTE) string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNED"></a><a id="cmsg_signed"></a><dl>
     * <dt><b>CMSG_SIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signed_encode_info">CMSG_SIGNED_ENCODE_INFO</a>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ENVELOPED"></a><a id="cmsg_enveloped"></a><dl>
     * <dt><b>CMSG_ENVELOPED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_enveloped_encode_info">CMSG_ENVELOPED_ENCODE_INFO</a>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNED_AND_ENVELOPED"></a><a id="cmsg_signed_and_enveloped"></a><dl>
     * <dt><b>CMSG_SIGNED_AND_ENVELOPED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not implemented.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_HASHED"></a><a id="cmsg_hashed"></a><dl>
     * <dt><b>CMSG_HASHED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_hashed_encode_info">CMSG_HASHED_ENCODE_INFO</a>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ENCRYPTED"></a><a id="cmsg_encrypted"></a><dl>
     * <dt><b>CMSG_ENCRYPTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not implemented.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvMsgEncodeInfo A pointer to the data to be encoded. The type of data pointed to depends on the value of <i>dwMsgType</i>. For details, see the <i>dwMsgType</i> table.
     * @param {PSTR} pszInnerContentObjID When calling <b>CryptMsgCalculateEncodedLength</b> with data provided to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a> already encoded, the appropriate object identifier is passed in <i>pszInnerContentObjID</i>. If <i>pszInnerContentObjID</i> is <b>NULL</b>, the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">inner content</a> type is assumed not to have been previously encoded, and is encoded as an octet string and given the type CMSG_DATA. 
     * 
     * 
     * 
     * 
     * When streaming is being used, <i>pszInnerContentObjID</i> must be either <b>NULL</b> or szOID_RSA_data.
     * 
     * The following algorithm object identifiers are commonly used:
     * 
     * <ul>
     * <li>szOID_RSA_data</li>
     * <li>szOID_RSA_signedData</li>
     * <li>szOID_RSA_envelopedData</li>
     * <li>szOID_RSA_signEnvData</li>
     * <li>szOID_RSA_digestedData</li>
     * <li>szOID_RSA_encryptedData</li>
     * <li>SPC_INDIRECT_DATA_OBJID</li>
     * </ul>
     * A user can define new <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">inner content</a> usage. The user must ensure that the sender and receiver of the message agree upon the semantics associated with the object identifier.
     * @param {Integer} cbData The size, in bytes, of the content.
     * @returns {Integer} Returns the required length for an encoded cryptographic message. This length might not be the exact length but it will not be less than the required length. Zero is returned if the function fails.
     * 
     * To retrieve extended error information, use the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function. The following table lists the error codes most commonly returned.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_INVALID_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message type is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNKNOWN_ALGO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The cryptographic algorithm is unknown.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmsgcalculateencodedlength
     * @since windows5.1.2600
     */
    static CryptMsgCalculateEncodedLength(dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, cbData) {
        pszInnerContentObjID := pszInnerContentObjID is String ? StrPtr(pszInnerContentObjID) : pszInnerContentObjID

        pvMsgEncodeInfoMarshal := pvMsgEncodeInfo is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgCalculateEncodedLength", "uint", dwMsgEncodingType, "uint", dwFlags, "uint", dwMsgType, pvMsgEncodeInfoMarshal, pvMsgEncodeInfo, "ptr", pszInnerContentObjID, "uint", cbData, "uint")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Opens a cryptographic message for decoding and returns a handle of the opened message.
     * @param {Integer} dwMsgEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Integer} dwFlags This parameter can be one of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_DETACHED_FLAG"></a><a id="cmsg_detached_flag"></a><dl>
     * <dt><b>CMSG_DETACHED_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the message to be decoded is detached. If this flag is not set, the message is not detached.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CRYPT_RELEASE_CONTEXT_FLAG"></a><a id="cmsg_crypt_release_context_flag"></a><dl>
     * <dt><b>CMSG_CRYPT_RELEASE_CONTEXT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If set, the <i>hCryptProv</i> passed to this function is released on the final <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a>. The handle is not released if the function fails.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwMsgType Specifies the type of message to decode. In most cases, the message type is determined from the message header and zero is passed for this parameter. In some cases, notably with Internet Explorer 3.0, messages do not have headers and the type of message to be decoded must be supplied in this function call. If the header is missing and zero is passed for this parameter, the function fails.
     * 
     * 
     * This parameter can be one of the following predefined message types.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_DATA"></a><a id="cmsg_data"></a><dl>
     * <dt><b>CMSG_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is encoded data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ENVELOPED"></a><a id="cmsg_enveloped"></a><dl>
     * <dt><b>CMSG_ENVELOPED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is an enveloped message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_HASHED"></a><a id="cmsg_hashed"></a><dl>
     * <dt><b>CMSG_HASHED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is a hashed message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNED"></a><a id="cmsg_signed"></a><dl>
     * <dt><b>CMSG_SIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is a signed message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNED_AND_ENVELOPED"></a><a id="cmsg_signed_and_enveloped"></a><dl>
     * <dt><b>CMSG_SIGNED_AND_ENVELOPED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is a signed and enveloped message.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {HCRYPTPROV_LEGACY} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>Specifies a handle for the cryptographic provider to use for <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hashing</a> the message. For signed messages, <i>hCryptProv</i> is used for signature verification.This parameter's data type is <b>HCRYPTPROV</b>.
     * 
     * Unless there is a strong reason for passing in a specific cryptographic provider in <i>hCryptProv</i>, set this parameter to <b>NULL</b>. Passing in <b>NULL</b> causes the default RSA or DSS provider to be acquired before performing hash, signature verification, or recipient encryption operations.
     * @param {Pointer<CMSG_STREAM_INFO>} pStreamInfo When streaming is not being used, this parameter must be set to <b>NULL</b>.
     * 
     * 
     * <div class="alert"><b>Note</b>Streaming is not used with CMSG_HASHED messages. When dealing with hashed data, this parameter must be set to <b>NULL</b>.</div>
     * <div></div>
     * 
     * 
     * When streaming is being used, the <i>pStreamInfo</i> parameter is a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_stream_info">CMSG_STREAM_INFO</a> structure that contains a pointer to a callback to be called when 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a> is executed or when 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcontrol">CryptMsgControl</a> is executed when decoding a streamed enveloped message.
     * 
     * For a signed message, the callback is passed a block of the decoded bytes from the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">inner content</a> of the message.
     * 
     * For an enveloped message, after each call to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a>, you must check to determine whether the CMSG_ENVELOPE_ALGORITHM_PARAM property is available by calling 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsggetparam">CryptMsgGetParam</a> function. <b>CryptMsgGetParam</b> will fail and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return CRYPT_E_STREAM_MSG_NOT_READY until 
     * <b>CryptMsgUpdate</b> has processed enough of the message to make the CMSG_ENVELOPE_ALGORITHM_PARAM property available. When the CMSG_ENVELOPE_ALGORITHM_PARAM property is available, you can iterate through the recipients, retrieving a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure for each recipient by using the <b>CryptMsgGetParam</b> function to retrieve the CMSG_RECIPIENT_INFO_PARAM property. To prevent a denial of service attack from an enveloped message that has an artificially large header block, you must keep track of the amount of memory that has been passed to the <b>CryptMsgUpdate</b> function during this process.  If the amount of data exceeds an application defined limit before the CMSG_ENVELOPE_ALGORITHM_PARAM property is available, you must stop processing the message and call the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgclose">CryptMsgClose</a> function to cause the operating system to release any memory that has been allocated for the message. A suggested limit is the maximum allowable size of a message. For example, if the maximum message size is 10 MB, the limit for this test should be 10 MB.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure is used to find a matching certificate in a previously opened <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a> by using 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetsubjectcertificatefromstore">CertGetSubjectCertificateFromStore</a> function. When the correct certificate is found, 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatecontextproperty">CertGetCertificateContextProperty</a> function with a CERT_KEY_PROV_INFO_PROP_ID parameter is called to retrieve a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a> structure. The structure contains the information necessary to acquire the recipient's private key by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>, using the <b>pwszContainerName</b>, <b>pwszProvName</b>, <b>dwProvType</b>, and <b>dwFlags</b> members of the <b>CRYPT_KEY_PROV_INFO</b> structure. The <b>hCryptProv</b> acquired and the <b>dwKeySpec</b> member of the <b>CRYPT_KEY_PROV_INFO</b> structure are passed to 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcontrol">CryptMsgControl</a> structure as a member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_ctrl_decrypt_para">CMSG_CTRL_DECRYPT_PARA</a> structure to permit the start of the decryption of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">inner content</a>. The streaming code will then perform the decryption as the data is input. The resulting blocks of <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">plaintext</a> are passed to the callback function specified by the <b>pfnStreamOutput</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_stream_info">CMSG_STREAM_INFO</a> structure to handle the output of the decrypted message.
     * 
     * 
     * <div class="alert"><b>Note</b>Streamed decoding of an enveloped message queues the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">ciphertext</a> in memory until <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcontrol">CryptMsgControl</a> is called to start the decryption. The application must initiate decrypting in a timely manner so that the data can be saved to disk or routed elsewhere before the accumulated <i>ciphertext</i> becomes too large and the system runs out of memory.</div>
     * <div></div>
     * 
     * 
     * In the case of a signed message enclosed in an enveloped message, the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">plaintext</a> output from the streaming decode of the enveloped message can be fed into another streaming decode to process the signed message.
     * @returns {Pointer<Void>} If the function succeeds, the function returns the handle of the opened message.
     * 
     * If the function fails, it returns <b>NULL</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table lists the error codes most commonly returned by the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmsgopentodecode
     * @since windows5.1.2600
     */
    static CryptMsgOpenToDecode(dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pStreamInfo) {
        static pRecipientInfo := 0 ;Reserved parameters must always be NULL

        hCryptProv := hCryptProv is Win32Handle ? NumGet(hCryptProv, "ptr") : hCryptProv

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgOpenToDecode", "uint", dwMsgEncodingType, "uint", dwFlags, "uint", dwMsgType, "ptr", hCryptProv, "ptr", pRecipientInfo, "ptr", pStreamInfo, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptMsgDuplicate function duplicates a cryptographic message handle by incrementing its reference count.
     * @param {Pointer<Void>} hCryptMsg Handle of the cryptographic message to be duplicated. Duplication is done by incrementing the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> of the message. A copy of the message is not made.
     * @returns {Pointer<Void>} The returned handle is the same as the handle input. A copy of the message is not created. When you have finished using the duplicated message handle, decrease the reference count by calling the <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgclose">CryptMsgClose</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmsgduplicate
     * @since windows5.1.2600
     */
    static CryptMsgDuplicate(hCryptMsg) {
        hCryptMsgMarshal := hCryptMsg is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPT32.dll\CryptMsgDuplicate", hCryptMsgMarshal, hCryptMsg, "ptr")
        return result
    }

    /**
     * The CryptMsgClose function closes a cryptographic message handle. At each call to this function, the reference count on the message is reduced by one. When the reference count reaches zero, the message is fully released.
     * @param {Pointer<Void>} hCryptMsg Handle of the cryptographic message to be closed.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmsgclose
     * @since windows5.1.2600
     */
    static CryptMsgClose(hCryptMsg) {
        hCryptMsgMarshal := hCryptMsg is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgClose", hCryptMsgMarshal, hCryptMsg, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Adds contents to a cryptographic message.
     * @param {Pointer<Void>} hCryptMsg Cryptographic message handle of the message to be updated.
     * @param {Pointer} pbData A pointer to the buffer holding the data to be encoded or decoded.
     * @param {Integer} cbData Number of bytes of data in the <i>pbData</i> buffer.
     * @param {BOOL} fFinal Indicates that the last block of data for encoding or decoding is being processed. Correct usage of this flag is dependent upon whether the message being processed has detached data. The inclusion of detached data in a message is indicated by setting <i>dwFlags</i> to CMSG_DETACHED_FLAG in the call to the function that opened the message. 
     * 
     * 
     * 
     * 
     * If CMSG_DETACHED_FLAG was not set and the message was opened using either 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentoencode">CryptMsgOpenToEncode</a>, <i>fFinal</i> is set to <b>TRUE</b>, and <b>CryptMsgUpdate</b> is only called once.
     * 
     * If the CMSG_DETACHED_FLAG flag was set and a message is opened using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentoencode">CryptMsgOpenToEncode</a>, <i>fFinal</i> is set to <b>TRUE</b> only on the last call to <b>CryptMsgUpdate</b>.
     * 
     * If the CMSG_DETACHED_FLAG flag was set and a message is opened using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a>, <i>fFinal</i> is set to <b>TRUE</b> when the header is processed by a single call to <b>CryptMsgUpdate</b>. It is set to <b>FALSE</b> while processing the detached data in subsequent calls to <b>CryptMsgUpdate</b> until the last detached data block is to be processed. On the last call to <b>CryptMsgUpdate</b>, it is set to <b>TRUE</b>.
     * 
     * When detached data is decoded, the header and the content of a message are contained in different BLOBs. Each BLOB requires that <i>fFinal</i> be set to <b>TRUE</b> when the last call to the function is made for that BLOB.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * Errors encountered in the application defined callback function specified by <i>pStreamInfo</i> in 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a> and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentoencode">CryptMsgOpenToEncode</a> might be propagated to <b>CryptMsgUpdate</b> if streaming is used. If this happens, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> is not called by <b>CryptMsgUpdate</b> after the callback function returns, which preserves any errors encountered under the control of the application. It is the responsibility of the callback function (or one of the APIs that it calls) to call <b>SetLastError</b> if an error occurs while the application is processing the streamed data.
     * 
     * The following table lists the error codes most commonly returned by the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_INVALID_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message type is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_MSG_ERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error was encountered doing a cryptographic operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_OID_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The object identifier is badly formatted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_ENCODING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is not encoded as expected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNKNOWN_ALGO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The cryptographic algorithm is unknown.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ran out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Propagated errors might be encountered from any of the following functions:<ul>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetkeyparam">CryptGetKeyParam</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptencrypt">CryptEncrypt</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>
     * </li>
     * </ul>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmsgupdate
     * @since windows5.1.2600
     */
    static CryptMsgUpdate(hCryptMsg, pbData, cbData, fFinal) {
        hCryptMsgMarshal := hCryptMsg is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgUpdate", hCryptMsgMarshal, hCryptMsg, "ptr", pbData, "uint", cbData, "int", fFinal, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Acquires a message parameter after a cryptographic message has been encoded or decoded.
     * @param {Pointer<Void>} hCryptMsg Handle of a cryptographic message.
     * @param {Integer} dwParamType Indicates the parameter types of data to be retrieved. The type of data to be retrieved determines the type of structure to use for <i>pvData</i>. 
     * 
     * 
     * 
     * 
     * For an encoded message, only the CMSG_BARE_CONTENT, CMSG_ENCODE_SIGNER, CMSG_CONTENT_PARAM and CMSG_COMPUTED_HASH_PARAM <i>dwParamType</i>s are valid.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ATTR_CERT_COUNT_PARAM"></a><a id="cmsg_attr_cert_count_param"></a><dl>
     * <dt><b>CMSG_ATTR_CERT_COUNT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>DWORD</b>
     * 
     *  Returns the count of the attribute certificates in a SIGNED or ENVELOPED message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ATTR_CERT_PARAM"></a><a id="cmsg_attr_cert_param"></a><dl>
     * <dt><b>CMSG_ATTR_CERT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Retrieves an attribute certificate. To get all the attribute certificates, call <b>CryptMsgGetParam</b> varying <i>dwIndex</i> set to 0 the number of attributes minus one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_BARE_CONTENT_PARAM"></a><a id="cmsg_bare_content_param"></a><dl>
     * <dt><b>CMSG_BARE_CONTENT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Retrieves the encoded content of an encoded cryptographic message, without the outer layer of the CONTENT_INFO structure. That is, only the encoding of the PKCS #7 defined ContentInfo.content field is returned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CERT_COUNT_PARAM"></a><a id="cmsg_cert_count_param"></a><dl>
     * <dt><b>CMSG_CERT_COUNT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to <b>DWORD</b>
     * 
     * Returns the number of certificates in a received SIGNED or ENVELOPED message.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CERT_PARAM"></a><a id="cmsg_cert_param"></a><dl>
     * <dt><b>CMSG_CERT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Returns a signer's certificate. To get all of the signer's certificates, call <b>CryptMsgGetParam</b>, varying <i>dwIndex</i> from 0 to the number of available certificates minus one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_COMPUTED_HASH_PARAM"></a><a id="cmsg_computed_hash_param"></a><dl>
     * <dt><b>CMSG_COMPUTED_HASH_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Returns the  hash calculated of the data in the message. This type is applicable to both encode and decode.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CONTENT_PARAM"></a><a id="cmsg_content_param"></a><dl>
     * <dt><b>CMSG_CONTENT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     *  
     * 
     * 
     * Returns the whole PKCS #7 message from a message opened to encode. Retrieves the inner content of a message opened to decode. If the message is enveloped, the inner type is data, and <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcontrol">CryptMsgControl</a> has been called to decrypt the message, the decrypted content is returned. If the inner type is not data, the encoded BLOB that requires further decoding is returned.
     * If the message is not enveloped and the inner content is DATA, the returned data is the octets of the inner content.
     * This type is applicable to both encode and decode.
     * 
     * For decoding, if the type is CMSG_DATA, the content's octets are returned; else, the encoded inner content is returned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CRL_COUNT_PARAM"></a><a id="cmsg_crl_count_param"></a><dl>
     * <dt><b>CMSG_CRL_COUNT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to <b>DWORD</b>
     * 
     * Returns the count of CRLs in a received, SIGNED or ENVELOPED message.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CRL_PARAM"></a><a id="cmsg_crl_param"></a><dl>
     * <dt><b>CMSG_CRL_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Returns a CRL. To get all the CRLs, call <b>CryptMsgGetParam</b>, varying <i>dwIndex</i> from 0 to the number of available CRLs minus one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ENCODED_MESSAGE"></a><a id="cmsg_encoded_message"></a><dl>
     * <dt><b>CMSG_ENCODED_MESSAGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Changes the contents of an already encoded message. The message must first be decoded with a call to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a>. Then the change to the message is made through a call to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcontrol">CryptMsgControl</a>, <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcountersign">CryptMsgCountersign</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcountersignencoded">CryptMsgCountersignEncoded</a>. The message is then encoded again with a call to <b>CryptMsgGetParam</b>, specifying CMSG_ENCODED_MESSAGE to get a new encoding that reflects the changes made. This can be used, for instance, to add a time-stamp attribute to a message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ENCODED_SIGNER"></a><a id="cmsg_encoded_signer"></a><dl>
     * <dt><b>CMSG_ENCODED_SIGNER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Returns the encoded CMSG_SIGNER_INFO signer information for a message signer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ENCRYPTED_DIGEST"></a><a id="cmsg_encrypted_digest"></a><dl>
     * <dt><b>CMSG_ENCRYPTED_DIGEST</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Returns the encrypted hash of a signature. Typically used for performing time-stamping.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ENCRYPT_PARAM"></a><a id="cmsg_encrypt_param"></a><dl>
     * <dt><b>CMSG_ENCRYPT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array for a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_algorithm_identifier">CRYPT_ALGORITHM_IDENTIFIER</a> structure.
     * 
     *  Returns the encryption algorithm used to encrypted the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ENVELOPE_ALGORITHM_PARAM"></a><a id="cmsg_envelope_algorithm_param"></a><dl>
     * <dt><b>CMSG_ENVELOPE_ALGORITHM_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array for a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_algorithm_identifier">CRYPT_ALGORITHM_IDENTIFIER</a> structure.
     * 
     *  Returns the encryption algorithm used to encrypt an ENVELOPED message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_HASH_ALGORITHM_PARAM"></a><a id="cmsg_hash_algorithm_param"></a><dl>
     * <dt><b>CMSG_HASH_ALGORITHM_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array for a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_algorithm_identifier">CRYPT_ALGORITHM_IDENTIFIER</a> structure.
     * 
     *  Returns the hash algorithm used to hash the message when it was created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_HASH_DATA_PARAM"></a><a id="cmsg_hash_data_param"></a><dl>
     * <dt><b>CMSG_HASH_DATA_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Returns the hash value stored in the message when it was created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_INNER_CONTENT_TYPE_PARAM"></a><a id="cmsg_inner_content_type_param"></a><dl>
     * <dt><b>CMSG_INNER_CONTENT_TYPE_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a <b>null</b>-terminated <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) string.
     * 
     * Returns the inner content type of a received message. This type is not applicable to messages of type DATA.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_RECIPIENT_COUNT_PARAM"></a><a id="cmsg_recipient_count_param"></a><dl>
     * <dt><b>CMSG_RECIPIENT_COUNT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>DWORD</b>
     * 
     * Returns the number of key transport recipients of an ENVELOPED received message.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CMS_RECIPIENT_COUNT_PARAM"></a><a id="cmsg_cms_recipient_count_param"></a><dl>
     * <dt><b>CMSG_CMS_RECIPIENT_COUNT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to <b>DWORD</b>
     * 
     * Returns the total count of all message recipients including key agreement and mail list recipients.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_RECIPIENT_INDEX_PARAM"></a><a id="cmsg_recipient_index_param"></a><dl>
     * <dt><b>CMSG_RECIPIENT_INDEX_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>DWORD</b>
     * 
     * Returns the index of the key transport recipient used to decrypt an ENVELOPED message. This value is available only after a message has been decrypted.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CMS_RECIPIENT_INDEX_PARAM"></a><a id="cmsg_cms_recipient_index_param"></a><dl>
     * <dt><b>CMSG_CMS_RECIPIENT_INDEX_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>DWORD</b>
     * 
     * Returns the index of the key transport, key agreement, or mail list recipient used to decrypt an ENVELOPED message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM"></a><a id="cmsg_cms_recipient_encrypted_key_index_param"></a><dl>
     * <dt><b>CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>DWORD</b>
     * 
     * Returns the index of the encrypted key of a key agreement recipient used to decrypt an ENVELOPED message.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_RECIPIENT_INFO_PARAM"></a><a id="cmsg_recipient_info_param"></a><dl>
     * <dt><b>CMSG_RECIPIENT_INFO_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure.
     * 
     *  Returns certificate information about a key transport message's recipient. To get certificate information on all key transport message's recipients, repetitively call <b>CryptMsgGetParam</b>, varying <i>dwIndex</i> from 0 to the number of recipients minus one.
     * Only the Issuer, SerialNumber, and PublicKeyAlgorithm members of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure returned are available and valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CMS_RECIPIENT_INFO_PARAM"></a><a id="cmsg_cms_recipient_info_param"></a><dl>
     * <dt><b>CMSG_CMS_RECIPIENT_INFO_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_cms_recipient_info">CMSG_CMS_RECIPIENT_INFO</a> structure.
     * 
     * Returns information about a key transport, key agreement, or mail list recipient. It is not limited to key transport message recipients.
     * To get information on all of a message's recipients, repetitively call <b>CryptMsgGetParam</b>, varying <i>dwIndex</i> from 0 to the number of recipients minus one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNER_AUTH_ATTR_PARAM"></a><a id="cmsg_signer_auth_attr_param"></a><dl>
     * <dt><b>CMSG_SIGNER_AUTH_ATTR_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_attributes">CRYPT_ATTRIBUTES</a> structure.
     * 
     *  Returns the authenticated attributes of a message signer. To retrieve the authenticated attributes for a specified signer, call <b>CryptMsgGetParam</b> with <i>dwIndex</i> equal to that signer's index.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNER_CERT_INFO_PARAM"></a><a id="cmsg_signer_cert_info_param"></a><dl>
     * <dt><b>CMSG_SIGNER_CERT_INFO_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure.
     * 
     *  Returns information on a message signer needed to identify the signer's certificate. A certificate's Issuer and SerialNumber can be used to uniquely identify a certificate for retrieval. To retrieve information for all the signers, repetitively call <b>CryptMsgGetParam</b> varying <i>dwIndex</i> from 0 to the number of signers minus one.
     * Only the Issuer and SerialNumber fields in the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure returned contain available, valid data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNER_CERT_ID_PARAM"></a><a id="cmsg_signer_cert_id_param"></a><dl>
     * <dt><b>CMSG_SIGNER_CERT_ID_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_id">CERT_ID</a> structure.
     * 
     * Returns information on a message signer needed to identify the signer's public key. This could be a certificate's Issuer and SerialNumber, a KeyID, or a HashId. To retrieve information for all the signers, call <b>CryptMsgGetParam</b> varying <i>dwIndex</i> from 0 to the number of signers minus one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNER_COUNT_PARAM"></a><a id="cmsg_signer_count_param"></a><dl>
     * <dt><b>CMSG_SIGNER_COUNT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>DWORD</b>
     * 
     * Returns the number of signers of a received SIGNED message.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNER_HASH_ALGORITHM_PARAM"></a><a id="cmsg_signer_hash_algorithm_param"></a><dl>
     * <dt><b>CMSG_SIGNER_HASH_ALGORITHM_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_algorithm_identifier">CRYPT_ALGORITHM_IDENTIFIER</a> structure.
     * 
     *  Returns the hash algorithm used by a signer of the message. To get the hash algorithm for a specified signer, call <b>CryptMsgGetParam</b> with <i>dwIndex</i> equal to that signer's index.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNER_INFO_PARAM"></a><a id="cmsg_signer_info_param"></a><dl>
     * <dt><b>CMSG_SIGNER_INFO_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signer_info">CMSG_SIGNER_INFO</a> structure.
     * 
     *  Returns information on a message signer. This includes the issuer and serial number of the signer's certificate and authenticated and unauthenticated attributes of the signer's certificate.
     * To retrieve signer information on all of the signers of a message, call <b>CryptMsgGetParam</b> varying <i>dwIndex</i> from 0 to the number of signers minus one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CMS_SIGNER_INFO_PARAM"></a><a id="cmsg_cms_signer_info_param"></a><dl>
     * <dt><b>CMSG_CMS_SIGNER_INFO_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_cms_signer_info">CMSG_CMS_SIGNER_INFO</a> structure.
     * 
     *  Returns information on a message signer. This includes a signerId and authenticated and unauthenticated attributes.
     * To retrieve signer information on all of the signers of a message, call <b>CryptMsgGetParam</b> varying <i>dwIndex</i> from 0 to the number of signers minus one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNER_UNAUTH_ATTR_PARAM"></a><a id="cmsg_signer_unauth_attr_param"></a><dl>
     * <dt><b>CMSG_SIGNER_UNAUTH_ATTR_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_attributes">CRYPT_ATTRIBUTES</a> structure.
     * 
     *  Returns a message signer's unauthenticated attributes. To retrieve the unauthenticated attributes for a specified signer, call <b>CryptMsgGetParam</b>  with <i>dwIndex</i> equal to that signer's index.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_TYPE_PARAM"></a><a id="cmsg_type_param"></a><dl>
     * <dt><b>CMSG_TYPE_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>DWORD</b>
     * 
     * Returns the message type of a decoded message of unknown type. The retrieved message type can be compared to supported types to determine whether processing can continued. For supported message types, see the <i>dwMessageType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_UNPROTECTED_ATTR_PARAM"></a><a id="cmsg_unprotected_attr_param"></a><dl>
     * <dt><b>CMSG_UNPROTECTED_ATTR_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_attributes">CMSG_ATTR</a> structure.
     * 
     *  Returns the unprotected attributes in an enveloped message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_VERSION_PARAM"></a><a id="cmsg_version_param"></a><dl>
     * <dt><b>CMSG_VERSION_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>DWORD</b>
     * 
     *  Returns the version of the decoded message. For more information, see the table in the Remarks section.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwIndex Index for the parameter being retrieved, where applicable. When a parameter is not being retrieved, this parameter is ignored and is set to zero.
     * @param {Pointer} pvData A pointer to a buffer that receives the data retrieved. The form of this data will vary depending on the value of the <i>dwParamType</i> parameter. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * 
     * When processing the data returned in this buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.
     * @param {Pointer<Integer>} pcbData A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, the variable pointed to by the <i>pcbData</i> parameter contains the number of bytes stored in the buffer.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table lists the error codes most commonly returned by the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_ATTRIBUTES_MISSING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message does not contain the requested attributes.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_INVALID_INDEX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The index value is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_INVALID_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message type is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_DECRYPTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message content has not been decrypted yet.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_OID_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The object identifier is badly formatted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_ENCODING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is not encoded as expected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified buffer is not large enough to hold the returned data.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * For <i>dwParamType</i> CMSG_COMPUTED_HASH_PARAM, an error can be propagated from 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a>.
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmsggetparam
     * @since windows5.1.2600
     */
    static CryptMsgGetParam(hCryptMsg, dwParamType, dwIndex, pvData, pcbData) {
        hCryptMsgMarshal := hCryptMsg is VarRef ? "ptr" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgGetParam", hCryptMsgMarshal, hCryptMsg, "uint", dwParamType, "uint", dwIndex, "ptr", pvData, pcbDataMarshal, pcbData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Performs a control operation after a message has been decoded by a final call to the CryptMsgUpdate function.
     * @param {Pointer<Void>} hCryptMsg A handle of a cryptographic message for which a control is to be applied.
     * @param {Integer} dwFlags The following value is defined when the <i>dwCtrlType</i> parameter is one of the following:
     * 
     * <ul>
     * <li>CMSG_CTRL_DECRYPT</li>
     * <li>CMSG_CTRL_KEY_TRANS_DECRYPT</li>
     * <li>CMSG_CTRL_KEY_AGREE_DECRYPT</li>
     * <li>CMSG_CTRL_MAIL_LIST_DECRYPT</li>
     * </ul>
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CRYPT_RELEASE_CONTEXT_FLAG"></a><a id="cmsg_crypt_release_context_flag"></a><dl>
     * <dt><b>CMSG_CRYPT_RELEASE_CONTEXT_FLAG</b></dt>
     * <dt></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle to the cryptographic provider is released on the final call to the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgclose">CryptMsgClose</a> function. This handle is not released if the  <b>CryptMsgControl</b> function  fails.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the <i>dwCtrlType</i> parameter does not specify a decrypt operation, set this value to zero.
     * @param {Integer} dwCtrlType The type of operation to be performed. Currently defined message control types and the type of structure that should be passed to the <i>pvCtrlPara</i> parameter are shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_ADD_ATTR_CERT"></a><a id="cmsg_ctrl_add_attr_cert"></a><dl>
     * <dt><b>CMSG_CTRL_ADD_ATTR_CERT</b></dt>
     * <dt>14 (0xE)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a>  that contains the encoded bytes of attribute certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_ADD_CERT"></a><a id="cmsg_ctrl_add_cert"></a><dl>
     * <dt><b>CMSG_CTRL_ADD_CERT</b></dt>
     * <dt>10 (0xA)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A
     * 								<a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_INTEGER_BLOB</a>   structure that contains the encoded bytes of the certificate to be added to the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_ADD_CMS_SIGNER_INFO"></a><a id="cmsg_ctrl_add_cms_signer_info"></a><dl>
     * <dt><b>CMSG_CTRL_ADD_CMS_SIGNER_INFO</b></dt>
     * <dt>20 (0x14)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_cms_signer_info">CMSG_CMS_SIGNER_INFO</a> structure that contains signer information. This operation differs from <b>CMSG_CTRL_ADD_SIGNER</b> because the signer information contains the signature.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_ADD_CRL"></a><a id="cmsg_ctrl_add_crl"></a><dl>
     * <dt><b>CMSG_CTRL_ADD_CRL</b></dt>
     * <dt>12 (0xC)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A BLOB  that contains the encoded bytes of the CRL to be added to the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_ADD_SIGNER"></a><a id="cmsg_ctrl_add_signer"></a><dl>
     * <dt><b>CMSG_CTRL_ADD_SIGNER</b></dt>
     * <dt>6 (0x6)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signer_encode_info">CMSG_SIGNER_ENCODE_INFO</a>   structure that contains the signer information to be added to the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR"></a><a id="cmsg_ctrl_add_signer_unauth_attr"></a><dl>
     * <dt><b>CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR</b></dt>
     * <dt>8 (0x8)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-cmsg_ctrl_add_signer_unauth_attr_para">CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA</a>   structure that contains the index of the signer and a BLOB  that contains the unauthenticated attribute information to be added to the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DECRYPT"></a><a id="cmsg_ctrl_decrypt"></a><dl>
     * <dt><b>CMSG_CTRL_DECRYPT</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 
     * 								<a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_ctrl_decrypt_para">CMSG_CTRL_DECRYPT_PARA</a>  structure used to decrypt the message for the specified key transport recipient. This value is applicable to RSA recipients.  This operation specifies that the <b>CryptMsgControl</b> function search the recipient index to obtain the key transport recipient information.  If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return  <b>CRYPT_E_INVALID_INDEX</b> if no key transport recipient is found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_ATTR_CERT"></a><a id="cmsg_ctrl_del_attr_cert"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_ATTR_CERT</b></dt>
     * <dt>15 (0xF)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The index of the attribute certificate to be removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_CERT"></a><a id="cmsg_ctrl_del_cert"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_CERT</b></dt>
     * <dt>11 (0xB)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The index of the certificate to be deleted from the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_CRL"></a><a id="cmsg_ctrl_del_crl"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_CRL</b></dt>
     * <dt>13 (0xD)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The index of the CRL to be deleted from the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_SIGNER"></a><a id="cmsg_ctrl_del_signer"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_SIGNER</b></dt>
     * <dt>7 (0x7)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The index of the signer to be deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR"></a><a id="cmsg_ctrl_del_signer_unauth_attr"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR</b></dt>
     * <dt>9 (0x9)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-cmsg_ctrl_del_signer_unauth_attr_para">CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA</a>   structure that contains an index  that specifies the signer and the index  that specifies the signer's unauthenticated attribute to be deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_ENABLE_STRONG_SIGNATURE"></a><a id="cmsg_ctrl_enable_strong_signature"></a><dl>
     * <dt><b>CMSG_CTRL_ENABLE_STRONG_SIGNATURE</b></dt>
     * <dt>21 (0x15)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_strong_sign_para">CERT_STRONG_SIGN_PARA</a> structure used to perform strong signature checking.
     * 
     * To check for a strong signature, specify this control type before calling <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsggetandverifysigner">CryptMsgGetAndVerifySigner</a> or before calling <b>CryptMsgControl</b> with the following control types set:
     * 
     * <ul>
     * <li><b>CMSG_CTRL_VERIFY_SIGNATURE</b></li>
     * <li><b>CMSG_CTRL_VERIFY_SIGNATURE_EX</b></li>
     * </ul>
     * After the signature is successfully verified, this function checks for a strong signature. If the signature is not strong, the operation will fail and the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> value will be set to <b>NTE_BAD_ALGID</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_KEY_AGREE_DECRYPT"></a><a id="cmsg_ctrl_key_agree_decrypt"></a><dl>
     * <dt><b>CMSG_CTRL_KEY_AGREE_DECRYPT</b></dt>
     * <dt>17 (0x11)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_ctrl_key_agree_decrypt_para">CMSG_CTRL_KEY_AGREE_DECRYPT_PARA</a> structure used to decrypt the message for the specified key agreement session key. Key agreement is used with Diffie-Hellman encryption/decryption.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_KEY_TRANS_DECRYPT"></a><a id="cmsg_ctrl_key_trans_decrypt"></a><dl>
     * <dt><b>CMSG_CTRL_KEY_TRANS_DECRYPT</b></dt>
     * <dt>16 (0x10)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_ctrl_key_trans_decrypt_para">CMSG_CTRL_KEY_TRANS_DECRYPT_PARA</a> structure used to decrypt the message for the specified key transport recipient. Key transport is used with RSA encryption/decryption.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_MAIL_LIST_DECRYPT"></a><a id="cmsg_ctrl_mail_list_decrypt"></a><dl>
     * <dt><b>CMSG_CTRL_MAIL_LIST_DECRYPT</b></dt>
     * <dt>18 (0x12)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 
     * 								<a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_ctrl_mail_list_decrypt_para">CMSG_CTRL_MAIL_LIST_DECRYPT_PARA</a> structure used to decrypt the message for the specified recipient using a previously distributed key-encryption key (KEK).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_VERIFY_HASH"></a><a id="cmsg_ctrl_verify_hash"></a><dl>
     * <dt><b>CMSG_CTRL_VERIFY_HASH</b></dt>
     * <dt>5 (0x5)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_VERIFY_SIGNATURE"></a><a id="cmsg_ctrl_verify_signature"></a><dl>
     * <dt><b>CMSG_CTRL_VERIFY_SIGNATURE</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 
     * 								<a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a>  structure that identifies the signer of the message whose signature is to be verified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_VERIFY_SIGNATURE_EX"></a><a id="cmsg_ctrl_verify_signature_ex"></a><dl>
     * <dt><b>CMSG_CTRL_VERIFY_SIGNATURE_EX</b></dt>
     * <dt>19 (0x13)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-cmsg_ctrl_verify_signature_ex_para">CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA</a>   structure that specifies the signer index and public key to verify the message signature. The signer public key can be a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure, a certificate context, or a certificate chain context.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvCtrlPara A pointer to a structure determined by the value of <i>dwCtrlType</i>.
     * 
     * <table>
     * <tr>
     * <th><i>dwCtrlType</i> value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DECRYPT__CMSG_CTRL_KEY_TRANS_DECRYPT__CMSG_CTRL_KEY_AGREE_DECRYPT__or_CMSG_CTRL_MAIL_LIST_DECRYPT__and_the_streamed_enveloped_message_is_being_decoded"></a><a id="cmsg_ctrl_decrypt__cmsg_ctrl_key_trans_decrypt__cmsg_ctrl_key_agree_decrypt__or_cmsg_ctrl_mail_list_decrypt__and_the_streamed_enveloped_message_is_being_decoded"></a><a id="CMSG_CTRL_DECRYPT__CMSG_CTRL_KEY_TRANS_DECRYPT__CMSG_CTRL_KEY_AGREE_DECRYPT__OR_CMSG_CTRL_MAIL_LIST_DECRYPT__AND_THE_STREAMED_ENVELOPED_MESSAGE_IS_BEING_DECODED"></a><dl>
     * <dt><b>CMSG_CTRL_DECRYPT, CMSG_CTRL_KEY_TRANS_DECRYPT, CMSG_CTRL_KEY_AGREE_DECRYPT, or CMSG_CTRL_MAIL_LIST_DECRYPT, and the streamed enveloped message is being decoded</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Decoding will be done as if the streamed content were being decrypted. If any encrypted streamed content has accumulated prior to this call, some or all of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">plaintext</a>  that results from the decryption of the cipher text is passed back to the application through the callback function specified in the call to 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a> function.
     * 
     * <div class="alert"><b>Note</b>When streaming an enveloped message, the <b>CryptMsgControl</b>  function is not called until the polling for the availability of the CMSG_ENVELOPE_ALGORITHM_PARAM succeeds. If the polling does not succeed, an error results. For a description of that polling, see 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a> function.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_VERIFY_HASH"></a><a id="cmsg_ctrl_verify_hash"></a><dl>
     * <dt><b>CMSG_CTRL_VERIFY_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> computed from the content of the message is compared against the hash contained in the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_ADD_SIGNER"></a><a id="cmsg_ctrl_add_signer"></a><dl>
     * <dt><b>CMSG_CTRL_ADD_SIGNER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvCtrlPara</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signer_encode_info">CMSG_SIGNER_ENCODE_INFO</a> structure that contains the signer information to be added to the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_SIGNER"></a><a id="cmsg_ctrl_del_signer"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_SIGNER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * After a deletion is made, any other signer indices in use for this message are no longer valid and must be reacquired by calling 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsggetparam">CryptMsgGetParam</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR"></a><a id="cmsg_ctrl_del_signer_unauth_attr"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * After a deletion is made, any other unauthenticated attribute indices in use for this signer are no longer valid and must be reacquired by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsggetparam">CryptMsgGetParam</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_CERT"></a><a id="cmsg_ctrl_del_cert"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_CERT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * After a deletion is made, any other certificate indices in use for this message are no longer valid and must be reacquired by calling 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsggetparam">CryptMsgGetParam</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_CRL"></a><a id="cmsg_ctrl_del_crl"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_CRL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * After a deletion is made, any other CRL indices in use for this message are no longer valid and will need to be reacquired by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsggetparam">CryptMsgGetParam</a> function.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero and the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function   returns an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>. 
     * 
     * When a streamed, enveloped message is being decoded, errors encountered in the application-defined callback function specified by the <i>pStreamInfo</i>  parameter of the  
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a> function might be propagated to the <b>CryptMsgControl</b> function. If this happens, the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> function is not called by the <b>CryptMsgControl</b> function after the callback function returns. This preserves any errors encountered under the control of the application. It is the responsibility of the callback function (or one of the APIs that it calls) to call the <b>SetLastError</b> function if an error occurs while the application is processing the streamed data.
     * 
     * Propagated errors might be encountered from the following functions:<ul>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptdecrypt">CryptDecrypt</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetuserkey">CryptGetUserKey</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea">CryptVerifySignature</a>
     * </li>
     * </ul>
     * 
     * 
     * The following  error codes are most commonly returned.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_ALREADY_DECRYPTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message content has already been decrypted. This error can be returned if the <i>dwCtrlType</i> parameter is set to   CMSG_CTRL_DECRYPT.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_AUTH_ATTR_MISSING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message does not contain an expected authenticated attribute. This error can be returned if the <i>dwCtrlType</i> parameter is set to   CMSG_CTRL_VERIFY_SIGNATURE.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_BAD_ENCODE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error was encountered while encoding or decoding. This error can be returned if the <i>dwCtrlType</i>  parameter is set to  CMSG_CTRL_VERIFY_SIGNATURE.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_CONTROL_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The control type is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_HASH_VALUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash value is incorrect.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_INVALID_INDEX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The index value is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_INVALID_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message type is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_OID_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The object identifier is badly formatted. This error can be returned if the <i>dwCtrlType</i>  parameter is set to  CMSG_CTRL_ADD_SIGNER.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_RECIPIENT_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The enveloped data message does not contain the specified recipient. This error can be returned if the <i>dwCtrlType</i>  parameter is set to CMSG_CTRL_DECRYPT.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_SIGNER_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified signer for the message was not found. This error can be returned if the <i>dwCtrlType</i>  parameter is set to  CMSG_CTRL_VERIFY_SIGNATURE.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNKNOWN_ALGO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The cryptographic algorithm is unknown.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_ENCODING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is not encoded as expected. This error can be returned if the <i>dwCtrlType</i>  parameter is set to  CMSG_CTRL_VERIFY_SIGNATURE.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid. This error can be returned if the <i>dwCtrlType</i> parameter is set to   CMSG_CTRL_DECRYPT.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not enough memory was available to complete the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmsgcontrol
     * @since windows5.1.2600
     */
    static CryptMsgControl(hCryptMsg, dwFlags, dwCtrlType, pvCtrlPara) {
        hCryptMsgMarshal := hCryptMsg is VarRef ? "ptr" : "ptr"
        pvCtrlParaMarshal := pvCtrlPara is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgControl", hCryptMsgMarshal, hCryptMsg, "uint", dwFlags, "uint", dwCtrlType, pvCtrlParaMarshal, pvCtrlPara, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Verifies a countersignature in terms of the SignerInfo structure (as defined by PKCS
     * @param {HCRYPTPROV_LEGACY} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server2003 and WindowsXP:</b><b>NULL</b> or the handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic provider</a> to use to <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> the encryptedDigest field of <i>pbSignerInfo</i>.This parameter's data type is <b>HCRYPTPROV</b>.
     * 
     * Unless there is a strong reason for passing in a specific cryptographic provider in <i>hCryptProv</i>, pass <b>NULL</b> to cause the default RSA or DSS provider to be used.
     * @param {Integer} dwEncodingType Specifies the encoding type used. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. For either current encoding type, use: 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Pointer} pbSignerInfo A pointer to the encoded <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a> that contains the signer of the contents of a message to be countersigned.
     * @param {Integer} cbSignerInfo Count, in bytes, of the encoded BLOB for the signer of the contents.
     * @param {Pointer} pbSignerInfoCountersignature A pointer to the encoded BLOB containing the countersigner information.
     * @param {Integer} cbSignerInfoCountersignature Count, in bytes, of the encoded BLOB for the countersigner of the message.
     * @param {Pointer<CERT_INFO>} pciCountersigner A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> that includes with the issuer and serial number of the countersigner. For more information, see Remarks.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table lists the error codes most commonly returned by the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_AUTH_ATTR_MISSING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message does not contain an expected authenticated attribute.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_HASH_VALUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash value is not correct.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_ENCODING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is not encoded as expected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNKNOWN_ALGO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The cryptographic algorithm is unknown.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ran out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Propagated errors from the following functions might be returned.
     * 
     * <ul>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea">CryptVerifySignature</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>
     * </li>
     * </ul>
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmsgverifycountersignatureencoded
     * @since windows5.1.2600
     */
    static CryptMsgVerifyCountersignatureEncoded(hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, pciCountersigner) {
        hCryptProv := hCryptProv is Win32Handle ? NumGet(hCryptProv, "ptr") : hCryptProv

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgVerifyCountersignatureEncoded", "ptr", hCryptProv, "uint", dwEncodingType, "ptr", pbSignerInfo, "uint", cbSignerInfo, "ptr", pbSignerInfoCountersignature, "uint", cbSignerInfoCountersignature, "ptr", pciCountersigner, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Verifies that the pbSignerInfoCounterSignature parameter contains the encrypted hash of the encryptedDigest field of the pbSignerInfo parameter structure.
     * @param {HCRYPTPROV_LEGACY} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server2003 and WindowsXP:</b><b>NULL</b> or the handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic provider</a> to use to <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> the encryptedDigest field of <i>pbSignerInfo</i>.This parameter's data type is <b>HCRYPTPROV</b>.
     * 
     * Unless there is a strong reason for passing in a specific cryptographic provider in <i>hCryptProv</i>, pass <b>NULL</b> to cause the default RSA or DSS provider to be used.
     * @param {Integer} dwEncodingType The encoding type used. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. For either current encoding type, use:  
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Pointer} pbSignerInfo A pointer to the encoded <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a> that contains the signer of the contents of a message to be countersigned.
     * @param {Integer} cbSignerInfo The count, in bytes, of the encoded BLOB for the signer of the contents.
     * @param {Pointer} pbSignerInfoCountersignature A pointer to the encoded BLOB containing the countersigner information.
     * @param {Integer} cbSignerInfoCountersignature The count, in bytes, of the encoded BLOB for the countersigner of the message.
     * @param {Integer} dwSignerType The structure that contains the signer information. The following table shows the predefined values and the structures indicated.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>CMSG_VERIFY_SIGNER_PUBKEY</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSigner</i> is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>CMSG_VERIFY_SIGNER_CERT</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSigner</i> is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>CMSG_VERIFY_SIGNER_CHAIN</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSigner</i> is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvSigner A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure, a certificate context, or a chain context depending on the value of <i>dwSignerType</i>.
     * @param {Integer} dwFlags Flags that modify the function behavior. This can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_VERIFY_COUNTER_SIGN_ENABLE_STRONG_FLAG"></a><a id="cmsg_verify_counter_sign_enable_strong_flag"></a><dl>
     * <dt><b>CMSG_VERIFY_COUNTER_SIGN_ENABLE_STRONG_FLAG</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Performs a strong signature check after successful signature verification. Set the <i>pvExtra</i> parameter to point to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_strong_sign_para">CERT_STRONG_SIGN_PARA</a> structure that contains the parameters needed to check the signature strength..
     * 
     * <b>Windows8 and Windows Server2012:</b>Support for this flag begins.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvExtra If you set the <i>dwFlags</i> parameter to <b>CMSG_VERIFY_COUNTER_SIGN_ENABLE_STRONG_FLAG</b>, set this parameter (<i>pvExtra</i>) to point to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_strong_sign_para">CERT_STRONG_SIGN_PARA</a> structure that contains the parameters used to check the signature strength.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). 
     * 		  For extended error information, call 
     *            <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following error codes are most commonly returned by the 
     * 		       <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_AUTH_ATTR_MISSING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message does not contain an expected authenticated attribute.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_HASH_VALUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash value is not correct.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_ENCODING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is not encoded as expected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNKNOWN_ALGO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The cryptographic algorithm is unknown.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ran out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Propagated errors from the following functions might be returned.
     * 
     * <ul>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea">CryptVerifySignature</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>
     * </li>
     * </ul>
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmsgverifycountersignatureencodedex
     * @since windows5.1.2600
     */
    static CryptMsgVerifyCountersignatureEncodedEx(hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, dwSignerType, pvSigner, dwFlags, pvExtra) {
        hCryptProv := hCryptProv is Win32Handle ? NumGet(hCryptProv, "ptr") : hCryptProv

        pvSignerMarshal := pvSigner is VarRef ? "ptr" : "ptr"
        pvExtraMarshal := pvExtra is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgVerifyCountersignatureEncodedEx", "ptr", hCryptProv, "uint", dwEncodingType, "ptr", pbSignerInfo, "uint", cbSignerInfo, "ptr", pbSignerInfoCountersignature, "uint", cbSignerInfoCountersignature, "uint", dwSignerType, pvSignerMarshal, pvSigner, "uint", dwFlags, pvExtraMarshal, pvExtra, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Countersigns an existing signature in a message.
     * @param {Pointer<Void>} hCryptMsg Cryptographic message handle to be used.
     * @param {Integer} dwIndex Zero-based index of the signer in the signed or signed-and-enveloped message to be countersigned.
     * @param {Integer} cCountersigners Number of countersigners in the <i>rgCountersigners</i> array.
     * @param {Pointer<CMSG_SIGNER_ENCODE_INFO>} rgCountersigners Array of countersigners' 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signer_encode_info">CMSG_SIGNER_ENCODE_INFO</a> structures.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * An error can be propagated from
     * 								<a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcountersignencoded">CryptMsgCountersignEncoded</a>.
     * 
     * The following error codes are returned most often.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ran out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified area is not large enough to hold the returned data.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmsgcountersign
     * @since windows5.1.2600
     */
    static CryptMsgCountersign(hCryptMsg, dwIndex, cCountersigners, rgCountersigners) {
        hCryptMsgMarshal := hCryptMsg is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgCountersign", hCryptMsgMarshal, hCryptMsg, "uint", dwIndex, "uint", cCountersigners, "ptr", rgCountersigners, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Countersigns an existing PKCS
     * @param {Integer} dwEncodingType Specifies the encoding type used. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. For either current encoding type, use: 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Pointer} pbSignerInfo A pointer to the encoded SignerInfo that is to be countersigned.
     * @param {Integer} cbSignerInfo Count, in bytes, of the encoded SignerInfo data.
     * @param {Integer} cCountersigners Number of countersigners in the <i>rgCountersigners</i> array.
     * @param {Pointer<CMSG_SIGNER_ENCODE_INFO>} rgCountersigners Array of countersigners' 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signer_encode_info">CMSG_SIGNER_ENCODE_INFO</a> structures.
     * @param {Pointer} pbCountersignature A pointer to a buffer to receive an encoded PKCS #9 <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">countersignature</a> attribute.
     * 
     * On input, this parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbCountersignature A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pbCountersignature</i> parameter. When the function returns, the variable pointed to by the <i>pcbCountersignature</i> parameter contains the number of bytes stored in the buffer.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table lists the error codes most commonly returned by the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_OID_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The object identifier is badly formatted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ran out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Propagated errors might be returned from one of the following functions:
     * 
     * <ul>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentoencode">CryptMsgOpenToEncode</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a>
     * </li>
     * <li>
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcontrol">CryptMsgControl</a>
     * </li>
     * </ul>
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmsgcountersignencoded
     * @since windows5.1.2600
     */
    static CryptMsgCountersignEncoded(dwEncodingType, pbSignerInfo, cbSignerInfo, cCountersigners, rgCountersigners, pbCountersignature, pcbCountersignature) {
        pcbCountersignatureMarshal := pcbCountersignature is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgCountersignEncoded", "uint", dwEncodingType, "ptr", pbSignerInfo, "uint", cbSignerInfo, "uint", cCountersigners, "ptr", rgCountersigners, "ptr", pbCountersignature, pcbCountersignatureMarshal, pcbCountersignature, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Opens a certificate store by using a specified store provider type.
     * @param {PSTR} lpszStoreProvider A pointer to a null-terminated ANSI string that contains the store provider type.
     * 
     * The following values  represent the predefined store types. The store provider type determines the contents of the <i>pvPara</i> parameter and the use and meaning of the high word of the <i>dwFlags</i> parameter. Additional store providers can be installed or registered by using 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptinstalloidfunctionaddress">CryptInstallOIDFunctionAddress</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptregisteroidfunction">CryptRegisterOIDFunction</a> function. For more information about adding store providers, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/extending-certopenstore-functionality">Extending CertOpenStore Functionality</a>.
     * 
     * 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_COLLECTION"></a><a id="cert_store_prov_collection"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_COLLECTION</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_COLLECTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Opens a store that will be a collection of other stores. Stores are added to or removed from the collection by using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddstoretocollection">CertAddStoreToCollection</a> and <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certremovestorefromcollection">CertRemoveStoreFromCollection</a>. When a store is added to a collection, all certificates, CRLs, and CTLs in that store become available to searches or enumerations of the collection store.
     * 
     * The high word of <i>dwFlags</i> is set to zero.
     * 
     * <b><i>pvPara</i> value:</b>The <i>pvPara</i> parameter must be <b>NULL</b>.
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_FILE"></a><a id="cert_store_prov_file"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_FILE</b></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs read from a specified open file. This provider expects the file to contain only a serialized store and not either PKCS #7 signed messages or a single encoded certificate.
     * 
     * The file pointer must be positioned at the beginning of the serialized store information. After the data in the serialized store has been loaded into the certificate store, the file pointer is positioned at the beginning of any data that can follow the serialized store data in the file. If CERT_FILE_STORE_COMMIT_ENABLE is set in <i>dwFlags</i>, the file handle is duplicated and the store is always committed as a serialized store. The file is not closed when the store is closed.
     * 
     * <b><i>pvPara</i> value:</b>The <i>pvPara</i> parameter must contain a pointer to the handle of a file opened by using <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>.
     * 
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_FILENAME_A"></a><a id="cert_store_prov_filename_a"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_FILENAME_A</b></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from a file. The provider opens the file and first attempts to read the file as a serialized store, then as a PKCS #7 signed message, and finally as a single encoded certificate.
     * 
     * 
     * The <i>dwEncodingType</i> parameter must contain the encoding types to be used with both messages and certificates. If the file contains an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/x-gly">X.509</a> encoded certificate, the open operation fails and a call to the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function will return <b>ERROR_ACCESS_DENIED</b>.
     *          If the <b>CERT_FILE_STORE_COMMIT_ENABLE</b> flag is set in <i>dwFlags</i>, the <i>dwCreationDisposition</i> value passed to <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> is as follows:
     * 
     * <ul>
     * <li>If the <b>CERT_STORE_CREATE_NEW_FLAG</b> flag is set, 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> uses <b>CREATE_NEW</b>.</li>
     * <li>If the <b>CERT_STORE_OPEN_EXISTING_FLAG</b> flag is set, <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> uses <b>OPEN_EXISTING</b>.</li>
     * <li>For all other settings of <i>dwFlags</i>, <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> uses <b>OPEN_ALWAYS</b>.</li>
     * </ul>
     * 
     * 
     * If <i>dwFlags</i> includes <b>CERT_FILE_STORE_COMMIT_ENABLE</b>, the file is committed as either a PKCS #7 or a serialized store depending on the file type opened. If the file was empty or if the file name has either a .p7c or .spc extension, the file is committed as a PKCS #7. Otherwise, the file is committed as a serialized store.
     * 
     * <b><i>pvPara</i> value:</b>The <i>pvPara</i> parameter must contain a pointer to null-terminated ANSI string that contains the name of an existing, unopened file.
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_FILENAME__W_"></a><a id="cert_store_prov_filename__w_"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_FILENAME(_W)</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_FILENAME(_W)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Same as <b>CERT_STORE_PROV_FILENAME_A</b>.
     * 
     * <b><i>pvPara</i> value:</b>The <i>pvPara</i> parameter must contain a pointer to null-terminated Unicode string that contains the name of an existing, unopened file.
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_LDAP__W_"></a><a id="cert_store_prov_ldap__w_"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_LDAP(_W)</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_LDAP(_W)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from the results of an LDAP query.
     * 
     * To perform write operations on the store, the query string must specify a BASE query with no filter and a single attribute.
     * 
     * <b><i>pvPara</i> value:</b>If the <i>dwFlags</i> parameter contains  <b>CERT_LDAP_STORE_OPENED_FLAG</b>, set  <i>pvPara</i> to the address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_ldap_store_opened_para">CERT_LDAP_STORE_OPENED_PARA</a> structure that specifies the established LDAP session to use.
     * 
     * Otherwise,  set  <i>pvPara</i> to point to a null-terminated Unicode string that contains the LDAP query string. For more information about LDAP query strings, see <a href="https://docs.microsoft.com/windows/desktop/ADSI/ldap-dialect">LDAP Dialect</a>.
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_MEMORY"></a><a id="cert_store_prov_memory"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_MEMORY</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Creates a certificate store in cached memory. No certificates, <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate revocation lists</a> (CRLs), or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate trust lists</a> (CTLs) are initially loaded into the store. Typically used to create a temporary store.
     * 
     * Any addition of certificates, CRLs, or CTLs or changes in properties of certificates, CRLs, or CTLs in a memory store are not automatically saved. They can be saved to a file or to a memory <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a> by using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsavestore">CertSaveStore</a>.
     * 
     * <b><i>pvPara</i> value:</b>The <i>pvPara</i> parameter is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_MSG"></a><a id="cert_store_prov_msg"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_MSG</b></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from the specified cryptographic message. The <i>dwEncodingType</i> parameter must contain the encoding types used with both messages and certificates.
     * 
     * <b><i>pvPara</i> value:</b>The <i>pvPara</i> parameter contains an <b>HCRYPTMSG</b> handle of the encoded message, returned by a call to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_PHYSICAL__W_"></a><a id="cert_store_prov_physical__w_"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_PHYSICAL(_W)</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_PHYSICAL(_W)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from a specified physical store that is a member of a logical system store.
     * 
     * Two names are separated with an intervening backslash (\\), for example "Root\.Default". Here, "Root" is the name of the system store and ".Default" is the name of the physical store. The system and physical store names cannot contain any backslashes. The high word of <i>dwFlags</i> indicates the system store location, usually CERT_SYSTEM_STORE_CURRENT_USER. For more information, see <i>dwFlags</i> later in this topic and see <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/system-store-locations">System Store Locations</a>. Some physical store locations can be opened remotely.
     * 
     * <b><i>pvPara</i> value:</b>The <i>pvPara</i> parameter points to a null-terminated Unicode string that contains both the system store name and physical names.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_PKCS7"></a><a id="cert_store_prov_pkcs7"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_PKCS7</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_PKCS7</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from an encoded PKCS #7 signed message. The <i>dwEncodingType</i> parameter must specify the encoding types to be used with both messages and certificates.
     * 
     * <b><i>pvPara</i> value:</b>The <i>pvPara</i> parameter points to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure that represents the encoded message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_PKCS12"></a><a id="cert_store_prov_pkcs12"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_PKCS12</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_PKCS12</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with the contents of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">PKCS #12</a> packet.
     * 
     * If the PKCS #12 packet is protected with a NULL or empty password, this function will succeed in opening the store.
     * 
     * Beginning with Windows8 and Windows Server2012, if the password embedded in the PFX packet was protected to an Active Directory (AD) principal and the current user, as a member of that principal, has permission to decrypt the password, this function will succeed in opening the store. For more information, see the <i>pvPara</i> parameter and the <b>PKCS12_PROTECT_TO_DOMAIN_SIDS</b> flag of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-pfxexportcertstoreex">PFXExportCertStoreEx</a> function.
     * 
     * You can protect PFX passwords to an AD principal beginning in Windows8 and Windows Server2012.
     * 
     * <b><i>pvPara</i> value:</b>The <i>pvPara</i> parameter points to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure that represents the PKCS #12 packet.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_REG"></a><a id="cert_store_prov_reg"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_REG</b></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from a registry subkey.
     * 
     * This provider opens or creates the registry subkeys <b>Certificates</b>, <b>CRLs</b>, and <b>CTLs</b> under the key passed in <i>pvPara</i>. The input key is not closed by the provider. Before returning, the provider opens its own copy of the key passed in <i>pvPara</i>. If CERT_STORE_READONLY_FLAG is set in the low word of <i>dwFlags</i>, registry subkeys are opened by using the <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regopenkeya">RegOpenKey</a> with KEY_READ_ACCESS. Otherwise, registry subkeys are created by using <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regcreatekeya">RegCreateKey</a> with KEY_ALL_ACCESS. Any changes to the contents of the opened store are immediately persisted to the registry. However, if CERT_STORE_READONLY_FLAG is set in the low word of <i>dwFlags</i>, any attempt to add to the contents of the store or to change a context's property results in an error with <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning the E_ACCESSDENIED code.
     * 
     * <b><i>pvPara</i> value:</b>The <i>pvPara</i> parameter contains the handle of an open registry key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_SERIALIZED"></a><a id="cert_store_prov_serialized"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_SERIALIZED</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_SERIALIZED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from a memory location that contains a serialized store.
     * 
     * <b><i>pvPara</i> value:</b>The <i>pvPara</i> parameter points to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure that contains the serialized memory BLOB.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_SMART_CARD__W_"></a><a id="cert_store_prov_smart_card__w_"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_SMART_CARD(_W)</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_SMART_CARD(_W)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not currently used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_SYSTEM_A"></a><a id="cert_store_prov_system_a"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_SYSTEM_A</b></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from the specified system store.
     * 
     * The system store is a logical, collection store that consists of one or more physical stores. A physical store associated with a system store is registered with the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certregisterphysicalstore">CertRegisterPhysicalStore</a> function. After the system store is opened, all of the physical stores that are associated with it are also opened by calls to <b>CertOpenStore</b> and are added to the system store collection by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddstoretocollection">CertAddStoreToCollection</a> function. The high word of <i>dwFlags</i> indicates the system store location, usually set to CERT_SYSTEM_STORE_CURRENT_USER. For details about registry locations, see <i>dwFlags</i> later in this topic and <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/system-store-locations">System Store Locations</a>. Some system store locations can be opened remotely; for more information, see System Store Locations.
     * 
     * <b><i>pvPara</i> value:</b>The <i>pvPara</i> parameter points to a null-terminated ANSI string that contains a system store name, such as "My" or "Root".
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_SYSTEM__W_"></a><a id="cert_store_prov_system__w_"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_SYSTEM(_W)</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_SYSTEM(_W)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Same as <b>CERT_STORE_PROV_SYSTEM_A</b>.
     * 
     * <b><i>pvPara</i> value:</b>The <i>pvPara</i> parameter points to a null-terminated Unicode string that contains a system store name, such as "My" or "Root".
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_SYSTEM_REGISTRY_A"></a><a id="cert_store_prov_system_registry_a"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_SYSTEM_REGISTRY_A</b></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from a physical registry store. The physical store is not opened as a collection store. Enumerations and searches go through only the certificates, CRLs, and CTLs in that one physical store.
     * 
     * The high word of <i>dwFlags</i> indicates the system store location, usually set to CERT_SYSTEM_STORE_CURRENT_USER. For more information, see <i>dwFlags</i> later in this topic. Some system store locations can be open remotely; for more information, see <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/system-store-locations">System Store Locations</a>.
     * 
     * <b><i>pvPara</i> value:</b>The <i>pvPara</i> parameter points to a null-terminated ANSI string that contains a system store name, such as "My" or "Root".
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="_CERT_STORE_PROV_SYSTEM_REGISTRY__W_"></a><a id="_cert_store_prov_system_registry__w_"></a><dl>
     * <dt><b><b> CERT_STORE_PROV_SYSTEM_REGISTRY(_W)</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_SYSTEM_REGISTRY(_W)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Same as <b>CERT_STORE_PROV_SYSTEM_REGISTRY_A</b>.
     * 
     * <b><i>pvPara</i> value:</b>The <i>pvPara</i> parameter points to a null-terminated Unicode string that contains a system store name, such as "My" or "Root".
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwEncodingType Specifies the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a> and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a>. Encoding is used only when the <i>dwSaveAs</i> parameter of  the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsavestore">CertSaveStore</a> function contains <b>CERT_STORE_SAVE_AS_PKCS7</b>. Otherwise, the <i>dwMsgAndCertEncodingType</i> parameter is not used.
     * 
     * This parameter is only applicable  when the <b>CERT_STORE_PROV_MSG</b>, <b>CERT_STORE_PROV_PKCS7</b>, or <b>CERT_STORE_PROV_FILENAME</b> provider type is specified in the <i>lpszStoreProvider</i> parameter. For all other provider types, this parameter is unused and should be set to zero.
     * @param {Integer} dwFlags These values consist of high-word and low-word values combined by using a bitwise-<b>OR</b> operation.
     * @param {Pointer<Void>} pvPara A 32-bit value that can contain additional information for this function. The contents of this parameter depends on the value of the <i>lpszStoreProvider</i> and other parameters.
     * @returns {HCERTSTORE} If the function succeeds, the function returns a handle to the <a href="/windows/desktop/SecGloss/c-gly">certificate store</a>. When you have finished using the store, release the handle by calling the <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a> function.
     * 
     * If the function fails, it returns <b>NULL</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * <div class="alert"><b>Note</b><a href="/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>, <a href="/windows/desktop/api/fileapi/nf-fileapi-readfile">ReadFile</a>, or registry errors might be propagated and their error codes returned. <b>CertOpenStore</b> has a single error code of its own, the ERROR_FILE_NOT_FOUND code, which indicates that the function was unable to find the provider specified by the <i>lpszStoreProvider</i> parameter.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certopenstore
     * @since windows5.1.2600
     */
    static CertOpenStore(lpszStoreProvider, dwEncodingType, dwFlags, pvPara) {
        static hCryptProv := 0 ;Reserved parameters must always be NULL

        lpszStoreProvider := lpszStoreProvider is String ? StrPtr(lpszStoreProvider) : lpszStoreProvider

        pvParaMarshal := pvPara is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertOpenStore", "ptr", lpszStoreProvider, "uint", dwEncodingType, "ptr", hCryptProv, "uint", dwFlags, pvParaMarshal, pvPara, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        resultHandle := HCERTSTORE({Value: result}, True)
        return resultHandle
    }

    /**
     * Duplicates a store handle by incrementing the store's reference count.
     * @param {HCERTSTORE} hCertStore A handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a> for which the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> is being incremented.
     * @returns {HCERTSTORE} Currently, a copy is not made of the handle, and the returned handle is the same as the handle that was input. If <b>NULL</b> is passed in, the called function will raise an access violation exception.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certduplicatestore
     * @since windows5.1.2600
     */
    static CertDuplicateStore(hCertStore) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        result := DllCall("CRYPT32.dll\CertDuplicateStore", "ptr", hCertStore, "ptr")
        resultHandle := HCERTSTORE({Value: result}, True)
        return resultHandle
    }

    /**
     * Saves the certificate store to a file or to a memory BLOB.
     * @param {HCERTSTORE} hCertStore The handle of the certificate store to be saved.
     * @param {Integer} dwEncodingType Specifies the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a> and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a>. Encoding is used only when <i>dwSaveAs</i> contains <b>CERT_STORE_SAVE_AS_PKCS7</b>. Otherwise, the <i>dwMsgAndCertEncodingType</i> parameter is not used.
     * @param {Integer} dwSaveAs Specifies how to save the certificate store.
     * @param {Integer} dwSaveTo Specifies where and how to save the certificate store. The contents of this parameter determines the format of the <i>pvSaveToPara</i> parameter.
     * @param {Pointer<Void>} pvSaveToPara A pointer that represents where the store should be saved to. The contents of this parameter depends on the value of the <i>dwSaveTo</i> parameter.
     * @param {Integer} dwFlags This parameter is reserved for future use and must be set to zero.
     * @returns {BOOL} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * Note that <a href="/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> or <a href="/windows/desktop/api/fileapi/nf-fileapi-writefile">WriteFile</a> errors can be propagated to this function. One possible error code is <b>CRYPT_E_FILE_ERROR</b> which indicates that an error occurred while writing to the file.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certsavestore
     * @since windows5.1.2600
     */
    static CertSaveStore(hCertStore, dwEncodingType, dwSaveAs, dwSaveTo, pvSaveToPara, dwFlags) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        pvSaveToParaMarshal := pvSaveToPara is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSaveStore", "ptr", hCertStore, "uint", dwEncodingType, "uint", dwSaveAs, "uint", dwSaveTo, pvSaveToParaMarshal, pvSaveToPara, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Closes a certificate store handle and reduces the reference count on the store.
     * @param {HCERTSTORE} hCertStore Handle of the certificate store to be closed.
     * @param {Integer} dwFlags Typically, this parameter uses the default value zero. The default is to close the store with memory remaining allocated for contexts that have not been freed. In this case, no check is made to determine whether memory for contexts remains allocated. 
     * 
     * 
     * 
     * 
     * Set flags can force the freeing of memory for all of a store's <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a>, <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate revocation list</a> (CRL), and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate trust list</a> (CTL) contexts when the store is closed. Flags can also be set that check whether all of the store's certificate, CRL, and CTL contexts have been freed. The following values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CLOSE_STORE_CHECK_FLAG"></a><a id="cert_close_store_check_flag"></a><dl>
     * <dt><b>CERT_CLOSE_STORE_CHECK_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Checks for nonfreed certificate, CRL, and CTL contexts. A returned error code indicates that one or more store elements is still in use. This flag should only be used as a diagnostic tool in the development of applications.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CLOSE_STORE_FORCE_FLAG"></a><a id="cert_close_store_force_flag"></a><dl>
     * <dt><b>CERT_CLOSE_STORE_FORCE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Forces the freeing of memory for all contexts associated with the store. This flag can be safely used only when the store is opened in a function and neither the store handle nor any of its contexts are passed to any called functions. For details, see  Remarks.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If CERT_CLOSE_STORE_CHECK_FLAG is not set or if it is set and all contexts associated with the store have been freed, the return value is <b>TRUE</b>.
     * 
     * If CERT_CLOSE_STORE_CHECK_FLAG is set and memory for one or more contexts associated with the store remains allocated, the return value is <b>FALSE</b>. The store is always closed even when the function returns <b>FALSE</b>. For details, see  Remarks.
     * 
     * 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> is set to CRYPT_E_PENDING_CLOSE if memory for contexts associated with the store remains allocated. Any existing value returned by <b>GetLastError</b> is preserved unless CERT_CLOSE_STORE_CHECK_FLAG is set.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certclosestore
     * @since windows5.1.2600
     */
    static CertCloseStore(hCertStore, dwFlags) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertCloseStore", "ptr", hCertStore, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Returns from a certificate store a subject certificate context uniquely identified by its issuer and serial number.
     * @param {HCERTSTORE} hCertStore A handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a>.
     * @param {Integer} dwCertEncodingType The type of encoding used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_INFO>} pCertId A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure. Only the <b>Issuer</b> and <b>SerialNumber</b> members are used.
     * @returns {Pointer<CERT_CONTEXT>} If the function succeeds, the function returns a pointer to a read-only 
     * <a href="/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a>. The <b>CERT_CONTEXT</b> must be freed by calling 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a>.
     * 
     * The returned certificate might not be valid. Usually, it is verified when getting its issuer certificate (<a href="/windows/desktop/api/wincrypt/nf-wincrypt-certgetissuercertificatefromstore">CertGetIssuerCertificateFromStore</a>).
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The subject certificate was not found in the store.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certgetsubjectcertificatefromstore
     * @since windows5.1.2600
     */
    static CertGetSubjectCertificateFromStore(hCertStore, dwCertEncodingType, pCertId) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetSubjectCertificateFromStore", "ptr", hCertStore, "uint", dwCertEncodingType, "ptr", pCertId, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the first or next certificate in a certificate store. Used in a loop, this function can retrieve in sequence all certificates in a certificate store.
     * @param {HCERTSTORE} hCertStore A handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a>.
     * @param {Pointer<CERT_CONTEXT>} pPrevCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> of the previous <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a> found.
     * 
     * This parameter must be <b>NULL</b> to begin the enumeration and get the first certificate in the store. Successive certificates are enumerated by setting <i>pPrevCertContext</i> to the pointer returned by a previous call to the function. This function frees the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> referenced by non-<b>NULL</b> values of this parameter.
     * 
     * For <a href="https://docs.microsoft.com/windows/desktop/SecGloss/l-gly">logical stores</a>, including collection stores, a duplicate of the <i>pCertContext</i> returned by this function cannot be used to begin a new subsequence of enumerations because the duplicated certificate loses the initial enumeration <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">state</a>. The enumeration skips any certificate previously deleted by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certdeletecertificatefromstore">CertDeleteCertificateFromStore</a>.
     * @returns {Pointer<CERT_CONTEXT>} If the function succeeds, the function returns  a pointer to the next 
     * <a href="/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> in the store. If no more certificates exist in the store, the function returns <b>NULL</b>.
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hCertStore</i> parameter is not the same as that in the certificate context pointed to by <i>pPrevCertContext</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND </b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No certificates were found. This happens if the store is empty or if the function reached the end of the store's list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_FILES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Applies to external stores. No certificates were found. This happens if the store is empty or if the function reached the end of the store's list.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certenumcertificatesinstore
     * @since windows5.1.2600
     */
    static CertEnumCertificatesInStore(hCertStore, pPrevCertContext) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertEnumCertificatesInStore", "ptr", hCertStore, "ptr", pPrevCertContext, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Finds the first or next certificate context in a certificate store that matches a search criteria established by the dwFindType and its associated pvFindPara.
     * @param {HCERTSTORE} hCertStore A handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a> to be searched.
     * @param {Integer} dwCertEncodingType Specifies the type of encoding used. Both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> must be specified by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Integer} dwFindFlags Used with some <i>dwFindType</i> values to modify the search criteria. For most <i>dwFindType</i> values, <i>dwFindFlags</i> is not used and should be set to zero. For detailed information, see  Remarks.
     * @param {Integer} dwFindType 
     * @param {Pointer<Void>} pvFindPara Points to a data item or structure used with <i>dwFindType</i>.
     * @param {Pointer<CERT_CONTEXT>} pPrevCertContext A pointer to the last 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure returned by this function. This parameter must be <b>NULL</b> on the first call of the function. To find successive certificates meeting the search criteria,  set <i>pPrevCertContext</i> to the pointer returned by the previous call to the function. This function frees the <b>CERT_CONTEXT</b> referenced by non-<b>NULL</b> values of this parameter.
     * @returns {Pointer<CERT_CONTEXT>} If the function succeeds, the function returns a pointer to a read-only <a href="/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure.
     * 
     * If the function fails and a certificate that matches the search criteria is not found, the return value is <b>NULL</b>.
     * 
     * A non-<b>NULL</b> <a href="/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> that <b>CertFindCertificateInStore</b> returns must be freed by 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> or by being passed as the <i>pPrevCertContext</i> parameter on a subsequent call to <b>CertFindCertificateInStore</b>.
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No certificate was found matching the search criteria. This can happen if the store is empty or the end of the store's list is reached.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hCertStore</i> parameter is not the same as that in the certificate <a href="/windows/desktop/SecGloss/c-gly">context</a> pointed to by the <i>pPrevCertContext</i> parameter, or a value that is not valid was specified in the <i>dwFindType</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certfindcertificateinstore
     * @since windows5.1.2600
     */
    static CertFindCertificateInStore(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        pvFindParaMarshal := pvFindPara is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertFindCertificateInStore", "ptr", hCertStore, "uint", dwCertEncodingType, "uint", dwFindFlags, "uint", dwFindType, pvFindParaMarshal, pvFindPara, "ptr", pPrevCertContext, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the certificate context from the certificate store for the first or next issuer of the specified subject certificate. The new Certificate Chain Verification Functions are recommended instead of the use of this function.
     * @param {HCERTSTORE} hCertStore Handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a>.
     * @param {Pointer<CERT_CONTEXT>} pSubjectContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure that contains the subject information. This parameter can be obtained from any certificate store or can be created by the calling application using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certcreatecertificatecontext">CertCreateCertificateContext</a> function.
     * @param {Pointer<CERT_CONTEXT>} pPrevIssuerContext A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure that contains the issuer information. An issuer can have multiple certificates, especially when a validity period is about to change. This parameter must be <b>NULL</b> on the call to get the first issuer certificate. To get the next certificate for the issuer, set <i>pPrevIssuerContext</i> to the <b>CERT_CONTEXT</b> structure returned by the previous call. 
     * 
     * This function frees the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> referenced by non-<b>NULL</b> values of this parameter.
     * @param {Pointer<Integer>} pdwFlags The following flags enable verification checks on the returned certificate. They can be combined using a bitwise-<b>OR</b> operation to enable multiple verifications. 
     * 
     * 
     * 
     * 
     * 						
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_NO_CRL_FLAG"></a><a id="cert_store_no_crl_flag"></a><dl>
     * <dt><b>CERT_STORE_NO_CRL_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates no matching CRL was found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_NO_ISSUER_FLAG"></a><a id="cert_store_no_issuer_flag"></a><dl>
     * <dt><b>CERT_STORE_NO_ISSUER_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates no issuer certificate was found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_REVOCATION_FLAG"></a><a id="cert_store_revocation_flag"></a><dl>
     * <dt><b>CERT_STORE_REVOCATION_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Checks whether the subject certificate is on the issuer's revocation list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_SIGNATURE_FLAG"></a><a id="cert_store_signature_flag"></a><dl>
     * <dt><b>CERT_STORE_SIGNATURE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uses the public key in the issuer's certificate to verify the signature on the subject certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_TIME_VALIDITY_FLAG"></a><a id="cert_store_time_validity_flag"></a><dl>
     * <dt><b>CERT_STORE_TIME_VALIDITY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Gets the current time and verifies that it is within the subject certificate's validity period.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If a verification check of an enabled type succeeds, its flag is set to zero. If it fails, its flag remains set upon return. For CERT_STORE_REVOCATION_FLAG, the verification succeeds if the function does not find a CRL related to the subject certificate.
     * 
     * If CERT_STORE_REVOCATION_FLAG is set and the issuer does not have a CRL in the store, CERT_STORE_NO_CRL_FLAG is set and CERT_STORE_REVOCATION_FLAG remains set.
     * 
     * If CERT_STORE_SIGNATURE_FLAG or CERT_STORE_REVOCATION_FLAG is set, CERT_STORE_NO_ISSUER_FLAG is set if the function does not find an issuer certificate in the store. For more details, see  Remarks.
     * 
     * In the case of a verification check failure, a pointer to the issuer's 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> is still returned and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> is not updated.
     * @returns {Pointer<CERT_CONTEXT>} If the function succeeds, the return value is a pointer to a read-only issuer <a href="/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a>.
     * 
     * If the function fails and the first or next issuer certificate is not found, the return value is <b>NULL</b>.
     * 
     * Only the last returned <a href="/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure must be freed by calling 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a>. When the returned <b>CERT_CONTEXT</b> from one call to the function is supplied as the <i>pPrevIssuerContext</i> parameter on a subsequent call, the context is freed as part of the action of the function.
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No issuer was found for the subject certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_SELF_SIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The issuer certificate is the same as the subject certificate. It is a self-signed <a href="/windows/desktop/SecGloss/r-gly">root certificate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hCertStore</i> parameter is not the same as that of the certificate context pointed to by the <i>pPrevIssuerContext</i> parameter, or an unsupported flag was set in <i>pdwFlags</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certgetissuercertificatefromstore
     * @since windows5.1.2600
     */
    static CertGetIssuerCertificateFromStore(hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        pdwFlagsMarshal := pdwFlags is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetIssuerCertificateFromStore", "ptr", hCertStore, "ptr", pSubjectContext, "ptr", pPrevIssuerContext, pdwFlagsMarshal, pdwFlags, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertVerifySubjectCertificateContext function performs the enabled verification checks on a certificate by checking the validity of the certificate's issuer. The new Certificate Chain Verification Functions are recommended instead of this function.
     * @param {Pointer<CERT_CONTEXT>} pSubject A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure containing the subject's certificate.
     * @param {Pointer<CERT_CONTEXT>} pIssuer A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> containing the issuer's certificate. When checking just CERT_STORE_TIME_VALIDITY_FLAG, <i>pIssuer</i> can be <b>NULL</b>.
     * @param {Pointer<Integer>} pdwFlags A pointer to a <b>DWORD</b> value contain verification check flags. The following flags can be set to enable verification checks on the subject certificate. They can be combined using a bitwise-<b>OR</b> operation to enable multiple verifications.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_REVOCATION_FLAG"></a><a id="cert_store_revocation_flag"></a><dl>
     * <dt><b>CERT_STORE_REVOCATION_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Checks whether the subject certificate is on the issuer's revocation list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_SIGNATURE_FLAG"></a><a id="cert_store_signature_flag"></a><dl>
     * <dt><b>CERT_STORE_SIGNATURE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uses the public key in the issuer's certificate to verify the signature on the subject certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_TIME_VALIDITY_FLAG"></a><a id="cert_store_time_validity_flag"></a><dl>
     * <dt><b>CERT_STORE_TIME_VALIDITY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Gets the current time and verifies that it is within the subject certificate's validity period.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If an enabled verification check succeeds, its flag is set to zero. If it fails, then its flag is set upon return.
     * 
     * If CERT_STORE_REVOCATION_FLAG was enabled and the issuer does not have a CRL in the store, then CERT_STORE_NO_CRL_FLAG is set in addition to CERT_STORE_REVOCATION_FLAG.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>.
     * 
     * For a verification check failure, <b>TRUE</b> is still returned. <b>FALSE</b> is returned only when a bad parameter is passed in.
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unsupported bit was set in <i>pdwFlags</i>. Any combination of CERT_STORE_SIGNATURE_FLAG, CERT_STORE_TIME_VALIDITY_FLAG, and CERT_STORE_REVOCATION_FLAG can be set. If <i>pIssuer</i> is <b>NULL</b>, only CERT_STORE_TIME_VALIDITY_FLAG can be set.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certverifysubjectcertificatecontext
     * @since windows5.1.2600
     */
    static CertVerifySubjectCertificateContext(pSubject, pIssuer, pdwFlags) {
        pdwFlagsMarshal := pdwFlags is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertVerifySubjectCertificateContext", "ptr", pSubject, "ptr", pIssuer, pdwFlagsMarshal, pdwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Duplicates a certificate context by incrementing its reference count.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure for which the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> is incremented.
     * @returns {Pointer<CERT_CONTEXT>} Currently, a copy is not made of the <a href="/windows/desktop/SecGloss/c-gly">context</a>, and the returned pointer to a context has the same value as the pointer to a context that was input. If the pointer passed into this function is <b>NULL</b>, <b>NULL</b> is returned. When you have finished using the duplicate context, decrease its reference count by calling the <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certduplicatecertificatecontext
     * @since windows5.1.2600
     */
    static CertDuplicateCertificateContext(pCertContext) {
        result := DllCall("CRYPT32.dll\CertDuplicateCertificateContext", "ptr", pCertContext, "ptr")
        return result
    }

    /**
     * Creates a certificate context from an encoded certificate. The created context is not persisted to a certificate store. The function makes a copy of the encoded certificate within the created context.
     * @param {Integer} dwCertEncodingType Specifies the type of encoding used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer} pbCertEncoded A pointer to a buffer that contains the encoded certificate from which the context is to be created.
     * @param {Integer} cbCertEncoded The size, in bytes, of the <i>pbCertEncoded</i> buffer.
     * @returns {Pointer<CERT_CONTEXT>} If the function succeeds, the function returns a pointer to a read-only 
     * <a href="/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a>. When you have finished using the certificate context, free it by calling the <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function.
     * 
     * If the function is unable to decode and create the <a href="/windows/desktop/SecGloss/c-gly">certificate context</a>, it returns <b>NULL</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A certificate encoding type that is not valid was specified. Currently, only the X509_ASN_ENCODING type is supported.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certcreatecertificatecontext
     * @since windows5.1.2600
     */
    static CertCreateCertificateContext(dwCertEncodingType, pbCertEncoded, cbCertEncoded) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertCreateCertificateContext", "uint", dwCertEncodingType, "ptr", pbCertEncoded, "uint", cbCertEncoded, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Frees a certificate context by decrementing its reference count. When the reference count goes to zero, CertFreeCertificateContext frees the memory used by a certificate context.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> to be freed.
     * @returns {BOOL} The function always returns nonzero.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certfreecertificatecontext
     * @since windows5.1.2600
     */
    static CertFreeCertificateContext(pCertContext) {
        result := DllCall("CRYPT32.dll\CertFreeCertificateContext", "ptr", pCertContext, "int")
        return result
    }

    /**
     * Sets an extended property for a specified certificate context.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure.
     * @param {Integer} dwPropId The property to be set. The value of <i>dwPropId</i> determines the type and content of the <i>pvData</i> parameter. Currently defined identifiers and their related <i>pvData</i> types are as follows.
     * 
     * <div class="alert"><b>Note</b><a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a> and <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> are described in the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_INTEGER_BLOB</a> topic.</div>
     * <div></div>
     * @param {Integer} dwFlags CERT_STORE_NO_CRYPT_RELEASE_FLAG can be set for the CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_CONTEXT_PROP_ID <i>dwPropId</i> properties.
     * 
     * If the CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG value is set, any provider-write errors are ignored and the cached context's properties are always set.
     * 
     * If CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG is set, any context property set is not persisted.
     * @param {Pointer<Void>} pvData A pointer to a data type determined by the value of <i>dwPropId</i>.
     * 
     * <div class="alert"><b>Note</b>For any <i>dwPropId</i>, setting <i>pvData</i> to <b>NULL</b> deletes the property.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, the function returns <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property is not valid. The identifier specified was greater than 0x0000FFFF, or, for the CERT_KEY_CONTEXT_PROP_ID property, a <b>cbSize</b> member that is not valid was specified in the <a href="/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certsetcertificatecontextproperty
     * @since windows5.1.2600
     */
    static CertSetCertificateContextProperty(pCertContext, dwPropId, dwFlags, pvData) {
        pvDataMarshal := pvData is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSetCertificateContextProperty", "ptr", pCertContext, "uint", dwPropId, "uint", dwFlags, pvDataMarshal, pvData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the information contained in an extended property of a certificate context.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a> that contains the property to be retrieved.
     * @param {Integer} dwPropId The property to be retrieved. 
     * 			 Currently defined identifiers and the data type to be 
     * 			 returned in <i>pvData</i> are listed in the 
     * 			 following table.
     * @param {Pointer} pvData A pointer to a buffer to receive the data as determined by <i>dwPropId</i>. Structures pointed to by members of a structure returned are also returned following the base structure. Therefore, the size contained in <i>pcbData</i> often exceeds the size of the base structure.
     * 
     * This parameter can be <b>NULL</b> to set the size of the information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbData A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes to be stored in the buffer.
     * 
     * To obtain the required size of a buffer at run time, pass <b>NULL</b> for the <i>pvData</i> parameter, and set the value pointed to by this parameter to zero. If the <i>pvData</i> parameter is not <b>NULL</b> and the size specified in <i>pcbData</i>   is less than the number of bytes required to  contain the data, the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_MORE_DATA</b>, and the required size is placed in the variable pointed to by the <i>pcbData</i> parameter.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     *  Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The certificate does not have the specified property.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pvData</i> parameter is not large enough to hold the returned data, the function sets the <b>ERROR_MORE_DATA</b> code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbData</i>.
     * 							
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Errors from the called function 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a> can be propagated to this function.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certgetcertificatecontextproperty
     * @since windows5.1.2600
     */
    static CertGetCertificateContextProperty(pCertContext, dwPropId, pvData, pcbData) {
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetCertificateContextProperty", "ptr", pCertContext, "uint", dwPropId, "ptr", pvData, pcbDataMarshal, pcbData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertEnumCertificateContextProperties function retrieves the first or next extended property associated with a certificate context.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure of the certificate containing the properties to be enumerated.
     * @param {Integer} dwPropId Property number of the last property enumerated. To get the first property, <i>dwPropId</i> is zero. To retrieve subsequent properties, <i>dwPropId</i> is set to the property number returned by the last call to the function. To enumerate all the properties, function calls continue until the function returns zero. 
     * 
     * 
     * 
     * 
     * Applications can call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatecontextproperty">CertGetCertificateContextProperty</a> with the <i>dwPropId</i> returned by this function to retrieve that property's data.
     * @returns {Integer} The return value is a <b>DWORD</b> value that identifies a <a href="/windows/desktop/SecGloss/c-gly">certificate context's</a> property. The <b>DWORD</b> value returned by one call of the function can be supplied as the <i>dwPropId</i> in a subsequent call to the function. If there are no more properties to be enumerated or if the function fails, zero is returned.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certenumcertificatecontextproperties
     * @since windows5.1.2600
     */
    static CertEnumCertificateContextProperties(pCertContext, dwPropId) {
        result := DllCall("CRYPT32.dll\CertEnumCertificateContextProperties", "ptr", pCertContext, "uint", dwPropId, "uint")
        return result
    }

    /**
     * The CertCreateCTLEntryFromCertificateContextProperties function creates a certificate trust list (CTL) entry whose attributes are the properties of the certificate context. The SubjectIdentifier in the CTL entry is the SHA1 hash of the certificate.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> used to create the CTL.
     * @param {Integer} cOptAttr A <b>DWORD</b> that specifies the number of additional attributes to be added.
     * @param {Pointer<CRYPT_ATTRIBUTE>} rgOptAttr A pointer to any array of <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_attribute">CRYPT_ATTRIBUTE</a> attributes to be added to the CTL.
     * @param {Integer} dwFlags A <b>DWORD</b>. Can be set to CTL_ENTRY_FROM_PROP_CHAIN_FLAG to force the inclusion of the chain building hash properties as attributes.
     * @param {Pointer} pCtlEntry Address of a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_entry">CTL_ENTRY</a> structure. Call this function twice to retrieve a CTL entry. Set this parameter to <b>NULL</b> on the first call. When the function returns, use the number of bytes retrieved from the <i>pcbCtlEntry</i> parameter to allocate memory. Call the function again, setting this parameter to the address of the allocated memory.
     * @param {Pointer<Integer>} pcbCtlEntry Pointer to a <b>DWORD</b> that contains the number of bytes that must be allocated for the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_entry">CTL_ENTRY</a> structure.  Call this function twice to retrieve the number of bytes. For the first call, set this parameter to the address of a <b>DWORD</b> value that contains zero and set the <i>pCtlEntry</i> parameter to <b>NULL</b>. If the first call succeeds, the <b>DWORD</b> value will contain the number of bytes that you must allocate for the <b>CTL_ENTRY</b> structure. Allocate the required memory and call the function again, supplying the address of the memory in the <i>pCtlEntry</i> parameter.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns  zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certcreatectlentryfromcertificatecontextproperties
     * @since windows5.1.2600
     */
    static CertCreateCTLEntryFromCertificateContextProperties(pCertContext, cOptAttr, rgOptAttr, dwFlags, pCtlEntry, pcbCtlEntry) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        pcbCtlEntryMarshal := pcbCtlEntry is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertCreateCTLEntryFromCertificateContextProperties", "ptr", pCertContext, "uint", cOptAttr, "ptr", rgOptAttr, "uint", dwFlags, "ptr", pvReserved, "ptr", pCtlEntry, pcbCtlEntryMarshal, pcbCtlEntry, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Sets the properties on the certificate context by using the attributes in the specified certificate trust list (CTL) entry.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> whose attributes are to be set.
     * @param {Pointer<CTL_ENTRY>} pCtlEntry A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_entry">CTL_ENTRY</a> structure used to set the attributes on the certificate.
     * @param {Integer} dwFlags A <b>DWORD</b>. This parameter can be set to CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG to ignore any persisted error flags.
     * @returns {BOOL} If the function succeeds, the function returns nonzero.
     * 
     *   If the function fails, it returns zero.  For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certsetcertificatecontextpropertiesfromctlentry
     * @since windows5.1.2600
     */
    static CertSetCertificateContextPropertiesFromCTLEntry(pCertContext, pCtlEntry, dwFlags) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSetCertificateContextPropertiesFromCTLEntry", "ptr", pCertContext, "ptr", pCtlEntry, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Gets the first or next certificate revocation list (CRL) context from the certificate store for the specified issuer.
     * @param {HCERTSTORE} hCertStore Handle of a certificate store.
     * @param {Pointer<CERT_CONTEXT>} pIssuerContext A pointer to an issuer 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a>. The <i>pIssuerContext</i> pointer can come from this store or another store, or could have been created by the calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certcreatecertificatecontext">CertCreateCertificateContext</a>. If <b>NULL</b> is passed for this parameter, all the CRLs in the store are found.
     * @param {Pointer<CRL_CONTEXT>} pPrevCrlContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a>. An issuer can have multiple CRLs. For example, it can generate delta CRLs by using an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/x-gly">X.509</a> version 3 extension. This parameter must be <b>NULL</b> on the first call to get the CRL. To get the next CRL for the issuer, the parameter is set to the <b>CRL_CONTEXT</b> returned by a previous call. A non-<b>NULL</b><i>pPrevCrlContext</i> is always freed by this function by calling <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a>, even for an error.
     * @param {Pointer<Integer>} pdwFlags The following flag values are defined to enable verification checks on the returned CRL. These flags can be combined using a bitwise-<b>OR</b> operation. 
     * 
     * 
     * 
     * 
     * 						
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_SIGNATURE_FLAG"></a><a id="cert_store_signature_flag"></a><dl>
     * <dt><b>CERT_STORE_SIGNATURE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uses the public key in the issuer's certificate to verify the signature on the returned CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_TIME_VALIDITY_FLAG"></a><a id="cert_store_time_validity_flag"></a><dl>
     * <dt><b>CERT_STORE_TIME_VALIDITY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Gets the current time and verifies that it is within the time between the CRL's ThisUpdate and NextUpdate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_BASE_CRL_FLAG"></a><a id="cert_store_base_crl_flag"></a><dl>
     * <dt><b>CERT_STORE_BASE_CRL_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Gets a base CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_DELTA_CRL_FLAG"></a><a id="cert_store_delta_crl_flag"></a><dl>
     * <dt><b>CERT_STORE_DELTA_CRL_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Gets a delta CRL.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If an enabled verification check succeeds, its flag is set to zero. 
     * 						
     * 
     * If an enabled verification check fails, its flag remains set upon return. If <i>pIssuerContext</i> is <b>NULL</b>, then an enabled CERT_STORE_SIGNATURE_FLAG always fails and the CERT_STORE_NO_ISSUER_FLAG is also set. For more details, see  Remarks.
     * 
     * If only one of CERT_STORE_BASE_CRL_FLAG or CERT_STORE_DELTA_CRL_FLAG is set, this function returns either a base or delta CRL and the appropriate base or delta flag will be cleared on return. If both flags are set, only one of the flags will be cleared.
     * 
     * For a verification check failure, a pointer to the first or next 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> is still returned and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> is not updated.
     * @returns {Pointer<CRL_CONTEXT>} If the function succeeds, the return value is a pointer to a read-only <a href="/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a>.
     * 
     * If the function fails and the first or next CRL is not found, the return value is <b>NULL</b>.
     * 
     * The returned <a href="/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> must be freed by calling 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a>. However, when the returned <b>CRL_CONTEXT</b> is supplied for <i>pPrevCrlContext</i> on a subsequent call, the function frees it.
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hCertStore</i> parameter is not the same as that in the CRL context pointed to by the <i>pPrevCrlContext</i> parameter, or an unsupported flag was set in <i>pdwFlags</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either no CRLs existed in the store for the issuer, or the function reached the end of the store's list.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certgetcrlfromstore
     * @since windows5.1.2600
     */
    static CertGetCRLFromStore(hCertStore, pIssuerContext, pPrevCrlContext, pdwFlags) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        pdwFlagsMarshal := pdwFlags is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetCRLFromStore", "ptr", hCertStore, "ptr", pIssuerContext, "ptr", pPrevCrlContext, pdwFlagsMarshal, pdwFlags, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertEnumCRLsInStore function retrieves the first or next certificate revocation list (CRL) context in a certificate store. Used in a loop, this function can retrieve in sequence all CRL contexts in a certificate store.
     * @param {HCERTSTORE} hCertStore Handle of a certificate store.
     * @param {Pointer<CRL_CONTEXT>} pPrevCrlContext A pointer to the previous 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure found. The <i>pPrevCrlContext</i> parameter must be <b>NULL</b> to get the first CRL in the store. Successive CRLs are enumerated by setting <i>pPrevCrlContext</i> to the pointer returned by a previous call to the function.  This function frees the <b>CRL_CONTEXT</b> referenced by non-<b>NULL</b> values of this parameter. The enumeration skips any CRLs previously deleted by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certdeletecrlfromstore">CertDeleteCRLFromStore</a>.
     * @returns {Pointer<CRL_CONTEXT>} If the function succeeds, the return value is a pointer to the next 
     * <a href="/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> in the store.
     * 
     * <b>NULL</b> is returned if the function fails. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hCertStore</i> parameter is not the same as that in the certificate context pointed to by <i>pPrevCrlContext</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No CRL was found. This happens if the store is empty or the end of the store's list is reached.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certenumcrlsinstore
     * @since windows5.1.2600
     */
    static CertEnumCRLsInStore(hCertStore, pPrevCrlContext) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertEnumCRLsInStore", "ptr", hCertStore, "ptr", pPrevCrlContext, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Finds the first or next certificate revocation list (CRL) context in a certificate store that matches a search criterion established by the dwFindType parameter and the associated pvFindPara parameter.
     * @param {HCERTSTORE} hCertStore A handle of the certificate store to be searched.
     * @param {Integer} dwCertEncodingType This parameter is not currently used. It must be set to zero.
     * @param {Integer} dwFindFlags If <i>dwFindType</i> is CRL_FIND_ISSUED_BY, by default, only issuer name matching is done. The following flags can be used to do additional filtering.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_ISSUED_BY_AKI_FLAG"></a><a id="crl_find_issued_by_aki_flag"></a><dl>
     * <dt><b>CRL_FIND_ISSUED_BY_AKI_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Checks for a CRL that has an Authority Key Identifier (AKI) extension. If the CRL has an AKI, only a CRL whose AKI matches the issuer is returned.
     * 
     * <div class="alert"><b>Note</b>The AKI extension has the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) value szOID_AUTHORITY_KEY_IDENTIFIER2 and its corresponding data structure.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_ISSUED_BY_SIGNATURE_FLAG"></a><a id="crl_find_issued_by_signature_flag"></a><dl>
     * <dt><b>CRL_FIND_ISSUED_BY_SIGNATURE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the public key in the issuer's certificate to verify the signature on the CRL. Only returns a CRL that has a valid signature.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_ISSUED_BY_DELTA_FLAG"></a><a id="crl_find_issued_by_delta_flag"></a><dl>
     * <dt><b>CRL_FIND_ISSUED_BY_DELTA_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finds and returns a delta CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_ISSUED_BY_BASE_FLAG"></a><a id="crl_find_issued_by_base_flag"></a><dl>
     * <dt><b>CRL_FIND_ISSUED_BY_BASE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finds and returns a base CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_ISSUED_FOR_SET_STRONG_PROPERTIES_FLAG"></a><a id="crl_find_issued_for_set_strong_properties_flag"></a><dl>
     * <dt><b>CRL_FIND_ISSUED_FOR_SET_STRONG_PROPERTIES_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature is checked for strength after successful verification. This flag applies only when the <i>dwFindType</i> parameter is set to <b>CRL_FIND_ISSUED_FOR</b>. You must also set <b>CRL_FIND_ISSUED_BY_SIGNATURE_FLAG</b>. If successful, the following strong signature properties will be set on the CRL context:
     * 
     * <ul>
     * <li><b>CERT_SIGN_HASH_CNG_ALG_PROP_ID</b></li>
     * <li><b>CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID</b></li>
     * </ul>
     * <b>Windows8 and Windows Server2012:</b>Support for this flag begins.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFindType Specifies the type of search being made. The value of <i>dwFindType</i> determines the data type, contents, and use of the <i>pvFindPara</i> parameter. Currently defined search types and their <i>pvFindPara</i> requirements are as follows.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_ANY"></a><a id="crl_find_any"></a><dl>
     * <dt><b>CRL_FIND_ANY</b></dt>
     * <dt>The <i>pvFindPara</i> parameter is not used. It must be set to <b>NULL</b>.</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No search criteria. The next CRL in the store is returned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_ISSUED_BY"></a><a id="crl_find_issued_by"></a><dl>
     * <dt><b>CRL_FIND_ISSUED_BY</b></dt>
     * <dt>A pointer to a CERT_CONTEXT.</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches for the next CRL in the store matching the issuer in the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_EXISTING"></a><a id="crl_find_existing"></a><dl>
     * <dt><b>CRL_FIND_EXISTING</b></dt>
     * <dt>A pointer to a CRL_CONTEXT.</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches for the next CRL that matches the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> in the following ways:
     * 
     * <ul>
     * <li> Both are base or delta CRLs.</li>
     * <li>The issuer-name BLOBs for both are identical.</li>
     * <li>If they exist, the Authority/KeyIdentifier and IssuingDistributionPoint encoded extension BLOBs match.</li>
     * </ul>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_ISSUED_FOR"></a><a id="crl_find_issued_for"></a><dl>
     * <dt><b>CRL_FIND_ISSUED_FOR</b></dt>
     * <dt>A pointer to a CRL_FIND_ISSUED_FOR_PARA.</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches for the next CRL in the store that matches the issuer of the subject certificate in the CRL_FIND_ISSUED_FOR_PARA structure.
     * 
     * If no CRL is found, searches for the next CRL in the store that matches the issuer in the CRL_FIND_ISSUED_FOR_PARA structure.
     * 
     * <div class="alert"><b>Note</b>When using cross certificates, the subject name in the issuer's certificate might not match the issuer name in the subject certificate and its corresponding CRL.</div>
     * <div></div>
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvFindPara This parameter is determined by the value of <i>dwFindType</i>. For details, see the table earlier in this topic.
     * @param {Pointer<CRL_CONTEXT>} pPrevCrlContext A pointer to the last 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> returned by this function. Must be <b>NULL</b> to get the first CRL in the store meeting the search criteria. Successive CRLs meeting the search criteria can be found by setting <i>pPrevCrlContext</i> to the <b>PCCRL_CONTEXT</b> pointer returned by a previous call to the function. The search process skips any CRLs that do not match the search criteria or that have been previously deleted from the store by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certdeletecrlfromstore">CertDeleteCRLFromStore</a>. This function frees the <b>CRL_CONTEXT</b> referenced by values of this parameter that are not <b>NULL</b>.
     * @returns {Pointer<CRL_CONTEXT>} If the function succeeds, the function returns a pointer to a read-only CRL context. When you have finished using the returned CRL context, free it by calling 
     * the <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a> function or implicitly free it by passing it as the <i>pPrevCrlContext</i> parameter on a subsequent call to the <b>CertFindCRLInStore</b> function.
     * 						
     * 						
     * 
     * If the function fails and a CRL that matches the search criteria is not found, the return value is <b>NULL</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hCertStore</i> parameter is not the same as that in the CRL context pointed to by the <i>pPrevCrlContext</i> parameter, or a search type that is not valid was specified in the <i>dwFindType</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No CRLs are in the store, no CRL was found that matched the search criteria, or the end of the store's list was reached.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certfindcrlinstore
     * @since windows5.1.2600
     */
    static CertFindCRLInStore(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCrlContext) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        pvFindParaMarshal := pvFindPara is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertFindCRLInStore", "ptr", hCertStore, "uint", dwCertEncodingType, "uint", dwFindFlags, "uint", dwFindType, pvFindParaMarshal, pvFindPara, "ptr", pPrevCrlContext, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertDuplicateCRLContext function duplicates a certificate revocation list (CRL) context by incrementing its reference count.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure for which the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> is being incremented.
     * @returns {Pointer<CRL_CONTEXT>} Currently, a copy is not made of the context, and the returned context is the same as the context that was input. If the pointer passed into this function is <b>NULL</b>, <b>NULL</b> is returned.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certduplicatecrlcontext
     * @since windows5.1.2600
     */
    static CertDuplicateCRLContext(pCrlContext) {
        result := DllCall("CRYPT32.dll\CertDuplicateCRLContext", "ptr", pCrlContext, "ptr")
        return result
    }

    /**
     * The CertCreateCRLContext function creates a certificate revocation list (CRL) context from an encoded CRL. The created context is not persisted to a certificate store. It makes a copy of the encoded CRL within the created context.
     * @param {Integer} dwCertEncodingType Specifies the type of encoding used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer} pbCrlEncoded A pointer to a buffer containing the encoded <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CRL</a> from which the context is to be created.
     * @param {Integer} cbCrlEncoded The size, in bytes, of the <i>pbCrlEncoded</i> buffer.
     * @returns {Pointer<CRL_CONTEXT>} If the function succeeds, the return value is a pointer to a read-only 
     * <a href="/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a>.
     * 
     * If the function fails and is unable to decode and create the <a href="/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a>, the return value is <b>NULL</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following table shows a possible error code.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Currently, only the encoding type X509_ASN_ENCODING is supported.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certcreatecrlcontext
     * @since windows5.1.2600
     */
    static CertCreateCRLContext(dwCertEncodingType, pbCrlEncoded, cbCrlEncoded) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertCreateCRLContext", "uint", dwCertEncodingType, "ptr", pbCrlEncoded, "uint", cbCrlEncoded, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Frees a certificate revocation list (CRL) context by decrementing its reference count.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> to be freed.
     * @returns {BOOL} The function always returns <b>TRUE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certfreecrlcontext
     * @since windows5.1.2600
     */
    static CertFreeCRLContext(pCrlContext) {
        result := DllCall("CRYPT32.dll\CertFreeCRLContext", "ptr", pCrlContext, "int")
        return result
    }

    /**
     * Sets an extended property for the specified certificate revocation list (CRL) context.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure.
     * @param {Integer} dwPropId Identifies the property to be set. The value of <i>dwPropId</i> determines the type and content of the <i>pvData</i> parameter. Currently defined identifiers and the data type to be returned in <i>pvData</i> are listed in the following table.
     * 
     * Usually, only the following properties are set:<ul>
     * <li>CERT_HASH_PROP_ID</li>
     * <li>CERT_SHA1_HASH_PROP_ID</li>
     * <li>CERT_MD5_HASH_PROP_ID</li>
     * <li>CERT_SIGNATURE_HASH_PROP_ID</li>
     * </ul>
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ACCESS_STATE_PROP_ID"></a><a id="cert_access_state_prop_id"></a><dl>
     * <dt><b>CERT_ACCESS_STATE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>DWORD</b>
     * 
     * Sets a <b>DWORD</b> value indicating whether write operations to the certificate are persisted. The <b>DWORD</b> value is not set if the certificate is in a memory store or in a registry-based store that is opened as read-only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ARCHIVED_PROP_ID"></a><a id="cert_archived_prop_id"></a><dl>
     * <dt><b>CERT_ARCHIVED_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: <b>NULL</b>
     * 
     * Indicates the certificate is skipped during enumerations. A certificate with this property set is found with explicit search operations, such as those used to find a certificate with a specific hash or a serial number. No data in <i>pvData</i> is associated with this property.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_AUTO_ENROLL_PROP_ID"></a><a id="cert_auto_enroll_prop_id"></a><dl>
     * <dt><b>CERT_AUTO_ENROLL_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets a <b>null</b>-terminated Unicode string naming the certificate type for which the certificate has been auto enrolled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CTL_USAGE_PROP_ID"></a><a id="cert_ctl_usage_prop_id"></a><dl>
     * <dt><b>CERT_CTL_USAGE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets an array of bytes containing an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoded <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CTL_USAGE</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_DESCRIPTION_PROP_ID"></a><a id="cert_description_prop_id"></a><dl>
     * <dt><b>CERT_DESCRIPTION_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets the property displayed by the certificate UI. This property allows the user to describe the certificate's use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ENHKEY_USAGE_PROP_ID"></a><a id="cert_enhkey_usage_prop_id"></a><dl>
     * <dt><b>CERT_ENHKEY_USAGE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: 
     * 
     * Sets an array of bytes containing an ASN.1 encoded <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CERT_ENHKEY_USAGE</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_FRIENDLY_NAME_PROP_ID"></a><a id="cert_friendly_name_prop_id"></a><dl>
     * <dt><b>CERT_FRIENDLY_NAME_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets a <b>null</b>-terminated Unicode character string that contains the display name for the CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID"></a><a id="cert_issuer_chain_pub_key_cng_alg_bit_length_prop_id"></a><dl>
     * <dt><b>CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/dpapi/ns-dpapi-crypt_integer_blob">CRYPT_DATA_BLOB</a> structure.
     * 
     * 
     * 
     * Sets a string containing a set of L"<i>&lt;PUBKEY&gt;</i>/<i>&lt;BITLENGTH&gt;</i>" public key algorithm and bit length pairs. The semicolon, L";", is used as the delimiter.
     * 
     * The <i>&lt;PUBKEY&gt;</i> value identifies the CNG public key algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"RSA" (BCRYPT_RSA_ALGORITHM)</li>
     * <li>L"DSA" (BCRYPT_DSA_ALGORITHM)</li>
     * <li>L"ECDSA" (SSL_ECDSA_ALGORITHM)</li>
     * </ul>
     * A <i>&lt;PUBKEY&gt;</i>/<i>&lt;BITLENGTH&gt;</i> pair is set for each certificate in the CRL issuer chain excluding the leaf. This property can be set when an OCSP response with an independent signer chain is converted to a CRL.
     * 
     * <div class="alert"><b>Note</b>This property should not be set for a delegated OCSP signer certificate. A delegated signer certificate is signed with the same key used to sign the subject certificate and is checked there.</div>
     * <div></div>
     * The following is an example:
     * 
     * : L"RSA/2048;RSA/4096"
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID"></a><a id="cert_issuer_chain_sign_hash_cng_alg_prop_id"></a><dl>
     * <dt><b>CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/dpapi/ns-dpapi-crypt_integer_blob">CRYPT_DATA_BLOB</a> structure.
     * 
     * 
     * 
     * Sets a string that contains a set of L"<i>&lt;SIGNATURE&gt;</i>/<i>&lt;HASH&gt;</i>" algorithm pairs. The semicolon, L";", is used as the delimiter between pairs.
     * 
     * This property is set only when an OCSP response is converted to a CRL. For a delegated OCSP signer certificate, only the algorithm pair for the signer certificate is returned. For an independent OCSP signer certificate chain, an algorithm pair is returned for each certificate in the chain excluding the root.
     * 
     * The <i>&lt;SIGNATURE&gt;</i> value identifies the CNG public key algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"RSA" (BCRYPT_RSA_ALGORITHM)</li>
     * <li>L"DSA" (BCRYPT_DSA_ALGORITHM)</li>
     * <li>L"ECDSA" (SSL_ECDSA_ALGORITHM)</li>
     * </ul>
     * The <i>&lt;HASH&gt;</i> value identifies the CNG hash algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"MD5" (BCRYPT_MD5_ALGORITHM)</li>
     * <li>L"SHA1" (BCRYPT_SHA1_ALGORITHM)</li>
     * <li>L"SHA256" (BCRYPT_SHA256_ALGORITHM)</li>
     * <li>L"SHA384" (BCRYPT_SHA384_ALGORITHM)</li>
     * <li>L"SHA512" (BCRYPT_SHA512_ALGORITHM)</li>
     * </ul>
     * The following is an  example:
     * 
     * <ul>
     * <li>L"RSA/SHA256;RSA/SHA256"</li>
     * </ul>
     * This property is explicitly set by the verify revocation functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID"></a><a id="cert_issuer_pub_key_bit_length_prop_id"></a><dl>
     * <dt><b>CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/dpapi/ns-dpapi-crypt_integer_blob">CRYPT_DATA_BLOB</a> structure.
     * 
     * 
     * 
     * Sets the length, in bits, of the public key in the CRL issuer certificate. This property is also applicable to an OCSP that has been converted to a CRL.
     * 
     * This property is explicitly set by the verify revocation functions.
     * 
     * <b>Windows8 and Windows Server2012:</b>Support for this property begins.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_CONTEXT_PROP_ID"></a><a id="cert_key_context_prop_id"></a><dl>
     * <dt><b>CERT_KEY_CONTEXT_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a>
     * 
     * 
     * Sets a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_IDENTIFIER_PROP_ID"></a><a id="cert_key_identifier_prop_id"></a><dl>
     * <dt><b>CERT_KEY_IDENTIFIER_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_PROV_HANDLE_PROP_ID"></a><a id="cert_key_prov_handle_prop_id"></a><dl>
     * <dt><b>CERT_KEY_PROV_HANDLE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>:  pointer to an <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a>
     * 
     * 
     * Sets the provider handle obtained from the CERT_KEY_CONTEXT_PROP_ID.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_PROV_INFO_PROP_ID"></a><a id="cert_key_prov_info_prop_id"></a><dl>
     * <dt><b>CERT_KEY_PROV_INFO_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>:  pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a>
     * 
     * 
     * Sets a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_SPEC_PROP_ID"></a><a id="cert_key_spec_prop_id"></a><dl>
     * <dt><b>CERT_KEY_SPEC_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>DWORD</b>
     * 
     * Sets a <b>DWORD</b> value specifying the private key obtained from CERT_KEY_CONTEXT_PROP_ID property if it exists. Otherwise, if CERT_KEY_PROV_INFO_PROP_ID exists, it is the source of the <i>dwKeySpec</i>.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_MD5_HASH_PROP_ID"></a><a id="cert_md5_hash_prop_id"></a><dl>
     * <dt><b>CERT_MD5_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets the MD5 hash. You can compute the hash by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NEXT_UPDATE_LOCATION_PROP_ID"></a><a id="cert_next_update_location_prop_id"></a><dl>
     * <dt><b>CERT_NEXT_UPDATE_LOCATION_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets the ASN.1 encoded 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_alt_name_info">CERT_ALT_NAME_INFO</a> structure on a CTL.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_PVK_FILE_PROP_ID"></a><a id="cert_pvk_file_prop_id"></a><dl>
     * <dt><b>CERT_PVK_FILE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets a <b>null</b>-terminated Unicode, wide character string specifying the name of the file that contains the private key associated with the certificate's public key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SHA1_HASH_PROP_ID"></a><a id="cert_sha1_hash_prop_id"></a><dl>
     * <dt><b>CERT_SHA1_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets the SHA1 hash. You can compute the hash by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SIGN_HASH_CNG_ALG_PROP_ID"></a><a id="cert_sign_hash_cng_alg_prop_id"></a><dl>
     * <dt><b>CERT_SIGN_HASH_CNG_ALG_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/dpapi/ns-dpapi-crypt_integer_blob">CRYPT_DATA_BLOB</a> structure.
     * 
     * Sets the L<i>&lt;SIGNATURE&gt;</i>/<i>&lt;HASH&gt;</i> string representing the certificate signature. The <i>&lt;SIGNATURE&gt;</i> value identifies the CNG public key algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"RSA" (BCRYPT_RSA_ALGORITHM)</li>
     * <li>L"DSA" (BCRYPT_DSA_ALGORITHM)</li>
     * <li>L"ECDSA" (SSL_ECDSA_ALGORITHM)</li>
     * </ul>
     * The <i>&lt;HASH&gt;</i> value identifies the CNG hash algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"MD5" (BCRYPT_MD5_ALGORITHM)</li>
     * <li>L"SHA1" (BCRYPT_SHA1_ALGORITHM)</li>
     * <li>L"SHA256" (BCRYPT_SHA256_ALGORITHM)</li>
     * <li>L"SHA384" (BCRYPT_SHA384_ALGORITHM)</li>
     * <li>L"SHA512" (BCRYPT_SHA512_ALGORITHM)</li>
     * </ul>
     * The following are common examples:
     * 
     * <ul>
     * <li>LRSA/SHA1</li>
     * <li>LRSA/SHA256</li>
     * <li>LECDSA/SHA256 </li>
     * </ul>
     * This property is also applicable to an OCSP response that has been converted to a  CRL.
     * 
     * This property is explicitly set by the verify revocation functions.
     * 
     * <b>Windows8 and Windows Server2012:</b>Support for this property begins.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SIGNATURE_HASH_PROP_ID"></a><a id="cert_signature_hash_prop_id"></a><dl>
     * <dt><b>CERT_SIGNATURE_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets the signature hash. If the hash does not exist, it is computed with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashtobesigned">CryptHashToBeSigned</a>. The length of the hash is 20 bytes for SHA and 16 for MD5.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The user can define additional <i>dwPropId</i> types by using <b>DWORD</b> values from CERT_FIRST_USER_PROP_ID to CERT_LAST_USER_PROP_ID. For all user-defined <i>dwPropId</i> types, <i>pvData</i> points to an encoded <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>.
     * 
     * For all the other property identifiers, <i>pvData</i> points to an encoded <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure.
     * @param {Integer} dwFlags CERT_STORE_NO_CRYPT_RELEASE_FLAG can be set for the CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_CONTEXT_PROP_ID <i>dwPropId</i> properties. 
     * 
     * 
     * 
     * 
     * If the CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG value is set, any provider-write errors are ignored and the cached context's properties are always set.
     * 
     * If the CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG is set, any property set is not persisted.
     * @param {Pointer<Void>} pvData A pointer to a data type that is determined by the value passed in <i>dwPropId</i>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>For any <i>dwPropId</i>, setting <i>pvData</i> to <b>NULL</b> deletes the property.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property is not valid. The identifier specified was greater than 0x0000FFFF, or, for the CERT_KEY_CONTEXT_PROP_ID property, a <b>cbSize</b> member that is not valid was specified in the <a href="/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certsetcrlcontextproperty
     * @since windows5.1.2600
     */
    static CertSetCRLContextProperty(pCrlContext, dwPropId, dwFlags, pvData) {
        pvDataMarshal := pvData is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSetCRLContextProperty", "ptr", pCrlContext, "uint", dwPropId, "uint", dwFlags, pvDataMarshal, pvData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Gets an extended property for the specified certificate revocation list (CRL) context.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure.
     * @param {Integer} dwPropId Identifies the property to be retrieved. Currently defined identifiers and the data type to be returned in <i>pvData</i> are listed in the following table. 
     * 
     * 
     * 
     * 
     * 						
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ACCESS_STATE_PROP_ID"></a><a id="cert_access_state_prop_id"></a><dl>
     * <dt><b>CERT_ACCESS_STATE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>DWORD</b>
     * 
     * Returns a <b>DWORD</b> value indicating whether write operations to the certificate are persisted. The <b>DWORD</b> value is not set if the certificate is in a memory store or in a registry-based store that is opened as read-only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ARCHIVED_PROP_ID"></a><a id="cert_archived_prop_id"></a><dl>
     * <dt><b>CERT_ARCHIVED_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: <b>NULL</b>
     * 
     * Indicates the certificate is skipped during enumerations. A certificate with this property set is found with explicit search operations, such as those used to find a certificate with a specific hash or a serial number. No data in <i>pvData</i> is associated with this property.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_AUTO_ENROLL_PROP_ID"></a><a id="cert_auto_enroll_prop_id"></a><dl>
     * <dt><b>CERT_AUTO_ENROLL_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns a <b>null</b>-terminated Unicode string naming the certificate type for which the certificate has been auto enrolled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CTL_USAGE_PROP_ID"></a><a id="cert_ctl_usage_prop_id"></a><dl>
     * <dt><b>CERT_CTL_USAGE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns an array of bytes containing an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoded <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CTL_USAGE</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_DESCRIPTION_PROP_ID"></a><a id="cert_description_prop_id"></a><dl>
     * <dt><b>CERT_DESCRIPTION_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the property displayed by the certificate UI. This property allows the user to describe the certificate's use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ENHKEY_USAGE_PROP_ID"></a><a id="cert_enhkey_usage_prop_id"></a><dl>
     * <dt><b>CERT_ENHKEY_USAGE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: 
     * 
     * Returns an array of bytes containing an ASN.1 encoded <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CERT_ENHKEY_USAGE</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_FRIENDLY_NAME_PROP_ID"></a><a id="cert_friendly_name_prop_id"></a><dl>
     * <dt><b>CERT_FRIENDLY_NAME_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns a <b>null</b>-terminated Unicode character string that contains the display name for the CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID"></a><a id="cert_issuer_chain_pub_key_cng_alg_bit_length_prop_id"></a><dl>
     * <dt><b>CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: Pointer to a null-terminated Unicode string.
     * 
     * Returns a string containing a set of L"<i>&lt;PUBKEY&gt;</i>/<i>&lt;BITLENGTH&gt;</i>" public key algorithm and bit length pairs. The semicolon, L";", is used as the delimiter.
     * 
     * The <i>&lt;PUBKEY&gt;</i> value identifies the CNG public key algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"RSA" (BCRYPT_RSA_ALGORITHM)</li>
     * <li>L"DSA" (BCRYPT_DSA_ALGORITHM)</li>
     * <li>L"ECDSA" (SSL_ECDSA_ALGORITHM)</li>
     * </ul>
     * An <i>&lt;PUBKEY&gt;</i>/<i>&lt;BITLENGTH&gt;</i> pair is returned for each certificate in the CRL issuer chain excluding the leaf. This property is only set when an OCSP response with an independent signer chain is converted to a CRL.
     * 
     * <div class="alert"><b>Note</b>This property cannot be retrieved for a delegated OCSP signer certificate. A delegated signer certificate is signed with the same key used to sign the subject certificate and is checked there.</div>
     * <div></div>
     * The following is an example:
     * 
     * : L"RSA/2048;RSA/4096"
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID"></a><a id="cert_issuer_chain_sign_hash_cng_alg_prop_id"></a><dl>
     * <dt><b>CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: Pointer to a null-terminated Unicode string.
     * 
     * Returns a string that contains a set of L"<i>&lt;SIGNATURE&gt;</i>/<i>&lt;HASH&gt;</i>" algorithm pairs. The semicolon, L";", is used as the delimiter between pairs.
     * 
     * This property is set only when an OCSP response is converted to a CRL. For a delegated OCSP signer certificate, only the algorithm pair for the signer certificate is returned. For an independent OCSP signer certificate chain, an algorithm pair is returned for each certificate in the chain excluding the root.
     * 
     * The <i>&lt;SIGNATURE&gt;</i> value identifies the CNG public key algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"RSA" (BCRYPT_RSA_ALGORITHM)</li>
     * <li>L"DSA" (BCRYPT_DSA_ALGORITHM)</li>
     * <li>L"ECDSA" (SSL_ECDSA_ALGORITHM)</li>
     * </ul>
     * The <i>&lt;HASH&gt;</i> value identifies the CNG hash algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"MD5" (BCRYPT_MD5_ALGORITHM)</li>
     * <li>L"SHA1" (BCRYPT_SHA1_ALGORITHM)</li>
     * <li>L"SHA256" (BCRYPT_SHA256_ALGORITHM)</li>
     * <li>L"SHA384" (BCRYPT_SHA384_ALGORITHM)</li>
     * <li>L"SHA512" (BCRYPT_SHA512_ALGORITHM)</li>
     * </ul>
     * The following shows an  example:
     * 
     * <ul>
     * <li>L"RSA/SHA256;RSA/SHA256"</li>
     * </ul>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID"></a><a id="cert_issuer_pub_key_bit_length_prop_id"></a><dl>
     * <dt><b>CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: Pointer to a <b>DWORD</b> value.
     * 
     * Returns the length, in bits, of the public key in the CRL issuer certificate. This property is also applicable to an OCSP response that has been converted to a CRL.
     * 
     * <b>Windows8 and Windows Server2012:</b>Support for this property begins.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_CONTEXT_PROP_ID"></a><a id="cert_key_context_prop_id"></a><dl>
     * <dt><b>CERT_KEY_CONTEXT_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a>
     * 
     * 
     * Returns a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_IDENTIFIER_PROP_ID"></a><a id="cert_key_identifier_prop_id"></a><dl>
     * <dt><b>CERT_KEY_IDENTIFIER_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * If nonexistent, searches for the szOID_SUBJECT_KEY_IDENTIFIER extension. If that fails, a SHA1 hash is done on the certificate's <b>SubjectPublicKeyInfo</b> member to produce the identifier values.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_PROV_HANDLE_PROP_ID"></a><a id="cert_key_prov_handle_prop_id"></a><dl>
     * <dt><b>CERT_KEY_PROV_HANDLE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>:  pointer to an <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a>
     * 
     * 
     * Returns the provider handle obtained from the CERT_KEY_CONTEXT_PROP_ID.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_PROV_INFO_PROP_ID"></a><a id="cert_key_prov_info_prop_id"></a><dl>
     * <dt><b>CERT_KEY_PROV_INFO_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>:  pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a>
     * 
     * 
     * Returns a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_SPEC_PROP_ID"></a><a id="cert_key_spec_prop_id"></a><dl>
     * <dt><b>CERT_KEY_SPEC_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>DWORD</b>
     * 
     * Returns a <b>DWORD</b> value specifying the private key obtained from CERT_KEY_CONTEXT_PROP_ID property if it exists. Otherwise, if CERT_KEY_PROV_INFO_PROP_ID exists, it is the source of the <i>dwKeySpec</i>.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_MD5_HASH_PROP_ID"></a><a id="cert_md5_hash_prop_id"></a><dl>
     * <dt><b>CERT_MD5_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the MD5 hash. If the hash does not exist, it is computed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NEXT_UPDATE_LOCATION_PROP_ID"></a><a id="cert_next_update_location_prop_id"></a><dl>
     * <dt><b>CERT_NEXT_UPDATE_LOCATION_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the ASN.1 encoded 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_alt_name_info">CERT_ALT_NAME_INFO</a> structure. 
     * 
     * 
     * 
     * 
     * CERT_NEXT_UPDATE_LOCATION_PROP_ID is currently used only with CTLs.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_PVK_FILE_PROP_ID"></a><a id="cert_pvk_file_prop_id"></a><dl>
     * <dt><b>CERT_PVK_FILE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns a <b>null</b>-terminated Unicode, wide character string specifying the file name containing the private key associated with the certificate's public key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SHA1_HASH_PROP_ID"></a><a id="cert_sha1_hash_prop_id"></a><dl>
     * <dt><b>CERT_SHA1_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the SHA1 hash. If the hash does not exist, it is computed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SIGN_HASH_CNG_ALG_PROP_ID"></a><a id="cert_sign_hash_cng_alg_prop_id"></a><dl>
     * <dt><b>CERT_SIGN_HASH_CNG_ALG_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: Pointer to a null-terminated Unicode string.
     * 
     * Returns the L<i>&lt;SIGNATURE&gt;</i>/<i>&lt;HASH&gt;</i> string representing the certificate signature. The <i>&lt;SIGNATURE&gt;</i> value identifies the CNG public key algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"RSA" (BCRYPT_RSA_ALGORITHM)</li>
     * <li>L"DSA" (BCRYPT_DSA_ALGORITHM)</li>
     * <li>L"ECDSA" (SSL_ECDSA_ALGORITHM)</li>
     * </ul>
     * The <i>&lt;HASH&gt;</i> value identifies the CNG hash algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"MD5" (BCRYPT_MD5_ALGORITHM)</li>
     * <li>L"SHA1" (BCRYPT_SHA1_ALGORITHM)</li>
     * <li>L"SHA256" (BCRYPT_SHA256_ALGORITHM)</li>
     * <li>L"SHA384" (BCRYPT_SHA384_ALGORITHM)</li>
     * <li>L"SHA512" (BCRYPT_SHA512_ALGORITHM)</li>
     * </ul>
     * The following are common examples:
     * 
     * <ul>
     * <li>LRSA/SHA1</li>
     * <li>LRSA/SHA256</li>
     * <li>LECDSA/SHA256 </li>
     * </ul>
     * This property is also applicable to an OCSP response that has been converted to a CRL.
     * 
     * <b>Windows8 and Windows Server2012:</b>Support for this property begins.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SIGNATURE_HASH_PROP_ID"></a><a id="cert_signature_hash_prop_id"></a><dl>
     * <dt><b>CERT_SIGNATURE_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the signature hash. If the hash does not exist, it is computed with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashtobesigned">CryptHashToBeSigned</a>. The length of the hash is 20 bytes for SHA and 16 for MD5.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * For many property identifiers, <i>pvData</i> points to an array of bytes and not a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> as pointed to by the <i>pvData</i> parameter in <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsetcrlcontextproperty">CertSetCRLContextProperty</a>.
     * 
     * For more information about each property identifier, see the documentation on the <i>dwPropId</i> parameter in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsetcertificatecontextproperty">CertSetCertificateContextProperty</a>.
     * @param {Pointer} pvData A pointer to a buffer to receive the data as determined by <i>dwPropId</i>. Structures pointed to by members of a structure returned are also returned following the base structure. Therefore, the size contained in <i>pcbData</i> often exceed the size of the base structure. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of the information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbData A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes to be stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. 
     * 
     * Note that errors from the called function 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a> can be propagated to this function. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CRL does not have the specified property.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pvData</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbData</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certgetcrlcontextproperty
     * @since windows5.1.2600
     */
    static CertGetCRLContextProperty(pCrlContext, dwPropId, pvData, pcbData) {
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetCRLContextProperty", "ptr", pCrlContext, "uint", dwPropId, "ptr", pvData, pcbDataMarshal, pcbData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertEnumCRLContextProperties function retrieves the first or next extended property associated with a certificate revocation list (CRL) context.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure.
     * @param {Integer} dwPropId Property number of the last property enumerated. To get the first property, <i>dwPropId</i> is zero. To retrieve subsequent properties, <i>dwPropId</i> is set to the property number returned by the last call to the function. To enumerate all the properties, function calls continue until the function returns zero. 
     * 
     * 
     * 
     * 
     * Applications can call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcrlcontextproperty">CertGetCRLContextProperty</a> with the <i>dwPropId</i> returned by this function to retrieve that property's data.
     * @returns {Integer} The return value is a <b>DWORD</b> value that identifies a CRL context's property. The <b>DWORD</b> value returned by one call of the function can be supplied as the <i>dwPropId</i> in a subsequent call to the function. If there are no more properties to be enumerated or if the function fails, zero is returned.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certenumcrlcontextproperties
     * @since windows5.1.2600
     */
    static CertEnumCRLContextProperties(pCrlContext, dwPropId) {
        result := DllCall("CRYPT32.dll\CertEnumCRLContextProperties", "ptr", pCrlContext, "uint", dwPropId, "uint")
        return result
    }

    /**
     * The CertFindCertificateInCRL function searches the certificate revocation list (CRL) for the specified certificate.
     * @param {Pointer<CERT_CONTEXT>} pCert A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> of the certificate to be searched for in the CRL.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> to be searched.
     * @param {Integer} dwFlags Reserved for future use. Must be set to zero.
     * @param {Pointer<Pointer<CRL_ENTRY>>} ppCrlEntry If the certificate is found in the CRL, this pointer is updated with a pointer to the entry. Otherwise, it is set to <b>NULL</b>. The returned entry is not allocated and must not be freed.
     * @returns {BOOL} <b>TRUE</b> if the list was searched; otherwise <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certfindcertificateincrl
     * @since windows5.1.2600
     */
    static CertFindCertificateInCRL(pCert, pCrlContext, dwFlags, ppCrlEntry) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        ppCrlEntryMarshal := ppCrlEntry is VarRef ? "ptr*" : "ptr"

        result := DllCall("CRYPT32.dll\CertFindCertificateInCRL", "ptr", pCert, "ptr", pCrlContext, "uint", dwFlags, "ptr", pvReserved, ppCrlEntryMarshal, ppCrlEntry, "int")
        return result
    }

    /**
     * The CertIsValidCRLForCertificate function checks a CRL to find out if it is a CRL that would include a specific certificate if that certificate were revoked.
     * @param {Pointer<CERT_CONTEXT>} pCert A pointer to a certificate <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a>.
     * @param {Pointer<CRL_CONTEXT>} pCrl A pointer to a CRL. The function checks this CRL to determine whether it could contain the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a> pointed to by <i>pCert</i>. The function does not look for the certificate in the CRL.
     * @param {Integer} dwFlags Currently not used and must be set to zero.
     * @returns {BOOL} The function returns <b>TRUE</b> if the CRL is a valid CRL to be searched for the specific certificate. It returns <b>FALSE</b> if the CRL is not a valid CRL for searching for the certificate.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certisvalidcrlforcertificate
     * @since windows5.1.2600
     */
    static CertIsValidCRLForCertificate(pCert, pCrl, dwFlags) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("CRYPT32.dll\CertIsValidCRLForCertificate", "ptr", pCert, "ptr", pCrl, "uint", dwFlags, "ptr", pvReserved, "int")
        return result
    }

    /**
     * Creates a certificate context from an encoded certificate and adds it to the certificate store.
     * @param {HCERTSTORE} hCertStore A handle to the certificate store.
     * @param {Integer} dwCertEncodingType Specifies the type of encoding used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer} pbCertEncoded A pointer to a buffer containing the encoded certificate that is to be added to the certificate store.
     * @param {Integer} cbCertEncoded The size, in bytes, of the <i>pbCertEncoded</i> buffer.
     * @param {Integer} dwAddDisposition Specifies the action to take if a matching certificate or link to a matching certificate exists in the store. Currently defined disposition values and their uses are as follows.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function makes no check for an existing matching certificate or link to a matching certificate. A new certificate is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or a link to a matching certificate exists in the store, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or link to a matching certificate exists in the store, the existing certificate or link is deleted and a new certificate is created and added to the store. If a matching certificate or link to a matching certificate does not exist, a new certificate is created and added to the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES"></a><a id="cert_store_add_replace_existing_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate exists in the store, that existing context is deleted before creating and adding the new context. The new context inherits properties from the existing certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or a link to a matching certificate exists, that existing certificate or link is used and properties from the new certificate are added. The function does not fail, but it does not add a new context. If <i>ppCertContext</i> is not <b>NULL</b>, the existing context is duplicated.
     * 
     * If a matching certificate or link to a matching certificate does not exist, a new certificate is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Pointer<CERT_CONTEXT>>} ppCertContext A pointer to a pointer to the decoded <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a>. This is an optional parameter that can be <b>NULL</b>, indicating that the calling application does not require a copy of the new or existing certificate. When a copy is made, its context must be freed by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a>.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This code is returned if CERT_STORE_ADD_NEW is set and the certificate already exists in the store, or if CERT_STORE_ADD_NEWER is set and there is a certificate in the store with a <b>NotBefore</b> date greater than or equal to the <b>NotBefore</b> date on the certificate to be added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A disposition value that is not valid was specified in the <i>dwAddDisposition</i> parameter, or a certificate encoding type that is not valid was specified. Currently, only the X509_ASN_ENCODING type is supported.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>  returns an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certaddencodedcertificatetostore
     * @since windows5.1.2600
     */
    static CertAddEncodedCertificateToStore(hCertStore, dwCertEncodingType, pbCertEncoded, cbCertEncoded, dwAddDisposition, ppCertContext) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        ppCertContextMarshal := ppCertContext is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddEncodedCertificateToStore", "ptr", hCertStore, "uint", dwCertEncodingType, "ptr", pbCertEncoded, "uint", cbCertEncoded, "uint", dwAddDisposition, ppCertContextMarshal, ppCertContext, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Adds a certificate context to the certificate store.
     * @param {HCERTSTORE} hCertStore Handle of a certificate store.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure to be added to the store.
     * @param {Integer} dwAddDisposition Specifies the action to take if a matching certificate or a link to a matching certificate already exists in the store. Currently defined disposition values and their uses are as follows. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function makes no check for an existing matching certificate or link to a matching certificate. A new certificate is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or a link to a matching certificate exists, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="___CERT_STORE_ADD_NEWER"></a><a id="___cert_store_add_newer"></a><dl>
     * <dt><b>   CERT_STORE_ADD_NEWER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or a link to a matching certificate exists  and the NotBefore
     * time of the existing context is equal to or greater than the
     * NotBefore time of the new context being added, the operation fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code. 
     * 
     * If the NotBefore
     * time of the existing context is less than the
     * NotBefore time of the new context being added, the existing certificate or link is deleted and a new certificate is created and added to the store. If a matching certificate or a link to a matching certificate does not exist, a new link is added.      
     * 
     * If <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate revocation lists</a> (CRLs) or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate trust list</a> (CTLs) are being compared, the ThisUpdate time is  used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES"></a><a id="cert_store_add_newer_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or a link to a matching certificate exists and the NotBefore
     * time of the existing context is equal to or greater than the
     * NotBefore time of the new context being added, the operation fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code. 
     * 
     * If the NotBefore
     * time of the existing context is less than the
     * NotBefore time of the new context being added, the existing context is deleted before creating and adding the new context. The new added context inherits properties from the existing certificate.
     * 
     * If CRLs or CTLs are being compared, the ThisUpdate time is  used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a link to a matching certificate exists, that existing certificate or link is deleted and a new certificate is created and added to the store. If a matching certificate or a link to a matching certificate does not exist, a new link is added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES"></a><a id="cert_store_add_replace_existing_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate exists in the store, the existing context is not replaced. The existing context inherits properties from the new certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or a link to a matching certificate exists, that existing certificate or link is used and properties from the new certificate are added. The function does not fail, but it does not add a new context. If <i>pCertContext</i> is not <b>NULL</b>, the existing context is duplicated. 
     * 
     * 
     * 
     * 
     * If a matching certificate or a link to a matching certificate does not exist, a new certificate is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Pointer<CERT_CONTEXT>>} ppStoreContext A pointer to a pointer to the copy to be made of the certificate that was added to the store. 
     * 
     * 
     * 
     * 
     * The <i>ppStoreContext</i> parameter can be <b>NULL</b>, indicating that the calling application does not require a copy of the added certificate. If a copy is made, it must be freed by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a>.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value is returned if CERT_STORE_ADD_NEW is set and the certificate already exists in the store, or if CERT_STORE_ADD_NEWER is set and a certificate exists in the store with a <b>NotBefore</b> date greater than or equal to the <b>NotBefore</b> date on the certificate to be added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A disposition value that is not valid was specified in the <i>dwAddDisposition</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Errors from the called functions, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certaddencodedcertificatetostore">CertAddEncodedCertificateToStore</a> and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certsetcertificatecontextproperty">CertSetCertificateContextProperty</a>, can be propagated to this function.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certaddcertificatecontexttostore
     * @since windows5.1.2600
     */
    static CertAddCertificateContextToStore(hCertStore, pCertContext, dwAddDisposition, ppStoreContext) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        ppStoreContextMarshal := ppStoreContext is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddCertificateContextToStore", "ptr", hCertStore, "ptr", pCertContext, "uint", dwAddDisposition, ppStoreContextMarshal, ppStoreContext, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Adds a serialized certificate, certificate revocation list (CRL), or certificate trust list (CTL) element to the store.
     * @param {HCERTSTORE} hCertStore The handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a> where the created certificate will be stored. If <i>hCertStore</i> is <b>NULL</b>, the function creates a copy of a certificate, CRL, or CTL context with its extended properties, but the certificate, CRL, or CTL is not persisted in any store.
     * @param {Pointer} pbElement A pointer to a buffer that contains the certificate, CRL, or CTL information to be serialized and added to the certificate store.
     * @param {Integer} cbElement The size, in bytes, of the <i>pbElement</i> buffer.
     * @param {Integer} dwAddDisposition Specifies the action to take if the certificate, CRL, or CTL already exists in the store. Currently defined disposition values are shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate, CRL, or CTL is new, it is created and persisted to the store. The operation fails if an identical certificate, CRL, or CTL already exists in the store. The last error code is set to CRYPT_E_EXISTS.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate, CRL, or CTL is new, it is added to the store. If an identical certificate, CRL, or CTL already exists, the existing element is used. If <i>ppvContext</i> is not <b>NULL</b>, the existing context is duplicated. The function only adds properties that do not already exist. The SHA-1 and MD5 hash properties are not copied.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If an identical certificate, CRL, or CTL already exists in the store, the existing certificate, CRL, or CTL context is deleted before creating and adding the new context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No check is made to determine whether an identical certificate, CRL, or CTL already exists. A new element is always created. This can lead to duplicates in the store. To determine whether the element already exists in the store, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcrlfromstore">CertGetCRLFromStore</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetsubjectcertificatefromstore">CertGetSubjectCertificateFromStore</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER"></a><a id="cert_store_add_newer"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or CTL or a link to a matching CRL or CTL exists, the function compares the <b>NotBefore</b> times on the CRL or CTL. If the existing CRL or CTL has a <b>NotBefore</b> time less than the <b>NotBefore</b> time on the new element, the old element or link is replaced just as with CERT_STORE_ADD_REPLACE_EXISTING. If the existing element has a <b>NotBefore</b> time greater than or equal to the <b>NotBefore</b> time on the element to be added, the function fails with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning the CRYPT_E_EXISTS code.
     * 
     * If a matching CRL or CTL or a link to a matching CRL or CTL is not found in the store, a new element is added to the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES"></a><a id="cert_store_add_newer_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The action is the same as for CERT_STORE_ADD_NEWER. However, if an older CRL or CTL is replaced, the properties of the older element are incorporated into the replacement.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES"></a><a id="cert_store_add_replace_existing_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate exists in the store, the existing context is deleted before creating and adding the new context. The new added context inherits properties from the existing certificate.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Integer} dwContextTypeFlags Specifics the contexts that can be added. For example, to add either a certificate, CRL, or CTL, set <i>dwContextTypeFlags</i> to <b>CERT_STORE_CERTIFICATE_CONTEXT_FLAG</b> or <b>CERT_STORE_CRL_CONTEXT_FLAG</b>.
     * 						
     * 
     * Currently defined context type flags are shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ALL_CONTEXT_FLAG"></a><a id="cert_store_all_context_flag"></a><dl>
     * <dt><b>CERT_STORE_ALL_CONTEXT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Adds any context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CERTIFICATE_CONTEXT_FLAG"></a><a id="cert_store_certificate_context_flag"></a><dl>
     * <dt><b>CERT_STORE_CERTIFICATE_CONTEXT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Adds only a certificate context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CRL_CONTEXT_FLAG"></a><a id="cert_store_crl_context_flag"></a><dl>
     * <dt><b>CERT_STORE_CRL_CONTEXT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Adds only a CRL context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CTL_CONTEXT_FLAG"></a><a id="cert_store_ctl_context_flag"></a><dl>
     * <dt><b>CERT_STORE_CTL_CONTEXT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Adds only a CTL context.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Integer>} pdwContextType A pointer to the context type of the added serialized element. This is an optional parameter and can be <b>NULL</b>, which indicates that the calling application does not require the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a> type.
     * 
     * Currently defined context types are shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CERTIFICATE_CONTEXT"></a><a id="cert_store_certificate_context"></a><dl>
     * <dt><b>CERT_STORE_CERTIFICATE_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Certificates
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CRL_CONTEXT"></a><a id="cert_store_crl_context"></a><dl>
     * <dt><b>CERT_STORE_CRL_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * CRLs
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CTL_CONTEXT"></a><a id="cert_store_ctl_context"></a><dl>
     * <dt><b>CERT_STORE_CTL_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * CTLs
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Pointer<Void>>} ppvContext A pointer to a pointer to the decoded certificate, CRL, or CTL context. This is an optional parameter and can be <b>NULL</b>, which indicates that the calling application does not require the context of the added or existing certificate, CRL, or CTL.
     * 
     * If <i>ppvContext</i> is not <b>NULL</b>, it must be the address of a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a>, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a>. When the application is finished with the context, the context must be freed by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> for a certificate, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a> for a CRL, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreectlcontext">CertFreeCTLContext</a> for a CTL.
     * @returns {BOOL} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the <i>dwAddDisposition</i> parameter is set to CERT_STORE_ADD_NEW, the certificate, CRL, or CTL already exists in the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A disposition value that is not valid was specified in the <i>dwAddDisposition</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certaddserializedelementtostore
     * @since windows5.1.2600
     */
    static CertAddSerializedElementToStore(hCertStore, pbElement, cbElement, dwAddDisposition, dwFlags, dwContextTypeFlags, pdwContextType, ppvContext) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        pdwContextTypeMarshal := pdwContextType is VarRef ? "uint*" : "ptr"
        ppvContextMarshal := ppvContext is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddSerializedElementToStore", "ptr", hCertStore, "ptr", pbElement, "uint", cbElement, "uint", dwAddDisposition, "uint", dwFlags, "uint", dwContextTypeFlags, pdwContextTypeMarshal, pdwContextType, ppvContextMarshal, ppvContext, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertDeleteCertificateFromStore function deletes the specified certificate context from the certificate store.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure to be deleted.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 						
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_ACCESSDENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates the store was opened as read-only and a delete operation is not allowed.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certdeletecertificatefromstore
     * @since windows5.1.2600
     */
    static CertDeleteCertificateFromStore(pCertContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertDeleteCertificateFromStore", "ptr", pCertContext, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Creates a certificate revocation list (CRL) context from an encoded CRL and adds it to the certificate store.
     * @param {HCERTSTORE} hCertStore Handle of a certificate store.
     * @param {Integer} dwCertEncodingType Specifies the type of encoding used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer} pbCrlEncoded A pointer to a buffer containing the encoded CRL to be added to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a>.
     * @param {Integer} cbCrlEncoded The size, in bytes, of the <i>pbCrlEncoded</i> buffer.
     * @param {Integer} dwAddDisposition Specifies the action to take if a matching CRL or a link to a matching CRL already exists in the store. Currently defined disposition values and their uses are as follows.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Makes no check for an existing matching CRL or link to a matching CRL. A new CRL is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER"></a><a id="cert_store_add_newer"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, the <b>ThisUpdate</b> times on the CRLs are compared. If the existing CRL has a <b>ThisUpdate</b> time less than the <b>ThisUpdate</b> time on the new CRL, the old CRL or link is replaced just as with CERT_STORE_ADD_REPLACE_EXISTING. If the existing CRL has a <b>ThisUpdate</b> time greater than or equal to the <b>ThisUpdate</b> time on the CRL to be added, the function fails with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning the CRYPT_E_EXISTS code.
     * 
     * If a matching CRL or a link to a matching CRL is not found in the store, a new CRL is added to the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES"></a><a id="cert_store_add_newer_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The action is the same as for CERT_STORE_ADD_NEWER, except that if an older CRL is replaced, the properties of the older CRL are incorporated into the replacement CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, that existing CRL or link is deleted and a new CRL is created and added to the store. If a matching CRL or a link to a matching CRL does not exist, one is added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES"></a><a id="cert_store_add_replace_existing_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL exists in the store, that existing context is deleted before creating and adding the new context. The new context inherits properties from the existing CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, that existing CRL is used and properties from the new CRL are added. The function does not fail, but no new CRL is added. If <i>ppCertContext</i> is not <b>NULL</b>, the existing context is duplicated. 
     * 
     * 
     * 
     * 
     * If a matching CRL or a link to a matching CRL does not exist, a new CRL is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Pointer<CRL_CONTEXT>>} ppCrlContext A pointer to a pointer to the decoded 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure. This is an optional parameter that can be <b>NULL</b>, indicating that the calling application does not require a copy of the new or existing CRL. If a copy is made, that context must be freed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a>.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * CERT_STORE_ADD_NEW is set and the CRL already exists in the store, or CERT_STORE_ADD_NEWER is set and there is a CRL in the store with a <b>ThisUpdate</b> time greater than or equal to the <b>ThisUpdate</b> time for the CRL to be added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A disposition value that is not valid was specified in the <i>dwAddDisposition</i> parameter, or an encoding type that is not valid was specified. Currently, only the encoding type X509_ASN_ENCODING is supported.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certaddencodedcrltostore
     * @since windows5.1.2600
     */
    static CertAddEncodedCRLToStore(hCertStore, dwCertEncodingType, pbCrlEncoded, cbCrlEncoded, dwAddDisposition, ppCrlContext) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        ppCrlContextMarshal := ppCrlContext is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddEncodedCRLToStore", "ptr", hCertStore, "uint", dwCertEncodingType, "ptr", pbCrlEncoded, "uint", cbCrlEncoded, "uint", dwAddDisposition, ppCrlContextMarshal, ppCrlContext, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Adds a certificate revocation list (CRL) context to the specified certificate store.
     * @param {HCERTSTORE} hCertStore Handle of a certificate store.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure to be added.
     * @param {Integer} dwAddDisposition Specifies the action to take if a matching CRL or a link to a matching CRL already exists in the store. Currently defined disposition values and their uses are as follows.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Makes no check for an existing matching CRL or link to a matching CRL. A new CRL is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER"></a><a id="cert_store_add_newer"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, the function compares the <b>ThisUpdate</b> times on the CRLs. If the existing CRL has a <b>ThisUpdate</b> time less than the <b>ThisUpdate</b> time on the new CRL, the old CRL or link is replaced just as with CERT_STORE_ADD_REPLACE_EXISTING. If the existing CRL has a <b>ThisUpdate</b> time greater than or equal to the <b>ThisUpdate</b> time on the CRL to be added, the function fails with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning the CRYPT_E_EXISTS code.
     * 
     * If a matching CRL or a link to a matching CRL is not found in the store, a new CRL is added to the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES"></a><a id="cert_store_add_newer_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The action is the same as for CERT_STORE_ADD_NEWER, except that if an older CRL is replaced, the properties of the older CRL are incorporated into the replacement CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, the existing CRL or link is deleted and a new CRL is created and added to the store. If a matching CRL or a link to a matching CRL does not exist, one is added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES"></a><a id="cert_store_add_replace_existing_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL exists in the store, the existing context is deleted before creating and adding the new context. The added context inherits properties from the existing CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, that existing CRL is used and properties from the new CRL are added. The function does not fail, but no new CRL is added. If <i>ppCertContext</i> is not <b>NULL</b>, the existing context is duplicated. 
     * 
     * 
     * 
     * 
     * If a matching CRL or a link to a matching CRL does not exist, a new CRL is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Pointer<CRL_CONTEXT>>} ppStoreContext A pointer to a pointer to the decoded CRL context. This is an optional parameter and can be <b>NULL</b>, indicating that the calling application does not require a copy of the added or existing CRL. If a copy is made, that context must be freed by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a>.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certaddencodedcrltostore">CertAddEncodedCRLToStore</a> and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certsetcrlcontextproperty">CertSetCRLContextProperty</a> can be propagated to this function.
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This error is returned if CERT_STORE_ADD_NEW is set and the CRL already exists in the store or if CERT_STORE_ADD_NEWER is set and a CRL exists in the store with a <b>ThisUpdate</b> date greater than or equal to the <b>ThisUpdate</b> date on the CRL to be added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwAddDisposition</i> parameter specified a disposition value that is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certaddcrlcontexttostore
     * @since windows5.1.2600
     */
    static CertAddCRLContextToStore(hCertStore, pCrlContext, dwAddDisposition, ppStoreContext) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        ppStoreContextMarshal := ppStoreContext is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddCRLContextToStore", "ptr", hCertStore, "ptr", pCrlContext, "uint", dwAddDisposition, ppStoreContextMarshal, ppStoreContext, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertDeleteCRLFromStore function deletes the specified certificate revocation list (CRL) context from the certificate store.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure to be deleted.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_ACCESSDENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The store was opened read-only, and a delete operation is not allowed.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certdeletecrlfromstore
     * @since windows5.1.2600
     */
    static CertDeleteCRLFromStore(pCrlContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertDeleteCRLFromStore", "ptr", pCrlContext, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertSerializeCertificateStoreElement function serializes a certificate context's encoded certificate and its encoded properties. The result can be persisted to storage so that the certificate and properties can be retrieved at a later time.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> to be serialized.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer} pbElement A pointer to a buffer that receives the serialized output, including the encoded certificate and possibly its properties. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbElement A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pbElement</i> parameter. When the function returns, <b>DWORD</b> value contains the number of bytes stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certserializecertificatestoreelement
     * @since windows5.1.2600
     */
    static CertSerializeCertificateStoreElement(pCertContext, dwFlags, pbElement, pcbElement) {
        pcbElementMarshal := pcbElement is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSerializeCertificateStoreElement", "ptr", pCertContext, "uint", dwFlags, "ptr", pbElement, pcbElementMarshal, pcbElement, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertSerializeCRLStoreElement function serializes an encoded certificate revocation list (CRL) context and the encoded representation of its properties.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure being serialized.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer} pbElement A pointer to a buffer to receive the serialized output, including the encoded CRL, and possibly its properties. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbElement A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pbElement</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certserializecrlstoreelement
     * @since windows5.1.2600
     */
    static CertSerializeCRLStoreElement(pCrlContext, dwFlags, pbElement, pcbElement) {
        pcbElementMarshal := pcbElement is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSerializeCRLStoreElement", "ptr", pCrlContext, "uint", dwFlags, "ptr", pbElement, pcbElementMarshal, pcbElement, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertDuplicateCTLContext function duplicates a certificate trust list (CTL) context by incrementing its reference count.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure for which the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> is being incremented.
     * @returns {Pointer<CTL_CONTEXT>} Currently, a copy is not made of the context, and the returned pointer to <a href="/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> is the same as pointer input. If the pointer passed into this function is <b>NULL</b>, <b>NULL</b> is returned.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certduplicatectlcontext
     * @since windows5.1.2600
     */
    static CertDuplicateCTLContext(pCtlContext) {
        result := DllCall("CRYPT32.dll\CertDuplicateCTLContext", "ptr", pCtlContext, "ptr")
        return result
    }

    /**
     * The CertCreateCTLContext function creates a certificate trust list (CTL) context from an encoded CTL. The created context is not persisted to a certificate store. The function makes a copy of the encoded CTL within the created context.
     * @param {Integer} dwMsgAndCertEncodingType Specifies the type of encoding used. Both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> must be specified by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer} pbCtlEncoded A pointer to a buffer containing the encoded CTL from which the context is to be created.
     * @param {Integer} cbCtlEncoded The size, in bytes, of the <i>pbCtlEncoded</i> buffer.
     * @returns {Pointer<CTL_CONTEXT>} If the function succeeds, the return value is a pointer to a read-only 
     * <a href="/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a>.
     * 
     * If the function fails and is unable to decode and create the <a href="/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a>, the return value is <b>NULL</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following table shows a possible error code.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Only PKCS_7_ASN_ENCODING and X509_ASN_ENCODING are supported.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certcreatectlcontext
     * @since windows5.1.2600
     */
    static CertCreateCTLContext(dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertCreateCTLContext", "uint", dwMsgAndCertEncodingType, "ptr", pbCtlEncoded, "uint", cbCtlEncoded, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Frees a certificate trust list (CTL) context by decrementing its reference count.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> to be freed.
     * @returns {BOOL} The function always returns <b>TRUE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certfreectlcontext
     * @since windows5.1.2600
     */
    static CertFreeCTLContext(pCtlContext) {
        result := DllCall("CRYPT32.dll\CertFreeCTLContext", "ptr", pCtlContext, "int")
        return result
    }

    /**
     * Sets an extended property for the specified certificate trust list (CTL) context.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure.
     * @param {Integer} dwPropId Identifies the property to be set. The value of <i>dwPropId</i> determines the type and content of the <i>pvData</i> parameter. Currently defined identifiers and their related <i>pvData</i> types are as follows. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ARCHIVED_PROP_ID"></a><a id="cert_archived_prop_id"></a><dl>
     * <dt><b>CERT_ARCHIVED_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: <b>NULL</b>
     * 
     * Indicates the certificate is skipped during enumerations. A certificate with this property set is still found with explicit search operationssuch as finding a certificate with a specific <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> or a specific serial number.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_AUTO_ENROLL_PROP_ID"></a><a id="cert_auto_enroll_prop_id"></a><dl>
     * <dt><b>CERT_AUTO_ENROLL_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>
     * 
     * 
     * Property set after a certificate has been enrolled using Auto Enroll. The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure pointed to by <i>pvData</i> includes a <b>null</b>-terminated, Unicode name of the certificate type for which the certificates has been auto enrolled. Any subsequent calls to Auto Enroll for the certificate checks for this property to determine whether the certificate has been enrolled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CTL_USAGE_PROP_ID"></a><a id="cert_ctl_usage_prop_id"></a><dl>
     * <dt><b>CERT_CTL_USAGE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>
     * 
     * 
     * <i>pvData</i> points to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure containing an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoded 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CTL_USAGE</a> structure. This structure was encoded using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencodeobject">CryptEncodeObject</a> with X509_ENHANCED_KEY_USAGE value set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_DESCRIPTION_PROP_ID"></a><a id="cert_description_prop_id"></a><dl>
     * <dt><b>CERT_DESCRIPTION_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>
     * 
     * 
     * Property set and displayed by the certificate UI. This property allows the user to describe the certificate's use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ENHKEY_USAGE_PROP_ID"></a><a id="cert_enhkey_usage_prop_id"></a><dl>
     * <dt><b>CERT_ENHKEY_USAGE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>
     * 
     * 
     * The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure containing an ASN.1 encoded <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CERT_ENHKEY_USAGE</a> structure. This structure was encoded using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencodeobject">CryptEncodeObject</a> with X509_ENHANCED_KEY_USAGE value set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_FRIENDLY_NAME_PROP_ID"></a><a id="cert_friendly_name_prop_id"></a><dl>
     * <dt><b>CERT_FRIENDLY_NAME_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>
     * 
     * 
     * The  <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure specifies the display name of the certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_HASH_PROP_ID"></a><a id="cert_hash_prop_id"></a><dl>
     * <dt><b>CERT_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a>
     * 
     * 
     * This property is implicitly set by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatecontextproperty">CertGetCertificateContextProperty</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_CONTEXT_PROP_ID"></a><a id="cert_key_context_prop_id"></a><dl>
     * <dt><b>CERT_KEY_CONTEXT_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a>
     * 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a> structure  contains both the <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a> value and the key specification for the private key. For more information about the <b>hCryptProv</b> member and <i>dwFlags</i> settings, see CERT_KEY_PROV_HANDLE_PROP_ID, following. Note that more <b>CERT_KEY_CONTEXT</b> structure members can be added for this property. If so, the <b>cbSize</b> member value will be adjusted accordingly. The <b>cbSize</b> member must be set to the size of the <b>CERT_KEY_CONTEXT</b> structure
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_IDENTIFIER_PROP_ID"></a><a id="cert_key_identifier_prop_id"></a><dl>
     * <dt><b>CERT_KEY_IDENTIFIER_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>
     * 
     * 
     * This property is typically implicitly set by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatecontextproperty">CertGetCertificateContextProperty</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_PROV_HANDLE_PROP_ID"></a><a id="cert_key_prov_handle_prop_id"></a><dl>
     * <dt><b>CERT_KEY_PROV_HANDLE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a>
     * 
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a> handle for the certificate's private key is passed. The <b>hCryptProv</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a> structure is updated if it exists. If it does not exist, it is created with <b>dwKeySpec</b> initialized by CERT_KEY_PROV_INFO_PROP_ID. If CERT_STORE_NO_CRYPT_RELEASE_FLAG is not set, the <b>hCryptProv</b> value is implicitly released either when the property is set to <b>NULL</b> or on the final freeing of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_PROV_INFO_PROP_ID"></a><a id="cert_key_prov_info_prop_id"></a><dl>
     * <dt><b>CERT_KEY_PROV_INFO_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a>
     * 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a> structure specifies the certificate's private key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_SPEC_PROP_ID"></a><a id="cert_key_spec_prop_id"></a><dl>
     * <dt><b>CERT_KEY_SPEC_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <b>DWORD</b>
     * 
     * The <b>DWORD</b> value specifies the private key. The <b>dwKeySpec</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a> structure is updated if it exists. If it does not, it is created with <b>hCryptProv</b> set to zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_MD5_HASH_PROP_ID"></a><a id="cert_md5_hash_prop_id"></a><dl>
     * <dt><b>CERT_MD5_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a>
     * 
     * 
     * This property is implicitly set by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatecontextproperty">CertGetCertificateContextProperty</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NEXT_UPDATE_LOCATION_PROP_ID"></a><a id="cert_next_update_location_prop_id"></a><dl>
     * <dt><b>CERT_NEXT_UPDATE_LOCATION_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>
     * 
     * 
     * The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure contains an ASN.1 encoded 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_alt_name_info">CERT_ALT_NAME_INFO</a> structure encoded using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencodeobject">CryptEncodeObject</a> with the X509_ALTERNATE_NAME value set. CERT_NEXT_UPDATE_LOCATION_PROP_ID is currently used only with CTLs.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_PVK_FILE_PROP_ID"></a><a id="cert_pvk_file_prop_id"></a><dl>
     * <dt><b>CERT_PVK_FILE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>
     * 
     * 
     * The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure specifies the name of a file containing the private key associated with the certificate's public key. Inside the <b>CRYPT_DATA_BLOB</b> structure, the <b>pbData</b> member is a pointer to a <b>null</b>-terminated Unicode, wide-character string, and the <b>cbData</b> member indicates the length of the string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SHA1_HASH_PROP_ID"></a><a id="cert_sha1_hash_prop_id"></a><dl>
     * <dt><b>CERT_SHA1_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a>
     * 
     * 
     * This property is implicitly set by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatecontextproperty">CertGetCertificateContextProperty</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SIGNATURE_HASH_PROP_ID"></a><a id="cert_signature_hash_prop_id"></a><dl>
     * <dt><b>CERT_SIGNATURE_HASH_PROP_ID</b></dt>
     * <dt>
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a>
     * </dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a>
     * 
     * 
     * If a signature hash does not exist, it is computed with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashtobesigned">CryptHashToBeSigned</a>. <i>pvData</i> points to an existing or computed hash. Usually, the length of the hash is 20 bytes for SHA and 16 for MD5.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Typically, only the CERT_NEXT_UPDATE_LOCATION_PROP_ID property is set.
     * 
     * Additional <i>dwPropId</i> types can be defined by the user using <b>DWORD</b> values from CERT_FIRST_USER_PROP_ID to CERT_LAST_USER_PROP_ID. For all user-defined <i>dwPropId</i> types, <i>pvData</i> points to an encoded <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure.
     * @param {Integer} dwFlags CERT_STORE_NO_CRYPT_RELEASE_FLAG can be set for the CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_CONTEXT_PROP_ID <i>dwPropId</i> properties. 
     * 
     * 
     * 
     * 
     * If the CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG value is set, any provider-write errors are ignored and the cached context's properties are always set.
     * 
     * If CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG is set, any property set is not persisted.
     * @param {Pointer<Void>} pvData A pointer to a data type that is determined by the value passed in <i>dwPropId</i>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>For any <i>dwPropId</i>, setting <i>pvData</i> to <b>NULL</b> deletes the property.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid property identifier. For details, see 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certsetcertificatecontextproperty">CertSetCertificateContextProperty</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certsetctlcontextproperty
     * @since windows5.1.2600
     */
    static CertSetCTLContextProperty(pCtlContext, dwPropId, dwFlags, pvData) {
        pvDataMarshal := pvData is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSetCTLContextProperty", "ptr", pCtlContext, "uint", dwPropId, "uint", dwFlags, pvDataMarshal, pvData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves an extended property of a certificate trust list (CTL) context.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure.
     * @param {Integer} dwPropId Identifies the property to be retrieved. Currently defined identifiers and the data type to be returned in <i>pvData</i> are listed in the following table. 
     * 
     * 
     * 
     * 
     * 						
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ACCESS_STATE_PROP_ID"></a><a id="cert_access_state_prop_id"></a><dl>
     * <dt><b>CERT_ACCESS_STATE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>DWORD</b>
     * 
     * Returns a <b>DWORD</b> value indicating whether write operations to the certificate are persisted. The <b>DWORD</b> value is not set if the certificate is in a memory store or in a registry-based store that is opened as read-only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ARCHIVED_PROP_ID"></a><a id="cert_archived_prop_id"></a><dl>
     * <dt><b>CERT_ARCHIVED_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: <b>NULL</b>
     * 
     * Indicates the certificate is skipped during enumerations. A certificate with this property set is found with explicit search operations, such as those used to find a certificate with a specific hash or a serial number. No data in <i>pvData</i> is associated with this property.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_AUTO_ENROLL_PROP_ID"></a><a id="cert_auto_enroll_prop_id"></a><dl>
     * <dt><b>CERT_AUTO_ENROLL_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns a <b>null</b>-terminated Unicode string naming the certificate type for which the certificate has been auto enrolled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CTL_USAGE_PROP_ID"></a><a id="cert_ctl_usage_prop_id"></a><dl>
     * <dt><b>CERT_CTL_USAGE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns an array of bytes containing an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoded <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CTL_USAGE</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_DESCRIPTION_PROP_ID"></a><a id="cert_description_prop_id"></a><dl>
     * <dt><b>CERT_DESCRIPTION_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the property displayed by the certificate UI. This property allows the user to describe the certificate's use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ENHKEY_USAGE_PROP_ID"></a><a id="cert_enhkey_usage_prop_id"></a><dl>
     * <dt><b>CERT_ENHKEY_USAGE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns an array of bytes containing an ASN.1 encoded <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CERT_ENHKEY_USAGE</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_FRIENDLY_NAME_PROP_ID"></a><a id="cert_friendly_name_prop_id"></a><dl>
     * <dt><b>CERT_FRIENDLY_NAME_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns a <b>null</b>-terminated Unicode character string that contains the display name for the CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_HASH_PROP_ID"></a><a id="cert_hash_prop_id"></a><dl>
     * <dt><b>CERT_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the SHA1 hash. If the hash does not exist, it is computed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_CONTEXT_PROP_ID"></a><a id="cert_key_context_prop_id"></a><dl>
     * <dt><b>CERT_KEY_CONTEXT_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a>
     * 
     * 
     * Returns a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_IDENTIFIER_PROP_ID"></a><a id="cert_key_identifier_prop_id"></a><dl>
     * <dt><b>CERT_KEY_IDENTIFIER_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * If nonexistent, searches for the szOID_SUBJECT_KEY_IDENTIFIER extension. If that fails, a SHA1 hash is done on the certificate's <b>SubjectPublicKeyInfo</b> member to produce the identifier values.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_PROV_HANDLE_PROP_ID"></a><a id="cert_key_prov_handle_prop_id"></a><dl>
     * <dt><b>CERT_KEY_PROV_HANDLE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to an <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a>
     * 
     * 
     * Returns the provider handle obtained from the CERT_KEY_CONTEXT_PROP_ID.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_PROV_INFO_PROP_ID"></a><a id="cert_key_prov_info_prop_id"></a><dl>
     * <dt><b>CERT_KEY_PROV_INFO_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a> structure
     * 
     * Returns a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_SPEC_PROP_ID"></a><a id="cert_key_spec_prop_id"></a><dl>
     * <dt><b>CERT_KEY_SPEC_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>DWORD</b>
     * 
     * Returns a <b>DWORD</b> value specifying the private key obtained from CERT_KEY_CONTEXT_PROP_ID property if it exists. Otherwise, if CERT_KEY_PROV_INFO_PROP_ID exists, it is the source of the <i>dwKeySpec</i>.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_MD5_HASH_PROP_ID"></a><a id="cert_md5_hash_prop_id"></a><dl>
     * <dt><b>CERT_MD5_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the MD5 hash. If the hash does not exist, it is computed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NEXT_UPDATE_LOCATION_PROP_ID"></a><a id="cert_next_update_location_prop_id"></a><dl>
     * <dt><b>CERT_NEXT_UPDATE_LOCATION_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the ASN.1 encoded 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_alt_name_info">CERT_ALT_NAME_INFO</a> structure. 
     * 
     * 
     * 
     * 
     * CERT_NEXT_UPDATE_LOCATION_PROP_ID is currently used only with CTLs.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_PVK_FILE_PROP_ID"></a><a id="cert_pvk_file_prop_id"></a><dl>
     * <dt><b>CERT_PVK_FILE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns a <b>null</b>-terminated Unicode, wide character string specifying the file name containing the private key associated with the certificate's public key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SHA1_HASH_PROP_ID"></a><a id="cert_sha1_hash_prop_id"></a><dl>
     * <dt><b>CERT_SHA1_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the SHA1 hash. If the hash does not exist, it is computed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SIGNATURE_HASH_PROP_ID"></a><a id="cert_signature_hash_prop_id"></a><dl>
     * <dt><b>CERT_SIGNATURE_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the signature hash. If the hash does not exist, it is computed with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashtobesigned">CryptHashToBeSigned</a>. The length of the hash is 20 bytes for SHA and 16 for MD5.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * For all other property identifiers, <i>pvData</i> points to an array of bytes and not a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> as pointed to by the <i>pvData</i> parameter in <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsetcertificatecontextproperty">CertSetCertificateContextProperty</a>.
     * 
     * For more information about each property identifier, see the documentation on the <i>dwPropId</i> parameter in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsetcertificatecontextproperty">CertSetCertificateContextProperty</a>. CERT_SHA1_HASH_PROP_ID and CERT_NEXT_UPDATE_LOCATION_PROP_ID are the predefined properties of most interest.
     * @param {Pointer} pvData A pointer to a buffer to receive the data as determined by <i>dwPropId</i>. Structures pointed to by members of a structure returned are also returned following the base structure. Therefore, the size contained in <i>pcbData</i> often exceed the size of the base structure. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of the information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbData A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes to be stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. 
     * 
     * Errors from the called function, <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a>, can be propagated to this function. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * Some possible error codes follow.
     * 						
     * 					
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CTL does not have the specified property.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pvData</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbData</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certgetctlcontextproperty
     * @since windows5.1.2600
     */
    static CertGetCTLContextProperty(pCtlContext, dwPropId, pvData, pcbData) {
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetCTLContextProperty", "ptr", pCtlContext, "uint", dwPropId, "ptr", pvData, pcbDataMarshal, pcbData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertEnumCTLContextProperties function retrieves the first or next extended property associated with a certificate trust list (CTL) context. Used in a loop, this function can retrieve in sequence all extended properties associated with a CTL context.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure.
     * @param {Integer} dwPropId Property number of the last property enumerated. To get the first property, <i>dwPropId</i> is zero. To retrieve subsequent properties, <i>dwPropId</i> is set to the property number returned by the last call to the function. To enumerate all the properties, function calls continue until the function returns zero. 
     * 
     * 
     * 
     * 
     * Applications can call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetctlcontextproperty">CertGetCTLContextProperty</a> with the <i>dwPropId</i> returned by this function to retrieved that property's data.
     * @returns {Integer} The return value is a <b>DWORD</b> value that identifies a CTL context's property. The <b>DWORD</b> value returned by one call of the function can be supplied as the <i>dwPropId</i> in a subsequent call to the function. If there are no more properties to be enumerated or if the function fails, zero is returned.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certenumctlcontextproperties
     * @since windows5.1.2600
     */
    static CertEnumCTLContextProperties(pCtlContext, dwPropId) {
        result := DllCall("CRYPT32.dll\CertEnumCTLContextProperties", "ptr", pCtlContext, "uint", dwPropId, "uint")
        return result
    }

    /**
     * The CertEnumCTLsInStore function retrieves the first or next certificate trust list (CTL) context in a certificate store. Used in a loop, this function can retrieve in sequence all CTL contexts in a certificate store.
     * @param {HCERTSTORE} hCertStore Handle of a certificate store.
     * @param {Pointer<CTL_CONTEXT>} pPrevCtlContext A pointer to the previous 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure found. It must be <b>NULL</b> to get the first CTL in the store. Successive CTLs are enumerated by setting <i>pPrevCtlContext</i> to the pointer returned by a previous call. This function frees the <b>CTL_CONTEXT</b> referenced by non-<b>NULL</b> values of this parameter. The enumeration skips any CTLs previously deleted by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certdeletectlfromstore">CertDeleteCTLFromStore</a>.
     * @returns {Pointer<CTL_CONTEXT>} If the function succeeds, the return value is a pointer to a read-only 
     * <a href="/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a>.
     * 
     * If the function fails and a CTL is not found, the return value is <b>NULL</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either no CTLs exist in the store, or the function reached the end of the store's list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hCertStore</i> parameter is not the same as that in the CTL context pointed to by the <i>pPrevCtlContext</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certenumctlsinstore
     * @since windows5.1.2600
     */
    static CertEnumCTLsInStore(hCertStore, pPrevCtlContext) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertEnumCTLsInStore", "ptr", hCertStore, "ptr", pPrevCtlContext, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertFindSubjectInCTL function attempts to find the specified subject in a certificate trust list (CTL).
     * @param {Integer} dwEncodingType Specifies the encoding type used. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. For either current encoding type, use: 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Integer} dwSubjectType Specifies the type of subject to be searched for in the CTL. May be <b>NULL</b> for a default search.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CTL_CERT_SUBJECT_TYPE"></a><a id="ctl_cert_subject_type"></a><dl>
     * <dt><b>CTL_CERT_SUBJECT_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSubject</i> data type: Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure.
     * 
     * The CTL's <b>SubjectAlgorithm</b> is examined to determine the representation of the subject's identity. Initially, only SHA1 and MD5 hashes are supported as values for <b>SubjectAlgorithm</b>. The appropriate hash property is obtained from the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CTL_ANY_SUBJECT_TYPE"></a><a id="ctl_any_subject_type"></a><dl>
     * <dt><b>CTL_ANY_SUBJECT_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSubject</i> data type: Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_any_subject_info">CTL_ANY_SUBJECT_INFO</a> structure.
     * 
     * The <b>SubjectAlgorithm</b> member of this structure must match the algorithm type of the CTL, and the <b>SubjectIdentifier</b> member must match one of the CTL entries.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The certificate's <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> or the <b>SubjectIdentifier</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_any_subject_info">CTL_ANY_SUBJECT_INFO</a> structure is used as the key in searching the subject entries. A binary memory comparison is done between the key and the entry's SubjectIdentifier.
     * 
     * If <i>dwSubjectType</i> is set to either preceding value, <i>dwEncodingType</i> is not used.
     * @param {Pointer<Void>} pvSubject Pointer used in conjunction with the <i>dwSubjectType</i> parameter.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure being searched.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @returns {Pointer<CTL_ENTRY>} If the function succeeds, the return value is the entry, if it is found.
     * 
     * If the function fails, the return value is <b>NULL</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The subject was not found in the CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwSubjectType</i> parameter was not either CTL_CERT_SUBJECT_TYPE or CTL_ANY_SUBJECT_TYPE.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CTL's <b>SubjectAlgorithm</b> member did not map to either SHA1 or MD5.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certfindsubjectinctl
     * @since windows5.1.2600
     */
    static CertFindSubjectInCTL(dwEncodingType, dwSubjectType, pvSubject, pCtlContext, dwFlags) {
        pvSubjectMarshal := pvSubject is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertFindSubjectInCTL", "uint", dwEncodingType, "uint", dwSubjectType, pvSubjectMarshal, pvSubject, "ptr", pCtlContext, "uint", dwFlags, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Finds the first or next certificate trust list (CTL) context that matches search criteria established by the dwFindType and its associated pvFindPara.
     * @param {HCERTSTORE} hCertStore Handle of the certificate store to be searched.
     * @param {Integer} dwMsgAndCertEncodingType Specifies the type of encoding used on the CTL. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * 
     * 
     * This parameter is used only when the <i>dwFindType</i> parameter is set to CTL_FIND_USAGE.
     * @param {Integer} dwFindFlags Can be set when <i>dwFindType</i> is set to CTL_FIND_USAGE. For details, see the comments under CTL_FIND_USAGE, following.
     * @param {Integer} dwFindType 
     * @param {Pointer<Void>} pvFindPara A pointer to the search value associated with the <i>dwFindType</i> parameter.
     * @param {Pointer<CTL_CONTEXT>} pPrevCtlContext A pointer to the last 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> returned by this function. It must be <b>NULL</b> to get the first CTL in the store. Successive CTLs are retrieved by setting <i>pPrevCtlContext</i> to the pointer to the <b>CTL_CONTEXT</b> returned by a previous function call. Any certificates that do not meet the search criteria or that have been previously deleted by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certdeletectlfromstore">CertDeleteCTLFromStore</a> are skipped. This function frees the <b>CTL_CONTEXT</b> referenced by non-<b>NULL</b> values of this parameter.
     * @returns {Pointer<CTL_CONTEXT>} If the function succeeds, the return value is a pointer to a read-only <a href="/windows/desktop/SecGloss/c-gly">CTL</a><a href="/windows/desktop/SecGloss/c-gly">context</a>.
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either no CTLs were found in the store, no CTL was found matching the search criteria, or the function reached the end of the store's list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hCertStore</i> parameter is not the same as that in the CTL context pointed to by the <i>pPrevCtlContext</i> parameter, or a value that is not valid was specified in the <i>dwFindType</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certfindctlinstore
     * @since windows5.1.2600
     */
    static CertFindCTLInStore(hCertStore, dwMsgAndCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCtlContext) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        pvFindParaMarshal := pvFindPara is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertFindCTLInStore", "ptr", hCertStore, "uint", dwMsgAndCertEncodingType, "uint", dwFindFlags, "uint", dwFindType, pvFindParaMarshal, pvFindPara, "ptr", pPrevCtlContext, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Creates a certificate trust list (CTL) context from an encoded CTL and adds it to the certificate store.
     * @param {HCERTSTORE} hCertStore Handle of a certificate store.
     * @param {Integer} dwMsgAndCertEncodingType Specifies the type of encoding used. Both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> must be specified by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:<ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer} pbCtlEncoded A pointer to a buffer containing the encoded CTL to be added to the certificate store.
     * @param {Integer} cbCtlEncoded The size, in bytes, of the <i>pbCtlEncoded</i> buffer.
     * @param {Integer} dwAddDisposition Specifies the action to take if a matching CTL or a link to a matching CTL already exists in the store. Currently defined disposition values and their uses are as follows 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Makes no check for an existing matching CTL or link to a matching CTL. A new CTL is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER"></a><a id="cert_store_add_newer"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the <b>ThisUpdate</b> times on the CTLs are compared. If the existing CTL has a <b>ThisUpdate</b> time less than the <b>ThisUpdate</b> time on the new CTL, the old CTL or link is replaced just as with CERT_STORE_ADD_REPLACE_EXISTING. If the existing CTL has a <b>ThisUpdate</b> time greater than or equal to the <b>ThisUpdate</b> time on the CTL to be added, the function fails with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning the CRYPT_E_EXISTS code. 
     * 
     * 
     * 
     * 
     * If a matching CTL or a link to a matching CTL is not found in the store, a new CTL is added to the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES"></a><a id="cert_store_add_newer_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The action is the same as for CERT_STORE_ADD_NEWER, except that if an older CTL is replaced, the properties of the older CTL are incorporated into the replacement CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the existing CTL or link is deleted and a new CTL is created and added to the store. If a matching CTL or a link to a matching CTL does not exist, one is added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES"></a><a id="cert_store_add_replace_existing_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL exists in the store, that existing context is deleted before creating and adding the new context. The added context inherits properties from the existing CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, that existing CTL is used and properties from the new CTL are added. The function does not fail, but no new CTL is added. If <i>ppCertContext</i> is not <b>NULL</b>, the existing context is duplicated. 
     * 
     * 
     * 
     * 
     * If a matching CTL or a link to a matching CTL does not exist, a new CTL is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Pointer<CTL_CONTEXT>>} ppCtlContext A pointer to a pointer to the decoded 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure. Can be <b>NULL</b> indicating that the calling application does not require a copy of the added or existing CTL. If a copy is made, it must be freed by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreectlcontext">CertFreeCTLContext</a>.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * Some possible error codes follow.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * CERT_STORE_ADD_NEW is set, and the CTL already exists in the store; or CERT_STORE_ADD_NEWER is set and there is a CTL in the store with a <b>ThisUpdate</b> time greater than or equal to the <b>ThisUpdate</b> time on the CTL to be added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A disposition value that is not valid was specified in the <i>dwAddDisposition</i> parameter, or an encoding type that is not valid was specified. Currently, only the encoding types X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are supported.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certaddencodedctltostore
     * @since windows5.1.2600
     */
    static CertAddEncodedCTLToStore(hCertStore, dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded, dwAddDisposition, ppCtlContext) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        ppCtlContextMarshal := ppCtlContext is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddEncodedCTLToStore", "ptr", hCertStore, "uint", dwMsgAndCertEncodingType, "ptr", pbCtlEncoded, "uint", cbCtlEncoded, "uint", dwAddDisposition, ppCtlContextMarshal, ppCtlContext, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Adds a certificate trust list (CTL) context to a certificate store.
     * @param {HCERTSTORE} hCertStore Handle of a certificate store.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure to be added to the store.
     * @param {Integer} dwAddDisposition Specifies the action to take if a matching CTL or a link to a matching CTL already exists in the store. Currently defined disposition values and their uses are as follows.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Makes no check for an existing matching CTL or link to a matching CTL. A new CTL is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER"></a><a id="cert_store_add_newer"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the <b>ThisUpdate</b> times on the CTLs are compared. If the existing CTL has a <b>ThisUpdate</b> time less than the <b>ThisUpdate</b> time on the new CTL, the old CTL or link is replaced just as with CERT_STORE_ADD_REPLACE_EXISTING. If the existing CTL has a <b>ThisUpdate</b> time greater than or equal to the <b>ThisUpdate</b> time on the CTL to be added, the function fails with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning the CRYPT_E_EXISTS code.
     * 
     * If a matching CTL or a link to a matching CTL is not found in the store, a new CTL is added to the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES"></a><a id="cert_store_add_newer_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The action is the same as for CERT_STORE_ADD_NEWER, except that if an older CTL is replaced, the properties of the older CTL are incorporated into the replacement CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the existing CTL or link is deleted and a new CTL is created and added to the store. If a matching CTL or a link to a matching CTL does not exist, one is added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES"></a><a id="cert_store_add_replace_existing_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL exists in the store, that existing context is deleted before creating and adding the new context. The added context inherits properties from the existing CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, that existing CTL is used and properties from the new CTL are added. The function does not fail, but no new CTL is added. If <i>ppCertContext</i> is not <b>NULL</b>, the existing context is duplicated.
     * 
     * If a matching CTL or a link to a matching CTL does not exist, a new CTL is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Pointer<CTL_CONTEXT>>} ppStoreContext Pointer to a pointer to the decoded CTL <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a>. This optional parameter can be <b>NULL</b> indicating that the calling application does not require a copy of the added or existing CTL. If a copy is made, that context must be freed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreectlcontext">CertFreeCTLContext</a>.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certaddencodedcrltostore">CertAddEncodedCRLToStore</a> and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certsetcrlcontextproperty">CertSetCRLContextProperty</a> can be propagated to this function.
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This error is returned if CERT_STORE_ADD_NEW is set and the CTL exists in the store or if CERT_STORE_ADD_NEWER is set and a CTL exists in the store with a <b>ThisUpdate</b> date greater than or equal to the <b>ThisUpdate</b> date on the CTL to be added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An add disposition that is not valid was specified by the <i>dwAddDisposition</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certaddctlcontexttostore
     * @since windows5.1.2600
     */
    static CertAddCTLContextToStore(hCertStore, pCtlContext, dwAddDisposition, ppStoreContext) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        ppStoreContextMarshal := ppStoreContext is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddCTLContextToStore", "ptr", hCertStore, "ptr", pCtlContext, "uint", dwAddDisposition, ppStoreContextMarshal, ppStoreContext, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertSerializeCTLStoreElement function serializes an encoded certificate trust list (CTL) context and the encoded representation of its properties. The result can be persisted to storage so that the CTL and properties can be retrieved later.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure being serialized.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer} pbElement A pointer to a buffer that receives the serialized output, including the encoded CTL and, possibly, its properties. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbElement A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the buffer that is pointed to by the <i>pbElement</i> parameter. When the function returns the <b>DWORD</b> value contains the number of bytes stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certserializectlstoreelement
     * @since windows5.1.2600
     */
    static CertSerializeCTLStoreElement(pCtlContext, dwFlags, pbElement, pcbElement) {
        pcbElementMarshal := pcbElement is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSerializeCTLStoreElement", "ptr", pCtlContext, "uint", dwFlags, "ptr", pbElement, pcbElementMarshal, pcbElement, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertDeleteCTLFromStore function deletes the specified certificate trust list (CTL) context from a certificate store.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure to be deleted.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_ACCESSDENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The store was opened read-only, and a delete operation is not allowed.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certdeletectlfromstore
     * @since windows5.1.2600
     */
    static CertDeleteCTLFromStore(pCtlContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertDeleteCTLFromStore", "ptr", pCtlContext, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Adds a link in a certificate store to a certificate context in a different store.
     * @param {HCERTSTORE} hCertStore A handle to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a> where the link is to be added.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure to be linked.
     * @param {Integer} dwAddDisposition Specifies the action if a matching certificate or a link to a matching certificate already exists in the store. Currently defined disposition values and their uses are as follows. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function makes no check for an existing matching certificate or link to a matching certificate. A new certificate is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or a link to a matching certificate exists, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a link to a matching certificate exists, that existing link is deleted and a new link is created and added to the store. If no matching certificate or link to a matching certificate exists, one is added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or a link to a matching certificate exists, the existing certificate is used. The function does not fail, but no new link is added. If no matching certificate or link to a matching certificate exists, a new link is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Pointer<CERT_CONTEXT>>} ppStoreContext A pointer to a pointer to a copy of the link created. The <i>ppStoreContext</i> parameter can be <b>NULL</b> to indicate that a copy of the link is not needed. If a copy of the link is created, that copy must be freed using 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a <i>dwAddDisposition</i> parameter of CERT_STORE_ADD_NEW, the certificate already exists in the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A disposition value that is not valid was specified in the <i>dwAddDisposition</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certaddcertificatelinktostore
     * @since windows5.1.2600
     */
    static CertAddCertificateLinkToStore(hCertStore, pCertContext, dwAddDisposition, ppStoreContext) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        ppStoreContextMarshal := ppStoreContext is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddCertificateLinkToStore", "ptr", hCertStore, "ptr", pCertContext, "uint", dwAddDisposition, ppStoreContextMarshal, ppStoreContext, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Adds a link in a store to a certificate revocation list (CRL) context in a different store.
     * @param {HCERTSTORE} hCertStore Handle of a certificate store where the link is to be added.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure to be linked.
     * @param {Integer} dwAddDisposition Specifies the action to take if a matching CRL or a link to a matching CRL exists in the store. Currently defined disposition values and their uses are as follows.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Makes no check for an existing matching CRL or link to a matching CRL. A new link is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER"></a><a id="cert_store_add_newer"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, the <b>ThisUpdate</b> times on the CRLs are compared. If the existing CRL has a <b>ThisUpdate</b> time less than the <b>ThisUpdate</b> time on the new CRL, the old link is replaced just as with CERT_STORE_ADD_REPLACE_EXISTING. If the existing CRL has a <b>ThisUpdate</b> time greater than or equal to the <b>ThisUpdate</b> time on the CRL to be added, the function fails with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning the CRYPT_E_EXISTS code. 
     * 
     * 
     * 
     * 
     * If a matching CRL or a link to a matching CRL is not found in the store, a new link is added to the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a link to the matching CRL exists, that existing link is deleted and a new link is created and added to the store. If a matching CRL or a link to a matching CRL does not exist, a new link is added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, that existing link is used. The function does not fail, but no new link is added. If a matching CRL or link to a CRL does not exist, a new link is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Pointer<CRL_CONTEXT>>} ppStoreContext A pointer to a pointer of a copy of the link created. The <i>ppStoreContext</i> parameter can be <b>NULL</b> to indicate that a copy of the link is not needed. If a copy of the link is created, that copy must be freed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a>.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a <i>dwAddDisposition</i> of CERT_STORE_ADD_NEW, the CTL already exists in the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A disposition value that is not valid was specified in the <i>dwAddDisposition</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certaddcrllinktostore
     * @since windows5.1.2600
     */
    static CertAddCRLLinkToStore(hCertStore, pCrlContext, dwAddDisposition, ppStoreContext) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        ppStoreContextMarshal := ppStoreContext is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddCRLLinkToStore", "ptr", hCertStore, "ptr", pCrlContext, "uint", dwAddDisposition, ppStoreContextMarshal, ppStoreContext, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertAddCTLLinkToStore function adds a link in a store to a certificate trust list (CTL) context in a different store. Instead of creating and adding a duplicate of a CTL context, this function adds a link to the original CTL context.
     * @param {HCERTSTORE} hCertStore Handle of the certificate store where the link is to be added.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure to be linked.
     * @param {Integer} dwAddDisposition Specifies the action to take if a matching CTL or a link to a matching CTL already exists in the store. Currently defined disposition values and their uses are as follows.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Makes no check for an existing matching CTL or link to a matching CTL. A new CTL is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER"></a><a id="cert_store_add_newer"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the <b>ThisUpdate</b> times on the CTLs are compared. If the existing CTL has a <b>ThisUpdate</b> time less than the <b>ThisUpdate</b> time on the new CTL, the old CTL or link is replaced just as with CERT_STORE_ADD_REPLACE_EXISTING. If the existing CTL has a <b>ThisUpdate</b> time greater than or equal to the <b>ThisUpdate</b> time on the CTL to be added, the function fails with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning the CRYPT_E_EXISTS code. 
     * 
     * 
     * 
     * 
     * If a matching CTL or a link to a matching CTL is not found in the store, a new CTL is added to the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES"></a><a id="cert_store_add_newer_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The action is the same as for CERT_STORE_ADD_NEWER, except that if an older CTL is replaced, the properties of the older CTL are incorporated into the replacement CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the existing CTL or link is deleted and a new CTL is created and added to the store. If a matching CTL or a link to a matching CTL does not exist, one is added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES"></a><a id="cert_store_add_replace_existing_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL exists in the store, that existing context is deleted before creating and adding the new context. The added context inherits properties from the existing CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, that existing CTL is used and properties from the new CTL are added. The function does not fail, but no new CTL is added. If <i>ppCertContext</i> is not <b>NULL</b>, the existing context is duplicated.
     * 
     * If a matching CTL or a link to a matching CTL does not exist, a new CTL is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Pointer<CTL_CONTEXT>>} ppStoreContext A pointer to a pointer to a copy of the link created. <i>ppStoreContext</i> can be <b>NULL</b> to indicate that a copy of the link is not needed. If a copy of the link is created, that copy must be freed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreectlcontext">CertFreeCTLContext</a>.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a <i>dwAddDisposition</i> of CERT_STORE_ADD_NEW, the CTL already exists in the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The add disposition specified by the <i>dwAddDisposition</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certaddctllinktostore
     * @since windows5.1.2600
     */
    static CertAddCTLLinkToStore(hCertStore, pCtlContext, dwAddDisposition, ppStoreContext) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        ppStoreContextMarshal := ppStoreContext is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddCTLLinkToStore", "ptr", hCertStore, "ptr", pCtlContext, "uint", dwAddDisposition, ppStoreContextMarshal, ppStoreContext, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertAddStoreToCollection function adds a sibling certificate store to a collection certificate store.
     * @param {HCERTSTORE} hCollectionStore Handle of a certificate store.
     * @param {HCERTSTORE} hSiblingStore Handle of a sibling store to be added to the collection store. For more information, see  Remarks.
     * @param {Integer} dwUpdateFlags Indicates whether <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificates</a>, CRLs, and CTLs can be added to the new sibling store member of the collection store. To enable addition, set <i>dwUpdateFlag</i> to CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG.   To disable additions, set <i>dwUpdateFlag</i> to zero.
     * @param {Integer} dwPriority Sets a priority level of the new store in the collection, with zero being the lowest priority. If zero is passed for this parameter, the specified store is appended as the last store in the collection. The priority levels of the stores in a collection determine the order in which the stores are enumerated, and the search order of the stores when attempting to retrieve a certificate, CRL, or CTL. Priority levels also determine to which store of a collection a new certificate, CRL, or CTL is added. For more information, see  Remarks.
     * @returns {BOOL} If the function succeeds, the function returns nonzero and a new store is added to the collection of stores.
     * 
     * If the function fails, it returns zero and the store was not added.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certaddstoretocollection
     * @since windows5.1.2600
     */
    static CertAddStoreToCollection(hCollectionStore, hSiblingStore, dwUpdateFlags, dwPriority) {
        hCollectionStore := hCollectionStore is Win32Handle ? NumGet(hCollectionStore, "ptr") : hCollectionStore
        hSiblingStore := hSiblingStore is Win32Handle ? NumGet(hSiblingStore, "ptr") : hSiblingStore

        result := DllCall("CRYPT32.dll\CertAddStoreToCollection", "ptr", hCollectionStore, "ptr", hSiblingStore, "uint", dwUpdateFlags, "uint", dwPriority, "int")
        return result
    }

    /**
     * Removes a sibling certificate store from a collection store.
     * @param {HCERTSTORE} hCollectionStore A handle of the collection certificate store.
     * @param {HCERTSTORE} hSiblingStore Handle of the sibling certificate store to be removed from the collection store.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certremovestorefromcollection
     * @since windows5.1.2600
     */
    static CertRemoveStoreFromCollection(hCollectionStore, hSiblingStore) {
        hCollectionStore := hCollectionStore is Win32Handle ? NumGet(hCollectionStore, "ptr") : hCollectionStore
        hSiblingStore := hSiblingStore is Win32Handle ? NumGet(hSiblingStore, "ptr") : hSiblingStore

        DllCall("CRYPT32.dll\CertRemoveStoreFromCollection", "ptr", hCollectionStore, "ptr", hSiblingStore)
    }

    /**
     * Allows an application to be notified when there is a difference between the contents of a cached store in use and the contents of that store as it is persisted to storage.
     * @param {HCERTSTORE} hCertStore Handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a>.
     * @param {Integer} dwFlags 
     * @param {Integer} dwCtrlType Control action to be taken by <b>CertControlStore</b>. The interpretations of <i>pvCtrlPara</i> and <i>dwFlags</i> depend on the value of <i>dwCtrlType</i>. Currently, the following  actions are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CTRL_RESYNC"></a><a id="cert_store_ctrl_resync"></a><dl>
     * <dt><b>CERT_STORE_CTRL_RESYNC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The cached store is resynchronized and made to match the persisted store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CTRL_NOTIFY_CHANGE"></a><a id="cert_store_ctrl_notify_change"></a><dl>
     * <dt><b>CERT_STORE_CTRL_NOTIFY_CHANGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A signal is returned in the space pointed to by <i>pvCtrlPara</i> to indicate that the current contents of the cached store differ from the store's persisted <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">state</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CTRL_COMMIT"></a><a id="cert_store_ctrl_commit"></a><dl>
     * <dt><b>CERT_STORE_CTRL_COMMIT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Any changes made to the cached store are copied to persisted storage. If no changes were made since the cached store was opened or since the last commit, the call is ignored. The call is also ignored if the store provider is a provider that automatically persists changes immediately.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CTRL_AUTO_RESYNC"></a><a id="cert_store_ctrl_auto_resync"></a><dl>
     * <dt><b>CERT_STORE_CTRL_AUTO_RESYNC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * At the start of every enumeration or find store call, a check is made to determine whether a change has been made in the store. If the store has changed, a re-synchronization is done. This check is only done on first enumeration or find calls, when the <i>pPrevContext</i> is <b>NULL</b>.
     * 
     * 
     * The <b>pvCtrPara</b> member is not used and must be set to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CTRL_CANCEL_NOTIFY"></a><a id="cert_store_ctrl_cancel_notify"></a><dl>
     * <dt><b>CERT_STORE_CTRL_CANCEL_NOTIFY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Cancels notification signaling of the event HANDLE passed in a previous CERT_STORE_CTRL_NOTIFY_CHANGE or CERT_STORE_CTRL_RESYNC. The <i>pvCtrlPara</i> parameter points to the event HANDLE to be canceled.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvCtrlPara If <i>dwCtrlType</i> is CERT_STORE_NOTIFY_CHANGE, <i>pvCtrlPara</i> is set to the address of a handle where the system signals the notification change event when a change from the persisted <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">state</a> of the store is detected. The handle must be initialized with a call to the function <a href="https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-createeventa">CreateEvent</a>. The <i>pvCtrlPara</i> parameter can be set to <b>NULL</b> for registry-based stores. If <i>pvCtrlPara</i> is <b>NULL</b>, an internal notification change event is created and registered to be signaled. Using the internal notification change event allows resynchronization operations only if the store was changed. 
     * 
     * 
     * 
     * 
     * If <i>dwCtrlType</i> is CERT_STORE_CTRL_RESYNC, set <i>pvCtrlPara</i> to the address of the event handle to be signaled on the next change in the persisted store. Typically, this address is the address of the event handle passed with CERT_STORE_CTRL_NOTIFY_CHANGE during initialization. The event handle passed is rearmed. If <i>pvCtrlPara</i> is set to <b>NULL</b>, no event is rearmed.
     * 
     * If <i>dwCtrlType</i> CERT_STORE_CTRL_COMMIT, <i>pvCtrlPara</i> is not used and must be set to <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <i>dwCtrlType</i> is CERT_STORE_NOTIFY_CHANGE, the function returns nonzero if a handle for the event signal was successfully set up. The function returns zero if the event handle was not set up.
     * 
     * If <i>dwCtrlType</i> is CERT_STORE_CTRL_RESYNC, the function returns nonzero if the resynchronization succeeded. The function returns zero if the resynchronization failed.
     * 
     * If <i>dwCtrlType</i> is CERT_STORE_CTRL_COMMIT, the function returns nonzero to indicate the successful completion of the commit to persisted storage. The function returns zero if the commit failed.
     * 
     * Some providers might not support specific control types. In these cases, <b>CertControlStore</b> returns zero and <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> is set to the ERROR_NOT_SUPPORTED code.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certcontrolstore
     * @since windows5.1.2600
     */
    static CertControlStore(hCertStore, dwFlags, dwCtrlType, pvCtrlPara) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        pvCtrlParaMarshal := pvCtrlPara is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertControlStore", "ptr", hCertStore, "uint", dwFlags, "uint", dwCtrlType, pvCtrlParaMarshal, pvCtrlPara, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertSetStoreProperty function sets a store property.
     * @param {HCERTSTORE} hCertStore Handle for the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a>.
     * @param {Integer} dwPropId Indicates one of a range of store properties. Values for user-defined properties must be outside the current range of predefined context property values. Currently, user-defined <i>dwPropId</i> values begin at 4,096. There is one predefined store property, CERT_STORE_LOCALIZED_NAME_PROP_ID, the localized name of the store.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Void>} pvData The type definition for <i>pvData</i> depends on the <i>dwPropId</i> value. If <i>dwPropId</i> is CERT_STORE_LOCALIZED_NAME_PROP_ID, <i>pvData</i> points to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure. The <b>pbData</b> member of that structure is a pointer to a <b>null</b>-terminated Unicode character string. The <b>cbData</b> member of that structure is a <b>DWORD</b> value holding the length of the string. 
     * 
     * 
     * 
     * 
     * For user-defined <i>dwPropId</i> values, <i>pvData</i> is a pointer to an encoded <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>.
     * 
     * If a value already exists for the selected property, the old value is replaced.
     * 
     * Calling this function with <i>pvData</i> set to <b>NULL</b> deletes a property.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certsetstoreproperty
     * @since windows5.1.2600
     */
    static CertSetStoreProperty(hCertStore, dwPropId, dwFlags, pvData) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        pvDataMarshal := pvData is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPT32.dll\CertSetStoreProperty", "ptr", hCertStore, "uint", dwPropId, "uint", dwFlags, pvDataMarshal, pvData, "int")
        return result
    }

    /**
     * Retrieves a store property.
     * @param {HCERTSTORE} hCertStore A handle of an open <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a>.
     * @param {Integer} dwPropId Indicates one of a range of store properties. There is one predefined store property, CERT_STORE_LOCALIZED_NAME_PROP_ID, the localized name of the store.
     * 
     * User defined properties must be outside the current range of values for predefined context properties. Currently, user defined <i>dwPropId</i> values begin at 4,096.
     * @param {Pointer} pvData A pointer to a buffer that receives the data as determined by <i>dwPropId</i>. For CERT_STORE_LOCALIZED_NAME_PROP_ID, this is the localized name of the store, and <i>pvData</i> points to a null-terminated Unicode wide-character string. For other <i>dwPropId</i>s, <i>pvData</i> points to an array of bytes.
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbData A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the <i>pvData</i> buffer. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer.
     * @returns {BOOL} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero.
     * 
     * If the store property is found, the function returns nonzero, <i>pvData</i> points to the property, and <i>pcbData</i> points to the length of the string. If the store property is not found, the function returns zero and 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns CRYPT_E_NOT_FOUND.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certgetstoreproperty
     * @since windows5.1.2600
     */
    static CertGetStoreProperty(hCertStore, dwPropId, pvData, pcbData) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetStoreProperty", "ptr", hCertStore, "uint", dwPropId, "ptr", pvData, pcbDataMarshal, pcbData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Creates the specified context from the encoded bytes. The context created does not include any extended properties.
     * @param {Integer} dwContextType Specifies the contexts that can be created. For example, to create a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a>, set <i>dwContextType</i> to CERT_STORE_CERTIFICATE_CONTEXT.
     * 						
     * 
     * Currently defined context type flags are shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CERTIFICATE_CONTEXT"></a><a id="cert_store_certificate_context"></a><dl>
     * <dt><b>CERT_STORE_CERTIFICATE_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Certificate context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CRL_CONTEXT"></a><a id="cert_store_crl_context"></a><dl>
     * <dt><b>CERT_STORE_CRL_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * CRL context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CTL_CONTEXT"></a><a id="cert_store_ctl_context"></a><dl>
     * <dt><b>CERT_STORE_CTL_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * CTL context.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwEncodingType Specifies the encoding type used. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. For either current encoding type, use: 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Pointer} pbEncoded A pointer to a buffer that contains the existing encoded context content to be copied.
     * @param {Integer} cbEncoded The size, in bytes, of the <i>pbEncoded</i> buffer.
     * @param {Integer} dwFlags The following flag values are defined and can be combined by using a bitwise-<b>OR</b> operation.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CREATE_CONTEXT_NOCOPY_FLAG"></a><a id="cert_create_context_nocopy_flag"></a><dl>
     * <dt><b>CERT_CREATE_CONTEXT_NOCOPY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The created context points directly to the content pointed to by <i>pbEncoded</i> instead of an allocated copy.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CREATE_CONTEXT_SORTED_FLAG"></a><a id="cert_create_context_sorted_flag"></a><dl>
     * <dt><b>CERT_CREATE_CONTEXT_SORTED_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function creates a context with sorted entries. Currently, this flag only applies to a CTL context.
     * 
     * For CTLs, the <b>cCTLEntry</b> member of the returned 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_info">CTL_INFO</a> structure is always zero. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfindsubjectinsortedctl">CertFindSubjectInSortedCTL</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certenumsubjectinsortedctl">CertEnumSubjectInSortedCTL</a> must be called to find or enumerate the CTL entries.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG"></a><a id="cert_create_context_no_hcryptmsg_flag"></a><dl>
     * <dt><b>CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * By default, when a CTL context is created, a HCRYTPMSG handle to its <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/signeddata">SignedData</a> message is created. This flag can be set to improve performance by not creating this handle. This flag can only be used when <i>dwContextType</i> is CERT_STORE_CTL_CONTEXT.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CREATE_CONTEXT_NO_ENTRY_FLAG"></a><a id="cert_create_context_no_entry_flag"></a><dl>
     * <dt><b>CERT_CREATE_CONTEXT_NO_ENTRY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * By default, when a CTL context is created, its entries are decoded. When this flag is set, the entries are not decoded and performance is improved. This flag can only be used when <i>dwContextType</i> is CERT_STORE_CTL_CONTEXT.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CERT_CREATE_CONTEXT_PARA>} pCreatePara A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_create_context_para">CERT_CREATE_CONTEXT_PARA</a> structure. 
     * 
     * 
     * 
     * 
     * If <i>pCreatePara</i> and its <b>pfnFree</b> member are both non-<b>NULL</b>, the <b>pfnFree</b> member is used to free the memory specified by the <b>pvFree</b> member. If the <b>pvFree</b> member is <b>NULL</b>, the <b>pfnFree</b> member is used to free the <i>pbEncoded</i> pointer.
     * 
     * If <i>pCreatePara</i> or its <b>pfnFree</b> member is <b>NULL</b>, no attempt is made to free <i>pbEncoded</i>.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a pointer to the newly created context. The <b>pvFree</b> member of <i>pCreatePara</i> must be called to free the created context.
     * 						
     * 
     * If the function fails, the return value is <b>NULL</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_CANCELLED</b>, this means that the <a href="/windows/desktop/api/wincrypt/nc-wincrypt-pfn_cert_create_context_sort_func">PFN_CERT_CREATE_CONTEXT_SORT_FUNC</a> callback function returned <b>FALSE</b> to stop the sort.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certcreatecontext
     * @since windows5.1.2600
     */
    static CertCreateContext(dwContextType, dwEncodingType, pbEncoded, cbEncoded, dwFlags, pCreatePara) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertCreateContext", "uint", dwContextType, "uint", dwEncodingType, "ptr", pbEncoded, "uint", cbEncoded, "uint", dwFlags, "ptr", pCreatePara, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Registers a system store.
     * @param {Pointer<Void>} pvSystemStore Identifies the system store to be registered. If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in the <i>dwFlags</i> parameter, <i>pvSystemStore</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure. Otherwise, it points to a <b>null</b>-terminated Unicode string that names the system store. 
     * 
     * 
     * 
     * 
     * With appropriate settings in <i>dwFlags</i>, the identified store can be a system store on a remote local computer. Stores on remote computers can be registered with the computer name as a prefix to the name of the system store. For example, a remote local computer store can be registered with <i>pvSystemStore</i> pointing to the string "\\ComputerName\Trust" or "ComputerName\Trust".
     * 
     * Leading "\\" backslashes are optional before a ComputerName.
     * @param {Integer} dwFlags The high word of the <i>dwFlags</i> parameter is used to specify the location of the system store. 
     * 
     * 
     * 
     * 						
     * 						
     * 						
     * 						
     * 					
     * 
     * 
     * The following high-word values are defined.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_CURRENT_SERVICE"></a><a id="cert_system_store_current_service"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_CURRENT_SERVICE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSystemStore</i> can be a system store name that is prefixed with the ServiceName.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_CURRENT_USER"></a><a id="cert_system_store_current_user"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_CURRENT_USER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSystemStore</i> can be a system store name that is prefixed with the UserName.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_LOCAL_MACHINE"></a><a id="cert_system_store_local_machine"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_LOCAL_MACHINE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSystemStore</i> can be a system store that is on a remote computer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY"></a><a id="cert_system_store_local_machine_group_policy"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSystemStore</i> is a group policy store and can be on a remote computer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_SERVICES"></a><a id="cert_system_store_services"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_SERVICES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSystemStore</i> must be a system store name prefixed with the ServiceName.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_USERS"></a><a id="cert_system_store_users"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_USERS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSystemStore</i> must be a system store name that is prefixed with the UserName.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Stores on remote computers can be registered for CERT_SYSTEM_STORE_LOCAL_MACHINE, CERT_SYSTEM_STORE_SERVICES, CERT_SYSTEM_STORE_USERS, or CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY.
     * 
     * 
     * The following low-word values are also defined and can be combined using a bitwise-<b>OR</b> operation with high-word values.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_RELOCATE_FLAG"></a><a id="cert_system_store_relocate_flag"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_RELOCATE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system store is not in its default register location and <i>pvSystemStore</i> must be a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CREATE_NEW_FLAG"></a><a id="cert_store_create_new_flag"></a><dl>
     * <dt><b>CERT_STORE_CREATE_NEW_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function fails if the system store already exists in the store location.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CERT_SYSTEM_STORE_INFO>} pStoreInfo Reserved for future use and must be set to <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certregistersystemstore
     * @since windows5.1.2600
     */
    static CertRegisterSystemStore(pvSystemStore, dwFlags, pStoreInfo) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        pvSystemStoreMarshal := pvSystemStore is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPT32.dll\CertRegisterSystemStore", pvSystemStoreMarshal, pvSystemStore, "uint", dwFlags, "ptr", pStoreInfo, "ptr", pvReserved, "int")
        return result
    }

    /**
     * Adds a physical store to a registry system store collection.
     * @param {Pointer<Void>} pvSystemStore The system store collection to which the physical store is added. This parameter points either to a <b>null</b>-terminated Unicode string or to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure. For information about using the structure and on adding a ServiceName or ComputerName before the system store name string, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certregistersystemstore">CertRegisterSystemStore</a>.
     * @param {Integer} dwFlags The high word of the <i>dwFlags</i> parameter specifies the location of the system store. For information about defined high-word flags and appending ServiceName, UserNames, and ComputerNames to the end of the system store name, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certregistersystemstore">CertRegisterSystemStore</a>. 
     * 
     * 
     * 
     * 
     * The following low-word flags are also defined and can be combined with high-word flags using a bitwise-<b>OR</b> operation.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_RELOCATE_FLAG"></a><a id="cert_system_store_relocate_flag"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_RELOCATE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system store is not in its default registry location and the <i>pvSystemStore</i> parameter must be a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CREATE_NEW_FLAG"></a><a id="cert_store_create_new_flag"></a><dl>
     * <dt><b>CERT_STORE_CREATE_NEW_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function fails if the physical store already exists in the store location.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} pwszStoreName A pointer to a Unicode string that names the physical store to be added to the system store collection. To remove a physical store from the system store collection, call the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certunregisterphysicalstore">CertUnregisterPhysicalStore</a> function.
     * @param {Pointer<CERT_PHYSICAL_STORE_INFO>} pStoreInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_physical_store_info">CERT_PHYSICAL_STORE_INFO</a> structure that provides basic information about the physical store.
     * @returns {BOOL} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certregisterphysicalstore
     * @since windows5.1.2600
     */
    static CertRegisterPhysicalStore(pvSystemStore, dwFlags, pwszStoreName, pStoreInfo) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        pwszStoreName := pwszStoreName is String ? StrPtr(pwszStoreName) : pwszStoreName

        pvSystemStoreMarshal := pvSystemStore is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPT32.dll\CertRegisterPhysicalStore", pvSystemStoreMarshal, pvSystemStore, "uint", dwFlags, "ptr", pwszStoreName, "ptr", pStoreInfo, "ptr", pvReserved, "int")
        return result
    }

    /**
     * The CertUnregisterSystemStore function unregisters a specified system store.
     * @param {Pointer<Void>} pvSystemStore Identifies the system store to be unregistered. It points either to a null-terminated Unicode string or to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure. For information about using the structure and on appending a ServiceName or ComputerName to the end of the system store name string, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certregistersystemstore">CertRegisterSystemStore</a>.
     * @param {Integer} dwFlags The high word of the <i>dwFlags</i> parameter specifies the location of the system store. For information about defined high-word flags and on appending ServiceName, UserNames, and ComputerNames to the end of the system store name, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certregistersystemstore">CertRegisterSystemStore</a>. 
     * 
     * 
     * 
     * 
     * The following low-word values are also defined and can be combined with high-word values using a bitwise-<b>OR</b> operation.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_RELOCATE_FLAG"></a><a id="cert_system_store_relocate_flag"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_RELOCATE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system store is not in its default registry location and <i>pvSystemStore</i> must be a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_DELETE_FLAG"></a><a id="cert_store_delete_flag"></a><dl>
     * <dt><b>CERT_STORE_DELETE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system store is deleted after it has been unregistered.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certunregistersystemstore
     * @since windows5.1.2600
     */
    static CertUnregisterSystemStore(pvSystemStore, dwFlags) {
        pvSystemStoreMarshal := pvSystemStore is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPT32.dll\CertUnregisterSystemStore", pvSystemStoreMarshal, pvSystemStore, "uint", dwFlags, "int")
        return result
    }

    /**
     * The CertUnregisterPhysicalStore function removes a physical store from a specified system store collection. CertUnregisterPhysicalStore can also be used to delete the physical store.
     * @param {Pointer<Void>} pvSystemStore A pointer to an identifier of the system store collection from which the physical store is to be removed. It is either to a null-terminated Unicode string or to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure. For information about using the structure and on appending a ServiceName or ComputerName to the end of the system store name string, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certregistersystemstore">CertRegisterSystemStore</a>.
     * @param {Integer} dwFlags The high word of the <i>dwFlags</i> parameter specifies the location of the system store. For information about defined high-word flags and on appending ServiceName, UserNames, and ComputerNames to the end of the system store name, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certregistersystemstore">CertRegisterSystemStore</a>. 
     * 
     * 
     * 
     * 						
     * 					
     * 
     * 
     * The following low-word values are also defined. They can be combined using bitwise-<b>OR</b> operations with high-word values.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_RELOCATE_FLAG"></a><a id="cert_system_store_relocate_flag"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_RELOCATE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system store is not in its default registry location and <i>pvSystemStore</i> must be a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_DELETE_FLAG"></a><a id="cert_store_delete_flag"></a><dl>
     * <dt><b>CERT_STORE_DELETE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The physical store is first removed from the system store collection and is then deleted.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} pwszStoreName Null-terminated Unicode string that contains the name of the physical store.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certunregisterphysicalstore
     * @since windows5.1.2600
     */
    static CertUnregisterPhysicalStore(pvSystemStore, dwFlags, pwszStoreName) {
        pwszStoreName := pwszStoreName is String ? StrPtr(pwszStoreName) : pwszStoreName

        pvSystemStoreMarshal := pvSystemStore is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPT32.dll\CertUnregisterPhysicalStore", pvSystemStoreMarshal, pvSystemStore, "uint", dwFlags, "ptr", pwszStoreName, "int")
        return result
    }

    /**
     * The CertEnumSystemStoreLocation function retrieves all of the system store locations. The function calls the provided callback function for each system store location found.
     * @param {Integer} dwFlags Reserved for future use; must be zero.
     * @param {Pointer<Void>} pvArg A pointer to a <b>void</b>  that allows the application to declare, define, and initialize a structure to hold any information to be passed to the callback enumeration function.
     * @param {Pointer<PFN_CERT_ENUM_SYSTEM_STORE_LOCATION>} pfnEnum A pointer to the callback function used to show the details for each store location. This callback function determines the content and format for the presentation of information on each store location. For the signature and parameters of the callback function, see <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nc-wincrypt-pfn_cert_enum_system_store_location">CertEnumSystemStoreLocationCallback</a>.
     * @returns {BOOL} If the function succeeds, the function returns <b>TRUE</b>.
     * 						
     * 						
     * 
     * If the function fails, it returns <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certenumsystemstorelocation
     * @since windows5.1.2600
     */
    static CertEnumSystemStoreLocation(dwFlags, pvArg, pfnEnum) {
        pvArgMarshal := pvArg is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPT32.dll\CertEnumSystemStoreLocation", "uint", dwFlags, pvArgMarshal, pvArg, "ptr", pfnEnum, "int")
        return result
    }

    /**
     * The CertEnumSystemStore function retrieves the system stores available. The function calls the provided callback function for each system store found.
     * @param {Integer} dwFlags Specifies the location of the system store. This parameter can be one of the following flags: 
     * 
     * 
     * 
     * 
     * <ul>
     * <li>CERT_SYSTEM_STORE_CURRENT_USER</li>
     * <li>CERT_SYSTEM_STORE_CURRENT_SERVICE</li>
     * <li>CERT_SYSTEM_STORE_LOCAL_MACHINE</li>
     * <li>CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY</li>
     * <li>CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY</li>
     * <li>CERT_SYSTEM_STORE_SERVICES</li>
     * <li>CERT_SYSTEM_STORE_USERS</li>
     * <li>CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE</li>
     * </ul>
     * In addition, the CERT_SYSTEM_STORE_RELOCATE_FLAG can be combined, by using a bitwise-<b>OR</b> operation, with any of the high-word location flags.
     * @param {Pointer<Void>} pvSystemStoreLocationPara If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in the <i>dwFlags</i> parameter, <i>pvSystemStoreLocationPara</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure that indicates both the name and the location of the system store. Otherwise, <i>pvSystemStoreLocationPara</i> is a pointer to a Unicode string that names the system store. 
     * 
     * 
     * 
     * 
     * For CERT_SYSTEM_STORE_LOCAL_MACHINE or CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY, <i>pvSystemStoreLocationPara</i> can optionally be set to a Unicode computer name for enumerating local computer stores on a remote computer, for example "&#92;&#92;<i>computer_name</i>" or "<i>computer_name</i>". The leading backslashes (\\) are optional in the <i>computer_name</i>.
     * 
     * For CERT_SYSTEM_STORE_SERVICES or CERT_SYSTEM_STORE_USERS, if <i>pvSystemStoreLocationPara</i> is <b>NULL</b>, the function enumerates both the service/user names and the stores for each service/user name. Otherwise, <i>pvSystemStoreLocationPara</i> is a Unicode string that contains a remote computer name and, if available, a service/user name, for example, "<i>service_name</i>", "&#92;&#92;<i>computer_name</i>", or "<i>computer_name</i>\".
     * 
     * If only the <i>computer_name</i> is specified, it must have either the leading backslashes (\\) or a trailing backslash (\\). Otherwise, it is interpreted as the <i>service_name</i> or <i>user_name</i>.
     * @param {Pointer<Void>} pvArg A pointer to a <b>void</b>  that allows the application to declare, define, and initialize a structure to hold any information to be passed to the callback enumeration function.
     * @param {Pointer<PFN_CERT_ENUM_SYSTEM_STORE>} pfnEnum A pointer to the callback function used to show the details for each system store. This callback function determines the content and format for the presentation of information on each system store. The application must provide the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nc-wincrypt-pfn_cert_enum_system_store">CertEnumSystemStoreCallback</a> callback function.
     * @returns {BOOL} If the function succeeds, the function returns  <b>TRUE</b>.
     * 
     * If the function fails, it returns  <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certenumsystemstore
     * @since windows5.1.2600
     */
    static CertEnumSystemStore(dwFlags, pvSystemStoreLocationPara, pvArg, pfnEnum) {
        pvSystemStoreLocationParaMarshal := pvSystemStoreLocationPara is VarRef ? "ptr" : "ptr"
        pvArgMarshal := pvArg is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPT32.dll\CertEnumSystemStore", "uint", dwFlags, pvSystemStoreLocationParaMarshal, pvSystemStoreLocationPara, pvArgMarshal, pvArg, "ptr", pfnEnum, "int")
        return result
    }

    /**
     * The CertEnumPhysicalStore function retrieves the physical stores on a computer. The function calls the provided callback function for each physical store found.
     * @param {Pointer<Void>} pvSystemStore If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in <i>dwFlags</i>, <i>pvSystemStore</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure that indicates both the name and the location of the system store to be enumerated. Otherwise, <i>pvSystemStore</i> is a pointer to a Unicode string that names the system store whose physical stores are to be enumerated. For information about prefixing a ServiceName or ComputerName to the system store name, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certregistersystemstore">CertRegisterSystemStore</a>.
     * @param {Integer} dwFlags Specifies the location of the system store. The following flag values are defined:
     * 
     * <ul>
     * <li>CERT_SYSTEM_STORE_CURRENT_USER</li>
     * <li>CERT_SYSTEM_STORE_CURRENT_SERVICE</li>
     * <li>CERT_SYSTEM_STORE_LOCAL_MACHINE</li>
     * <li>CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY</li>
     * <li>CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY</li>
     * <li>CERT_SYSTEM_STORE_SERVICES</li>
     * <li>CERT_SYSTEM_STORE_USERS</li>
     * <li>CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE</li>
     * </ul>
     * In addition, CERT_SYSTEM_STORE_RELOCATE_FLAG or CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG can be combined using a bitwise-<b>OR</b> operation with any of the high-word location flags.
     * @param {Pointer<Void>} pvArg A pointer to a <b>void</b> that allows the application to declare, define, and initialize a structure to hold any information to be passed to the callback enumeration function.
     * @param {Pointer<PFN_CERT_ENUM_PHYSICAL_STORE>} pfnEnum A pointer to the callback function used to show the details for each physical store. This callback function determines the content and format for the presentation of information on each physical store. The application must provide the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nc-wincrypt-pfn_cert_enum_physical_store">CertEnumPhysicalStoreCallback</a> callback function.
     * @returns {BOOL} If the function succeeds and another physical store was found, the return value is <b>TRUE</b>.
     * 
     * If the system store location only supports system stores and does not support physical stores, the function returns <b>FALSE</b> and 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the ERROR_NOT_SUPPORTED code.
     * 
     * If the function fails and another physical store was not found, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certenumphysicalstore
     * @since windows5.1.2600
     */
    static CertEnumPhysicalStore(pvSystemStore, dwFlags, pvArg, pfnEnum) {
        pvSystemStoreMarshal := pvSystemStore is VarRef ? "ptr" : "ptr"
        pvArgMarshal := pvArg is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertEnumPhysicalStore", pvSystemStoreMarshal, pvSystemStore, "uint", dwFlags, pvArgMarshal, pvArg, "ptr", pfnEnum, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Returns information from the enhanced key usage (EKU) extension or the EKU extended property of a certificate.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> certificate context.
     * @param {Integer} dwFlags Indicates whether the function will report on extensions of a certificate, its extended properties, or both. If set to zero, the function returns the valid uses of a certificate based on both the EKU extension and the EKU extended property value of the certificate. 
     * 
     * 
     * 
     * 
     * To return only the EKU extension or EKU property value, set the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG"></a><a id="cert_find_ext_only_enhkey_usage_flag"></a><dl>
     * <dt><b>CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Get only the extension.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG"></a><a id="cert_find_prop_only_enhkey_usage_flag"></a><dl>
     * <dt><b>CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Get only the extended property value.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} pUsage A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CERT_ENHKEY_USAGE</a> structure (<b>CERT_ENHKEY_USAGE</b> is an alternate typedef name for the <b>CTL_USAGE</b> structure) that receives the valid uses of the certificate. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of the key usage for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbUsage A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the structure pointed to by <i>pUsage</i>. When the function returns, the <b>DWORD</b> contains the size, in bytes, of the structure.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certgetenhancedkeyusage
     * @since windows5.1.2600
     */
    static CertGetEnhancedKeyUsage(pCertContext, dwFlags, pUsage, pcbUsage) {
        pcbUsageMarshal := pcbUsage is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetEnhancedKeyUsage", "ptr", pCertContext, "uint", dwFlags, "ptr", pUsage, pcbUsageMarshal, pcbUsage, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertSetEnhancedKeyUsage function sets the enhanced key usage (EKU) property for the certificate.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> of the specified certificate.
     * @param {Pointer<CTL_USAGE>} pUsage Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CERT_ENHKEY_USAGE</a> structure (equivalent to a 
     * <b>CTL_USAGE</b> structure) that contains an array of EKU <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifiers</a> (OIDs) to be set as extended properties of the certificate.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certsetenhancedkeyusage
     * @since windows5.1.2600
     */
    static CertSetEnhancedKeyUsage(pCertContext, pUsage) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSetEnhancedKeyUsage", "ptr", pCertContext, "ptr", pUsage, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertAddEnhancedKeyUsageIdentifier function adds a usage identifier object identifier (OID) to the enhanced key usage (EKU) extended property of the certificate.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> of the certificate for which the usage identifier is to be added.
     * @param {PSTR} pszUsageIdentifier Specifies the usage identifier OID to add.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certaddenhancedkeyusageidentifier
     * @since windows5.1.2600
     */
    static CertAddEnhancedKeyUsageIdentifier(pCertContext, pszUsageIdentifier) {
        pszUsageIdentifier := pszUsageIdentifier is String ? StrPtr(pszUsageIdentifier) : pszUsageIdentifier

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddEnhancedKeyUsageIdentifier", "ptr", pCertContext, "ptr", pszUsageIdentifier, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertRemoveEnhancedKeyUsageIdentifier function removes a usage identifier object identifier (OID) from the enhanced key usage (EKU) extended property of the certificate.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> of the certificate for which the usage identifier OID is to be removed.
     * @param {PSTR} pszUsageIdentifier A pointer to the usage identifier OID to remove.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certremoveenhancedkeyusageidentifier
     * @since windows5.1.2600
     */
    static CertRemoveEnhancedKeyUsageIdentifier(pCertContext, pszUsageIdentifier) {
        pszUsageIdentifier := pszUsageIdentifier is String ? StrPtr(pszUsageIdentifier) : pszUsageIdentifier

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertRemoveEnhancedKeyUsageIdentifier", "ptr", pCertContext, "ptr", pszUsageIdentifier, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Returns an array of usages that consist of the intersection of the valid usages for all certificates in an array of certificates.
     * @param {Integer} cCerts The number of certificates in the array to be checked.
     * @param {Pointer<Pointer<CERT_CONTEXT>>} rghCerts An array of certificates to be checked for valid usage.
     * @param {Pointer<Integer>} cNumOIDs The number of valid usages found as the intersection of the valid usages of all certificates in the array. If all of the certificates are valid for all usages, <i>cNumOIDs</i> is set to negative one (1).
     * @param {Pointer} rghOIDs An array of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifiers</a> (OIDs) of the valid usages that are shared by all of the certificates in the <i>rghCerts</i> array. This parameter can be <b>NULL</b> to set the size of this structure for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbOIDs A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the <i>rghOIDs</i> array and the strings pointed to. When the function returns, the <b>DWORD</b> value contains the number of bytes needed for the array.
     * @returns {BOOL} If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certgetvalidusages
     * @since windows5.1.2600
     */
    static CertGetValidUsages(cCerts, rghCerts, cNumOIDs, rghOIDs, pcbOIDs) {
        rghCertsMarshal := rghCerts is VarRef ? "ptr*" : "ptr"
        cNumOIDsMarshal := cNumOIDs is VarRef ? "int*" : "ptr"
        pcbOIDsMarshal := pcbOIDs is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetValidUsages", "uint", cCerts, rghCertsMarshal, rghCerts, cNumOIDsMarshal, cNumOIDs, "ptr", rghOIDs, pcbOIDsMarshal, pcbOIDs, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptMsgGetAndVerifySigner function verifies a cryptographic message's signature.
     * @param {Pointer<Void>} hCryptMsg Handle of a cryptographic message.
     * @param {Integer} cSignerStore Number of stores in the <i>rghSignerStore</i> array.
     * @param {Pointer<HCERTSTORE>} rghSignerStore Array of certificate store handles that can be searched for a signer's certificate.
     * @param {Integer} dwFlags Indicates particular use of the function. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_TRUSTED_SIGNER_FLAG"></a><a id="cmsg_trusted_signer_flag"></a><dl>
     * <dt><b>CMSG_TRUSTED_SIGNER_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The stores in <i>rghSignerStore</i> are assumed trusted and they are the only stores searched to find the certificate corresponding to the signer's issuer and serial number. Otherwise, signer stores can be provided to supplement the message's store of certificates. If a signer certificate is found, its public key is used to verify the message signature.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNER_ONLY_FLAG"></a><a id="cmsg_signer_only_flag"></a><dl>
     * <dt><b>CMSG_SIGNER_ONLY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Return the signer without doing the signature verification.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_USE_SIGNER_INDEX_FLAG"></a><a id="cmsg_use_signer_index_flag"></a><dl>
     * <dt><b>CMSG_USE_SIGNER_INDEX_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Only the signer specified by *<i>pdwSignerIndex</i> is returned. Otherwise, iterate through all the signers until a signature is verified or there are no more signers.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Pointer<CERT_CONTEXT>>} ppSigner If the signature is verified, <i>ppSigner</i> is updated to point to the signer's <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a>. When you have finished using the certificate, free the context by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function. This parameter can be <b>NULL</b> if the application has no need for the signer's certificate.
     * @param {Pointer<Integer>} pdwSignerIndex If the signature is verified, <i>pdwSigner</i> is updated to point to the index of the signer in the array of signers. This parameter can be <b>NULL</b> if the application has no need for the index of the signer.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmsggetandverifysigner
     * @since windows5.1.2600
     */
    static CryptMsgGetAndVerifySigner(hCryptMsg, cSignerStore, rghSignerStore, dwFlags, ppSigner, pdwSignerIndex) {
        hCryptMsgMarshal := hCryptMsg is VarRef ? "ptr" : "ptr"
        ppSignerMarshal := ppSigner is VarRef ? "ptr*" : "ptr"
        pdwSignerIndexMarshal := pdwSignerIndex is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgGetAndVerifySigner", hCryptMsgMarshal, hCryptMsg, "uint", cSignerStore, "ptr", rghSignerStore, "uint", dwFlags, ppSignerMarshal, ppSigner, pdwSignerIndexMarshal, pdwSignerIndex, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptMsgSignCTL function creates a signed message containing an encoded CTL.
     * @param {Integer} dwMsgEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer} pbCtlContent The encoded 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_info">CTL_INFO</a> that can be a member of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure or can be created using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencodeobject">CryptEncodeObject</a> function.
     * @param {Integer} cbCtlContent The size, in bytes, of the content pointed to by <i>pbCtlContent</i>.
     * @param {Pointer<CMSG_SIGNED_ENCODE_INFO>} pSignInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signed_encode_info">CMSG_SIGNED_ENCODE_INFO</a> structure containing an array of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signer_encode_info">CMSG_SIGNER_ENCODE_INFO</a> structures.
     * 
     * The message can be encoded without signers if the <b>cbSize</b> member of the structure is set to the size of the structure and all of the other members are set to zero.
     * @param {Integer} dwFlags If CMS_PKCS7 is defined, can be set to CMSG_CMS_ENCAPSULATED_CTL_FLAG to encode a CMS compatible V3 SignedData message.
     * @param {Pointer} pbEncoded A pointer to a buffer to receives the encoded message.
     * 
     * This parameter can be <b>NULL</b> to get the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbEncoded A pointer to a <b>DWORD</b> specifying the size, in bytes, of the <i>pbEncoded</i> buffer. When the function returns, the <b>DWORD</b> contains the number of bytes stored or to be stored in the buffer.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. This function can return errors propagated from calls to 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentoencode">CryptMsgOpenToEncode</a> and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmsgsignctl
     * @since windows5.1.2600
     */
    static CryptMsgSignCTL(dwMsgEncodingType, pbCtlContent, cbCtlContent, pSignInfo, dwFlags, pbEncoded, pcbEncoded) {
        pcbEncodedMarshal := pcbEncoded is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgSignCTL", "uint", dwMsgEncodingType, "ptr", pbCtlContent, "uint", cbCtlContent, "ptr", pSignInfo, "uint", dwFlags, "ptr", pbEncoded, pcbEncodedMarshal, pcbEncoded, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptMsgEncodeAndSignCTL function encodes a CTL and creates a signed message containing the encoded CTL.This function first encodes the CTL pointed to by pCtlInfo and then calls CryptMsgSignCTL to sign the encoded message.
     * @param {Integer} dwMsgEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CTL_INFO>} pCtlInfo A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_info">CTL_INFO</a> structure containing the CTL to be encoded and signed.
     * @param {Pointer<CMSG_SIGNED_ENCODE_INFO>} pSignInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signed_encode_info">CMSG_SIGNED_ENCODE_INFO</a> structure that contains an array of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signer_encode_info">CMSG_SIGNER_ENCODE_INFO</a> structures.
     * 
     * The message can be encoded without signers if the <b>cbSize</b> member of the structure is set to the size of the structure and all of the other members are set to zero.
     * @param {Integer} dwFlags CMSG_ENCODE_SORTED_CTL_FLAG is set if the CTL entries are to be sorted before encoding. This flag is set if the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfindsubjectinsortedctl">CertFindSubjectInSortedCTL</a> or <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certenumsubjectinsortedctl">CertEnumSubjectInSortedCTL</a> functions will be called.
     * 
     * CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG is set if CMSG_ENCODE_SORTED_CTL_FLAG is set, and the identifier for the TrustedSubjects is a hash, such as MD5 or SHA1.
     * 
     * If CMS_PKCS7 is defined, <i>dwFlags</i> can be set to CMSG_CMS_ENCAPSULATED_CTL_FLAG to encode a CMS compatible V3 SignedData message.
     * @param {Pointer} pbEncoded A pointer to a buffer that receives the encoded, signed message created.
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbEncoded A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the <i>pbEncoded</i> buffer. When the function returns, the <b>DWORD</b> contains the number of bytes stored or to be stored in the buffer.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Errors can be propagated from calls to 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentoencode">CryptMsgOpenToEncode</a> and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmsgencodeandsignctl
     * @since windows5.1.2600
     */
    static CryptMsgEncodeAndSignCTL(dwMsgEncodingType, pCtlInfo, pSignInfo, dwFlags, pbEncoded, pcbEncoded) {
        pcbEncodedMarshal := pcbEncoded is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgEncodeAndSignCTL", "uint", dwMsgEncodingType, "ptr", pCtlInfo, "ptr", pSignInfo, "uint", dwFlags, "ptr", pbEncoded, pcbEncodedMarshal, pcbEncoded, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertFindSubjectInSortedCTL function attempts to find the specified subject in a sorted certificate trust list (CTL).
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pSubjectIdentifier A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure uniquely identifying the subject. The information in this structure can be a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> or any unique byte sequence.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure to be searched.
     * @param {Integer} dwFlags Reserved for future use and must be <b>NULL</b>.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pEncodedAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DER_BLOB</a> structure containing a byte count and a pointer to the subject's encoded attributes.
     * @returns {BOOL} If the function succeeds and the subject identifier exists in the CTL, the return value is <b>TRUE</b>.
     * 
     * If the function fails and does not locate a matching subject identifier, the return value is <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certfindsubjectinsortedctl
     * @since windows5.1.2600
     */
    static CertFindSubjectInSortedCTL(pSubjectIdentifier, pCtlContext, dwFlags, pEncodedAttributes) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("CRYPT32.dll\CertFindSubjectInSortedCTL", "ptr", pSubjectIdentifier, "ptr", pCtlContext, "uint", dwFlags, "ptr", pvReserved, "ptr", pEncodedAttributes, "int")
        return result
    }

    /**
     * Retrieves the first or next TrustedSubject in a sorted certificate trust list (CTL).
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure to be searched.
     * @param {Pointer<Pointer<Void>>} ppvNextSubject A pointer to the address of the last TrustedSubject found. To start the enumeration, <i>ppvNextSubject</i> must point to a pointer  set to <b>NULL</b>. Upon return, the pointer addressed by <i>ppvNextSubject</i> is updated to point to the next TrustedSubject in the encoded sequence.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pSubjectIdentifier A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DER_BLOB</a> structure, uniquely identifying a TrustedSubject. The information in this structure can be a hash or any unique byte sequence.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pEncodedAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DER_BLOB</a> structure containing a byte count and a pointer to the TrustedSubject's encoded attributes.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>, with <i>ppvNextSubject</i> updated to point to the next TrustedSubject in the encoded sequence.
     * 
     * If the function fails, the return value is <b>FALSE</b>. The return value is <b>FALSE</b> if there are no more subjects or there is an argument that is not valid.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certenumsubjectinsortedctl
     * @since windows5.1.2600
     */
    static CertEnumSubjectInSortedCTL(pCtlContext, ppvNextSubject, pSubjectIdentifier, pEncodedAttributes) {
        ppvNextSubjectMarshal := ppvNextSubject is VarRef ? "ptr*" : "ptr"

        result := DllCall("CRYPT32.dll\CertEnumSubjectInSortedCTL", "ptr", pCtlContext, ppvNextSubjectMarshal, ppvNextSubject, "ptr", pSubjectIdentifier, "ptr", pEncodedAttributes, "int")
        return result
    }

    /**
     * Verifies that a subject is trusted for a specified usage by finding a signed and time-valid certificate trust list (CTL) with the usage identifiers that contain the subject.
     * @param {Integer} dwEncodingType Specifies the encoding type used. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types can be added in the future. For either current encoding type, use  
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Integer} dwSubjectType If the <i>dwSubjectType</i> parameter is set to CTL_CERT_SUBJECT_TYPE, <i>pvSubject</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure. The structure's <b>SubjectAlgorithm</b> member is examined to determine the representation of the subject's identity. Initially, only SHA1 and MD5 hashes are supported as values for <b>SubjectAlgorithm</b>. The appropriate hash property is obtained from the <b>CERT_CONTEXT</b> structure.
     * 
     * If the <i>dwSubjectType</i> parameter is set to CTL_ANY_SUBJECT_TYPE, <i>pvSubject</i> points to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_any_subject_info">CTL_ANY_SUBJECT_INFO</a> structure. The <b>SubjectAlgorithm</b> member of this structure must match the algorithm type of the CTL, and the <b>SubjectIdentifier</b> member must match one of the CTL entries.
     * 
     * If <i>dwSubjectType</i> is set to either preceding value, <i>dwEncodingType</i> is not used.
     * @param {Pointer<Void>} pvSubject Value used in conjunction with the <i>dwSubjectType</i> parameter.
     * @param {Pointer<CTL_USAGE>} pSubjectUsage A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CTL_USAGE</a> structure used to specify the intended usage of the subject.
     * @param {Integer} dwFlags If the CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG is not set, a CTL whose time is no longer valid in one of the stores specified by <b>rghCtlStore</b> in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_verify_usage_para">CTL_VERIFY_USAGE_PARA</a> can be replaced. When replaced, the CERT_VERIFY_UPDATED_CTL_FLAG is set in the  <b>dwFlags</b> member of <i>pVerifyUsageStatus</i>. If this flag is set, an update will not be made, even if a time-valid, updated CTL is received for a CTL that is in the store and whose time is no longer valid.
     * 
     * If the CERT_VERIFY_TRUSTED_SIGNERS_FLAG is set, only the signer stores specified by <b>rghSignerStore</b> in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_verify_usage_para">CTL_VERIFY_USAGE_PARA</a> are searched to find the signer. Otherwise, the signer stores provide additional sources to find the signer's certificate. For more information, see Remarks.
     * 
     * If CERT_VERIFY_NO_TIME_CHECK_FLAG is set, the CTLs are not checked for time validity. Otherwise, they are.
     * 
     * If CERT_VERIFY_ALLOW_MORE_USAGE_FLAG is set, the CTL can contain usage identifiers in addition to those specified by <i>pSubjectUsage</i>. Otherwise, the found CTL will contain no additional usage identifiers.
     * @param {Pointer<CTL_VERIFY_USAGE_PARA>} pVerifyUsagePara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_verify_usage_para">CTL_VERIFY_USAGE_PARA</a> structure that specifies the stores to be searched to find the CTL and the stores that contain acceptable CTL signers. Setting the <b>ListIdentifier</b> member further limits the search.
     * @param {Pointer<CTL_VERIFY_USAGE_STATUS>} pVerifyUsageStatus A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_verify_usage_status">CTL_VERIFY_USAGE_STATUS</a> structure. The <b>cbSize</b> member of the structure must to be set to the size, in bytes, of the structure, and all other fields must be set to zero before <b>CertVerifyCTLUsage</b> is called. For more information, see 
     * <b>CTL_VERIFY_USAGE_STATUS</b>.
     * @returns {BOOL} If the subject is trusted for the specified usage, <b>TRUE</b> is returned. Otherwise, <b>FALSE</b> is returned. <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_VERIFY_USAGE_DLL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No DLL or exported function was found to verify subject usage.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_VERIFY_USAGE_CHECK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The called function was not able to do a usage check on the subject.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_VERIFY_USAGE_OFFLINE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The server was offline; therefore, the called function could not complete the usage check.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_IN_CTL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The subject was not found in a CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_TRUSTED_SIGNER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No trusted signer was found to verify the signature of the message or trust list.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The <b>dwError</b> member of the <a href="/windows/desktop/api/wincrypt/ns-wincrypt-ctl_verify_usage_para">CTL_VERIFY_USAGE_PARA</a> pointed to by <i>pVerifyUsageStatus</i> is set to the same error code.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certverifyctlusage
     * @since windows5.1.2600
     */
    static CertVerifyCTLUsage(dwEncodingType, dwSubjectType, pvSubject, pSubjectUsage, dwFlags, pVerifyUsagePara, pVerifyUsageStatus) {
        pvSubjectMarshal := pvSubject is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertVerifyCTLUsage", "uint", dwEncodingType, "uint", dwSubjectType, pvSubjectMarshal, pvSubject, "ptr", pSubjectUsage, "uint", dwFlags, "ptr", pVerifyUsagePara, "ptr", pVerifyUsageStatus, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Checks the revocation status of the certificates contained in the rgpvContext array. If a certificate in the list is found to be revoked, no further checking is done.
     * @param {Integer} dwEncodingType Specifies the encoding type used. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. For either current encoding type, use X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Integer} dwRevType Indicates the type of the context structure passed in <i>rgpvContext</i>. Currently only CERT_CONTEXT_REVOCATION_TYPE, the revocation of certificates, is defined.
     * @param {Integer} cContext Count of elements in the <i>rgpvContext</i> array.
     * @param {Pointer<Pointer<Void>>} rgpvContext When the <i>dwRevType</i> is CERT_CONTEXT_REVOCATION_TYPE, <i>rgpvContext</i> is an array of pointers to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structures. These contexts must contain sufficient information to allow the installable or registered revocation DLLs to find the revocation server. This information would normally be conveyed in an extension such as the CRLDistributionsPoints extension defined by the Internet Engineering Task Force (IETF) in PKIX Part 1. 
     * 
     * 
     * 
     * 
     * For efficiency, the more contexts that are passed in at one time, the better.
     * @param {Integer} dwFlags Indicates any special processing needs. This parameter can be one of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_VERIFY_REV_CHAIN_FLAG"></a><a id="cert_verify_rev_chain_flag"></a><dl>
     * <dt><b>CERT_VERIFY_REV_CHAIN_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Verification of the chain of certificates is done assuming each certificate except the first certificate is the issuer of the certificate that precedes it. If <i>dwRevType</i> is not CERT_CONTEXT_REVOCATION_TYPE, no assumptions are made about the order of the contexts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION"></a><a id="cert_verify_cache_only_based_revocation"></a><dl>
     * <dt><b>CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Prevents the revocation handler from accessing any network-based resources for revocation checking.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG"></a><a id="cert_verify_rev_accumulative_timeout_flag"></a><dl>
     * <dt><b>CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When set, <b>dwUrlRetrievalTimeout</b> is the cumulative time-out across all URL wire retrievals.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_VERIFY_REV_SERVER_OCSP_FLAG"></a><a id="cert_verify_rev_server_ocsp_flag"></a><dl>
     * <dt><b>CERT_VERIFY_REV_SERVER_OCSP_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When set, this function only uses <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">online certificate status protocol</a> (OCSP) for revocation checking. If the certificate does not have any OCSP AIA URLs, the <b>dwError</b> member of the <i>pRevStatus</i> parameter is set to CRYPT_E_NOT_IN_REVOCATION_DATABASE.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CERT_REVOCATION_PARA>} pRevPara Optionally set to assist in finding the issuer. For details, see the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_revocation_para">CERT_REVOCATION_PARA</a> structure.
     * @param {Pointer<CERT_REVOCATION_STATUS>} pRevStatus Only the <b>cbSize</b> member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_revocation_status">CERT_REVOCATION_STATUS</a> pointed to by <i>pRevStatus</i> needs to be set before <b>CertVerifyRevocation</b> is called.
     * 
     * If the function returns <b>FALSE</b>, this structure's members will contain error status information. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_revocation_status">CERT_REVOCATION_STATUS</a>. For a description of how <i>pRevStatus</i> is updated when a revocation verification problem is encountered, see Remarks.
     * @returns {BOOL} If the function successfully checks all of the contexts and none were revoked, the function returns <b>TRUE</b>. If the function fails, it returns <b>FALSE</b> and updates the <a href="/windows/desktop/api/wincrypt/ns-wincrypt-cert_revocation_status">CERT_REVOCATION_STATUS</a> structure pointed to by <i>pRevStatus</i> as described in 
     * <b>CERT_REVOCATION_STATUS</b>.
     * 
     * When the revocation handler for any of the contexts returns <b>FALSE</b> due to an error, the <b>dwError</b> member in the structure pointed to by <i>pRevStatus</i> will be set by the handler to specify which error was encountered. 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns an error code equal to the error specified in the <b>dwError</b> member of the <a href="/windows/desktop/api/wincrypt/ns-wincrypt-cert_revocation_status">CERT_REVOCATION_STATUS</a> structure. <b>GetLastError</b> can be one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_REVOCATION_CHECK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An installed or registered revocation function was not able to do a revocation check on the context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_REVOCATION_DLL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No installed or registered DLL was found that was able to verify revocation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_IN_REVOCATION_DATABASE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The context to be checked was not found in the revocation server's database.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_REVOCATION_OFFLINE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * It was not possible to connect to the revocation server.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_REVOKED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The context was revoked. <b>dwReason</b> in <i>pRevStatus</i> contains the reason for revocation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The context was good.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>cbSize</b> in <i>pRevStatus</i> is less than sizeof(<a href="/windows/desktop/api/wincrypt/ns-wincrypt-cert_revocation_status">CERT_REVOCATION_STATUS</a>). Note that <b>dwError</b> in <i>pRevStatus</i> is not updated for this error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certverifyrevocation
     * @since windows5.1.2600
     */
    static CertVerifyRevocation(dwEncodingType, dwRevType, cContext, rgpvContext, dwFlags, pRevPara, pRevStatus) {
        rgpvContextMarshal := rgpvContext is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertVerifyRevocation", "uint", dwEncodingType, "uint", dwRevType, "uint", cContext, rgpvContextMarshal, rgpvContext, "uint", dwFlags, "ptr", pRevPara, "ptr", pRevStatus, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertCompareIntegerBlob function compares two integer BLOBs to determine whether they represent equal numeric values.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pInt1 A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_INTEGER_BLOB</a> structure that contains the first integer in the comparison.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pInt2 A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_INTEGER_BLOB</a> structure that contains the second integer in the comparison.
     * @returns {BOOL} If the representations of the integer BLOBs are identical and the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certcompareintegerblob
     * @since windows5.1.2600
     */
    static CertCompareIntegerBlob(pInt1, pInt2) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertCompareIntegerBlob", "ptr", pInt1, "ptr", pInt2, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines whether two certificates are identical by comparing the issuer name and serial number of the certificates.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_INFO>} pCertId1 A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> for the first certificate in the comparison.
     * @param {Pointer<CERT_INFO>} pCertId2 A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> for the second certificate in the comparison.
     * @returns {BOOL} If the certificates are identical and the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certcomparecertificate
     * @since windows5.1.2600
     */
    static CertCompareCertificate(dwCertEncodingType, pCertId1, pCertId2) {
        result := DllCall("CRYPT32.dll\CertCompareCertificate", "uint", dwCertEncodingType, "ptr", pCertId1, "ptr", pCertId2, "int")
        return result
    }

    /**
     * The CertCompareCertificateName function compares two certificate CERT_NAME_BLOB structures to determine whether they are identical. The CERT_NAME_BLOB structures are used for the subject and the issuer of certificates.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pCertName1 A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CERT_NAME_BLOB</a> for the first name in the comparison. For more information, see 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_INTEGER_BLOB</a>.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pCertName2 A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CERT_NAME_BLOB</a> for the second name in the comparison.
     * @returns {BOOL} If the names are identical and the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certcomparecertificatename
     * @since windows5.1.2600
     */
    static CertCompareCertificateName(dwCertEncodingType, pCertName1, pCertName2) {
        result := DllCall("CRYPT32.dll\CertCompareCertificateName", "uint", dwCertEncodingType, "ptr", pCertName1, "ptr", pCertName2, "int")
        return result
    }

    /**
     * The CertIsRDNAttrsInCertificateName function compares the attributes in the certificate name with the specified CERT_RDN to determine whether all attributes are included there.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Integer} dwFlags CERT_UNICODE_IS_RDN_ATTRS_FLAG must be set if the <i>pRDN</i> was initialized with Unicode strings as in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencodeobject">CryptEncodeObject</a> with <i>lpszStructType</i> set to X509_UNICODE_NAME.
     * 
     * CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG is set to do a case insensitive match. Otherwise, an exact, case sensitive match is done.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pCertName A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_INTEGER_BLOB</a> that contains the encoded subject or issuer name.
     * @param {Pointer<CERT_RDN>} pRDN Array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_rdn">CERT_RDN</a> structures that contain the attributes to be found in the name. The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_rdn_attr">CERT_RDN_ATTR</a> member of the <b>CERT_RDN</b> structure behaves according to the following rules.
     * 
     * <ul>
     * <li>If <b>pszObjId</b> is <b>NULL</b>, the attribute <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) is ignored.</li>
     * <li>If <b>dwValueType</b> is CERT_RDN_ANY_TYPE, the value type is ignored.</li>
     * <li>If the <b>pbData</b> member of <b>Value</b> is  <b>NULL</b>, any value can be a match.</li>
     * </ul>
     * @returns {BOOL} If the function succeeds and all of the RDN values in the specified <a href="/windows/desktop/api/wincrypt/ns-wincrypt-cert_rdn">CERT_RDN</a> are in the certificate name, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, or if there are  RDN values in the specified <a href="/windows/desktop/api/wincrypt/ns-wincrypt-cert_rdn">CERT_RDN</a> that are not in the certificate name, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table lists some possible error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_MATCH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not all the attributes were found and matched.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Currently only X509_ASN_ENCODING is supported.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certisrdnattrsincertificatename
     * @since windows5.1.2600
     */
    static CertIsRDNAttrsInCertificateName(dwCertEncodingType, dwFlags, pCertName, pRDN) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertIsRDNAttrsInCertificateName", "uint", dwCertEncodingType, "uint", dwFlags, "ptr", pCertName, "ptr", pRDN, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertComparePublicKeyInfo function compares two encoded public keys to determine whether they are identical.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pPublicKey1 A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> for the first public key in the comparison.
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pPublicKey2 A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> for the second public key in the comparison.
     * @returns {BOOL} If the public keys are identical and the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certcomparepublickeyinfo
     * @since windows5.1.2600
     */
    static CertComparePublicKeyInfo(dwCertEncodingType, pPublicKey1, pPublicKey2) {
        result := DllCall("CRYPT32.dll\CertComparePublicKeyInfo", "uint", dwCertEncodingType, "ptr", pPublicKey1, "ptr", pPublicKey2, "int")
        return result
    }

    /**
     * The CertGetPublicKeyLength function acquires the bit length of public/private keys from a public key BLOB.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pPublicKey A pointer to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key BLOB</a> containing the keys for which the length is being retrieved.
     * @returns {Integer} Returns the length of the public/private keys in bits. If unable to determine the key's length, returns zero.
     * 
     * Call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to see the reason for any failures.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certgetpublickeylength
     * @since windows5.1.2600
     */
    static CertGetPublicKeyLength(dwCertEncodingType, pPublicKey) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetPublicKeyLength", "uint", dwCertEncodingType, "ptr", pPublicKey, "uint")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Verifies the signature of a certificate, certificate revocation list (CRL), or certificate request by using the public key in a CERT_PUBLIC_KEY_INFO structure.
     * @param {HCRYPTPROV_LEGACY} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>A handle to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) used to verify the signature.This parameter's data type is <b>HCRYPTPROV</b>.
     * 
     * <b>NULL</b> is passed unless there is a strong reason for passing in a specific cryptographic provider. Passing in <b>NULL</b> causes the default RSA or DSS provider to be acquired.
     * @param {Integer} dwCertEncodingType The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a> that was used to encrypt the subject. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> identifier, contained in the high <b>WORD</b> of this value, is ignored by this function.
     * 
     * 
     * This parameter can be the following currently defined certificate encoding type.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies <a href="https://docs.microsoft.com/windows/desktop/SecGloss/x-gly">X.509</a> certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} pbEncoded A pointer to an encoded <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a> of <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_signed_content_info">CERT_SIGNED_CONTENT_INFO</a> content on which the signature is to be verified.
     * @param {Integer} cbEncoded The size, in bytes, of the encoded content in <i>pbEncoded</i>.
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pPublicKey A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure that contains the public key to use when verifying the signature.
     * @returns {BOOL} Returns nonzero if successful or zero otherwise.
     * 						
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea">CryptVerifySignature</a>, and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> may be propagated to this function.</div>
     * <div></div>
     * On failure, this function will cause the following error codes to be returned from <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Currently only <b>X509_ASN_ENCODING</b> is supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature algorithm's <a href="/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) does not map to a known or supported <a href="/windows/desktop/SecGloss/h-gly">hash</a> algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature was not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>  may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptverifycertificatesignature
     * @since windows5.1.2600
     */
    static CryptVerifyCertificateSignature(hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pPublicKey) {
        hCryptProv := hCryptProv is Win32Handle ? NumGet(hCryptProv, "ptr") : hCryptProv

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptVerifyCertificateSignature", "ptr", hCryptProv, "uint", dwCertEncodingType, "ptr", pbEncoded, "uint", cbEncoded, "ptr", pPublicKey, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Verifies the signature of a subject certificate, certificate revocation list, certificate request, or keygen request by using the issuer's public key.
     * @param {HCRYPTPROV_LEGACY} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>A handle to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> used to verify the signature.This parameter's data type is <b>HCRYPTPROV</b>.
     * 
     * <b>NULL</b> is passed unless there is a strong reason for passing in a specific cryptographic provider. Passing in <b>NULL</b> causes the default RSA or DSS provider to be acquired.
     * @param {Integer} dwCertEncodingType The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a>   that was used to encrypt the subject.
     * 					 The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> identifier, contained in the high <b>WORD</b> of this value, is ignored by this function.
     * 
     * 
     * This parameter can be the following currently defined certificate encoding type.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies X.509 certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwSubjectType The subject type. This parameter can be one of the following subject types.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB"></a><a id="crypt_verify_cert_sign_subject_blob"></a><dl>
     * <dt><b>CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSubject</i> is a pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT"></a><a id="crypt_verify_cert_sign_subject_cert"></a><dl>
     * <dt><b>CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSubject</i> is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CCERT_CONTEXT</a>structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL"></a><a id="crypt_verify_cert_sign_subject_crl"></a><dl>
     * <dt><b>CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL</b></dt>
     * <dt>3 (0x3)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSubject</i> is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CCRL_CONTEXT</a>structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CERT_SIGN_SUBJECT_OCSP_BASIC_SIGNED_RESPONSE"></a><a id="crypt_verify_cert_sign_subject_ocsp_basic_signed_response"></a><dl>
     * <dt><b>CRYPT_VERIFY_CERT_SIGN_SUBJECT_OCSP_BASIC_SIGNED_RESPONSE</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSubject</i> is a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ocsp_basic_signed_response_info">OCSP_BASIC_SIGNED_RESPONSE_INFO</a> structure.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>This subject type is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvSubject A pointer to a structure of the type indicated by <i>dwSubjectType</i> that contains the signature to be verified.
     * @param {Integer} dwIssuerType The issuer type. This parameter can be one of the following issuer types.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY"></a><a id="crypt_verify_cert_sign_issuer_pubkey"></a><dl>
     * <dt><b>CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvIssuer</i> is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a>structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT"></a><a id="crypt_verify_cert_sign_issuer_cert"></a><dl>
     * <dt><b>CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvIssuer</i> is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CCERT_CONTEXT</a>structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN"></a><a id="crypt_verify_cert_sign_issuer_chain"></a><dl>
     * <dt><b>CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN</b></dt>
     * <dt>3 (0x3)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvIssuer</i> is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CCERT_CHAIN_CONTEXT</a>structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL"></a><a id="crypt_verify_cert_sign_issuer_null"></a><dl>
     * <dt><b>CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvIssuer</i> must be <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>If <i>dwIssuerType</i> is <b>CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL</b> and the signature algorithm is a hashing algorithm, the signature is expected to contain only unencrypted hash octets. Only <b>CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL</b> can be specified in this nonencrypted signature case. If any other <i>dwIssuerType</i> is specified, verification fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns E_INVALIDARG.</div>
     * <div></div>
     * @param {Pointer<Void>} pvIssuer A pointer to a structure of the type indicated by the value of <i>dwIssuerType</i>. The structure contains access to the public key needed to verify the signature.
     * @param {Integer} dwFlags 
     * @param {Pointer<Void>} pvExtra Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-crypt_verify_cert_sign_strong_properties_info">CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO</a> structure if the <i>dwFlags</i> parameter is set to <b>CRYPT_VERIFY_CERT_SIGN_RETURN_STRONG_PROPERTIES_FLAG</b>.
     * 
     * You must call <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmemfree">CryptMemFree</a> to free the structure.
     * @returns {BOOL} Returns nonzero if successful or zero otherwise. 
     * 						
     * 						
     * 						
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea">CryptVerifySignature</a>, and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> may be propagated to this function.</div>
     * <div></div>
     * On failure, this function will cause the following error codes to be returned from <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Currently only <b>X509_ASN_ENCODING</b> is supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature algorithm's <a href="/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) does not map to a known or supported <a href="/windows/desktop/SecGloss/h-gly">hash</a> algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature was not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptverifycertificatesignatureex
     * @since windows5.1.2600
     */
    static CryptVerifyCertificateSignatureEx(hCryptProv, dwCertEncodingType, dwSubjectType, pvSubject, dwIssuerType, pvIssuer, dwFlags, pvExtra) {
        hCryptProv := hCryptProv is Win32Handle ? NumGet(hCryptProv, "ptr") : hCryptProv

        pvSubjectMarshal := pvSubject is VarRef ? "ptr" : "ptr"
        pvIssuerMarshal := pvIssuer is VarRef ? "ptr" : "ptr"
        pvExtraMarshal := pvExtra is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptVerifyCertificateSignatureEx", "ptr", hCryptProv, "uint", dwCertEncodingType, "uint", dwSubjectType, pvSubjectMarshal, pvSubject, "uint", dwIssuerType, pvIssuerMarshal, pvIssuer, "uint", dwFlags, pvExtraMarshal, pvExtra, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Determines whether the specified hash algorithm and the public key in the signing certificate can be used to perform strong signing.
     * @param {Pointer<CERT_STRONG_SIGN_PARA>} pStrongSignPara Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_strong_sign_para">CERT_STRONG_SIGN_PARA</a> structure that contains information about supported signing and hashing algorithms.
     * @param {PWSTR} pwszCNGHashAlgid Pointer to a Unicode string that contains the name of the hashing algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"MD5" (BCRYPT_MD5_ALGORITHM)</li>
     * <li>L"SHA1" (BCRYPT_SHA1_ALGORITHM)</li>
     * <li>L"SHA256" (BCRYPT_SHA256_ALGORITHM)</li>
     * <li>L"SHA256" (BCRYPT_SHA256_ALGORITHM)</li>
     * <li>L"SHA512" (BCRYPT_SHA512_ALGORITHM)</li>
     * </ul>
     * @param {Pointer<CERT_CONTEXT>} pSigningCert Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure that  contains the signing certificate. The public key algorithm in the signing certificate is checked for strength. The public key (asymmetric) algorithm is used for signing. The following signature algorithms are supported:
     * 
     * <ul>
     * <li>L"RSA" (BCRYPT_RSA_ALGORITHM)</li>
     * <li>L"DSA" (BCRYPT_DSA_ALGORITHM)</li>
     * <li>L"ECDSA" (SSL_ECDSA_ALGORITHM)</li>
     * </ul>
     * This parameter can be <b>NULL</b> if you want to check only whether the hashing algorithm is strong.
     * @returns {BOOL} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>.
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. This function has the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the input arguments is not correct.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A specified algorithm is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certisstronghashtosign
     * @since windows8.0
     */
    static CertIsStrongHashToSign(pStrongSignPara, pwszCNGHashAlgid, pSigningCert) {
        pwszCNGHashAlgid := pwszCNGHashAlgid is String ? StrPtr(pwszCNGHashAlgid) : pwszCNGHashAlgid

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertIsStrongHashToSign", "ptr", pStrongSignPara, "ptr", pwszCNGHashAlgid, "ptr", pSigningCert, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * ImportantThis API is deprecated.
     * @param {HCRYPTPROV_LEGACY} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>A handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) to use to compute the hash.This parameter's data type is <b>HCRYPTPROV</b>.
     * 
     * Unless there is a strong reason for passing in a specific cryptographic provider in <i>hCryptProv</i>, zero is passed in. Passing in zero causes the default <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">RSA</a> or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">Digital Signature Standard</a> (DSS) provider to be acquired before doing hash, <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">signature verification</a>, or recipient <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">encryption</a> operations.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a> and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer} pbEncoded Address of a buffer that contains the content to be hashed. This is the encoded form of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_signed_content_info">CERT_SIGNED_CONTENT_INFO</a>.
     * @param {Integer} cbEncoded The size, in bytes, of the buffer.
     * @param {Pointer} pbComputedHash A pointer to a buffer to receive the computed hash.
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbComputedHash A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pbComputedHash</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a>, and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> might be propagated to this function. This function has the following error codes.</div>
     * <div></div>
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbComputedHash</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbComputedHash</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Currently only X509_ASN_ENCODING is supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) of the signature algorithm does not map to a known or supported hash algorithm.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-crypthashtobesigned
     * @since windows5.1.2600
     */
    static CryptHashToBeSigned(hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash) {
        hCryptProv := hCryptProv is Win32Handle ? NumGet(hCryptProv, "ptr") : hCryptProv

        pcbComputedHashMarshal := pcbComputedHash is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptHashToBeSigned", "ptr", hCryptProv, "uint", dwCertEncodingType, "ptr", pbEncoded, "uint", cbEncoded, "ptr", pbComputedHash, pcbComputedHashMarshal, pcbComputedHash, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptHashCertificate function hashes the entire encoded content of a certificate including its signature.
     * @param {HCRYPTPROV_LEGACY} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>A handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) to use to compute the hash. 
     * 
     * 
     * This parameter's data type is <b>HCRYPTPROV</b>.
     * 
     * Unless there is a strong reason for passing in a specific CSP in <i>hCryptProv</i>, zero is passed in. Passing in zero causes the default <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">RSA</a> or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">Digital Signature Standard</a> (DSS) provider to be acquired before doing hash, signature verification, or recipient encryption operations.
     * @param {Integer} Algid An 
     * 						<a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> structure that specifies the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash algorithm</a> to use. If <i>Algid</i> is zero, the default hash algorithm, SHA1, is used.
     * @param {Integer} dwFlags Value to be passed to the hash API. For details, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>.
     * @param {Pointer} pbEncoded Address of the encoded content to be hashed.
     * @param {Integer} cbEncoded The size, in bytes, of the encoded content.
     * @param {Pointer} pbComputedHash A pointer to a buffer to receive the computed hash. 
     * 
     * 
     * 
     * 
     * To set the size of this information for memory allocation purposes, this parameter can be <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbComputedHash A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pbComputedHash</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a> and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> might be propagated to this function.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-crypthashcertificate
     * @since windows5.1.2600
     */
    static CryptHashCertificate(hCryptProv, Algid, dwFlags, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash) {
        hCryptProv := hCryptProv is Win32Handle ? NumGet(hCryptProv, "ptr") : hCryptProv

        pcbComputedHashMarshal := pcbComputedHash is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptHashCertificate", "ptr", hCryptProv, "uint", Algid, "uint", dwFlags, "ptr", pbEncoded, "uint", cbEncoded, "ptr", pbComputedHash, pcbComputedHashMarshal, pcbComputedHash, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Hashes a block of data by using a CNG hash provider.
     * @param {PWSTR} pwszCNGHashAlgid The address of a null-terminated Unicode string that contains the CNG hash algorithm identifier of the hash algorithm to use to hash the certificate. This can be one of the <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-algorithm-identifiers">CNG Algorithm Identifiers</a> that represents a hash algorithm or any other registered hash algorithm identifier.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are defined for this function.
     * @param {Pointer} pbEncoded The address of an array of bytes to be hashed. The <i>cbEncoded</i> parameter contains the size of this array.
     * @param {Integer} cbEncoded The number of elements in the <i>pbEncoded</i> array.
     * @param {Pointer} pbComputedHash The address of a buffer that receives the computed hash. The variable pointed to by the <i>pcbComputedHash</i> parameter contains the size of this buffer.
     * @param {Pointer<Integer>} pcbComputedHash The address of a <b>DWORD</b> variable that, on entry, contains the size, in bytes, of the  <i>pbComputedHash</i> buffer. After this function returns, this variable contains the number of bytes copied to the <i>pbComputedHash</i> buffer.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some of the possible error codes are identified in the following topics.<dl>
     * <dd>
     * <a href="/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a>
     * </dd>
     * <dd>
     * <a href="/windows/desktop/api/bcrypt/nf-bcrypt-bcryptcreatehash">BCryptCreateHash</a>
     * </dd>
     * <dd>
     * <a href="/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a>
     * </dd>
     * <dd>
     * <a href="/windows/desktop/api/bcrypt/nf-bcrypt-bcrypthashdata">BCryptHashData</a>
     * </dd>
     * <dd>
     * <a href="/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfinishhash">BCryptFinishHash</a>
     * </dd>
     * </dl>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-crypthashcertificate2
     * @since windows6.0.6000
     */
    static CryptHashCertificate2(pwszCNGHashAlgid, dwFlags, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        pwszCNGHashAlgid := pwszCNGHashAlgid is String ? StrPtr(pwszCNGHashAlgid) : pwszCNGHashAlgid

        pcbComputedHashMarshal := pcbComputedHash is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptHashCertificate2", "ptr", pwszCNGHashAlgid, "uint", dwFlags, "ptr", pvReserved, "ptr", pbEncoded, "uint", cbEncoded, "ptr", pbComputedHash, pcbComputedHashMarshal, pcbComputedHash, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptSignCertificate function signs the &quot;to be signed&quot; information in the encoded signed content.
     * @param {HCRYPTPROV_OR_NCRYPT_KEY_HANDLE} hCryptProvOrNCryptKey 
     * @param {Integer} dwKeySpec Identifies the private key to use from the provider's container. It can be AT_KEYEXCHANGE or AT_SIGNATURE. This parameter is ignored if an <b>NCRYPT_KEY_HANDLE</b> is used in the <i>hCryptProvOrNCryptKey</i> parameter.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer} pbEncodedToBeSigned A pointer to the encoded content to be signed.
     * @param {Integer} cbEncodedToBeSigned The size, in bytes, of the encoded content, <i>pbEncodedToBeSigned</i>.
     * @param {Pointer<CRYPT_ALGORITHM_IDENTIFIER>} pSignatureAlgorithm A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_algorithm_identifier">CRYPT_ALGORITHM_IDENTIFIER</a> structure with a <b>pszObjId</b> member set to one of the following:
     * 
     * <ul>
     * <li>szOID_RSA_MD5RSA</li>
     * <li>szOID_RSA_SHA1RSA</li>
     * <li>szOID_X957_SHA1DSA</li>
     * <li>szOID_RSA_SSA_PSS</li>
     * <li>szOID_ECDSA_SPECIFIED</li>
     * </ul>
     * If the signature algorithm is a hash algorithm, the signature contains only the un-encrypted hash octets. A private key is not used to encrypt the hash. <i>dwKeySpec</i> is not used and <i>hCryptProvOrNCryptKey</i> can be <b>NULL</b> if an appropriate default CSP can be used for hashing.
     * @param {Pointer<Void>} pvHashAuxInfo Not currently used. Must be <b>NULL</b>.
     * @param {Pointer} pbSignature A pointer to a buffer to receive the signed <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> of the content.
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbSignature A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pbSignature</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored or to be stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a> and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> might be propagated to this function.</div>
     * <div></div>
     * This function has the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbSignature</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbSignature</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature algorithm's <a href="/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) does not map to a known or supported hash algorithm.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptsigncertificate
     * @since windows5.1.2600
     */
    static CryptSignCertificate(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pbEncodedToBeSigned, cbEncodedToBeSigned, pSignatureAlgorithm, pvHashAuxInfo, pbSignature, pcbSignature) {
        hCryptProvOrNCryptKey := hCryptProvOrNCryptKey is Win32Handle ? NumGet(hCryptProvOrNCryptKey, "ptr") : hCryptProvOrNCryptKey

        pvHashAuxInfoMarshal := pvHashAuxInfo is VarRef ? "ptr" : "ptr"
        pcbSignatureMarshal := pcbSignature is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptSignCertificate", "ptr", hCryptProvOrNCryptKey, "uint", dwKeySpec, "uint", dwCertEncodingType, "ptr", pbEncodedToBeSigned, "uint", cbEncodedToBeSigned, "ptr", pSignatureAlgorithm, pvHashAuxInfoMarshal, pvHashAuxInfo, "ptr", pbSignature, pcbSignatureMarshal, pcbSignature, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Encodes and signs a certificate, certificate revocation list (CRL), certificate trust list (CTL), or certificate request.
     * @param {HCRYPTPROV_OR_NCRYPT_KEY_HANDLE} hCryptProvOrNCryptKey 
     * @param {Integer} dwKeySpec 
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. This can be the following value.
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies <a href="https://docs.microsoft.com/windows/desktop/SecGloss/x-gly">X.509</a> certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PSTR} lpszStructType A pointer to a null-terminated ANSI string that contains the type of data to be encoded and signed. The following predefined <i>lpszStructType</i> constants are used with encode operations.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_CERT_CRL_TO_BE_SIGNED"></a><a id="x509_cert_crl_to_be_signed"></a><dl>
     * <dt><b>X509_CERT_CRL_TO_BE_SIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvStructInfo</i> is the address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_info">CRL_INFO</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_CERT_REQUEST_TO_BE_SIGNED"></a><a id="x509_cert_request_to_be_signed"></a><dl>
     * <dt><b>X509_CERT_REQUEST_TO_BE_SIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvStructInfo</i> is the address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_request_info">CERT_REQUEST_INFO</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_CERT_TO_BE_SIGNED"></a><a id="x509_cert_to_be_signed"></a><dl>
     * <dt><b>X509_CERT_TO_BE_SIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvStructInfo</i> is the address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_KEYGEN_REQUEST_TO_BE_SIGNED"></a><a id="x509_keygen_request_to_be_signed"></a><dl>
     * <dt><b>X509_KEYGEN_REQUEST_TO_BE_SIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvStructInfo</i> is the address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_keygen_request_info">CERT_KEYGEN_REQUEST_INFO</a> structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvStructInfo The address of a structure that contains the data to be signed and encoded. The format of this structure is determined by the <i>lpszStructType</i> parameter.
     * @param {Pointer<CRYPT_ALGORITHM_IDENTIFIER>} pSignatureAlgorithm A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_algorithm_identifier">CRYPT_ALGORITHM_IDENTIFIER</a> structure that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) of the signature algorithm and any additional parameters needed. This function uses the following algorithm OIDs:
     * 
     * <ul>
     * <li>szOID_RSA_MD5RSA</li>
     * <li>szOID_RSA_SHA1RSA</li>
     * <li>szOID_X957_SHA1DSA</li>
     * </ul>
     * If the signature algorithm is a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> algorithm, the signature contains only the unencrypted hash octets. A private key is not used to encrypt the hash. <i>dwKeySpec</i> is not used and <i>hCryptProvOrNCryptKey</i> can be <b>NULL</b> if an appropriate default CSP can be used for hashing.
     * @param {Pointer<Void>} pvHashAuxInfo Reserved. Must be <b>NULL</b>.
     * @param {Pointer} pbEncoded A pointer to a buffer to receive the signed and encoded output.
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbEncoded A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pbEncoded</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored or to be stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a> and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> might be propagated to this function.</div>
     * <div></div>
     * Possible error codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbEncoded</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbEncoded</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Currently only X509_ASN_ENCODING is supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature algorithm's OID does not map to a known or supported hash algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_BAD_ENCODE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error was encountered while encoding or decoding. The most likely cause of this error is the improper initialization of the fields in the structure pointed to by <i>pvStructInfo</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptsignandencodecertificate
     * @since windows5.1.2600
     */
    static CryptSignAndEncodeCertificate(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, lpszStructType, pvStructInfo, pSignatureAlgorithm, pvHashAuxInfo, pbEncoded, pcbEncoded) {
        hCryptProvOrNCryptKey := hCryptProvOrNCryptKey is Win32Handle ? NumGet(hCryptProvOrNCryptKey, "ptr") : hCryptProvOrNCryptKey
        lpszStructType := lpszStructType is String ? StrPtr(lpszStructType) : lpszStructType

        pvStructInfoMarshal := pvStructInfo is VarRef ? "ptr" : "ptr"
        pvHashAuxInfoMarshal := pvHashAuxInfo is VarRef ? "ptr" : "ptr"
        pcbEncodedMarshal := pcbEncoded is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptSignAndEncodeCertificate", "ptr", hCryptProvOrNCryptKey, "uint", dwKeySpec, "uint", dwCertEncodingType, "ptr", lpszStructType, pvStructInfoMarshal, pvStructInfo, "ptr", pSignatureAlgorithm, pvHashAuxInfoMarshal, pvHashAuxInfo, "ptr", pbEncoded, pcbEncodedMarshal, pcbEncoded, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertVerifyTimeValidity function verifies the time validity of a certificate.
     * @param {Pointer<FILETIME>} pTimeToVerify A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure containing the comparison time. If <b>NULL</b>, the current time is used.
     * @param {Pointer<CERT_INFO>} pCertInfo A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure of the certificate for which the time is being verified.
     * @returns {Integer} Returns a minus one if the comparison time is before the <b>NotBefore</b> member of the 
     * <a href="/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure. Returns a plus one if the comparison time is after the <b>NotAfter</b> member. Returns zero for valid time for the certificate.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certverifytimevalidity
     * @since windows5.1.2600
     */
    static CertVerifyTimeValidity(pTimeToVerify, pCertInfo) {
        result := DllCall("CRYPT32.dll\CertVerifyTimeValidity", "ptr", pTimeToVerify, "ptr", pCertInfo, "int")
        return result
    }

    /**
     * The CertVerifyCRLTimeValidity function verifies the time validity of a CRL.
     * @param {Pointer<FILETIME>} pTimeToVerify A pointer to <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure containing the time to be used in the verification. If set to <b>NULL</b>, the current time is used.
     * @param {Pointer<CRL_INFO>} pCrlInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_info">CRL_INFO</a> structure containing the CRL for which the time is to be verified.
     * @returns {Integer} Returns a minus one (1) if the comparison time is before the <b>ThisUpdate</b> member of the <a href="/windows/desktop/api/wincrypt/ns-wincrypt-crl_info">CRL_INFO</a> pointed to by <i>pCrlInfo</i>. Returns a plus one (+1) if the comparison time is after the <b>NextUpdate</b> time. Returns zero for valid time for the CRL.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certverifycrltimevalidity
     * @since windows5.1.2600
     */
    static CertVerifyCRLTimeValidity(pTimeToVerify, pCrlInfo) {
        result := DllCall("CRYPT32.dll\CertVerifyCRLTimeValidity", "ptr", pTimeToVerify, "ptr", pCrlInfo, "int")
        return result
    }

    /**
     * The CertVerifyValidityNesting function verifies that a subject certificate's time validity nests correctly within its issuer's time validity.
     * @param {Pointer<CERT_INFO>} pSubjectInfo A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure of the subject certificate.
     * @param {Pointer<CERT_INFO>} pIssuerInfo A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure of the issuer certificate.
     * @returns {BOOL} Returns <b>TRUE</b> if the <b>NotBefore</b> time of the subject's certificate is after the <b>NotBefore</b> time of the issuer's certificate and the <b>NotAfter</b> time of the subject's certificate is not after the <b>NotAfter</b> time of the issuer's certificate. Otherwise, returns <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certverifyvaliditynesting
     * @since windows5.1.2600
     */
    static CertVerifyValidityNesting(pSubjectInfo, pIssuerInfo) {
        result := DllCall("CRYPT32.dll\CertVerifyValidityNesting", "ptr", pSubjectInfo, "ptr", pIssuerInfo, "int")
        return result
    }

    /**
     * Check a certificate revocation list (CRL) to determine whether a subject's certificate has or has not been revoked.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_INFO>} pCertId A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure of the certificate to be checked against the CRL.
     * @param {Integer} cCrlInfo Number of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_info">CRL_INFO</a> pointers in the <i>rgpCrlInfo</i> array.
     * @param {Pointer<Pointer<CRL_INFO>>} rgpCrlInfo Array of pointers to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_info">CRL_INFO</a> structures.
     * @returns {BOOL} Returns <b>TRUE</b> if the certificate is not on the CRL and therefore is valid.
     * 						
     * 
     * It returns <b>FALSE</b> if the certificate is on the list and therefore has been revoked and is not valid.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certverifycrlrevocation
     * @since windows5.1.2600
     */
    static CertVerifyCRLRevocation(dwCertEncodingType, pCertId, cCrlInfo, rgpCrlInfo) {
        rgpCrlInfoMarshal := rgpCrlInfo is VarRef ? "ptr*" : "ptr"

        result := DllCall("CRYPT32.dll\CertVerifyCRLRevocation", "uint", dwCertEncodingType, "ptr", pCertId, "uint", cCrlInfo, rgpCrlInfoMarshal, rgpCrlInfo, "int")
        return result
    }

    /**
     * Converts a CryptoAPI algorithm identifier (ALG_ID) to an Abstract Syntax Notation One (ASN.1) object identifier (OID) string.
     * @param {Integer} dwAlgId Value to be converted to an OID.
     * @returns {PSTR} If the function succeeds, the function returns the null-terminated OID string.
     * 
     * If no OID string corresponds to the algorithm identifier, the function returns <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certalgidtooid
     * @since windows5.1.2600
     */
    static CertAlgIdToOID(dwAlgId) {
        result := DllCall("CRYPT32.dll\CertAlgIdToOID", "uint", dwAlgId, "ptr")
        return result
    }

    /**
     * Use the CryptFindOIDInfo function instead of this function because ALG_ID identifiers are no longer supported in CNG.
     * @param {PSTR} pszObjId Pointer to the ASN.1 OID to be converted to an algorithm identifier.
     * @returns {Integer} Returns the 
     * <a href="/windows/desktop/SecCrypto/alg-id">ALG_ID</a> that corresponds to the object identifier (OID) or zero if no <b>ALG_ID</b> corresponds to the OID.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certoidtoalgid
     * @since windows5.1.2600
     */
    static CertOIDToAlgId(pszObjId) {
        pszObjId := pszObjId is String ? StrPtr(pszObjId) : pszObjId

        result := DllCall("CRYPT32.dll\CertOIDToAlgId", "ptr", pszObjId, "uint")
        return result
    }

    /**
     * The CertFindExtension function finds the first extension in the CERT_EXTENSION array, as identified by its object identifier (OID).
     * @param {PSTR} pszObjId A pointer to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) to use in the search.
     * @param {Integer} cExtensions Number of extensions in the <i>rgExtensions</i> array.
     * @param {Pointer<CERT_EXTENSION>} rgExtensions Array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_extension">CERT_EXTENSION</a> structures.
     * @returns {Pointer<CERT_EXTENSION>} Returns a pointer to the extension, if one is found. Otherwise, <b>NULL</b> is returned.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certfindextension
     * @since windows5.1.2600
     */
    static CertFindExtension(pszObjId, cExtensions, rgExtensions) {
        pszObjId := pszObjId is String ? StrPtr(pszObjId) : pszObjId

        result := DllCall("CRYPT32.dll\CertFindExtension", "ptr", pszObjId, "uint", cExtensions, "ptr", rgExtensions, "ptr")
        return result
    }

    /**
     * The CertFindAttribute function finds the first attribute in the CRYPT_ATTRIBUTE array, as identified by its object identifier (OID).
     * @param {PSTR} pszObjId A pointer to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) to use in the search.
     * @param {Integer} cAttr Number of attributes in the <i>rgAttr</i> array.
     * @param {Pointer<CRYPT_ATTRIBUTE>} rgAttr Array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_attribute">CRYPT_ATTRIBUTE</a> structures.
     * @returns {Pointer<CRYPT_ATTRIBUTE>} Returns a pointer to the attribute, if one is found. Otherwise, <b>NULL</b> is returned.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certfindattribute
     * @since windows5.1.2600
     */
    static CertFindAttribute(pszObjId, cAttr, rgAttr) {
        pszObjId := pszObjId is String ? StrPtr(pszObjId) : pszObjId

        result := DllCall("CRYPT32.dll\CertFindAttribute", "ptr", pszObjId, "uint", cAttr, "ptr", rgAttr, "ptr")
        return result
    }

    /**
     * The CertFindRDNAttr function finds the first RDN attribute identified by its object identifier (OID) in a list of the Relative Distinguished Names (RDN).
     * @param {PSTR} pszObjId A pointer to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) to use In the search.
     * @param {Pointer<CERT_NAME_INFO>} pName A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_name_info">CERT_NAME_INFO</a> structure containing the list of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">Relative Distinguished Names</a> to be searched.
     * @returns {Pointer<CERT_RDN_ATTR>} Returns a pointer to the attribute, if one is found. Otherwise, <b>NULL</b> is returned.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certfindrdnattr
     * @since windows5.1.2600
     */
    static CertFindRDNAttr(pszObjId, pName) {
        pszObjId := pszObjId is String ? StrPtr(pszObjId) : pszObjId

        result := DllCall("CRYPT32.dll\CertFindRDNAttr", "ptr", pszObjId, "ptr", pName, "ptr")
        return result
    }

    /**
     * Acquires the intended key usage bytes from a certificate.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_INFO>} pCertInfo A pointer to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure of the specified certificate.
     * @param {Pointer} pbKeyUsage A pointer to a buffer to receive the intended key usage. The following list shows currently defined values. These can be combined by using bitwise-<b>OR</b> operations.
     * 
     * <ul>
     * <li>CERT_DATA_ENCIPHERMENT_KEY_USAGE</li>
     * <li>CERT_DIGITAL_SIGNATURE_KEY_USAGE</li>
     * <li>CERT_KEY_AGREEMENT_KEY_USAGE</li>
     * <li>CERT_KEY_CERT_SIGN_KEY_USAGE</li>
     * <li>CERT_KEY_ENCIPHERMENT_KEY_USAGE</li>
     * <li>CERT_NON_REPUDIATION_KEY_USAGE</li>
     * <li>CERT_OFFLINE_CRL_SIGN_KEY_USAGE</li>
     * </ul>
     * @param {Integer} cbKeyUsage The size, in bytes, of the buffer pointed to by <i>pbKeyUsage</i>. Currently, the intended key usage occupies 1 or 2 bytes of data.
     * @returns {BOOL} If the certificate does not have any intended key usage bytes, <b>FALSE</b> is returned and <i>pbKeyUsage</i> is zeroed. Otherwise, <b>TRUE</b> is returned and up to <i>cbKeyUsage</i> number of bytes are copied into <i>pbKeyUsage</i>. Any remaining bytes not copied are zeroed.
     * 
     * 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns zero if none of the required extensions is found.
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certgetintendedkeyusage
     * @since windows5.1.2600
     */
    static CertGetIntendedKeyUsage(dwCertEncodingType, pCertInfo, pbKeyUsage, cbKeyUsage) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetIntendedKeyUsage", "uint", dwCertEncodingType, "ptr", pCertInfo, "ptr", pbKeyUsage, "uint", cbKeyUsage, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Installs a specific provider to be the default context provider for the specified algorithm.
     * @param {Pointer} hCryptProv The handle of the cryptographic service provider to be used as the default context. This handle is obtained by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function.
     * @param {Integer} dwDefaultType 
     * @param {Pointer<Void>} pvDefaultPara Specifies the object or objects to install the default context provider for. The format of this parameter depends on the contents of the <i>dwDefaultType</i> parameter.
     * @param {Integer} dwFlags 
     * @param {Pointer<Pointer<Void>>} phDefaultContext The address of an <b>HCRYPTDEFAULTCONTEXT</b> variable that receives the default context handle. This handle is passed to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptuninstalldefaultcontext">CryptUninstallDefaultContext</a> function to uninstall the default context provider.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE). If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptinstalldefaultcontext
     * @since windows5.1.2600
     */
    static CryptInstallDefaultContext(hCryptProv, dwDefaultType, pvDefaultPara, dwFlags, phDefaultContext) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        pvDefaultParaMarshal := pvDefaultPara is VarRef ? "ptr" : "ptr"
        phDefaultContextMarshal := phDefaultContext is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptInstallDefaultContext", "ptr", hCryptProv, "uint", dwDefaultType, pvDefaultParaMarshal, pvDefaultPara, "uint", dwFlags, "ptr", pvReserved, phDefaultContextMarshal, phDefaultContext, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * ImportantThis API is deprecated.
     * @param {Pointer<Void>} hDefaultContext Handle of the context to be released.
     * @param {Integer} dwFlags Reserved for future use.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE) .If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptuninstalldefaultcontext
     * @since windows5.1.2600
     */
    static CryptUninstallDefaultContext(hDefaultContext, dwFlags) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        hDefaultContextMarshal := hDefaultContext is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptUninstallDefaultContext", hDefaultContextMarshal, hDefaultContext, "uint", dwFlags, "ptr", pvReserved, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptExportPublicKeyInfo function exports the public key information associated with the corresponding private key of the provider. For an updated version of this function, see CryptExportPublicKeyInfoEx.
     * @param {HCRYPTPROV_OR_NCRYPT_KEY_HANDLE} hCryptProvOrNCryptKey Handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) to use when exporting the public key information. This handle must be an <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a> handle that has been created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function or an <b>NCRYPT_KEY_HANDLE</b> handle that has been created by using the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenkey">NCryptOpenKey</a> function. New applications should always pass in the <b>NCRYPT_KEY_HANDLE</b> handle of a CNG CSP.
     * @param {Integer} dwKeySpec Identifies the private key to use from the container of the provider. It can be AT_KEYEXCHANGE or AT_SIGNATURE. This parameter is ignored if an <b>NCRYPT_KEY_HANDLE</b> is used in the <i>hCryptProvOrNCryptKey</i> parameter.
     * @param {Integer} dwCertEncodingType Specifies the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">encoding type</a> used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer} pInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a>  structure to receive the public key information to be exported.
     * 
     * To set the size of this information for memory allocation purposes, this parameter can be <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbInfo A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pInfo</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes needed for the return buffer.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetuserkey">CryptGetUserKey</a> and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a> might be propagated to this function.</div>
     * <div></div>
     * This function has the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pInfo</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbInfo</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Currently only X509_ASN_ENCODING is supported.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptexportpublickeyinfo
     * @since windows5.1.2600
     */
    static CryptExportPublicKeyInfo(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pInfo, pcbInfo) {
        hCryptProvOrNCryptKey := hCryptProvOrNCryptKey is Win32Handle ? NumGet(hCryptProvOrNCryptKey, "ptr") : hCryptProvOrNCryptKey

        pcbInfoMarshal := pcbInfo is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptExportPublicKeyInfo", "ptr", hCryptProvOrNCryptKey, "uint", dwKeySpec, "uint", dwCertEncodingType, "ptr", pInfo, pcbInfoMarshal, pcbInfo, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Exports the public key information associated with the provider's corresponding private key.
     * @param {HCRYPTPROV_OR_NCRYPT_KEY_HANDLE} hCryptProvOrNCryptKey A handle of the CSP to use when exporting the public key information. This handle must be an <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a> handle that has been created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function or an <b>NCRYPT_KEY_HANDLE</b> handle that has been created by using the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenkey">NCryptOpenKey</a> function. New applications should always pass in the <b>NCRYPT_KEY_HANDLE</b> handle of a CNG CSP.
     * @param {Integer} dwKeySpec Identifies the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key</a> to use from the provider's container. It can be AT_KEYEXCHANGE or AT_SIGNATURE. This parameter is ignored if an <b>NCRYPT_KEY_HANDLE</b> is used in the <i>hCryptProvOrNCryptKey</i> parameter.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {PSTR} pszPublicKeyObjId Specifies the public key algorithm.
     * 
     * <div class="alert"><b>Note</b><i>pszPublicKeyObjId</i> and <i>dwCertEncodingType</i> are used together to determine the installable <b>CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC</b> to call. If an installable function was not found for the <i>pszPublicKeyObjId</i> parameter, an attempt is made to export the key as an RSA Public Key (szOID_RSA_RSA).</div>
     * <div></div>
     * @param {Integer} dwFlags A <b>DWORD</b> flag value that indicates how the public key information  is exported. The flag value is passed directly to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptfindoidinfo">CryptFindOIDInfo</a> function when mapping the public key <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> to the corresponding CNG public key algorithm Unicode string. The following flag values can be set.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Skips public keys in the <b>CRYPT_PUBKEY_ALG_OID_GROUP_ID</b> group explicitly flagged with the <b>CRYPT_OID_PUBKEY_ENCRYPT_ONLY_FLAG</b> flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Skips public keys in the <b>CRYPT_PUBKEY_ALG_OID_GROUP_ID</b> group explicitly flagged with the <b>CRYPT_OID_PUBKEY_SIGN_ONLY_FLAG</b> flag.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvAuxInfo This parameter is reserved for future use and  must be set to <b>NULL</b>.
     * @param {Pointer} pInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a>  structure to receive the public key information to be exported.
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbInfo A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pInfo</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetuserkey">CryptGetUserKey</a> and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a> can be propagated to this function.</div>
     * <div></div>
     * This function has the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An export function that can be installed or registered could not be found for the specified <i>dwCertEncodingType</i> and <i>pszPublicKeyObjId</i> parameters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pInfo</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by the <i>pcbInfo</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptexportpublickeyinfoex
     * @since windows5.1.2600
     */
    static CryptExportPublicKeyInfoEx(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo) {
        hCryptProvOrNCryptKey := hCryptProvOrNCryptKey is Win32Handle ? NumGet(hCryptProvOrNCryptKey, "ptr") : hCryptProvOrNCryptKey
        pszPublicKeyObjId := pszPublicKeyObjId is String ? StrPtr(pszPublicKeyObjId) : pszPublicKeyObjId

        pvAuxInfoMarshal := pvAuxInfo is VarRef ? "ptr" : "ptr"
        pcbInfoMarshal := pcbInfo is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptExportPublicKeyInfoEx", "ptr", hCryptProvOrNCryptKey, "uint", dwKeySpec, "uint", dwCertEncodingType, "ptr", pszPublicKeyObjId, "uint", dwFlags, pvAuxInfoMarshal, pvAuxInfo, "ptr", pInfo, pcbInfoMarshal, pcbInfo, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Exports the public key information associated with a provider's corresponding private key.
     * @param {BCRYPT_KEY_HANDLE} hBCryptKey The handle of the key from which to export the public key information.
     * @param {Integer} dwCertEncodingType Specifies the encoding type to be matched.  
     * 
     * 
     * 
     * 						
     * 
     * This value can be a bitwise combination of the currently defined encoding types:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {PSTR} pszPublicKeyObjId A pointer to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) that identifies the installable function to  use to export the key. If the high-order word of the OID is nonzero, <i>pszPublicKeyObjId</i> is a pointer to either an OID string such as "2.5.29.1" or an ASCII string such as "file." If the high-order word of the OID is zero, the low-order word specifies the integer identifier to be used as the object identifier.
     * @param {Integer} dwFlags A <b>DWORD</b> value that indicates how the public key information  is exported.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG"></a><a id="crypt_oid_info_pubkey_sign_key_flag"></a><dl>
     * <dt><b>CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG</b></dt>
     * <dt>0x80000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Skips public keys in the <b>CRYPT_PUBKEY_ALG_OID_GROUP_ID</b> group that are explicitly flagged with the <b>CRYPT_OID_PUBKEY_ENCRYPT_ONLY_FLAG</b> flag.
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG"></a><a id="crypt_oid_info_pubkey_encrypt_key_flag"></a><dl>
     * <dt><b>CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG</b></dt>
     * <dt>0x40000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Skips public keys in the <b>CRYPT_PUBKEY_ALG_OID_GROUP_ID</b> group that are explicitly flagged with the <b>CRYPT_OID_PUBKEY_SIGN_ONLY_FLAG</b> flag.
     * 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvAuxInfo This parameter is reserved for future use and  must be set to <b>NULL</b>.
     * @param {Pointer} pInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a>  structure to receive the public key information to be exported.
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbInfo A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pInfo</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer.
     * @returns {BOOL} The function returns <b>TRUE</b> if it succeeds; otherwise, it returns <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptexportpublickeyinfofrombcryptkeyhandle
     * @since windows6.1
     */
    static CryptExportPublicKeyInfoFromBCryptKeyHandle(hBCryptKey, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo) {
        hBCryptKey := hBCryptKey is Win32Handle ? NumGet(hBCryptKey, "ptr") : hBCryptKey
        pszPublicKeyObjId := pszPublicKeyObjId is String ? StrPtr(pszPublicKeyObjId) : pszPublicKeyObjId

        pvAuxInfoMarshal := pvAuxInfo is VarRef ? "ptr" : "ptr"
        pcbInfoMarshal := pcbInfo is VarRef ? "uint*" : "ptr"

        result := DllCall("CRYPT32.dll\CryptExportPublicKeyInfoFromBCryptKeyHandle", "ptr", hBCryptKey, "uint", dwCertEncodingType, "ptr", pszPublicKeyObjId, "uint", dwFlags, pvAuxInfoMarshal, pvAuxInfo, "ptr", pInfo, pcbInfoMarshal, pcbInfo, "int")
        return result
    }

    /**
     * Converts and imports the public key information into the provider and returns a handle of the public key.
     * @param {Pointer} hCryptProv The handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) to use when importing the public key. This handle must have already been created using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pInfo The address of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure that contains the public key to import into the provider.
     * @param {Pointer<Pointer>} phKey The address of an <b>HCRYPTKEY</b> variable that receives the handle of the imported public key. When you have finished using the public key, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetuserkey">CryptGetUserKey</a> and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a> might be propagated to this function. This function has the following error code.</div>
     * <div></div>
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An import function that can be installed or registered could not be found for the specified <i>dwCertEncodingType</i> and
     * 								<i>pInfo-&gt;Algorithm.pszObjId</i> parameters.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptimportpublickeyinfo
     * @since windows5.1.2600
     */
    static CryptImportPublicKeyInfo(hCryptProv, dwCertEncodingType, pInfo, phKey) {
        phKeyMarshal := phKey is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptImportPublicKeyInfo", "ptr", hCryptProv, "uint", dwCertEncodingType, "ptr", pInfo, phKeyMarshal, phKey, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * ImportantThis API is deprecated.
     * @param {Pointer} hCryptProv The handle of the CSP to receive the imported public key. This handle must have already been created using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pInfo the address of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure that contains the public key to import into the provider.
     * 
     * <div class="alert"><b>Note</b>The <b>pzObjId</b> member of the <b>Algorithm</b> member pointed to by the <i>pInfo</i>  and <i>dwCertEncodingType</i> parameters determine an installable <b>CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC</b> callback function. If an installable function is not found, an attempt is made to import the key as an RSA Public Key (szOID_RSA_RSA).</div>
     * <div></div>
     * @param {Integer} aiKeyAlg An <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> structure that contains a CSP-specific algorithm to override the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CALG_RSA_KEYX</a> default algorithm.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Void>} pvAuxInfo Reserved for future use and must be <b>NULL</b>.
     * @param {Pointer<Pointer>} phKey The address of an <b>HCRYPTKEY</b> variable that receives the handle of the imported public key. When you have finished using the public key, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetuserkey">CryptGetUserKey</a> and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a> might be propagated to this function. This function has the following error code.</div>
     * <div></div>
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An import function that can be installed or registered could not be found for the specified <i>dwCertEncodingType</i> and <i>pInfo</i> parameters.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptimportpublickeyinfoex
     * @since windows5.1.2600
     */
    static CryptImportPublicKeyInfoEx(hCryptProv, dwCertEncodingType, pInfo, aiKeyAlg, dwFlags, pvAuxInfo, phKey) {
        pvAuxInfoMarshal := pvAuxInfo is VarRef ? "ptr" : "ptr"
        phKeyMarshal := phKey is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptImportPublicKeyInfoEx", "ptr", hCryptProv, "uint", dwCertEncodingType, "ptr", pInfo, "uint", aiKeyAlg, "uint", dwFlags, pvAuxInfoMarshal, pvAuxInfo, phKeyMarshal, phKey, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Imports a public key into the CNG asymmetric provider that corresponds to the public key object identifier (OID) and returns a CNG handle to the key.
     * @param {Integer} dwCertEncodingType The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a> that was used to encrypt the subject. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> identifier, contained in the high <b>WORD</b> of this value, is ignored by this function.
     * 
     * 
     * This parameter can be the following currently defined certificate encoding type.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies <a href="https://docs.microsoft.com/windows/desktop/SecGloss/x-gly">X.509</a> certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pInfo The address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure that contains the public key information to import into the provider.
     * @param {Integer} dwFlags 
     * @param {Pointer<Void>} pvAuxInfo This parameter is reserved for future use and must be set to <b>NULL</b>.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} phKey The address of a <b>BCRYPT_KEY_HANDLE</b> variable that receives the handle of the imported key.
     * 
     * When this handle is no longer needed, you must release it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroykey">BCryptDestroyKey</a> function.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An import function that can be installed or registered could not be found for the specified <i>dwCertEncodingType</i> and <i>pInfo</i> parameters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptimportpublickeyinfoex2
     * @since windows6.0.6000
     */
    static CryptImportPublicKeyInfoEx2(dwCertEncodingType, pInfo, dwFlags, pvAuxInfo, phKey) {
        pvAuxInfoMarshal := pvAuxInfo is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptImportPublicKeyInfoEx2", "uint", dwCertEncodingType, "ptr", pInfo, "uint", dwFlags, pvAuxInfoMarshal, pvAuxInfo, "ptr", phKey, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Obtains the private key for a certificate.
     * @param {Pointer<CERT_CONTEXT>} pCert The address of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a> for which a private key will be obtained.
     * @param {Integer} dwFlags 
     * @param {Pointer<Void>} pvParameters If the <b>CRYPT_ACQUIRE_WINDOWS_HANDLE_FLAG</b>  is set, then this is the address of an <b>HWND</b>. If the <b>CRYPT_ACQUIRE_WINDOWS_HANDLE_FLAG</b> is not set, then this parameter must be <b>NULL</b>.
     * 
     * 
     * <b>Windows Server2008R2, Windows7, Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP:</b>This parameter was  named <i>pvReserved</i> and reserved for future use and must be <b>NULL</b>.
     * @param {Pointer<HCRYPTPROV_OR_NCRYPT_KEY_HANDLE>} phCryptProvOrNCryptKey The address of an <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov-or-ncrypt-key-handle">HCRYPTPROV_OR_NCRYPT_KEY_HANDLE</a> variable that receives the handle of either the CryptoAPI provider or the CNG key. If the <i>pdwKeySpec</i> variable receives the <b>CERT_NCRYPT_KEY_SPEC</b> flag, this is a CNG key handle of type <b>NCRYPT_KEY_HANDLE</b>; otherwise, this is a CryptoAPI provider handle of type <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a>.
     * 
     * For more information about when and how to release this handle, see the description of the <i>pfCallerFreeProvOrNCryptKey</i> parameter.
     * @param {Pointer<Integer>} pdwKeySpec 
     * @param {Pointer<BOOL>} pfCallerFreeProvOrNCryptKey The address of a <b>BOOL</b> variable that receives a value that indicates whether the caller must free the handle returned in the <i>phCryptProvOrNCryptKey</i> variable. This receives <b>FALSE</b> if any of the following is true:
     * 
     * <ul>
     * <li>Public key acquisition or comparison fails.</li>
     * <li>The <i>dwFlags</i> parameter contains the <b>CRYPT_ACQUIRE_CACHE_FLAG</b> flag.</li>
     * <li>The <i>dwFlags</i> parameter contains the <b>CRYPT_ACQUIRE_USE_PROV_INFO_FLAG</b> flag, the certificate context property is set to <b>CERT_KEY_PROV_INFO_PROP_ID</b> with the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a> structure, and the <i>dwFlags</i> member of the <b>CRYPT_KEY_PROV_INFO</b> structure is set to <b>CERT_SET_KEY_CONTEXT_PROP_ID</b>.</li>
     * </ul>
     * If this variable receives <b>FALSE</b>, the calling application must not release the handle returned in the <i>phCryptProvOrNCryptKey</i> variable. The handle will be released on the last free action of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a>.
     * 
     * If this variable receives <b>TRUE</b>, the caller is responsible for releasing the handle returned in the <i>phCryptProvOrNCryptKey</i> variable. If the <i>pdwKeySpec</i> variable receives the <b>CERT_NCRYPT_KEY_SPEC</b> value, the handle must be released by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreeobject">NCryptFreeObject</a> function; otherwise, the handle is released by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptreleasecontext">CryptReleaseContext</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_PUBLIC_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="/windows/desktop/SecGloss/p-gly">public key</a> in the <a href="/windows/desktop/SecGloss/c-gly">certificate</a> does not match the public key returned by the CSP. This error code is returned if the CRYPT_ACQUIRE_COMPARE_KEY_FLAG is set and the public key in the certificate does not match the public key returned by the cryptographic provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_SILENT_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contained the <b>CRYPT_ACQUIRE_SILENT_FLAG</b> flag and the CSP could not continue an operation without displaying a user interface.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptacquirecertificateprivatekey
     * @since windows5.1.2600
     */
    static CryptAcquireCertificatePrivateKey(pCert, dwFlags, pvParameters, phCryptProvOrNCryptKey, pdwKeySpec, pfCallerFreeProvOrNCryptKey) {
        pvParametersMarshal := pvParameters is VarRef ? "ptr" : "ptr"
        pdwKeySpecMarshal := pdwKeySpec is VarRef ? "uint*" : "ptr"
        pfCallerFreeProvOrNCryptKeyMarshal := pfCallerFreeProvOrNCryptKey is VarRef ? "int*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptAcquireCertificatePrivateKey", "ptr", pCert, "uint", dwFlags, pvParametersMarshal, pvParameters, "ptr", phCryptProvOrNCryptKey, pdwKeySpecMarshal, pdwKeySpec, pfCallerFreeProvOrNCryptKeyMarshal, pfCallerFreeProvOrNCryptKey, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Enumerates the cryptographic providers and their containers to find the private key that corresponds to the certificate's public key.
     * @param {Pointer<CERT_CONTEXT>} pCert A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure of the certificate to use when exporting public key information.
     * @param {Integer} dwFlags 
     * @returns {BOOL} <b>TRUE</b> if the function finds a private key that corresponds to the certificate's public key within a searched <a href="/windows/desktop/SecGloss/k-gly">container</a>; <b>FALSE</b> if the function fails to find a container or a private key within a container.
     * 
     * 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the following error:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No container found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptfindcertificatekeyprovinfo
     * @since windows5.1.2600
     */
    static CryptFindCertificateKeyProvInfo(pCert, dwFlags) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptFindCertificateKeyProvInfo", "ptr", pCert, "uint", dwFlags, "ptr", pvReserved, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Imports the private key in PKCS
     * @param {CRYPT_PKCS8_IMPORT_PARAMS} sPrivateKeyAndParams A <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_pkcs8_import_params">CRYPT_PKCS8_IMPORT_PARAMS</a> structure that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key BLOB</a> and corresponding parameters.
     * @param {Integer} dwFlags 
     * @param {Pointer<Pointer>} phCryptProv A pointer to the <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a>  to receive the handle of the provider into which the key is
     * imported by calling the <b>CryptImportPKCS8</b> function.  
     * 
     * When you have finished using the handle, free the handle by calling <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptreleasecontext">CryptReleaseContext</a>. 
     * 
     * This parameter can be <b>NULL</b>, in which case the handle of the provider is not returned.
     * @param {Pointer<Void>} pvAuxInfo This parameter must be <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following error code is specific to this function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNSUPPORTED_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm <a href="/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) of the private
     *       key is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>  may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptimportpkcs8
     * @since windows5.1.2600
     */
    static CryptImportPKCS8(sPrivateKeyAndParams, dwFlags, phCryptProv, pvAuxInfo) {
        phCryptProvMarshal := phCryptProv is VarRef ? "ptr*" : "ptr"
        pvAuxInfoMarshal := pvAuxInfo is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptImportPKCS8", "ptr", sPrivateKeyAndParams, "uint", dwFlags, phCryptProvMarshal, phCryptProv, pvAuxInfoMarshal, pvAuxInfo, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Exports the private key in PKCS
     * @param {Pointer} hCryptProv An <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a>  variable that contains  the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP). This is a handle to the CSP obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} dwKeySpec A <b>DWORD</b>  variable that contains  the key specification. The following <i>dwKeySpec</i> values are defined for the default provider.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AT_KEYEXCHANGE"></a><a id="at_keyexchange"></a><dl>
     * <dt><b>AT_KEYEXCHANGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Keys used to encrypt/decrypt session keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AT_SIGNATURE"></a><a id="at_signature"></a><dl>
     * <dt><b>AT_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Keys used to create and verify digital signatures.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PSTR} pszPrivateKeyObjId An  <b>LPSTR</b>  variable that contains  the private key <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly"> object identifier</a> (OID).
     * @param {Integer} dwFlags This parameter should be zero if <i>pbPrivateKeyBlob</i> is <b>NULL</b> and 0x8000 otherwise.
     * @param {Pointer<Void>} pvAuxInfo This parameter must be set to <b>NULL</b>.
     * @param {Pointer} pbPrivateKeyBlob A pointer to an 
     * array of <b>BYTE</b> structures to receive the private key  to be exported. 
     * 
     * 
     * The private key will contain the information in a PKCS #8 PrivateKeyInfo <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) type found in the PKCS #8 standard.
     * 
     * For memory allocation purposes, you can get the size of the private key  to be exported by setting this parameter to <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbPrivateKeyBlob A pointer to a <b>DWORD</b> that may contain, on input, the size, in  bytes,  of the memory allocation needed to contain the <i>pbPrivateKeyBlob</i>. If <i>pbPrivateKeyBlob</i> is <b>NULL</b>, this parameter will return the size of the memory allocation needed for a second call to the function. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @returns {BOOL} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following error codes are specific to this function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNSUPPORTED_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An export function that can be installed or registered could not be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbPrivateKeyBlob</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by the <i>pcbPrivateKeyBlob</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>  may return an ASN.1 encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptexportpkcs8
     * @since windows5.1.2600
     */
    static CryptExportPKCS8(hCryptProv, dwKeySpec, pszPrivateKeyObjId, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob) {
        pszPrivateKeyObjId := pszPrivateKeyObjId is String ? StrPtr(pszPrivateKeyObjId) : pszPrivateKeyObjId

        pvAuxInfoMarshal := pvAuxInfo is VarRef ? "ptr" : "ptr"
        pcbPrivateKeyBlobMarshal := pcbPrivateKeyBlob is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptExportPKCS8", "ptr", hCryptProv, "uint", dwKeySpec, "ptr", pszPrivateKeyObjId, "uint", dwFlags, pvAuxInfoMarshal, pvAuxInfo, "ptr", pbPrivateKeyBlob, pcbPrivateKeyBlobMarshal, pcbPrivateKeyBlob, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Encodes the public key information in a CERT_PUBLIC_KEY_INFO structure and computes the hash of the encoded bytes.
     * @param {HCRYPTPROV_LEGACY} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>A handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) to use to compute the hash.This parameter's data type is <b>HCRYPTPROV</b>.
     * 
     * Unless there is a strong reason for passing in a specific cryptographic provider in <i>hCryptProv</i>, zero is passed in. Passing in zero causes the default <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">RSA</a> or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">Digital Signature Standard</a> (DSS) provider to be acquired before doing hash, <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">signature verification</a>, or recipient <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">encryption</a> operations.
     * @param {Integer} Algid An <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> structure that specifies the CryptoAPI hash algorithm to use. If <i>Algid</i> is zero, the default hash algorithm, MD5, is used.
     * @param {Integer} dwFlags Values to be passed on to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a> and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key</a> information to be encoded and hashed.
     * @param {Pointer} pbComputedHash A pointer to a buffer to receive the computed hash.
     * 
     * To set the size of this information for memory allocation purposes, this parameter can be <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbComputedHash A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pbComputedHash</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a>, and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> can be propagated to this function. This function has the following error codes.</div>
     * <div></div>
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbComputedHash</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbComputedHash</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Currently only X509_ASN_ENCODING is supported.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-crypthashpublickeyinfo
     * @since windows5.1.2600
     */
    static CryptHashPublicKeyInfo(hCryptProv, Algid, dwFlags, dwCertEncodingType, pInfo, pbComputedHash, pcbComputedHash) {
        hCryptProv := hCryptProv is Win32Handle ? NumGet(hCryptProv, "ptr") : hCryptProv

        pcbComputedHashMarshal := pcbComputedHash is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptHashPublicKeyInfo", "ptr", hCryptProv, "uint", Algid, "uint", dwFlags, "uint", dwCertEncodingType, "ptr", pInfo, "ptr", pbComputedHash, pcbComputedHashMarshal, pcbComputedHash, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertRDNValueToStr function converts a name in a CERT_RDN_VALUE_BLOB to a null-terminated character string.
     * @param {Integer} dwValueType Indicates the kind of RDN value to be converted.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pValue A pointer to an 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CERT_RDN_VALUE_BLOB</a> of a type appropriate for the <i>dwValueType</i>.
     * @param {PSTR} psz A pointer to a buffer to receive the returned string.
     * @param {Integer} csz Size, in characters, allocated for the returned string. The size must include the terminating <b>NULL</b> character.
     * @returns {Integer} Returns the number of characters converted, including the terminating <b>NULL</b> character. If <i>psz</i> is <b>NULL</b> or <i>csz</i> is zero, returns the required size of the destination string.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certrdnvaluetostra
     * @since windows5.1.2600
     */
    static CertRDNValueToStrA(dwValueType, pValue, psz, csz) {
        psz := psz is String ? StrPtr(psz) : psz

        result := DllCall("CRYPT32.dll\CertRDNValueToStrA", "uint", dwValueType, "ptr", pValue, "ptr", psz, "uint", csz, "uint")
        return result
    }

    /**
     * The CertRDNValueToStr function converts a name in a CERT_RDN_VALUE_BLOB to a null-terminated character string.
     * @param {Integer} dwValueType Indicates the kind of RDN value to be converted.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pValue A pointer to an 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CERT_RDN_VALUE_BLOB</a> of a type appropriate for the <i>dwValueType</i>.
     * @param {PWSTR} psz A pointer to a buffer to receive the returned string.
     * @param {Integer} csz Size, in characters, allocated for the returned string. The size must include the terminating <b>NULL</b> character.
     * @returns {Integer} Returns the number of characters converted, including the terminating <b>NULL</b> character. If <i>psz</i> is <b>NULL</b> or <i>csz</i> is zero, returns the required size of the destination string.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certrdnvaluetostrw
     * @since windows5.1.2600
     */
    static CertRDNValueToStrW(dwValueType, pValue, psz, csz) {
        psz := psz is String ? StrPtr(psz) : psz

        result := DllCall("CRYPT32.dll\CertRDNValueToStrW", "uint", dwValueType, "ptr", pValue, "ptr", psz, "uint", csz, "uint")
        return result
    }

    /**
     * Converts an encoded name in a CERT_NAME_BLOB structure to a null-terminated character string.
     * @param {Integer} dwCertEncodingType The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a>   that was used to encode the name. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> identifier, contained in the high <b>WORD</b> of this value, is ignored by this function.
     * 
     * 
     * This parameter can be the following currently defined certificate encoding type.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies X.509 certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pName A pointer to the 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CERT_NAME_BLOB</a> structure to be converted.
     * @param {Integer} dwStrType This parameter specifies the format of the output string. This parameter also specifies other options for the contents of the string.
     * @param {PSTR} psz A pointer to a character buffer that receives the returned string. The size of this buffer is specified in the <i>csz</i> parameter.
     * @param {Integer} csz The size, in characters, of the <i>psz</i> buffer. The size must include the terminating null character.
     * @returns {Integer} Returns the number of characters converted, including the terminating null character. 
     * 
     * If <i>psz</i> is <b>NULL</b> or <i>csz</i> is zero, returns the required size of the destination string.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certnametostra
     * @since windows5.1.2600
     */
    static CertNameToStrA(dwCertEncodingType, pName, dwStrType, psz, csz) {
        psz := psz is String ? StrPtr(psz) : psz

        result := DllCall("CRYPT32.dll\CertNameToStrA", "uint", dwCertEncodingType, "ptr", pName, "uint", dwStrType, "ptr", psz, "uint", csz, "uint")
        return result
    }

    /**
     * Converts an encoded name in a CERT_NAME_BLOB structure to a null-terminated character string.
     * @param {Integer} dwCertEncodingType The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a>   that was used to encode the name. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> identifier, contained in the high <b>WORD</b> of this value, is ignored by this function.
     * 
     * 
     * This parameter can be the following currently defined certificate encoding type.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies X.509 certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pName A pointer to the 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CERT_NAME_BLOB</a> structure to be converted.
     * @param {Integer} dwStrType This parameter specifies the format of the output string. This parameter also specifies other options for the contents of the string.
     * @param {PWSTR} psz A pointer to a character buffer that receives the returned string. The size of this buffer is specified in the <i>csz</i> parameter.
     * @param {Integer} csz The size, in characters, of the <i>psz</i> buffer. The size must include the terminating null character.
     * @returns {Integer} Returns the number of characters converted, including the terminating null character. 
     * 
     * If <i>psz</i> is <b>NULL</b> or <i>csz</i> is zero, returns the required size of the destination string.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certnametostrw
     * @since windows5.1.2600
     */
    static CertNameToStrW(dwCertEncodingType, pName, dwStrType, psz, csz) {
        psz := psz is String ? StrPtr(psz) : psz

        result := DllCall("CRYPT32.dll\CertNameToStrW", "uint", dwCertEncodingType, "ptr", pName, "uint", dwStrType, "ptr", psz, "uint", csz, "uint")
        return result
    }

    /**
     * Converts a null-terminated X.500 string to an encoded certificate name.
     * @param {Integer} dwCertEncodingType The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a>   that was used to encode the string. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> identifier, contained in the high <b>WORD</b> of this value, is ignored by this function.
     * 
     * 
     * This parameter can be the following currently defined certificate encoding type.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies <a href="https://docs.microsoft.com/windows/desktop/SecGloss/x-gly">X.509</a> certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PSTR} pszX500 A pointer to the null-terminated X.500 string to be converted. The format of this string is specified by the <i>dwStrType</i> parameter.
     * 
     * This string is expected to be formatted the same as the output from 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certnametostra">CertNameToStr</a> function.
     * @param {Integer} dwStrType This parameter specifies the type of the string. This parameter also specifies other options for the contents of the string. 
     * 
     * If no flags are combined with the string type specifier, the string can contain a comma (,) or a semicolon (;) as separators in the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">relative distinguished name</a> (RDN) and a plus sign (+) as the separator in multiple RDN values.
     * 
     * Quotation marks ("") are supported. A quotation can be included in a quoted value by using two sets of quotation marks, for example, CN="User ""one""". 
     * 
     * A value that starts with a number sign (#) is treated as <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">ASCII</a> hexadecimal and converted to a <b>CERT_RDN_OCTET_STRING</b>. Embedded white space is ignored. For example, 1.2.3 = # AB CD 01 is the same as 1.2.3=#ABCD01.
     * 
     * White space that surrounds the keys, object identifiers, and values is ignored.
     * @param {Pointer} pbEncoded A pointer to a buffer that receives the encoded structure. 
     * 
     * 
     * The size of this buffer is specified in the <i>pcbEncoded</i> parameter.
     * 
     * This parameter can be <b>NULL</b> to obtain the required size of the buffer for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbEncoded A pointer to a <b>DWORD</b> that, before calling the function, contains the size, in bytes, of the buffer pointed to by the <i>pbEncoded</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer.
     * 
     * If <i>pbEncoded</i> is <b>NULL</b>, the <b>DWORD</b> receives the size, in bytes, required for the buffer.
     * @param {Pointer<PSTR>} ppszError A pointer to a string pointer that receives additional error information about an input string that is not valid. 
     * 
     * 
     * If the <i>pszX500</i> string is not valid, <i>ppszError</i> is updated by this function to point to the beginning of the character sequence that is not valid. If no errors are detected in the input string, <i>ppszError</i> is set to <b>NULL</b>.
     * 						
     * 
     * If this information is not required, pass <b>NULL</b> for this parameter.
     * 
     * 
     * This parameter is updated for the following error codes returned from <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * <a id="CRYPT_E_INVALID_X500_STRING"></a>
     * <a id="crypt_e_invalid_x500_string"></a>
     * @returns {BOOL} Returns nonzero if successful or zero otherwise.
     * 						
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certstrtonamea
     * @since windows5.1.2600
     */
    static CertStrToNameA(dwCertEncodingType, pszX500, dwStrType, pbEncoded, pcbEncoded, ppszError) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        pszX500 := pszX500 is String ? StrPtr(pszX500) : pszX500

        pcbEncodedMarshal := pcbEncoded is VarRef ? "uint*" : "ptr"
        ppszErrorMarshal := ppszError is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertStrToNameA", "uint", dwCertEncodingType, "ptr", pszX500, "uint", dwStrType, "ptr", pvReserved, "ptr", pbEncoded, pcbEncodedMarshal, pcbEncoded, ppszErrorMarshal, ppszError, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts a null-terminated X.500 string to an encoded certificate name.
     * @param {Integer} dwCertEncodingType The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a>   that was used to encode the string. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> identifier, contained in the high <b>WORD</b> of this value, is ignored by this function.
     * 
     * 
     * This parameter can be the following currently defined certificate encoding type.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies <a href="https://docs.microsoft.com/windows/desktop/SecGloss/x-gly">X.509</a> certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} pszX500 A pointer to the null-terminated X.500 string to be converted. The format of this string is specified by the <i>dwStrType</i> parameter.
     * 
     * This string is expected to be formatted the same as the output from 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certnametostra">CertNameToStr</a> function.
     * @param {Integer} dwStrType This parameter specifies the type of the string. This parameter also specifies other options for the contents of the string. 
     * 
     * If no flags are combined with the string type specifier, the string can contain a comma (,) or a semicolon (;) as separators in the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">relative distinguished name</a> (RDN) and a plus sign (+) as the separator in multiple RDN values.
     * 
     * Quotation marks ("") are supported. A quotation can be included in a quoted value by using two sets of quotation marks, for example, CN="User ""one""". 
     * 
     * A value that starts with a number sign (#) is treated as <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">ASCII</a> hexadecimal and converted to a <b>CERT_RDN_OCTET_STRING</b>. Embedded white space is ignored. For example, 1.2.3 = # AB CD 01 is the same as 1.2.3=#ABCD01.
     * 
     * White space that surrounds the keys, object identifiers, and values is ignored.
     * @param {Pointer} pbEncoded A pointer to a buffer that receives the encoded structure. 
     * 
     * 
     * The size of this buffer is specified in the <i>pcbEncoded</i> parameter.
     * 
     * This parameter can be <b>NULL</b> to obtain the required size of the buffer for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbEncoded A pointer to a <b>DWORD</b> that, before calling the function, contains the size, in bytes, of the buffer pointed to by the <i>pbEncoded</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer.
     * 
     * If <i>pbEncoded</i> is <b>NULL</b>, the <b>DWORD</b> receives the size, in bytes, required for the buffer.
     * @param {Pointer<PWSTR>} ppszError A pointer to a string pointer that receives additional error information about an input string that is not valid. 
     * 
     * 
     * If the <i>pszX500</i> string is not valid, <i>ppszError</i> is updated by this function to point to the beginning of the character sequence that is not valid. If no errors are detected in the input string, <i>ppszError</i> is set to <b>NULL</b>.
     * 						
     * 
     * If this information is not required, pass <b>NULL</b> for this parameter.
     * 
     * 
     * This parameter is updated for the following error codes returned from <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * <a id="CRYPT_E_INVALID_X500_STRING"></a>
     * <a id="crypt_e_invalid_x500_string"></a>
     * @returns {BOOL} Returns nonzero if successful or zero otherwise.
     * 						
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certstrtonamew
     * @since windows5.1.2600
     */
    static CertStrToNameW(dwCertEncodingType, pszX500, dwStrType, pbEncoded, pcbEncoded, ppszError) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        pszX500 := pszX500 is String ? StrPtr(pszX500) : pszX500

        pcbEncodedMarshal := pcbEncoded is VarRef ? "uint*" : "ptr"
        ppszErrorMarshal := ppszError is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertStrToNameW", "uint", dwCertEncodingType, "ptr", pszX500, "uint", dwStrType, "ptr", pvReserved, "ptr", pbEncoded, pcbEncodedMarshal, pcbEncoded, ppszErrorMarshal, ppszError, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Obtains the subject or issuer name from a certificate CERT_CONTEXT structure and converts it to a null-terminated character string.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> certificate context that includes a subject and issuer name to be converted.
     * @param {Integer} dwType <b>DWORD</b> indicating how the name is to be found and how the output is to be formatted.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_EMAIL_TYPE"></a><a id="cert_name_email_type"></a><dl>
     * <dt><b>CERT_NAME_EMAIL_TYPE</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate has a Subject Alternative Name extension or Issuer Alternative Name, uses the first rfc822Name choice. If no rfc822Name choice is found in the extension, uses the Subject Name field for the Email OID. If either rfc822Name or the Email OID is found, uses the string. Otherwise, returns an empty string (returned character count is 1). <i>pvTypePara</i> is not used and is set to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_RDN_TYPE"></a><a id="cert_name_rdn_type"></a><dl>
     * <dt><b>CERT_NAME_RDN_TYPE</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Converts the Subject Name BLOB by calling <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certnametostra">CertNameToStr</a>. <i>pvTypePara</i> points to a <b>DWORD</b> containing the <i>dwStrType</i> passed to <b>CertNameToStr</b>. If the Subject Name field is empty and the certificate has a Subject Alternative Name extension, uses the first directory Name choice from <b>CertNameToStr</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_ATTR_TYPE"></a><a id="cert_name_attr_type"></a><dl>
     * <dt><b>CERT_NAME_ATTR_TYPE</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvTypePara</i> points to an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) specifying the name attribute to be returned. For example, if <i>pvTypePara</i> is szOID_COMMON_NAME, uses the Subject Name member. If the Subject Name member is empty and the certificate has a Subject Alternative Name extension, uses the first directoryName choice.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_SIMPLE_DISPLAY_TYPE"></a><a id="cert_name_simple_display_type"></a><dl>
     * <dt><b>CERT_NAME_SIMPLE_DISPLAY_TYPE</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Iterates through the following list of name attributes and uses the Subject Name or the Subject Alternative Name extension for the first occurrence of: szOID_COMMON_NAME, szOID_ORGANIZATIONAL_UNIT_NAME, szOID_ORGANIZATION_NAME, or szOID_RSA_emailAddr. 
     * 
     * 
     * 
     * 
     * If one of these attributes is not found, uses the Subject Alternative Name extension for a rfc822Name choice. If there is still no match, uses the first attribute.
     * 
     * <i>pvTypePara</i> is not used and is set to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_FRIENDLY_DISPLAY_TYPE"></a><a id="cert_name_friendly_display_type"></a><dl>
     * <dt><b>CERT_NAME_FRIENDLY_DISPLAY_TYPE</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Checks the certificate for a CERT_FRIENDLY_NAME_PROP_ID property. If the certificate has this property, it is returned. If the certificate does not have the property, the CERT_NAME_SIMPLE_DISPLAY_TYPE is returned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_DNS_TYPE"></a><a id="cert_name_dns_type"></a><dl>
     * <dt><b>CERT_NAME_DNS_TYPE</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate has a Subject Alternative Name extension for issuer, Issuer Alternative Name, search for first DNSName choice. 
     * 
     * 
     * 
     * 
     * If the DNSName choice is not found in the extension, search the Subject Name field for the CN OID, "2.5.4.3".
     * 
     * If the DNSName or CN OID is found, return the string. Otherwise, return an empty string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_URL_TYPE"></a><a id="cert_name_url_type"></a><dl>
     * <dt><b>CERT_NAME_URL_TYPE</b></dt>
     * <dt>7</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate has a Subject Alternative Name extension for issuer, Issuer Alternative Name, search for first URL choice. If the URL choice is found, return the string. Otherwise, return an empty string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_UPN_TYPE"></a><a id="cert_name_upn_type"></a><dl>
     * <dt><b>CERT_NAME_UPN_TYPE</b></dt>
     * <dt>8</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate has a Subject Alternative Name extension, search the OtherName choices looking for a pszObjId == szOID_NT_PRINCIPAL_NAME, ("1.3.6.1.4.1.311.20.2.3"). 
     * 
     * 
     * 
     * 
     * If the UPN OID is found, decode the BLOB as a X509_UNICODE_ANY_STRING and return the decoded string. Otherwise, return an empty string.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags Indicates the type of processing needed. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_ISSUER_FLAG"></a><a id="cert_name_issuer_flag"></a><dl>
     * <dt><b>CERT_NAME_ISSUER_FLAG</b></dt>
     * <dt>0x1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Acquires the issuer's name. If not set, acquires the subject's name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_DISABLE_IE4_UTF8_FLAG"></a><a id="cert_name_disable_ie4_utf8_flag"></a><dl>
     * <dt><b>CERT_NAME_DISABLE_IE4_UTF8_FLAG</b></dt>
     * <dt>0x00010000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Skips the default initial attempt to decode the value as UTF8 and decodes as 8-bit characters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_SEARCH_ALL_NAMES_FLAG"></a><a id="cert_name_search_all_names_flag"></a><dl>
     * <dt><b>CERT_NAME_SEARCH_ALL_NAMES_FLAG</b></dt>
     * <dt>0x2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the <i>dwType</i> parameter is set to <b>CERT_NAME_DNS_TYPE</b>, all applicable names are returned for the specified DNS value. If there is no DNS name but there is a CN component in the subject, the CN is returned instead. If there is a CN and a DNS name, only the DNS names are returned. This mimics the SSL chain building policy. If you set this flag for a name type other than <b>CERT_NAME_DNS_TYPE</b>, this function returns a null-terminated empty string.
     * 
     * <b>Windows8 and Windows Server2012:</b>Support for this flag begins.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_STR_ENABLE_PUNYCODE_FLAG"></a><a id="cert_name_str_enable_punycode_flag"></a><dl>
     * <dt><b>CERT_NAME_STR_ENABLE_PUNYCODE_FLAG</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag enables decoding of  <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> strings to Unicode string values based on the <i>dwType</i> parameter value as defined below:
     * 
     * <ul>
     * <li>CERT_NAME_EMAIL_TYPE: If the host name portion of the email address contains a Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> component, it is converted to the Unicode equivalent.</li>
     * <li>CERT_NAME_SIMPLE_DISPLAY_TYPE: If a Subject Name of szOID_RSA_emailAddr or the rfc822Name from the Subject Alternative Name is returned from the certificate, and the host name portion of the email address a contains Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> component, it is converted to the Unicode equivalent.</li>
     * <li>CERT_NAME_DNS_TYPE: If the certificate has an Issuer Alternative Name, with a DNSName choice, and the host name portion of the email address a contains Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> component, it is converted to the Unicode equivalent.</li>
     * <li>CERT_NAME_URL_TYPE: The URI is decoded and unescaped. If the server host name of the URI contains a Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> component, the host name string is converted to the Unicode equivalent.</li>
     * </ul>
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP:</b>This value is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvTypePara A pointer to either a <b>DWORD</b> containing the <i>dwStrType</i> or an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) specifying the name attribute. The type pointed to is determined by the value of <i>dwType</i>.
     * @param {PSTR} pszNameString A pointer to an allocated buffer to receive the returned string. If <i>pszNameString</i> is not <b>NULL</b> and <i>cchNameString</i> is not zero, <i>pszNameString</i> is a <b>null</b>-terminated string.
     * 
     * If <b>CERT_NAME_SEARCH_ALL_NAMES_FLAG</b> is specified in the <i>dwFlags</i> parameter and <b>CERT_NAME_DNS_TYPE</b> is set in the <i>dwType</i> parameter, the returned string will contain all of the DNS names that apply. Each string in the output string is null-terminated and the last string will be double null-terminated. If no DNS names are found, a single null-terminated empty string is returned.
     * @param {Integer} cchNameString Size, in characters, allocated for the returned string. The size must include the terminating <b>NULL</b> character.
     * @returns {Integer} Returns the number of characters converted, including the terminating zero character. If <i>pszNameString</i> is <b>NULL</b> or <i>cchNameString</i> is zero, returns the required size of the destination string (including the terminating <b>NULL</b> character). If the specified name type is not found, returns a <b>null</b>-terminated empty string with a returned character count of 1.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certgetnamestringa
     * @since windows5.1.2600
     */
    static CertGetNameStringA(pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString) {
        pszNameString := pszNameString is String ? StrPtr(pszNameString) : pszNameString

        pvTypeParaMarshal := pvTypePara is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPT32.dll\CertGetNameStringA", "ptr", pCertContext, "uint", dwType, "uint", dwFlags, pvTypeParaMarshal, pvTypePara, "ptr", pszNameString, "uint", cchNameString, "uint")
        return result
    }

    /**
     * Obtains the subject or issuer name from a certificate CERT_CONTEXT structure and converts it to a null-terminated character string.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> certificate context that includes a subject and issuer name to be converted.
     * @param {Integer} dwType <b>DWORD</b> indicating how the name is to be found and how the output is to be formatted.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_EMAIL_TYPE"></a><a id="cert_name_email_type"></a><dl>
     * <dt><b>CERT_NAME_EMAIL_TYPE</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate has a Subject Alternative Name extension or Issuer Alternative Name, uses the first rfc822Name choice. If no rfc822Name choice is found in the extension, uses the Subject Name field for the Email OID. If either rfc822Name or the Email OID is found, uses the string. Otherwise, returns an empty string (returned character count is 1). <i>pvTypePara</i> is not used and is set to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_RDN_TYPE"></a><a id="cert_name_rdn_type"></a><dl>
     * <dt><b>CERT_NAME_RDN_TYPE</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Converts the Subject Name BLOB by calling <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certnametostra">CertNameToStr</a>. <i>pvTypePara</i> points to a <b>DWORD</b> containing the <i>dwStrType</i> passed to <b>CertNameToStr</b>. If the Subject Name field is empty and the certificate has a Subject Alternative Name extension, uses the first directory Name choice from <b>CertNameToStr</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_ATTR_TYPE"></a><a id="cert_name_attr_type"></a><dl>
     * <dt><b>CERT_NAME_ATTR_TYPE</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvTypePara</i> points to an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) specifying the name attribute to be returned. For example, if <i>pvTypePara</i> is szOID_COMMON_NAME, uses the Subject Name member. If the Subject Name member is empty and the certificate has a Subject Alternative Name extension, uses the first directoryName choice.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_SIMPLE_DISPLAY_TYPE"></a><a id="cert_name_simple_display_type"></a><dl>
     * <dt><b>CERT_NAME_SIMPLE_DISPLAY_TYPE</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Iterates through the following list of name attributes and uses the Subject Name or the Subject Alternative Name extension for the first occurrence of: szOID_COMMON_NAME, szOID_ORGANIZATIONAL_UNIT_NAME, szOID_ORGANIZATION_NAME, or szOID_RSA_emailAddr. 
     * 
     * 
     * 
     * 
     * If one of these attributes is not found, uses the Subject Alternative Name extension for a rfc822Name choice. If there is still no match, uses the first attribute.
     * 
     * <i>pvTypePara</i> is not used and is set to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_FRIENDLY_DISPLAY_TYPE"></a><a id="cert_name_friendly_display_type"></a><dl>
     * <dt><b>CERT_NAME_FRIENDLY_DISPLAY_TYPE</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Checks the certificate for a CERT_FRIENDLY_NAME_PROP_ID property. If the certificate has this property, it is returned. If the certificate does not have the property, the CERT_NAME_SIMPLE_DISPLAY_TYPE is returned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_DNS_TYPE"></a><a id="cert_name_dns_type"></a><dl>
     * <dt><b>CERT_NAME_DNS_TYPE</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate has a Subject Alternative Name extension for issuer, Issuer Alternative Name, search for first DNSName choice. 
     * 
     * 
     * 
     * 
     * If the DNSName choice is not found in the extension, search the Subject Name field for the CN OID, "2.5.4.3".
     * 
     * If the DNSName or CN OID is found, return the string. Otherwise, return an empty string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_URL_TYPE"></a><a id="cert_name_url_type"></a><dl>
     * <dt><b>CERT_NAME_URL_TYPE</b></dt>
     * <dt>7</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate has a Subject Alternative Name extension for issuer, Issuer Alternative Name, search for first URL choice. If the URL choice is found, return the string. Otherwise, return an empty string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_UPN_TYPE"></a><a id="cert_name_upn_type"></a><dl>
     * <dt><b>CERT_NAME_UPN_TYPE</b></dt>
     * <dt>8</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate has a Subject Alternative Name extension, search the OtherName choices looking for a pszObjId == szOID_NT_PRINCIPAL_NAME, ("1.3.6.1.4.1.311.20.2.3"). 
     * 
     * 
     * 
     * 
     * If the UPN OID is found, decode the BLOB as a X509_UNICODE_ANY_STRING and return the decoded string. Otherwise, return an empty string.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags Indicates the type of processing needed. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_ISSUER_FLAG"></a><a id="cert_name_issuer_flag"></a><dl>
     * <dt><b>CERT_NAME_ISSUER_FLAG</b></dt>
     * <dt>0x1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Acquires the issuer's name. If not set, acquires the subject's name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_DISABLE_IE4_UTF8_FLAG"></a><a id="cert_name_disable_ie4_utf8_flag"></a><dl>
     * <dt><b>CERT_NAME_DISABLE_IE4_UTF8_FLAG</b></dt>
     * <dt>0x00010000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Skips the default initial attempt to decode the value as UTF8 and decodes as 8-bit characters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_SEARCH_ALL_NAMES_FLAG"></a><a id="cert_name_search_all_names_flag"></a><dl>
     * <dt><b>CERT_NAME_SEARCH_ALL_NAMES_FLAG</b></dt>
     * <dt>0x2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the <i>dwType</i> parameter is set to <b>CERT_NAME_DNS_TYPE</b>, all applicable names are returned for the specified DNS value. If there is no DNS name but there is a CN component in the subject, the CN is returned instead. If there is a CN and a DNS name, only the DNS names are returned. This mimics the SSL chain building policy. If you set this flag for a name type other than <b>CERT_NAME_DNS_TYPE</b>, this function returns a null-terminated empty string.
     * 
     * <b>Windows8 and Windows Server2012:</b>Support for this flag begins.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_STR_ENABLE_PUNYCODE_FLAG"></a><a id="cert_name_str_enable_punycode_flag"></a><dl>
     * <dt><b>CERT_NAME_STR_ENABLE_PUNYCODE_FLAG</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag enables decoding of  <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> strings to Unicode string values based on the <i>dwType</i> parameter value as defined below:
     * 
     * <ul>
     * <li>CERT_NAME_EMAIL_TYPE: If the host name portion of the email address contains a Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> component, it is converted to the Unicode equivalent.</li>
     * <li>CERT_NAME_SIMPLE_DISPLAY_TYPE: If a Subject Name of szOID_RSA_emailAddr or the rfc822Name from the Subject Alternative Name is returned from the certificate, and the host name portion of the email address a contains Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> component, it is converted to the Unicode equivalent.</li>
     * <li>CERT_NAME_DNS_TYPE: If the certificate has an Issuer Alternative Name, with a DNSName choice, and the host name portion of the email address a contains Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> component, it is converted to the Unicode equivalent.</li>
     * <li>CERT_NAME_URL_TYPE: The URI is decoded and unescaped. If the server host name of the URI contains a Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> component, the host name string is converted to the Unicode equivalent.</li>
     * </ul>
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP:</b>This value is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvTypePara A pointer to either a <b>DWORD</b> containing the <i>dwStrType</i> or an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) specifying the name attribute. The type pointed to is determined by the value of <i>dwType</i>.
     * @param {PWSTR} pszNameString A pointer to an allocated buffer to receive the returned string. If <i>pszNameString</i> is not <b>NULL</b> and <i>cchNameString</i> is not zero, <i>pszNameString</i> is a <b>null</b>-terminated string.
     * 
     * If <b>CERT_NAME_SEARCH_ALL_NAMES_FLAG</b> is specified in the <i>dwFlags</i> parameter and <b>CERT_NAME_DNS_TYPE</b> is set in the <i>dwType</i> parameter, the returned string will contain all of the DNS names that apply. Each string in the output string is null-terminated and the last string will be double null-terminated. If no DNS names are found, a single null-terminated empty string is returned.
     * @param {Integer} cchNameString Size, in characters, allocated for the returned string. The size must include the terminating <b>NULL</b> character.
     * @returns {Integer} Returns the number of characters converted, including the terminating zero character. If <i>pszNameString</i> is <b>NULL</b> or <i>cchNameString</i> is zero, returns the required size of the destination string (including the terminating <b>NULL</b> character). If the specified name type is not found, returns a <b>null</b>-terminated empty string with a returned character count of 1.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certgetnamestringw
     * @since windows5.1.2600
     */
    static CertGetNameStringW(pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString) {
        pszNameString := pszNameString is String ? StrPtr(pszNameString) : pszNameString

        pvTypeParaMarshal := pvTypePara is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPT32.dll\CertGetNameStringW", "ptr", pCertContext, "uint", dwType, "uint", dwFlags, pvTypeParaMarshal, pvTypePara, "ptr", pszNameString, "uint", cchNameString, "uint")
        return result
    }

    /**
     * The CryptSignMessage function creates a hash of the specified content, signs the hash, and then encodes both the original message content and the signed hash.
     * @param {Pointer<CRYPT_SIGN_MESSAGE_PARA>} pSignPara A pointer to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_sign_message_para">CRYPT_SIGN_MESSAGE_PARA</a> structure containing the signature parameters.
     * @param {BOOL} fDetachedSignature <b>TRUE</b> if this is to be a detached signature. Otherwise, <b>FALSE</b>. If this parameter is set to <b>TRUE</b>, only the signed hash is encoded in <i>pbSignedBlob</i>. Otherwise, both <i>rgpbToBeSigned</i> and the signed hash are encoded.
     * @param {Integer} cToBeSigned Count of the number of array elements in <i>rgpbToBeSigned</i> and <i>rgcbToBeSigned</i>. This parameter must be set to one unless <i>fDetachedSignature</i> is set to <b>TRUE</b>.
     * @param {Pointer<Pointer<Integer>>} rgpbToBeSigned Array of pointers to buffers that contain the contents to be signed.
     * @param {Pointer<Integer>} rgcbToBeSigned Array of sizes, in bytes, of the content buffers pointed to in <i>rgpbToBeSigned</i>.
     * @param {Pointer} pbSignedBlob A pointer to a buffer to receive the encoded signed hash, if <i>fDetachedSignature</i> is <b>TRUE</b>, or to both the encoded content and signed hash if <i>fDetachedSignature</i> is <b>FALSE</b>. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbSignedBlob A pointer to a <b>DWORD</b> specifying the size, in bytes, of the <i>pbSignedBlob</i> buffer. When the function returns, this variable contains the size, in bytes, of the signed and encoded message. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * The following lists the error codes most commonly returned by the 
     * 		       <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbSignedBlob</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbSignedBlob</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="/windows/desktop/SecGloss/m-gly">message encoding type</a> is not valid. Currently only PKCS_7_ASN_ENCODING is supported. The <b>cbSize</b> in *<i>pSignPara</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_KEY_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pSigningCert</i> in *<i>pSignPara</i> does not have a CERT_KEY_PROV_INFO_PROP_ID or CERT_KEY_CONTEXT_PROP_ID property.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>, and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a> might be propagated to this function.</div>
     * <div></div>
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptsignmessage
     * @since windows5.1.2600
     */
    static CryptSignMessage(pSignPara, fDetachedSignature, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, pbSignedBlob, pcbSignedBlob) {
        rgpbToBeSignedMarshal := rgpbToBeSigned is VarRef ? "ptr*" : "ptr"
        rgcbToBeSignedMarshal := rgcbToBeSigned is VarRef ? "uint*" : "ptr"
        pcbSignedBlobMarshal := pcbSignedBlob is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptSignMessage", "ptr", pSignPara, "int", fDetachedSignature, "uint", cToBeSigned, rgpbToBeSignedMarshal, rgpbToBeSigned, rgcbToBeSignedMarshal, rgcbToBeSigned, "ptr", pbSignedBlob, pcbSignedBlobMarshal, pcbSignedBlob, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Verifies a signed message's signature.
     * @param {Pointer<CRYPT_VERIFY_MESSAGE_PARA>} pVerifyPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_verify_message_para">CRYPT_VERIFY_MESSAGE_PARA</a> structure that contains verification parameters.
     * @param {Integer} dwSignerIndex The index of the desired signature. There can be more than one signature. <b>CryptVerifyMessageSignature</b> can be called repeatedly, incrementing <i>dwSignerIndex</i> each time. Set this parameter to zero for the first signer, or if there is only one signer. If the function returns <b>FALSE</b>, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns CRYPT_E_NO_SIGNER, the previous call processed the last signer of the message.
     * @param {Pointer} pbSignedBlob A pointer to a buffer that contains the signed message.
     * @param {Integer} cbSignedBlob The size, in bytes, of the signed message buffer.
     * @param {Pointer} pbDecoded A pointer to a buffer to receive the decoded message. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the decoded message is not needed for additional processing or to set the size of the message for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbDecoded A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the <i>pbDecoded</i> buffer. When the function returns, this <b>DWORD</b> contains the size, in bytes, of the decoded message. The decoded message will not be returned if this parameter is <b>NULL</b>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @param {Pointer<Pointer<CERT_CONTEXT>>} ppSignerCert The address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure pointer that receives the certificate of the signer. When you have finished using this structure, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function. This parameter can be <b>NULL</b> if the signer's certificate is not needed.
     * @returns {BOOL} If the function succeeds, the function returns nonzero. This does not necessarily mean that the signature was verified. In the case of a detached message, the variable pointed to by <i>pcbDecoded</i> will contain zero. In this case, this function will return nonzero, but the signature is not verified. To verify the signature of a detached message, use the <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifydetachedmessagesignature">CryptVerifyDetachedMessageSignature</a> function.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table shows the error codes most commonly returned by the 
     * 		       <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbDecoded</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbDecoded</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid message and certificate encoding types. Currently only PKCS_7_ASN_ENCODING and X509_ASN_ENCODING_TYPE are supported. Invalid <b>cbSize</b> in *<i>pVerifyPara</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not a signed cryptographic message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_SIGNER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message does not have any signers or a signer for the specified <i>dwSignerIndex</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message was hashed and signed by using an unknown or unsupported algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message's signature was not verified.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea">CryptVerifySignature</a>, and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a> can be propagated to this function. <p class="note">If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>. 
     * 
     * </div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptverifymessagesignature
     * @since windows5.1.2600
     */
    static CryptVerifyMessageSignature(pVerifyPara, dwSignerIndex, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded, ppSignerCert) {
        pcbDecodedMarshal := pcbDecoded is VarRef ? "uint*" : "ptr"
        ppSignerCertMarshal := ppSignerCert is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptVerifyMessageSignature", "ptr", pVerifyPara, "uint", dwSignerIndex, "ptr", pbSignedBlob, "uint", cbSignedBlob, "ptr", pbDecoded, pcbDecodedMarshal, pcbDecoded, ppSignerCertMarshal, ppSignerCert, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptGetMessageSignerCount function returns the number of signers of a signed message.
     * @param {Integer} dwMsgEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer} pbSignedBlob A pointer to a buffer containing the signed message.
     * @param {Integer} cbSignedBlob The size, in bytes, of the signed message.
     * @returns {Integer} Returns the number of signers of a signed message, zero when there are no signers, and minus one (1) for an error.
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following  error code is most commonly returned.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid <a href="/windows/desktop/SecGloss/m-gly">message encoding type</a>. Currently only PKCS_7_ASN_ENCODING is supported.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptgetmessagesignercount
     * @since windows5.1.2600
     */
    static CryptGetMessageSignerCount(dwMsgEncodingType, pbSignedBlob, cbSignedBlob) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptGetMessageSignerCount", "uint", dwMsgEncodingType, "ptr", pbSignedBlob, "uint", cbSignedBlob, "int")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptGetMessageCertificates function returns the handle of an open certificate store containing the message's certificates and CRLs. This function calls CertOpenStore using provider type CERT_STORE_PROV_PKCS7 as its lpszStoreProvider parameter.
     * @param {Integer} dwMsgAndCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {HCRYPTPROV_LEGACY} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>Handle of the CSP passed to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenstore">CertOpenStore</a>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenstore">CertOpenStore</a>.Unless there is a strong reason for passing a specific cryptographic provider in <i>hCryptProv</i>, pass zero to cause the default RSA or DSS provider to be acquired.
     * 
     * This parameter's data type is <b>HCRYPTPROV</b>.
     * @param {Integer} dwFlags Flags passed to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenstore">CertOpenStore</a>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenstore">CertOpenStore</a>.
     * @param {Pointer} pbSignedBlob A pointer to a buffered 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_INTEGER_BLOB</a> structure that contains the signed message.
     * @param {Integer} cbSignedBlob The size, in bytes, of the signed message.
     * @returns {HCERTSTORE} Returns the <a href="/windows/desktop/SecGloss/c-gly">certificate store</a> containing the message's certificates and CRLs. For an error, <b>NULL</b> is returned.
     * 
     * The following lists the error code most commonly returned by the 
     * 		       <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid message and certificate encoding types. Currently only PKCS_7_ASN_ENCODING and X509_ASN_ENCODING are supported.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptgetmessagecertificates
     * @since windows5.1.2600
     */
    static CryptGetMessageCertificates(dwMsgAndCertEncodingType, hCryptProv, dwFlags, pbSignedBlob, cbSignedBlob) {
        hCryptProv := hCryptProv is Win32Handle ? NumGet(hCryptProv, "ptr") : hCryptProv

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptGetMessageCertificates", "uint", dwMsgAndCertEncodingType, "ptr", hCryptProv, "uint", dwFlags, "ptr", pbSignedBlob, "uint", cbSignedBlob, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        resultHandle := HCERTSTORE({Value: result}, True)
        return resultHandle
    }

    /**
     * The CryptVerifyDetachedMessageSignature function verifies a signed message containing a detached signature or signatures.
     * @param {Pointer<CRYPT_VERIFY_MESSAGE_PARA>} pVerifyPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_verify_message_para">CRYPT_VERIFY_MESSAGE_PARA</a> structure containing the verification parameters.
     * @param {Integer} dwSignerIndex Index of the signature to be verified. A message might have several signers and this function can be called repeatedly, changing <i>dwSignerIndex</i> to verify other signatures. If the function returns FALSE, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns CRYPT_E_NO_SIGNER, the previous call received the last signer of the message.
     * @param {Pointer} pbDetachedSignBlob A pointer to a BLOB containing the encoded message signatures.
     * @param {Integer} cbDetachedSignBlob The size, in bytes, of the detached signature.
     * @param {Integer} cToBeSigned Number of array elements in <i>rgpbToBeSigned</i> and <i>rgcbToBeSigned</i>.
     * @param {Pointer<Pointer<Integer>>} rgpbToBeSigned Array of pointers to buffers containing the contents to be <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hashed</a>.
     * @param {Pointer<Integer>} rgcbToBeSigned Array of sizes, in bytes, for the content buffers pointed to in <i>rgpbToBeSigned</i>.
     * @param {Pointer<Pointer<CERT_CONTEXT>>} ppSignerCert A pointer to a 
     * pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure of a signer certificate. When you have finished using the certificate context, free it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function. A pointer to a <b>CERT_CONTEXT</b> structure will not be returned if this parameter is <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following lists the error codes most commonly returned by the 
     * 		       <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid message and certificate encoding types. Currently only PKCS_7_ASN_ENCODING and X509_ASN_ENCODING_TYPE are supported. Invalid <b>cbSize</b> in *<i>pVerifyPara</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not a signed cryptographic message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_SIGNER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message does not have any signers or a signer for the specified <i>dwSignerIndex</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message was hashed and signed by using an unknown or unsupported algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message's signature was not verified.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea">CryptVerifySignature</a>, and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a> might be propagated to this function.<p class="note">If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>. 
     * 
     * </div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptverifydetachedmessagesignature
     * @since windows5.1.2600
     */
    static CryptVerifyDetachedMessageSignature(pVerifyPara, dwSignerIndex, pbDetachedSignBlob, cbDetachedSignBlob, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, ppSignerCert) {
        rgpbToBeSignedMarshal := rgpbToBeSigned is VarRef ? "ptr*" : "ptr"
        rgcbToBeSignedMarshal := rgcbToBeSigned is VarRef ? "uint*" : "ptr"
        ppSignerCertMarshal := ppSignerCert is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptVerifyDetachedMessageSignature", "ptr", pVerifyPara, "uint", dwSignerIndex, "ptr", pbDetachedSignBlob, "uint", cbDetachedSignBlob, "uint", cToBeSigned, rgpbToBeSignedMarshal, rgpbToBeSigned, rgcbToBeSignedMarshal, rgcbToBeSigned, ppSignerCertMarshal, ppSignerCert, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptEncryptMessage function encrypts and encodes a message.
     * @param {Pointer<CRYPT_ENCRYPT_MESSAGE_PARA>} pEncryptPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_encrypt_message_para">CRYPT_ENCRYPT_MESSAGE_PARA</a> structure that contains the encryption parameters.
     * 
     * The <b>CryptEncryptMessage</b> function does not support the SHA2 OIDs, <b>szOID_DH_SINGLE_PASS_STDDH_SHA256_KDF</b> and  <b>szOID_DH_SINGLE_PASS_STDDH_SHA384_KDF</b>.
     * @param {Integer} cRecipientCert Number of elements in the <i>rgpRecipientCert</i> array.
     * @param {Pointer<Pointer<CERT_CONTEXT>>} rgpRecipientCert Array of pointers to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structures that contain the certificates of intended recipients of the message.
     * @param {Pointer} pbToBeEncrypted A pointer to a buffer that contains the message that is to be encrypted.
     * @param {Integer} cbToBeEncrypted The size, in bytes, of the message that is to be encrypted.
     * @param {Pointer} pbEncryptedBlob A pointer to <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a> that contains a buffer that receives the encrypted and encoded message. 
     * 
     * 
     * 
     * 
     * To set the size of this information for memory allocation purposes, this parameter can be <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbEncryptedBlob A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pbEncryptedBlob</i> parameter. When the function returns, this variable contains the size, in bytes, of the encrypted and encoded message copied to <i>pbEncryptedBlob</i>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer of the <i>pbEncryptedBlob</i>, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>Errors from calls to 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptencrypt">CryptEncrypt</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a>, and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a> can be propagated to this function.</div>
     * <div></div>
     * The <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the following error codes most often.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbEncryptedBlob</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbEncryptedBlob</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="/windows/desktop/SecGloss/m-gly">message encoding type</a> is not valid. Currently only PKCS_7_ASN_ENCODING is supported. The <b>cbSize</b> in *<i>pEncryptPara</i> is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptencryptmessage
     * @since windows5.1.2600
     */
    static CryptEncryptMessage(pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeEncrypted, cbToBeEncrypted, pbEncryptedBlob, pcbEncryptedBlob) {
        rgpRecipientCertMarshal := rgpRecipientCert is VarRef ? "ptr*" : "ptr"
        pcbEncryptedBlobMarshal := pcbEncryptedBlob is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptEncryptMessage", "ptr", pEncryptPara, "uint", cRecipientCert, rgpRecipientCertMarshal, rgpRecipientCert, "ptr", pbToBeEncrypted, "uint", cbToBeEncrypted, "ptr", pbEncryptedBlob, pcbEncryptedBlobMarshal, pcbEncryptedBlob, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptDecryptMessage function decodes and decrypts a message.
     * @param {Pointer<CRYPT_DECRYPT_MESSAGE_PARA>} pDecryptPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_decrypt_message_para">CRYPT_DECRYPT_MESSAGE_PARA</a> structure that contains decryption parameters.
     * @param {Pointer} pbEncryptedBlob A pointer to a buffer that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">encoded</a> and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">encrypted</a> message to be decrypted.
     * @param {Integer} cbEncryptedBlob The size, in bytes, of the encoded and encrypted message.
     * @param {Pointer} pbDecrypted A pointer to a buffer that receives the decrypted message. 
     * 
     * 
     * 
     * 
     * To set the size of this information for memory allocation purposes, this parameter can be <b>NULL</b>. A decrypted message will not be returned if this parameter is <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbDecrypted A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pbDecrypted</i> parameter. When the function returns, this variable contains the size, in bytes, of the decrypted message copied to <i>pbDecrypted</i>.
     * 						
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the <i>pbDecrypted</i> buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified in <i>pcbDecrypted</i> on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer. On output, the <b>DWORD</b> is updated to the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @param {Pointer<Pointer<CERT_CONTEXT>>} ppXchgCert A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a> that corresponds to the private <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">exchange key</a> needed to decrypt the message. To indicate that the function should not return the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a> used to decrypt, set this parameter to <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>Errors from calls to 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a> and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptdecrypt">CryptDecrypt</a> might be propagated to this function.</div>
     * <div></div>
     * The <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the following error codes most often.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbDecrypted</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbDecrypted</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid message and <a href="/windows/desktop/SecGloss/c-gly">certificate encoding types</a>. Currently only PKCS_7_ASN_ENCODING and X509_ASN_ENCODING_TYPE are supported. Invalid <b>cbSize</b> in *<i>pDecryptPara</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not an <a href="/windows/desktop/SecGloss/e-gly">enveloped</a> cryptographic message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message was encrypted by using an unknown or unsupported algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_DECRYPT_CERT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No certificate was found having a <a href="/windows/desktop/SecGloss/p-gly">private key</a> property to use for decrypting.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails,<a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptdecryptmessage
     * @since windows5.1.2600
     */
    static CryptDecryptMessage(pDecryptPara, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert) {
        pcbDecryptedMarshal := pcbDecrypted is VarRef ? "uint*" : "ptr"
        ppXchgCertMarshal := ppXchgCert is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptDecryptMessage", "ptr", pDecryptPara, "ptr", pbEncryptedBlob, "uint", cbEncryptedBlob, "ptr", pbDecrypted, pcbDecryptedMarshal, pcbDecrypted, ppXchgCertMarshal, ppXchgCert, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptSignAndEncryptMessage function creates a hash of the specified content, signs the hash, encrypts the content, hashes the encrypted contents and the signed hash, and then encodes both the encrypted content and the signed hash.
     * @param {Pointer<CRYPT_SIGN_MESSAGE_PARA>} pSignPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_sign_message_para">CRYPT_SIGN_MESSAGE_PARA</a> structure that contains the signature parameters.
     * @param {Pointer<CRYPT_ENCRYPT_MESSAGE_PARA>} pEncryptPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_encrypt_message_para">CRYPT_ENCRYPT_MESSAGE_PARA</a> structure containing encryption parameters.
     * @param {Integer} cRecipientCert Number of array elements in <i>rgpRecipientCert</i>.
     * @param {Pointer<Pointer<CERT_CONTEXT>>} rgpRecipientCert Array of pointers to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structures. Each structure is the certificate of an intended recipients of the message.
     * @param {Pointer} pbToBeSignedAndEncrypted A pointer to a buffer containing the content to be signed and encrypted.
     * @param {Integer} cbToBeSignedAndEncrypted The size, in bytes, of the <i>pbToBeSignedAndEncrypted</i> buffer.
     * @param {Pointer} pbSignedAndEncryptedBlob A pointer to a buffer to receive the encrypted and encoded message. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbSignedAndEncryptedBlob A pointer to <b>DWORD</b> specifying the size, in bytes, of the buffer pointed to by <i>pbSignedAndEncryptedBlob</i>. When the function returns, this variable contains the size, in bytes, of the signed and encrypted message copied to *<i>pbSignedAndEncryptedBlob</i>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE).
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * The following lists the error code most commonly returned by the 
     * 		       <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbSignedAndEncryptedBlob</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbSignedAndEncryptedBlob</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignmessage">CryptSignMessage</a> and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptencryptmessage">CryptEncryptMessage</a> might be propagated to this function.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptsignandencryptmessage
     * @since windows5.1.2600
     */
    static CryptSignAndEncryptMessage(pSignPara, pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeSignedAndEncrypted, cbToBeSignedAndEncrypted, pbSignedAndEncryptedBlob, pcbSignedAndEncryptedBlob) {
        rgpRecipientCertMarshal := rgpRecipientCert is VarRef ? "ptr*" : "ptr"
        pcbSignedAndEncryptedBlobMarshal := pcbSignedAndEncryptedBlob is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptSignAndEncryptMessage", "ptr", pSignPara, "ptr", pEncryptPara, "uint", cRecipientCert, rgpRecipientCertMarshal, rgpRecipientCert, "ptr", pbToBeSignedAndEncrypted, "uint", cbToBeSignedAndEncrypted, "ptr", pbSignedAndEncryptedBlob, pcbSignedAndEncryptedBlobMarshal, pcbSignedAndEncryptedBlob, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptDecryptAndVerifyMessageSignature function decrypts a message and verifies its signature.
     * @param {Pointer<CRYPT_DECRYPT_MESSAGE_PARA>} pDecryptPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_decrypt_message_para">CRYPT_DECRYPT_MESSAGE_PARA</a> structure that contains decryption parameters.
     * @param {Pointer<CRYPT_VERIFY_MESSAGE_PARA>} pVerifyPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_verify_message_para">CRYPT_VERIFY_MESSAGE_PARA</a> structure that contains  verification parameters.
     * @param {Integer} dwSignerIndex Identifies a particular signer of the message. A message can be signed by more than one signer and this function can be called multiple times changing this parameter to check for several signers. It is set to zero for the first signer. If the function returns <b>FALSE</b>, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns CRYPT_E_NO_SIGNER, the previous call received the last signer of the message.
     * @param {Pointer} pbEncryptedBlob A pointer to the signed, encoded, and encrypted message to be decrypted and verified.
     * @param {Integer} cbEncryptedBlob The size, in bytes, of the encrypted message.
     * @param {Pointer} pbDecrypted A pointer to a buffer to receive the decrypted message. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the decrypted message is not required or to set the size of the decrypted message for memory allocation purposes. A decrypted message will not be returned if this parameter is <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbDecrypted A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pbDecrypted</i> parameter. When the function returns, it contains the size of the decrypted message copied to <i>pbDecrypted</i>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the <i>pbDecrypted</i> buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified in <i>pcbDecrypted</i> on input. On output, the variable pointed to by this parameter is set to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @param {Pointer<Pointer<CERT_CONTEXT>>} ppXchgCert A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a> that corresponds to the private <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">exchange key</a> needed to decrypt the message.
     * @param {Pointer<Pointer<CERT_CONTEXT>>} ppSignerCert A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure of the certificate of the signer.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptdecryptmessage">CryptDecryptMessage</a> and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifymessagesignature">CryptVerifyMessageSignature</a> might be propagated to this function.</div>
     * <div></div>
     * The <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the following error code most often.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbDecrypted</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbDecrypted</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptdecryptandverifymessagesignature
     * @since windows5.1.2600
     */
    static CryptDecryptAndVerifyMessageSignature(pDecryptPara, pVerifyPara, dwSignerIndex, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert, ppSignerCert) {
        pcbDecryptedMarshal := pcbDecrypted is VarRef ? "uint*" : "ptr"
        ppXchgCertMarshal := ppXchgCert is VarRef ? "ptr*" : "ptr"
        ppSignerCertMarshal := ppSignerCert is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptDecryptAndVerifyMessageSignature", "ptr", pDecryptPara, "ptr", pVerifyPara, "uint", dwSignerIndex, "ptr", pbEncryptedBlob, "uint", cbEncryptedBlob, "ptr", pbDecrypted, pcbDecryptedMarshal, pcbDecrypted, ppXchgCertMarshal, ppXchgCert, ppSignerCertMarshal, ppSignerCert, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Decodes, decrypts, and verifies a cryptographic message.
     * @param {Integer} dwMsgTypeFlags Indicates the message type. Message types can be combined with the bitwise-<b>OR</b> operator. This parameter can be one of the following message types:
     * 
     * <ul>
     * <li>CMSG_DATA_FLAG</li>
     * <li>CMSG_SIGNED_FLAG</li>
     * <li>CMSG_ENVELOPED_FLAG</li>
     * <li>CMSG_SIGNED_AND_ENVELOPED_FLAG</li>
     * <li>CMSG_HASHED_FLAG</li>
     * </ul>
     * <div class="alert"><b>Note</b>After return, the <b>DWORD</b> pointed to by <i>pdwMsgType</i> is set with the type of the message.</div>
     * <div></div>
     * @param {Pointer<CRYPT_DECRYPT_MESSAGE_PARA>} pDecryptPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_decrypt_message_para">CRYPT_DECRYPT_MESSAGE_PARA</a> structure that contains  decryption parameters.
     * @param {Pointer<CRYPT_VERIFY_MESSAGE_PARA>} pVerifyPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_verify_message_para">CRYPT_VERIFY_MESSAGE_PARA</a> structure that contains   verification parameters.
     * @param {Integer} dwSignerIndex Indicates which signer, among the possible many signers of a message, is to be verified. This index can be changed in multiple calls to the function to verify additional signers. 
     * 
     * 
     * 
     * 
     * <i>dwSignerIndex</i> is set to zero for the first signer. If the function returns <b>FALSE</b>, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns CRYPT_E_NO_SIGNER, the previous call returned the last signer of the message. This parameter is used only with messages of types CMSG_SIGNED_AND_ENVELOPED or CMSG_SIGNED. For all other message types, it should be set to zero.
     * @param {Pointer} pbEncodedBlob A pointer to the encoded <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a> that is to be decoded.
     * @param {Integer} cbEncodedBlob The size, in bytes, of the encoded BLOB.
     * @param {Integer} dwPrevInnerContentType Only applicable when processing nested cryptographic messages. When processing an outer cryptographic message, it must be set to zero. When decoding a nested cryptographic message, it is set to the value returned at <i>pdwInnerContentType</i> by a previous calling of 
     * <b>CryptDecodeMessage</b> for the outer message. It can be any of the CMSG types listed in <i>pdwMsgType</i>. For backward compatibility, set <i>dwPrevInnerContentType</i> to zero.
     * @param {Pointer<Integer>} pdwMsgType A pointer to a <b>DWORD</b> that specifies the message type returned. This parameter can be one of the following message types:
     * 
     * <ul>
     * <li>CMSG_DATA</li>
     * <li>CMSG_SIGNED</li>
     * <li>CMSG_ENVELOPED</li>
     * <li>CMSG_SIGNED_AND_ENVELOPED</li>
     * <li>CMSG_HASHED</li>
     * </ul>
     * @param {Pointer<Integer>} pdwInnerContentType A pointer to a <b>DWORD</b> that specifies the type of an inner message. The message type codes used for <i>pdwMsgType</i> are used here, also. 
     * 
     * 
     * 
     * 
     * If there is no cryptographic nesting, CMSG_DATA is returned.
     * @param {Pointer} pbDecoded A pointer to a buffer to receive the decoded message. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the decoded message is not required or to set the size of the decoded message for memory allocation purposes. A decoded message will not be returned if this parameter is <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbDecoded A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pbDecoded</i> parameter. When the function returns, this variable contains the size of the decoded message. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @param {Pointer<Pointer<CERT_CONTEXT>>} ppXchgCert A pointer to a 
     * pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure with a certificate that corresponds to the private <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">exchange key</a> needed to decode the message. This parameter is only set for message types CMSG_ENVELOPED and CMSG_SIGNED_AND_ENVELOPED.
     * @param {Pointer<Pointer<CERT_CONTEXT>>} ppSignerCert A pointer to a 
     * pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a> of the signer. This parameter is only set for message types CMSG_SIGNED and CMSG_SIGNED_AND_ENVELOPED.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptdecryptmessage">CryptDecryptMessage</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifymessagesignature">CryptVerifyMessageSignature</a>, or 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifymessagehash">CryptVerifyMessageHash</a> functions can be propagated to this function.
     * 
     * The following error code is most commonly returned by the 
     * 		       <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbDecoded</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbDecoded</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptdecodemessage
     * @since windows5.1.2600
     */
    static CryptDecodeMessage(dwMsgTypeFlags, pDecryptPara, pVerifyPara, dwSignerIndex, pbEncodedBlob, cbEncodedBlob, dwPrevInnerContentType, pdwMsgType, pdwInnerContentType, pbDecoded, pcbDecoded, ppXchgCert, ppSignerCert) {
        pdwMsgTypeMarshal := pdwMsgType is VarRef ? "uint*" : "ptr"
        pdwInnerContentTypeMarshal := pdwInnerContentType is VarRef ? "uint*" : "ptr"
        pcbDecodedMarshal := pcbDecoded is VarRef ? "uint*" : "ptr"
        ppXchgCertMarshal := ppXchgCert is VarRef ? "ptr*" : "ptr"
        ppSignerCertMarshal := ppSignerCert is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptDecodeMessage", "uint", dwMsgTypeFlags, "ptr", pDecryptPara, "ptr", pVerifyPara, "uint", dwSignerIndex, "ptr", pbEncodedBlob, "uint", cbEncodedBlob, "uint", dwPrevInnerContentType, pdwMsgTypeMarshal, pdwMsgType, pdwInnerContentTypeMarshal, pdwInnerContentType, "ptr", pbDecoded, pcbDecodedMarshal, pcbDecoded, ppXchgCertMarshal, ppXchgCert, ppSignerCertMarshal, ppSignerCert, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Creates a hash of the message.
     * @param {Pointer<CRYPT_HASH_MESSAGE_PARA>} pHashPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_hash_message_para">CRYPT_HASH_MESSAGE_PARA</a> structure that contains the hash parameters.
     * @param {BOOL} fDetachedHash If this parameter is set to <b>TRUE</b>, only <i>pbComputedHash</i> is encoded in <i>pbHashedBlob</i>. Otherwise, both <i>rgpbToBeHashed</i> and <i>pbComputedHash</i> are encoded.
     * @param {Integer} cToBeHashed The number of array elements in <i>rgpbToBeHashed</i> and <i>rgcbToBeHashed</i>. This parameter can only be one unless <i>fDetachedHash</i> is set to <b>TRUE</b>.
     * @param {Pointer<Pointer<Integer>>} rgpbToBeHashed An array of pointers to buffers that contain the contents to be hashed.
     * @param {Pointer<Integer>} rgcbToBeHashed An array of sizes, in bytes, of the buffers pointed to by <i>rgpbToBeHashed</i>.
     * @param {Pointer} pbHashedBlob A pointer to a buffer to receive the hashed message encoded for transmission. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the hashed message is not needed for additional processing or to set the size of the hashed message for memory allocation purposes. A hashed message will not be returned if this parameter is <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbHashedBlob A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pbHashedBlob</i> parameter. When the function returns, this variable contains the size, in bytes, of the decrypted message copied to <i>pbHashedBlob</i>. This parameter must be the address of a <b>DWORD</b> and not <b>NULL</b> or the length of the buffer will not be returned. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @param {Pointer} pbComputedHash A pointer to a buffer to receive the newly created hash value. This parameter can be <b>NULL</b> if the newly created hash is not needed for additional processing, or to set the size of the hash for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbComputedHash A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pbComputedHash</i> parameter. When the function returns, this <b>DWORD</b> contains the size, in bytes, of the newly created hash that was copied to <i>pbComputedHash</i>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>, and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a> might be propagated to this function.</div>
     * <div></div>
     * The <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the following error codes most often.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="/windows/desktop/SecGloss/m-gly">message encoding type</a> is not valid. Currently only PKCS_7_ASN_ENCODING is supported. The <b>cbSize</b> in *<i>pHashPara</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbHashedBlob</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, into the variable pointed to by <i>pbHashedBlob</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-crypthashmessage
     * @since windows5.1.2600
     */
    static CryptHashMessage(pHashPara, fDetachedHash, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbHashedBlob, pcbHashedBlob, pbComputedHash, pcbComputedHash) {
        rgpbToBeHashedMarshal := rgpbToBeHashed is VarRef ? "ptr*" : "ptr"
        rgcbToBeHashedMarshal := rgcbToBeHashed is VarRef ? "uint*" : "ptr"
        pcbHashedBlobMarshal := pcbHashedBlob is VarRef ? "uint*" : "ptr"
        pcbComputedHashMarshal := pcbComputedHash is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptHashMessage", "ptr", pHashPara, "int", fDetachedHash, "uint", cToBeHashed, rgpbToBeHashedMarshal, rgpbToBeHashed, rgcbToBeHashedMarshal, rgcbToBeHashed, "ptr", pbHashedBlob, pcbHashedBlobMarshal, pcbHashedBlob, "ptr", pbComputedHash, pcbComputedHashMarshal, pcbComputedHash, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptVerifyMessageHash function verifies the hash of specified content.
     * @param {Pointer<CRYPT_HASH_MESSAGE_PARA>} pHashPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_hash_message_para">CRYPT_HASH_MESSAGE_PARA</a> structure containing hash parameters.
     * @param {Pointer} pbHashedBlob A pointer to a buffer containing original content and its hash.
     * @param {Integer} cbHashedBlob The size, in bytes, of the original hash buffer.
     * @param {Pointer} pbToBeHashed A pointer to a buffer to receive the original content that was hashed. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the original content is not needed for additional processing, or to set the size of the original content for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbToBeHashed A pointer to a <b>DWORD</b> specifying the size, in bytes, of the <i>pbToBeHashed</i> buffer. When the function returns, this variable contains the size, in bytes, of the original content copied to <i>pbToBeHashed</i>. The original content will not be returned if this parameter is <b>NULL</b>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @param {Pointer} pbComputedHash A pointer to a buffer to receive the computed hash. This parameter can be <b>NULL</b> if the created hash is not needed for additional processing, or to set the size of the original content for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbComputedHash A pointer to a <b>DWORD</b> specifying the size, in bytes, of the <i>pbComputedHash</i> buffer. When the function returns, this variable contains the size, in bytes, of the created hash. The hash is not returned if this parameter is <b>NULL</b>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE).
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following lists the error codes most commonly returned by the 
     * 		       <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not a hashed cryptographic message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="/windows/desktop/SecGloss/m-gly">message encoding type</a> is not valid. Currently only PKCS_7_ASN_ENCODING is supported. The <b>cbSize</b> in *<i>pHashPara</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbToBeHashed</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbToBeHashed</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>, and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a> might be propagated to this function. <p class="note">If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>. 
     * 
     * </div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptverifymessagehash
     * @since windows5.1.2600
     */
    static CryptVerifyMessageHash(pHashPara, pbHashedBlob, cbHashedBlob, pbToBeHashed, pcbToBeHashed, pbComputedHash, pcbComputedHash) {
        pcbToBeHashedMarshal := pcbToBeHashed is VarRef ? "uint*" : "ptr"
        pcbComputedHashMarshal := pcbComputedHash is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptVerifyMessageHash", "ptr", pHashPara, "ptr", pbHashedBlob, "uint", cbHashedBlob, "ptr", pbToBeHashed, pcbToBeHashedMarshal, pcbToBeHashed, "ptr", pbComputedHash, pcbComputedHashMarshal, pcbComputedHash, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptVerifyDetachedMessageHash function verifies a detached hash.
     * @param {Pointer<CRYPT_HASH_MESSAGE_PARA>} pHashPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_hash_message_para">CRYPT_HASH_MESSAGE_PARA</a> structure containing the hash parameters.
     * @param {Pointer} pbDetachedHashBlob A pointer to the encoded, detached hash.
     * @param {Integer} cbDetachedHashBlob The size, in bytes, of the detached hash.
     * @param {Integer} cToBeHashed Number of elements in the <i>rgpbToBeHashed</i> and <i>rgcbToBeHashed</i> arrays.
     * @param {Pointer<Pointer<Integer>>} rgpbToBeHashed Array of pointers to content buffers to be hashed.
     * @param {Pointer<Integer>} rgcbToBeHashed Array of sizes, in bytes, for the content buffers pointed to by the elements of the <i>rgcbToBeHashed</i> array.
     * @param {Pointer} pbComputedHash A pointer to a buffer to receive the computed hash. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the newly created hash is not needed for additional processing, or to set the size of the hash for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbComputedHash A pointer to a <b>DWORD</b> specifying the size, in bytes, of the <i>pbComputedHash</i> buffer. When the function returns, this <b>DWORD</b> contains the size, in bytes, of the created hash. The hash will not be returned if this parameter is <b>NULL</b>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned , applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE).
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following lists the error codes most commonly returned by the 
     * 		       <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not a hashed cryptographic message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="/windows/desktop/SecGloss/m-gly">message encoding type</a> is not valid. Currently only PKCS_7_ASN_ENCODING is supported. The <b>cbSize</b> in *<i>pHashPara</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbComputedHash</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbComputedHash</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>Errors from the called functions 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>, and 
     * <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a> might be propagated to this function. <p class="note">If the function fails, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>. 
     * 
     * </div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptverifydetachedmessagehash
     * @since windows5.1.2600
     */
    static CryptVerifyDetachedMessageHash(pHashPara, pbDetachedHashBlob, cbDetachedHashBlob, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbComputedHash, pcbComputedHash) {
        rgpbToBeHashedMarshal := rgpbToBeHashed is VarRef ? "ptr*" : "ptr"
        rgcbToBeHashedMarshal := rgcbToBeHashed is VarRef ? "uint*" : "ptr"
        pcbComputedHashMarshal := pcbComputedHash is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptVerifyDetachedMessageHash", "ptr", pHashPara, "ptr", pbDetachedHashBlob, "uint", cbDetachedHashBlob, "uint", cToBeHashed, rgpbToBeHashedMarshal, rgpbToBeHashed, rgcbToBeHashedMarshal, rgcbToBeHashed, "ptr", pbComputedHash, pcbComputedHashMarshal, pcbComputedHash, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Signs a message by using a CSP's private key specified in the parameters.
     * @param {Pointer<CRYPT_KEY_SIGN_MESSAGE_PARA>} pSignPara A pointer to 
     * a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_sign_message_para">CRYPT_KEY_SIGN_MESSAGE_PARA</a> structure that contains the signature parameters.
     * @param {Pointer} pbToBeSigned A pointer to a buffer array that contains the message to be signed.
     * @param {Integer} cbToBeSigned The number of array elements in the <i>pbToBeSigned</i> buffer array.
     * @param {Pointer} pbSignedBlob A pointer to a buffer to receive the encoded signed message. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbSignedBlob A pointer to a <b>DWORD</b> value that indicates the size, in bytes, of the <i>pbSignedBlob</i> buffer. When the function returns, this variable contains the size, in bytes, of the signed and encoded message. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE).
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * The following lists the error codes most commonly returned by the 
     * 		       <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbSignedBlob</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbSignedBlob</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="/windows/desktop/SecGloss/m-gly">message encoding type</a> is not valid. Currently only PKCS_7_ASN_ENCODING is supported. The <b>cbSize</b> in *<i>pSignPara</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_KEY_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pSigningCert</i> in *<i>pSignPara</i> does not have a CERT_KEY_PROV_INFO_PROP_ID or CERT_KEY_CONTEXT_PROP_ID property.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptsignmessagewithkey
     * @since windows5.1.2600
     */
    static CryptSignMessageWithKey(pSignPara, pbToBeSigned, cbToBeSigned, pbSignedBlob, pcbSignedBlob) {
        pcbSignedBlobMarshal := pcbSignedBlob is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptSignMessageWithKey", "ptr", pSignPara, "ptr", pbToBeSigned, "uint", cbToBeSigned, "ptr", pbSignedBlob, pcbSignedBlobMarshal, pcbSignedBlob, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Verifies a signed message's signature by using specified public key information.
     * @param {Pointer<CRYPT_KEY_VERIFY_MESSAGE_PARA>} pVerifyPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_verify_message_para">CRYPT_KEY_VERIFY_MESSAGE_PARA</a> structure that contains verification parameters.
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pPublicKeyInfo A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure that contains the public key that is used to verify the signed
     * message. If <b>NULL</b>, the signature is not verified.
     * @param {Pointer} pbSignedBlob A pointer to a buffer that contains the signed message.
     * @param {Integer} cbSignedBlob The size, in bytes, of the signed message buffer.
     * @param {Pointer} pbDecoded A pointer to a buffer to receive the decoded message. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the decoded message is not needed for additional processing or to set the size of the message for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbDecoded A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the <i>pbDecoded</i> buffer. When the function returns, this <b>DWORD</b> contains the size, in bytes, of the decoded message. The decoded message will not be returned if this parameter is <b>NULL</b>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table shows the error codes most commonly returned by the 
     * 		       <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbDecoded</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbDecoded</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid message and certificate encoding types. Currently only PKCS_7_ASN_ENCODING and X509_ASN_ENCODING_TYPE are supported. Invalid <b>cbSize</b> in *<i>pVerifyPara</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not a signed cryptographic message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_SIGNER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message does not have any signers or a signer for the specified <i>dwSignerIndex</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message was hashed and signed by using an unknown or unsupported algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message's signature was not verified.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptverifymessagesignaturewithkey
     * @since windows5.1.2600
     */
    static CryptVerifyMessageSignatureWithKey(pVerifyPara, pPublicKeyInfo, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded) {
        pcbDecodedMarshal := pcbDecoded is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptVerifyMessageSignatureWithKey", "ptr", pVerifyPara, "ptr", pPublicKeyInfo, "ptr", pbSignedBlob, "uint", cbSignedBlob, "ptr", pbDecoded, pcbDecodedMarshal, pcbDecoded, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Opens the most common system certificate store. To open certificate stores with more complex requirements, such as file-based or memory-based stores, use CertOpenStore.
     * @param {HCRYPTPROV_LEGACY} hProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>A handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP). Set <i>hProv</i> to <b>NULL</b> to use the default CSP. If <i>hProv</i> is not <b>NULL</b>, it must be a CSP handle created by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function.This parameter's data type is <b>HCRYPTPROV</b>.
     * @param {PSTR} szSubsystemProtocol A string that names a system store. If the system store name provided in this parameter is not the name of an existing system store, a new system store will be created and used. <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certenumsystemstore">CertEnumSystemStore</a> can be used to list the names of existing system stores. Some example system stores are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CA"></a><a id="ca"></a><dl>
     * <dt><b>CA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">Certification authority</a> certificates.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MY"></a><a id="my"></a><dl>
     * <dt><b>MY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A certificate store that holds certificates with associated private keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ROOT"></a><a id="root"></a><dl>
     * <dt><b>ROOT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">Root certificates</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPC"></a><a id="spc"></a><dl>
     * <dt><b>SPC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">Software Publisher Certificate</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {HCERTSTORE} If the function succeeds, the function returns a handle to the certificate store.
     * 
     * If the function fails, it returns <b>NULL</b>. For extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>Errors from the called function <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certopenstore">CertOpenStore</a> are propagated to this function.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certopensystemstorea
     * @since windows5.1.2600
     */
    static CertOpenSystemStoreA(hProv, szSubsystemProtocol) {
        hProv := hProv is Win32Handle ? NumGet(hProv, "ptr") : hProv
        szSubsystemProtocol := szSubsystemProtocol is String ? StrPtr(szSubsystemProtocol) : szSubsystemProtocol

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertOpenSystemStoreA", "ptr", hProv, "ptr", szSubsystemProtocol, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        resultHandle := HCERTSTORE({Value: result}, True)
        return resultHandle
    }

    /**
     * Opens the most common system certificate store. To open certificate stores with more complex requirements, such as file-based or memory-based stores, use CertOpenStore.
     * @param {HCRYPTPROV_LEGACY} hProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>A handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP). Set <i>hProv</i> to <b>NULL</b> to use the default CSP. If <i>hProv</i> is not <b>NULL</b>, it must be a CSP handle created by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function.This parameter's data type is <b>HCRYPTPROV</b>.
     * @param {PWSTR} szSubsystemProtocol A string that names a system store. If the system store name provided in this parameter is not the name of an existing system store, a new system store will be created and used. <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certenumsystemstore">CertEnumSystemStore</a> can be used to list the names of existing system stores. Some example system stores are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CA"></a><a id="ca"></a><dl>
     * <dt><b>CA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">Certification authority</a> certificates.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MY"></a><a id="my"></a><dl>
     * <dt><b>MY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A certificate store that holds certificates with associated private keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ROOT"></a><a id="root"></a><dl>
     * <dt><b>ROOT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">Root certificates</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPC"></a><a id="spc"></a><dl>
     * <dt><b>SPC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">Software Publisher Certificate</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {HCERTSTORE} If the function succeeds, the function returns a handle to the certificate store.
     * 
     * If the function fails, it returns <b>NULL</b>. For extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>Errors from the called function <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certopenstore">CertOpenStore</a> are propagated to this function.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certopensystemstorew
     * @since windows5.1.2600
     */
    static CertOpenSystemStoreW(hProv, szSubsystemProtocol) {
        hProv := hProv is Win32Handle ? NumGet(hProv, "ptr") : hProv
        szSubsystemProtocol := szSubsystemProtocol is String ? StrPtr(szSubsystemProtocol) : szSubsystemProtocol

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertOpenSystemStoreW", "ptr", hProv, "ptr", szSubsystemProtocol, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        resultHandle := HCERTSTORE({Value: result}, True)
        return resultHandle
    }

    /**
     * Opens the specified system store and adds the encoded certificate to it.
     * @param {PSTR} szCertStoreName A null-terminated string that contains the name of the system store for the encoded certificate.
     * @param {Pointer} pbCertEncoded A pointer to a buffer that contains the encoded certificate to add.
     * @param {Integer} cbCertEncoded The size, in bytes, of the <i>pbCertEncoded</i> buffer.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. <b>CertAddEncodedCertificateToSystemStore</b> depends on the functions listed in the following remarks for error handling. Refer to those function topics for their respective error handling behaviors. For extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certaddencodedcertificatetosystemstorea
     * @since windows5.1.2600
     */
    static CertAddEncodedCertificateToSystemStoreA(szCertStoreName, pbCertEncoded, cbCertEncoded) {
        szCertStoreName := szCertStoreName is String ? StrPtr(szCertStoreName) : szCertStoreName

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddEncodedCertificateToSystemStoreA", "ptr", szCertStoreName, "ptr", pbCertEncoded, "uint", cbCertEncoded, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Opens the specified system store and adds the encoded certificate to it.
     * @param {PWSTR} szCertStoreName A null-terminated string that contains the name of the system store for the encoded certificate.
     * @param {Pointer} pbCertEncoded A pointer to a buffer that contains the encoded certificate to add.
     * @param {Integer} cbCertEncoded The size, in bytes, of the <i>pbCertEncoded</i> buffer.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. <b>CertAddEncodedCertificateToSystemStore</b> depends on the functions listed in the following remarks for error handling. Refer to those function topics for their respective error handling behaviors. For extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certaddencodedcertificatetosystemstorew
     * @since windows5.1.2600
     */
    static CertAddEncodedCertificateToSystemStoreW(szCertStoreName, pbCertEncoded, cbCertEncoded) {
        szCertStoreName := szCertStoreName is String ? StrPtr(szCertStoreName) : szCertStoreName

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddEncodedCertificateToSystemStoreW", "ptr", szCertStoreName, "ptr", pbCertEncoded, "uint", cbCertEncoded, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {Pointer} pCertChains 
     * @param {Pointer<Integer>} pcbCertChains 
     * @param {Pointer} pbEncodedIssuerName 
     * @param {Integer} cbEncodedIssuerName 
     * @param {PWSTR} pwszPurpose 
     * @param {Integer} dwKeySpec 
     * @returns {Integer} 
     */
    static FindCertsByIssuer(pCertChains, pcbCertChains, pbEncodedIssuerName, cbEncodedIssuerName, pwszPurpose, dwKeySpec) {
        pwszPurpose := pwszPurpose is String ? StrPtr(pwszPurpose) : pwszPurpose

        pcbCertChainsMarshal := pcbCertChains is VarRef ? "uint*" : "ptr"

        result := DllCall("WINTRUST.dll\FindCertsByIssuer", "ptr", pCertChains, pcbCertChainsMarshal, pcbCertChains, "uint*", &pcCertChains := 0, "ptr", pbEncodedIssuerName, "uint", cbEncodedIssuerName, "ptr", pwszPurpose, "uint", dwKeySpec, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcCertChains
    }

    /**
     * Retrieves information about the contents of a cryptography API object, such as a certificate, a certificate revocation list, or a certificate trust list.
     * @param {Integer} dwObjectType 
     * @param {Pointer<Void>} pvObject A pointer to the object to be queried. 
     * 					The type of data pointer depends on the contents of the <i>dwObjectType</i> parameter.
     * 
     * <table>
     * <tr>
     * <th><i>dwObjectType</i> value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_QUERY_OBJECT_BLOB"></a><a id="cert_query_object_blob"></a><dl>
     * <dt><b>CERT_QUERY_OBJECT_BLOB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is a pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CERT_BLOB</a>, or similar, structure that contains the object to query.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_QUERY_OBJECT_FILE"></a><a id="cert_query_object_file"></a><dl>
     * <dt><b>CERT_QUERY_OBJECT_FILE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is a pointer to a null-terminated Unicode string that contains the path and name of the file to query.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwExpectedContentTypeFlags 
     * @param {Integer} dwExpectedFormatTypeFlags 
     * @param {Integer} dwFlags This parameter is reserved for future use and must be set to zero.
     * @param {Pointer<Integer>} pdwMsgAndCertEncodingType A pointer to a <b>DWORD</b> value that receives the type of encoding used in the message. If this information is not needed, set this parameter to <b>NULL</b>.
     * @param {Pointer<Integer>} pdwContentType 
     * @param {Pointer<Integer>} pdwFormatType 
     * @param {Pointer<HCERTSTORE>} phCertStore A pointer to an <b>HCERTSTORE</b> value that receives a handle to a certificate store that includes all of the certificates, CRLs, and CTLs in the object.
     * @param {Pointer<Pointer<Void>>} phMsg A pointer to an <b>HCRYPTMSG</b> value that receives the handle of an opened message.
     * @param {Pointer<Pointer<Void>>} ppvContext A pointer to a pointer that receives additional information about the object.
     * 
     * 
     * The format of this data depends on the value received by the <i>dwContentType</i> parameter. The following table lists the format of the data for the specified <i>dwContentType</i> value.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th><i>dwContentType</i> value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_QUERY_CONTENT_CERT"></a><a id="cert_query_content_cert"></a><dl>
     * <dt><b>CERT_QUERY_CONTENT_CERT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter receives a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure. When you have finished using the structure, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_QUERY_CONTENT_CRL"></a><a id="cert_query_content_crl"></a><dl>
     * <dt><b>CERT_QUERY_CONTENT_CRL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter receives a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure. When you have finished using the structure, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_QUERY_CONTENT_CTL"></a><a id="cert_query_content_ctl"></a><dl>
     * <dt><b>CERT_QUERY_CONTENT_CTL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter receives a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure. When you have finished using the structure, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreectlcontext">CertFreeCTLContext</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_QUERY_CONTENT_SERIALIZED_CERT"></a><a id="cert_query_content_serialized_cert"></a><dl>
     * <dt><b>CERT_QUERY_CONTENT_SERIALIZED_CERT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter receives a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure. When you have finished using the structure, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_QUERY_CONTENT_SERIALIZED_CRL"></a><a id="cert_query_content_serialized_crl"></a><dl>
     * <dt><b>CERT_QUERY_CONTENT_SERIALIZED_CRL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter receives a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure. When you have finished using the structure, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_QUERY_CONTENT_SERIALIZED_CTL"></a><a id="cert_query_content_serialized_ctl"></a><dl>
     * <dt><b>CERT_QUERY_CONTENT_SERIALIZED_CTL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter receives a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure. When you have finished using the structure, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreectlcontext">CertFreeCTLContext</a> function.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If this information is not needed, set this parameter to <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptqueryobject
     * @since windows5.1.2600
     */
    static CryptQueryObject(dwObjectType, pvObject, dwExpectedContentTypeFlags, dwExpectedFormatTypeFlags, dwFlags, pdwMsgAndCertEncodingType, pdwContentType, pdwFormatType, phCertStore, phMsg, ppvContext) {
        pvObjectMarshal := pvObject is VarRef ? "ptr" : "ptr"
        pdwMsgAndCertEncodingTypeMarshal := pdwMsgAndCertEncodingType is VarRef ? "uint*" : "ptr"
        pdwContentTypeMarshal := pdwContentType is VarRef ? "uint*" : "ptr"
        pdwFormatTypeMarshal := pdwFormatType is VarRef ? "uint*" : "ptr"
        phMsgMarshal := phMsg is VarRef ? "ptr*" : "ptr"
        ppvContextMarshal := ppvContext is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptQueryObject", "uint", dwObjectType, pvObjectMarshal, pvObject, "uint", dwExpectedContentTypeFlags, "uint", dwExpectedFormatTypeFlags, "uint", dwFlags, pdwMsgAndCertEncodingTypeMarshal, pdwMsgAndCertEncodingType, pdwContentTypeMarshal, pdwContentType, pdwFormatTypeMarshal, pdwFormatType, "ptr", phCertStore, phMsgMarshal, phMsg, ppvContextMarshal, ppvContext, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptMemAlloc function allocates memory for a buffer. It is used by all Crypt32.lib functions that return allocated buffers.
     * @param {Integer} cbSize Number of bytes to be allocated.
     * @returns {Pointer<Void>} Returns a pointer to the buffer allocated. If the function fails, <b>NULL</b> is returned. When you have finished using the buffer, free the memory by calling the <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptmemfree">CryptMemFree</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmemalloc
     * @since windows5.1.2600
     */
    static CryptMemAlloc(cbSize) {
        result := DllCall("CRYPT32.dll\CryptMemAlloc", "uint", cbSize, "ptr")
        return result
    }

    /**
     * The CryptMemRealloc function frees the memory currently allocated for a buffer and allocates memory for a new buffer.
     * @param {Pointer<Void>} pv A pointer to a currently allocated buffer.
     * @param {Integer} cbSize Number of bytes to be allocated.
     * @returns {Pointer<Void>} Returns a pointer to the buffer allocated. If the function fails, <b>NULL</b> is returned. When you have finished using the buffer, free the memory by calling the <a href="/windows/desktop/api/wincrypt/nf-wincrypt-cryptmemfree">CryptMemFree</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmemrealloc
     * @since windows5.1.2600
     */
    static CryptMemRealloc(pv, cbSize) {
        pvMarshal := pv is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPT32.dll\CryptMemRealloc", pvMarshal, pv, "uint", cbSize, "ptr")
        return result
    }

    /**
     * The CryptMemFree function frees memory allocated by CryptMemAlloc or CryptMemRealloc.
     * @param {Pointer<Void>} pv A pointer to the buffer to be freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptmemfree
     * @since windows5.1.2600
     */
    static CryptMemFree(pv) {
        pvMarshal := pv is VarRef ? "ptr" : "ptr"

        DllCall("CRYPT32.dll\CryptMemFree", pvMarshal, pv)
    }

    /**
     * 
     * @param {Integer} dwFlags Handle creation flags.
     * @param {Pointer<HCRYPTASYNC>} phAsync Receiveds a pointer to the created async handle.
     * @returns {BOOL} 
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptcreateasynchandle
     */
    static CryptCreateAsyncHandle(dwFlags, phAsync) {
        result := DllCall("CRYPT32.dll\CryptCreateAsyncHandle", "uint", dwFlags, "ptr", phAsync, "int")
        return result
    }

    /**
     * 
     * @param {HCRYPTASYNC} hAsync An async handle.
     * @param {PSTR} pszParamOid The parameter ID.
     * @param {Pointer<Void>} pvParam The paramter value.
     * @param {Pointer<PFN_CRYPT_ASYNC_PARAM_FREE_FUNC>} pfnFree A callback function called when the parameter is freed.
     * @returns {BOOL} S_OK on success.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptsetasyncparam
     */
    static CryptSetAsyncParam(hAsync, pszParamOid, pvParam, pfnFree) {
        hAsync := hAsync is Win32Handle ? NumGet(hAsync, "ptr") : hAsync
        pszParamOid := pszParamOid is String ? StrPtr(pszParamOid) : pszParamOid

        pvParamMarshal := pvParam is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPT32.dll\CryptSetAsyncParam", "ptr", hAsync, "ptr", pszParamOid, pvParamMarshal, pvParam, "ptr", pfnFree, "int")
        return result
    }

    /**
     * 
     * @param {HCRYPTASYNC} hAsync An async handle.
     * @param {PSTR} pszParamOid The parameter ID.
     * @param {Pointer<Pointer<Void>>} ppvParam Receives the parameter value.
     * @param {Pointer<Pointer<PFN_CRYPT_ASYNC_PARAM_FREE_FUNC>>} ppfnFree A callback function called when the parameter is freed.
     * @returns {BOOL} S_OK on success.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptgetasyncparam
     */
    static CryptGetAsyncParam(hAsync, pszParamOid, ppvParam, ppfnFree) {
        hAsync := hAsync is Win32Handle ? NumGet(hAsync, "ptr") : hAsync
        pszParamOid := pszParamOid is String ? StrPtr(pszParamOid) : pszParamOid

        ppvParamMarshal := ppvParam is VarRef ? "ptr*" : "ptr"
        ppfnFreeMarshal := ppfnFree is VarRef ? "ptr*" : "ptr"

        result := DllCall("CRYPT32.dll\CryptGetAsyncParam", "ptr", hAsync, "ptr", pszParamOid, ppvParamMarshal, ppvParam, ppfnFreeMarshal, ppfnFree, "int")
        return result
    }

    /**
     * 
     * @param {HCRYPTASYNC} hAsync The async handle to close.
     * @returns {BOOL} Returns S_OK on success.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptcloseasynchandle
     */
    static CryptCloseAsyncHandle(hAsync) {
        hAsync := hAsync is Win32Handle ? NumGet(hAsync, "ptr") : hAsync

        result := DllCall("CRYPT32.dll\CryptCloseAsyncHandle", "ptr", hAsync, "int")
        return result
    }

    /**
     * Retrieves the public key infrastructure (PKI) object from a location specified by a URL.
     * @param {PSTR} pszUrl The address of a PKI object to be retrieved. The following schemes are supported:
     * 
     * <ul>
     * <li>ldap (<a href="https://docs.microsoft.com/windows/desktop/SecGloss/l-gly">Lightweight Directory Access Protocol</a>)</li>
     * <li>http</li>
     * <li>https (<a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate revocation list</a> (CRL) or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">online certificate status protocol</a> (OCSP) retrievals only)</li>
     * <li>file</li>
     * </ul>
     * @param {PSTR} pszObjectOid 
     * @param {Integer} dwRetrievalFlags Determines whether to use the cached URL or a URL retrieved from the wire URL. The form in which objects are returned is determined by the value of <i>pszObjectOid</i>.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_AIA_RETRIEVAL"></a><a id="crypt_aia_retrieval"></a><dl>
     * <dt><b>CRYPT_AIA_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Validates the content retrieved by a wire URL before writing the URL  to the cache.
     * 
     * The default provider does not support the HTTPS protocol for AIA retrievals.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_ASYNC_RETRIEVAL"></a><a id="crypt_async_retrieval"></a><dl>
     * <dt><b>CRYPT_ASYNC_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_CACHE_ONLY_RETRIEVAL"></a><a id="crypt_cache_only_retrieval"></a><dl>
     * <dt><b>CRYPT_CACHE_ONLY_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the encoded bits from the URL cache only. Do not use the wire to retrieve the URL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DONT_CACHE_RESULT"></a><a id="crypt_dont_cache_result"></a><dl>
     * <dt><b>CRYPT_DONT_CACHE_RESULT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Does not store the retrieved encoded bits to the URL cache. If this flag is not set, the retrieved URL is cached.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_HTTP_POST_RETRIEVAL"></a><a id="crypt_http_post_retrieval"></a><dl>
     * <dt><b>CRYPT_HTTP_POST_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uses the POST method instead of the default GET method for HTTP retrievals.
     * 
     * In a POST URL, additional binary data and header strings are appended to the base URL in the following format:
     * 
     * <i>BaseURL</i><b>/</b><i>OptionalURLEscaped&amp;Base64EncodedAdditionalData</i><b>?</b><i>OptionalAdditionalHTTPHeaders</i>
     * 
     * The following example shows the additional binary data delimited by the last slash mark (/) and  a Content-Type header delimited by a question mark (?) appended to a base URL.
     * 
     * <c>http://ocsp.openvalidation.org/MEIwQDA%2BMDwwOjAJBgUrDgMCGgUABBQdKNEwjytjKBQADcgM61jfflNpyQQUv1NDgnjQnsOA5RtnygUA37lIg6UCAQI%3D?Content-Type: application/ocsp-request</c>
     * 
     * When this flag is set, the <b>CryptRetrieveObjectByUrl</b> function parses the URL by using the last slash mark (/) and question mark (?) delimiters. The string, which is delimited by a slash mark (/), contains an unescaped URL (that is, a plain text URL without escape characters or escape sequences) and Base64 data decoded into binary form before being passed to the <a href="https://docs.microsoft.com/windows/desktop/api/winhttp/nf-winhttp-winhttpsendrequest">WinHttpSendRequest</a> function as the <i>lpOptional</i> parameter. The string delimited by a question mark (?) is passed to the <b>WinHttpSendRequest</b> function as the <i>pwszHeaders</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL"></a><a id="crypt_ldap_arec_exclusive_retrieval"></a><dl>
     * <dt><b>CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Performs A-Record-only DNS lookup on the supplied host string, preventing the generation of false DNS queries when resolving host names. This flag should be used when passing a host name as opposed to a domain name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE"></a><a id="crypt_ldap_insert_entry_attribute"></a><dl>
     * <dt><b>CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the entry index and attribute name for each LDAP object. The beginning of each returned BLOB contains the following ANSI string:
     * 
     * "<i>entry index in decimal</i>\0<i>attribute name</i>\0"
     * 
     * When this flag is set, <i>pszObjectOid</i> must be <b>NULL</b> so that a BLOB is returned. This flag only applies to the ldap scheme.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL"></a><a id="crypt_ldap_scope_base_only_retrieval"></a><dl>
     * <dt><b>CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Fails if the LDAP search scope is not set to base in the URL. Use with LDAP only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LDAP_SIGN_RETRIEVAL"></a><a id="crypt_ldap_sign_retrieval"></a><dl>
     * <dt><b>CRYPT_LDAP_SIGN_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Digitally signs all of the LDAP traffic to and from a server by using the Kerberos authentication protocol. This feature provides integrity required by some applications.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NO_AUTH_RETRIEVAL"></a><a id="crypt_no_auth_retrieval"></a><dl>
     * <dt><b>CRYPT_NO_AUTH_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Inhibits automatic authentication handling.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NOT_MODIFIED_RETRIEVAL"></a><a id="crypt_not_modified_retrieval"></a><dl>
     * <dt><b>CRYPT_NOT_MODIFIED_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables a conditional HTTP URL retrieval. When this flag is set, for a conditional retrieval that returns <b>HTTP_STATUS_NOT_MODIFIED</b>, <b>CryptRetrieveObjectByUrl</b> returns <b>TRUE</b> and <i>ppvObject</i> is set to <b>NULL</b>. If <i>pAuxInfo</i> is not <b>NULL</b>, <b>dwHttpStatusCode</b> is set to <b>HTTP_STATUS_NOT_MODIFIED</b>. Otherwise, <i>ppvObject</i> is updated for a successful retrieval.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_OFFLINE_CHECK_RETRIEVAL"></a><a id="crypt_offline_check_retrieval"></a><dl>
     * <dt><b>CRYPT_OFFLINE_CHECK_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Keeps track of offline failures and delays before hitting the wire on subsequent retrievals. This value is for wire retrieval only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_PROXY_CACHE_RETRIEVAL"></a><a id="crypt_proxy_cache_retrieval"></a><dl>
     * <dt><b>CRYPT_PROXY_CACHE_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables proxy cache retrieval of an object. If a proxy cache was not explicitly bypassed, <b>fProxyCacheRetrieval</b> is set to <b>TRUE</b> in <i>pAuxInfo</i>. This value only applies to HTTP URL retrievals.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_RETRIEVE_MULTIPLE_OBJECTS"></a><a id="crypt_retrieve_multiple_objects"></a><dl>
     * <dt><b>CRYPT_RETRIEVE_MULTIPLE_OBJECTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves multiple objects if available. All objects must be of a homogeneous object type as determined by the value of <i>pszObjectOid</i>, unless the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) value is CONTEXT_OID_CAPI2_ANY.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_STICKY_CACHE_RETRIEVAL"></a><a id="crypt_sticky_cache_retrieval"></a><dl>
     * <dt><b>CRYPT_STICKY_CACHE_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Tags the URL as exempt from being flushed from the cache. For more information, see STICKY_CACHE_ENTRY in INTERNET_CACHE_ENTRY_INFO.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CONTEXT_SIGNATURE"></a><a id="crypt_verify_context_signature"></a><dl>
     * <dt><b>CRYPT_VERIFY_CONTEXT_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Acquires signature verification on the context created. In this case <i>pszObjectOid</i> must be non-<b>NULL</b> and <i>pvVerify</i> points to the signer certificate context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_DATA_HASH"></a><a id="crypt_verify_data_hash"></a><dl>
     * <dt><b>CRYPT_VERIFY_DATA_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not implemented. Do not use it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_WIRE_ONLY_RETRIEVAL"></a><a id="crypt_wire_only_retrieval"></a><dl>
     * <dt><b>CRYPT_WIRE_ONLY_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the encoded bits from the wire only. Does not use the URL cache.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwTimeout Specifies the maximum number of milliseconds to wait for retrieval. If a value of zero is specified, this function does not time out. This parameter is not used if the URL scheme is file:///.
     * @param {Pointer<Pointer<Void>>} ppvObject The address of a pointer to the returned object. The return type can be one of the supported types shown in <i>pszObjectOid</i>.
     * @param {HCRYPTASYNC} hAsyncRetrieve This parameter is reserved and must be set to <b>NULL</b>.
     * @param {Pointer<CRYPT_CREDENTIALS>} pCredentials This parameter is not used.
     * @param {Pointer<Void>} pvVerify A pointer to a verification object. This object is a function of the <i>dwRetrievalFlags</i> parameter. It can be <b>NULL</b> to indicate that the caller is not interested in getting the certificate context or index of the signer if <i>dwRetrievalFlags</i> is CRYPT_VERIFY_CONTEXT_SIGNATURE.
     * @param {Pointer<CRYPT_RETRIEVE_AUX_INFO>} pAuxInfo An optional pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_retrieve_aux_info">CRYPT_RETRIEVE_AUX_INFO</a> structure. If not <b>NULL</b> and if the <b>cbSize</b> member of the structure is set, this parameter returns the time of the last successful wire retrieval.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptretrieveobjectbyurla
     * @since windows5.1.2600
     */
    static CryptRetrieveObjectByUrlA(pszUrl, pszObjectOid, dwRetrievalFlags, dwTimeout, ppvObject, hAsyncRetrieve, pCredentials, pvVerify, pAuxInfo) {
        pszUrl := pszUrl is String ? StrPtr(pszUrl) : pszUrl
        pszObjectOid := pszObjectOid is String ? StrPtr(pszObjectOid) : pszObjectOid
        hAsyncRetrieve := hAsyncRetrieve is Win32Handle ? NumGet(hAsyncRetrieve, "ptr") : hAsyncRetrieve

        ppvObjectMarshal := ppvObject is VarRef ? "ptr*" : "ptr"
        pvVerifyMarshal := pvVerify is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPTNET.dll\CryptRetrieveObjectByUrlA", "ptr", pszUrl, "ptr", pszObjectOid, "uint", dwRetrievalFlags, "uint", dwTimeout, ppvObjectMarshal, ppvObject, "ptr", hAsyncRetrieve, "ptr", pCredentials, pvVerifyMarshal, pvVerify, "ptr", pAuxInfo, "int")
        return result
    }

    /**
     * Retrieves the public key infrastructure (PKI) object from a location specified by a URL.
     * @param {PWSTR} pszUrl The address of a PKI object to be retrieved. The following schemes are supported:
     * 
     * <ul>
     * <li>ldap (<a href="https://docs.microsoft.com/windows/desktop/SecGloss/l-gly">Lightweight Directory Access Protocol</a>)</li>
     * <li>http</li>
     * <li>https (<a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate revocation list</a> (CRL) or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">online certificate status protocol</a> (OCSP) retrievals only)</li>
     * <li>file</li>
     * </ul>
     * @param {PSTR} pszObjectOid 
     * @param {Integer} dwRetrievalFlags Determines whether to use the cached URL or a URL retrieved from the wire URL. The form in which objects are returned is determined by the value of <i>pszObjectOid</i>.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_AIA_RETRIEVAL"></a><a id="crypt_aia_retrieval"></a><dl>
     * <dt><b>CRYPT_AIA_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Validates the content retrieved by a wire URL before writing the URL  to the cache.
     * 
     * The default provider does not support the HTTPS protocol for AIA retrievals.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_ASYNC_RETRIEVAL"></a><a id="crypt_async_retrieval"></a><dl>
     * <dt><b>CRYPT_ASYNC_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_CACHE_ONLY_RETRIEVAL"></a><a id="crypt_cache_only_retrieval"></a><dl>
     * <dt><b>CRYPT_CACHE_ONLY_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the encoded bits from the URL cache only. Do not use the wire to retrieve the URL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DONT_CACHE_RESULT"></a><a id="crypt_dont_cache_result"></a><dl>
     * <dt><b>CRYPT_DONT_CACHE_RESULT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Does not store the retrieved encoded bits to the URL cache. If this flag is not set, the retrieved URL is cached.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_HTTP_POST_RETRIEVAL"></a><a id="crypt_http_post_retrieval"></a><dl>
     * <dt><b>CRYPT_HTTP_POST_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uses the POST method instead of the default GET method for HTTP retrievals.
     * 
     * In a POST URL, additional binary data and header strings are appended to the base URL in the following format:
     * 
     * <i>BaseURL</i><b>/</b><i>OptionalURLEscaped&amp;Base64EncodedAdditionalData</i><b>?</b><i>OptionalAdditionalHTTPHeaders</i>
     * 
     * The following example shows the additional binary data delimited by the last slash mark (/) and  a Content-Type header delimited by a question mark (?) appended to a base URL.
     * 
     * <c>http://ocsp.openvalidation.org/MEIwQDA%2BMDwwOjAJBgUrDgMCGgUABBQdKNEwjytjKBQADcgM61jfflNpyQQUv1NDgnjQnsOA5RtnygUA37lIg6UCAQI%3D?Content-Type: application/ocsp-request</c>
     * 
     * When this flag is set, the <b>CryptRetrieveObjectByUrl</b> function parses the URL by using the last slash mark (/) and question mark (?) delimiters. The string, which is delimited by a slash mark (/), contains an unescaped URL (that is, a plain text URL without escape characters or escape sequences) and Base64 data decoded into binary form before being passed to the <a href="https://docs.microsoft.com/windows/desktop/api/winhttp/nf-winhttp-winhttpsendrequest">WinHttpSendRequest</a> function as the <i>lpOptional</i> parameter. The string delimited by a question mark (?) is passed to the <b>WinHttpSendRequest</b> function as the <i>pwszHeaders</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL"></a><a id="crypt_ldap_arec_exclusive_retrieval"></a><dl>
     * <dt><b>CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Performs A-Record-only DNS lookup on the supplied host string, preventing the generation of false DNS queries when resolving host names. This flag should be used when passing a host name as opposed to a domain name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE"></a><a id="crypt_ldap_insert_entry_attribute"></a><dl>
     * <dt><b>CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the entry index and attribute name for each LDAP object. The beginning of each returned BLOB contains the following ANSI string:
     * 
     * "<i>entry index in decimal</i>\0<i>attribute name</i>\0"
     * 
     * When this flag is set, <i>pszObjectOid</i> must be <b>NULL</b> so that a BLOB is returned. This flag only applies to the ldap scheme.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL"></a><a id="crypt_ldap_scope_base_only_retrieval"></a><dl>
     * <dt><b>CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Fails if the LDAP search scope is not set to base in the URL. Use with LDAP only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LDAP_SIGN_RETRIEVAL"></a><a id="crypt_ldap_sign_retrieval"></a><dl>
     * <dt><b>CRYPT_LDAP_SIGN_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Digitally signs all of the LDAP traffic to and from a server by using the Kerberos authentication protocol. This feature provides integrity required by some applications.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NO_AUTH_RETRIEVAL"></a><a id="crypt_no_auth_retrieval"></a><dl>
     * <dt><b>CRYPT_NO_AUTH_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Inhibits automatic authentication handling.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NOT_MODIFIED_RETRIEVAL"></a><a id="crypt_not_modified_retrieval"></a><dl>
     * <dt><b>CRYPT_NOT_MODIFIED_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables a conditional HTTP URL retrieval. When this flag is set, for a conditional retrieval that returns <b>HTTP_STATUS_NOT_MODIFIED</b>, <b>CryptRetrieveObjectByUrl</b> returns <b>TRUE</b> and <i>ppvObject</i> is set to <b>NULL</b>. If <i>pAuxInfo</i> is not <b>NULL</b>, <b>dwHttpStatusCode</b> is set to <b>HTTP_STATUS_NOT_MODIFIED</b>. Otherwise, <i>ppvObject</i> is updated for a successful retrieval.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_OFFLINE_CHECK_RETRIEVAL"></a><a id="crypt_offline_check_retrieval"></a><dl>
     * <dt><b>CRYPT_OFFLINE_CHECK_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Keeps track of offline failures and delays before hitting the wire on subsequent retrievals. This value is for wire retrieval only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_PROXY_CACHE_RETRIEVAL"></a><a id="crypt_proxy_cache_retrieval"></a><dl>
     * <dt><b>CRYPT_PROXY_CACHE_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables proxy cache retrieval of an object. If a proxy cache was not explicitly bypassed, <b>fProxyCacheRetrieval</b> is set to <b>TRUE</b> in <i>pAuxInfo</i>. This value only applies to HTTP URL retrievals.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_RETRIEVE_MULTIPLE_OBJECTS"></a><a id="crypt_retrieve_multiple_objects"></a><dl>
     * <dt><b>CRYPT_RETRIEVE_MULTIPLE_OBJECTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves multiple objects if available. All objects must be of a homogeneous object type as determined by the value of <i>pszObjectOid</i>, unless the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) value is CONTEXT_OID_CAPI2_ANY.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_STICKY_CACHE_RETRIEVAL"></a><a id="crypt_sticky_cache_retrieval"></a><dl>
     * <dt><b>CRYPT_STICKY_CACHE_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Tags the URL as exempt from being flushed from the cache. For more information, see STICKY_CACHE_ENTRY in INTERNET_CACHE_ENTRY_INFO.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CONTEXT_SIGNATURE"></a><a id="crypt_verify_context_signature"></a><dl>
     * <dt><b>CRYPT_VERIFY_CONTEXT_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Acquires signature verification on the context created. In this case <i>pszObjectOid</i> must be non-<b>NULL</b> and <i>pvVerify</i> points to the signer certificate context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_DATA_HASH"></a><a id="crypt_verify_data_hash"></a><dl>
     * <dt><b>CRYPT_VERIFY_DATA_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not implemented. Do not use it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_WIRE_ONLY_RETRIEVAL"></a><a id="crypt_wire_only_retrieval"></a><dl>
     * <dt><b>CRYPT_WIRE_ONLY_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the encoded bits from the wire only. Does not use the URL cache.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwTimeout Specifies the maximum number of milliseconds to wait for retrieval. If a value of zero is specified, this function does not time out. This parameter is not used if the URL scheme is file:///.
     * @param {Pointer<Pointer<Void>>} ppvObject The address of a pointer to the returned object. The return type can be one of the supported types shown in <i>pszObjectOid</i>.
     * @param {HCRYPTASYNC} hAsyncRetrieve This parameter is reserved and must be set to <b>NULL</b>.
     * @param {Pointer<CRYPT_CREDENTIALS>} pCredentials This parameter is not used.
     * @param {Pointer<Void>} pvVerify A pointer to a verification object. This object is a function of the <i>dwRetrievalFlags</i> parameter. It can be <b>NULL</b> to indicate that the caller is not interested in getting the certificate context or index of the signer if <i>dwRetrievalFlags</i> is CRYPT_VERIFY_CONTEXT_SIGNATURE.
     * @param {Pointer<CRYPT_RETRIEVE_AUX_INFO>} pAuxInfo An optional pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_retrieve_aux_info">CRYPT_RETRIEVE_AUX_INFO</a> structure. If not <b>NULL</b> and if the <b>cbSize</b> member of the structure is set, this parameter returns the time of the last successful wire retrieval.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptretrieveobjectbyurlw
     * @since windows5.1.2600
     */
    static CryptRetrieveObjectByUrlW(pszUrl, pszObjectOid, dwRetrievalFlags, dwTimeout, ppvObject, hAsyncRetrieve, pCredentials, pvVerify, pAuxInfo) {
        pszUrl := pszUrl is String ? StrPtr(pszUrl) : pszUrl
        pszObjectOid := pszObjectOid is String ? StrPtr(pszObjectOid) : pszObjectOid
        hAsyncRetrieve := hAsyncRetrieve is Win32Handle ? NumGet(hAsyncRetrieve, "ptr") : hAsyncRetrieve

        ppvObjectMarshal := ppvObject is VarRef ? "ptr*" : "ptr"
        pvVerifyMarshal := pvVerify is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPTNET.dll\CryptRetrieveObjectByUrlW", "ptr", pszUrl, "ptr", pszObjectOid, "uint", dwRetrievalFlags, "uint", dwTimeout, ppvObjectMarshal, ppvObject, "ptr", hAsyncRetrieve, "ptr", pCredentials, pvVerifyMarshal, pvVerify, "ptr", pAuxInfo, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<PFN_CRYPT_CANCEL_RETRIEVAL>} pfnCancel 
     * @param {Pointer<Void>} pvArg 
     * @param {Integer} dwFlags 
     * @returns {BOOL} 
     */
    static CryptInstallCancelRetrieval(pfnCancel, pvArg, dwFlags) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        pvArgMarshal := pvArg is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPTNET.dll\CryptInstallCancelRetrieval", "ptr", pfnCancel, pvArgMarshal, pvArg, "uint", dwFlags, "ptr", pvReserved, "int")
        return result
    }

    /**
     * 
     * @param {Integer} dwFlags 
     * @returns {BOOL} 
     */
    static CryptUninstallCancelRetrieval(dwFlags) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("CRYPTNET.dll\CryptUninstallCancelRetrieval", "uint", dwFlags, "ptr", pvReserved, "int")
        return result
    }

    /**
     * Acquires the URL of the remote object from a certificate, certificate trust list (CTL), or certificate revocation list (CRL).
     * @param {PSTR} pszUrlOid A pointer to an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) that identifies the URL being requested. If the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a> of the <i>pszUrlOid</i> parameter is zero, the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> specifies the integer identifier for the type of the specified structure.
     * @param {Pointer<Void>} pvPara A structure determined by the value of <i>pszUrlOid</i>. For details, see the description for the <i>pszUrlOid</i> parameter.
     * @param {Integer} dwFlags 
     * @param {Pointer} pUrlArray A pointer to a buffer to receive the data for the value entry. This parameter can be <b>NULL</b> to find the length of the buffer required to hold the data. 
     * 
     * 
     * For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbUrlArray A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pUrlArray</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer. This parameter can be <b>NULL</b> only if <i>pUrlArray</i> is <b>NULL</b>.
     * @param {Pointer} pUrlInfo An optional pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_url_info">CRYPT_URL_INFO</a> structure that receives the data for the value entry.
     * @param {Pointer<Integer>} pcbUrlInfo A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pUrlArray</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptgetobjecturl
     * @since windows5.1.2600
     */
    static CryptGetObjectUrl(pszUrlOid, pvPara, dwFlags, pUrlArray, pcbUrlArray, pUrlInfo, pcbUrlInfo) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        pszUrlOid := pszUrlOid is String ? StrPtr(pszUrlOid) : pszUrlOid

        pvParaMarshal := pvPara is VarRef ? "ptr" : "ptr"
        pcbUrlArrayMarshal := pcbUrlArray is VarRef ? "uint*" : "ptr"
        pcbUrlInfoMarshal := pcbUrlInfo is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPTNET.dll\CryptGetObjectUrl", "ptr", pszUrlOid, pvParaMarshal, pvPara, "uint", dwFlags, "ptr", pUrlArray, pcbUrlArrayMarshal, pcbUrlArray, "ptr", pUrlInfo, pcbUrlInfoMarshal, pcbUrlInfo, "ptr", pvReserved, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Builds a self-signed certificate and returns a pointer to a CERT_CONTEXT structure that represents the certificate.
     * @param {HCRYPTPROV_OR_NCRYPT_KEY_HANDLE} hCryptProvOrNCryptKey A handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic provider</a> used to sign the certificate created. If <b>NULL</b>, information from the <i>pKeyProvInfo</i> parameter is used to acquire the needed handle. If <i>pKeyProvInfo</i> is also <b>NULL</b>, the default provider type, PROV_RSA_FULL provider type, the default key specification, AT_SIGNATURE, and a newly created <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a> with a unique container name are used.
     * 
     * This handle must be an <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a> handle that has been created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function or an <b>NCRYPT_KEY_HANDLE</b> handle that has been created by using the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenkey">NCryptOpenKey</a> function. New applications should always pass in the <b>NCRYPT_KEY_HANDLE</b> handle of a CNG <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP).
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pSubjectIssuerBlob A pointer to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a> that contains the distinguished name (DN) for the certificate subject. This parameter cannot be <b>NULL</b>. Minimally, a pointer to an empty DN must be provided. This BLOB is normally created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certstrtonamea">CertStrToName</a> function. It can also be created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencodeobject">CryptEncodeObject</a> function and specifying either the X509_NAME or X509_UNICODE_NAME <i>StructType</i>.
     * @param {Integer} dwFlags 
     * @param {Pointer<CRYPT_KEY_PROV_INFO>} pKeyProvInfo A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a> structure. Before a certificate is created, the CSP is queried for the key provider, key provider type, and the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a> name. If the CSP queried does not support these queries, the function fails. If the default provider does not support these queries, a <i>pKeyProvInfo</i> value must be specified. The RSA BASE does support these queries.
     * 
     * If the <i>pKeyProvInfo</i> parameter is not <b>NULL</b>, the corresponding values are set in the <b>CERT_KEY_PROV_INFO_PROP_ID</b> value of the generated certificate. You must ensure that all parameters of the supplied structure are correctly specified.
     * @param {Pointer<CRYPT_ALGORITHM_IDENTIFIER>} pSignatureAlgorithm A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_algorithm_identifier">CRYPT_ALGORITHM_IDENTIFIER</a> structure. If <b>NULL</b>, the default algorithm, SHA1RSA, is used.
     * @param {Pointer<SYSTEMTIME>} pStartTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure. If <b>NULL</b>, the system current time is used by default.
     * @param {Pointer<SYSTEMTIME>} pEndTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure. If <b>NULL</b>, the <i>pStartTime</i> value plus one year will be used by default.
     * @param {Pointer<CERT_EXTENSIONS>} pExtensions A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_extensions">CERT_EXTENSIONS</a> array of <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_extension">CERT_EXTENSION</a> structures. By default, the array is empty. An alternate subject name, if desired, can be specified as one of these extensions.
     * @returns {Pointer<CERT_CONTEXT>} If the function succeeds, a <a href="/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">PCCERT_CONTEXT</a> variable that points to the created certificate is returned. If the function fails, it returns <b>NULL</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certcreateselfsigncertificate
     * @since windows5.1.2600
     */
    static CertCreateSelfSignCertificate(hCryptProvOrNCryptKey, pSubjectIssuerBlob, dwFlags, pKeyProvInfo, pSignatureAlgorithm, pStartTime, pEndTime, pExtensions) {
        hCryptProvOrNCryptKey := hCryptProvOrNCryptKey is Win32Handle ? NumGet(hCryptProvOrNCryptKey, "ptr") : hCryptProvOrNCryptKey

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertCreateSelfSignCertificate", "ptr", hCryptProvOrNCryptKey, "ptr", pSubjectIssuerBlob, "uint", dwFlags, "ptr", pKeyProvInfo, "ptr", pSignatureAlgorithm, "ptr", pStartTime, "ptr", pEndTime, "ptr", pExtensions, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptGetKeyIdentifierProperty acquires a specific property from a specified key identifier.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pKeyIdentifier A pointer to the 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a> that contains the key identifier.
     * @param {Integer} dwPropId Identifies the property to retrieve. The value of <i>dwPropId</i> determines the type and content of the <i>pvData</i> parameter. Any certificate property ID can be used.
     * @param {Integer} dwFlags The following flags can be used. They can be combined with a bitwise-<b>OR</b> operation. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_KEYID_MACHINE_FLAG"></a><a id="crypt_keyid_machine_flag"></a><dl>
     * <dt><b>CRYPT_KEYID_MACHINE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Search the list of key identifiers of the LocalMachine (if <i>pwszComputerName</i> is <b>NULL</b>) or remote computer (if <i>pwszComputerName</i> is not <b>NULL</b>). For more information, see <i>pwszComputerName</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_KEYID_ALLOC_FLAG"></a><a id="crypt_keyid_alloc_flag"></a><dl>
     * <dt><b>CRYPT_KEYID_ALLOC_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>LocalAlloc()</b> function is called to allocate memory for <i>pvData</i>. *<i>pvData</i> is updated with a pointer to the allocated memory. <b>LocalFree()</b> must be called to free the allocated memory.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} pwszComputerName A pointer to the name of a remote computer to be searched. If CRYPT_KEYID_MACHINE_FLAG flag is set, searches the remote computer for a list of key identifiers. If the local computer is to be searched and not a remote computer, set <i>pwszComputerName</i> to <b>NULL</b>.
     * @param {Pointer} pvData A pointer to a buffer to receive the data as determined by <i>dwPropId</i>. Elements pointed to by fields in the <i>pvData</i> structure follow the structure. Therefore, the size contained in <i>pcbData</i> can exceed the size of the structure. 
     * 
     * 
     * 
     * 
     * If <i>dwPropId</i> is CERT_KEY_PROV_INFO_PROP_ID, <i>pvData</i> points to a CRYPT_KEY_PROV_INFO structure that contains the property of the key identifier.
     * 
     * If <i>dwPropId</i> is not CERT_KEY_PROV_INFO_PROP_ID, <i>pvData</i> points to an array of bytes that contains the property of the key identifier.
     * 
     * To get the size of this information for memory allocation purposes, this parameter can be <b>NULL</b> when the CRYPT_KEYID_ALLOC_FLAG is not set. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * 
     * When the CRYPT_KEYID_ALLOC_FLAG is set, <i>pvData</i> is the address of a pointer to the buffer that will be updated. Because memory is allocated and its pointer is stored at *<i>pvData</i>, <i>pvData</i> must not be <b>NULL</b>.
     * @param {Pointer<Integer>} pcbData A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer. The size contained in the variable pointed to by <i>pcbData</i> can indicate a size larger than the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a> structure because the structure can contain pointers to auxiliary data. This size is the sum of the size needed by the structure and all auxiliary data. 
     * 
     * 
     * 
     * 
     * When the CRYPT_KEYID_ALLOC_FLAG is set, <i>pcbData</i> is the address of a pointer to the <b>DWORD</b> that will be updated.
     * 
     * <div class="alert"><b>Note</b>When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div></div>
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptgetkeyidentifierproperty
     * @since windows5.1.2600
     */
    static CryptGetKeyIdentifierProperty(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvData, pcbData) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        pwszComputerName := pwszComputerName is String ? StrPtr(pwszComputerName) : pwszComputerName

        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptGetKeyIdentifierProperty", "ptr", pKeyIdentifier, "uint", dwPropId, "uint", dwFlags, "ptr", pwszComputerName, "ptr", pvReserved, "ptr", pvData, pcbDataMarshal, pcbData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptSetKeyIdentifierProperty function sets the property of a specified key identifier. This function can set the property on the computer identified in pwszComputerName.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pKeyIdentifier A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a> containing the key identifier.
     * @param {Integer} dwPropId Identifies the property to be set. The value of <i>dwPropId</i> determines the type and content of the <i>pvData</i> parameter. Any certificate property ID can be used. CERT_KEY_PROV_INFO_PROP_ID is the property of most interest.
     * @param {Integer} dwFlags The following flags can be set. They can be combined with a bitwise-<b>OR</b> operation.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_KEYID_MACHINE_FLAG"></a><a id="crypt_keyid_machine_flag"></a><dl>
     * <dt><b>CRYPT_KEYID_MACHINE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the property of the LocalMachine (if <i>pwszComputerName</i> is <b>NULL</b>) or remote computer (if <i>pwszComputerName</i> is not <b>NULL</b>). For more information, see <i>pwszComputerName</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_KEYID_DELETE_FLAG"></a><a id="crypt_keyid_delete_flag"></a><dl>
     * <dt><b>CRYPT_KEYID_DELETE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key identifier and all of its properties are deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_KEYID_SET_NEW_FLAG"></a><a id="crypt_keyid_set_new_flag"></a><dl>
     * <dt><b>CRYPT_KEYID_SET_NEW_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets a new key identifier property. If the property already exists, the attempt fails, and <b>FALSE</b> is returned with the last error code set to CRYPT_E_EXISTS.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} pwszComputerName A pointer to a <b>null</b>-terminated string that contains the name of a remote computer that has the key identifier where the properties are set. If CRYPT_KEYID_MACHINE_FLAG flag is set, searches the remote computer for a list of key identifiers. If the local computer is to be set and not a remote computer, set <i>pwszComputerName</i> to <b>NULL</b>.
     * @param {Pointer<Void>} pvData If <i>dwPropId</i> is CERT_KEY_PROV_INFO_PROP_ID, <i>pvData</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a> structure containing the property of the key identifier. 
     * 
     * 
     * 
     * 
     * If <i>dwPropId</i> is not CERT_KEY_PROV_INFO_PROP_ID, <i>pvData</i> points to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure containing the property of the key identifier.
     * 
     * Setting <i>pvData</i> to <b>NULL</b> deletes the property.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>If CRYPT_KEYID_SET_NEW_FLAG is set and the property already exists, <b>FALSE</b> is returned with the last error code set to CRYPT_E_EXISTS.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptsetkeyidentifierproperty
     * @since windows5.1.2600
     */
    static CryptSetKeyIdentifierProperty(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvData) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        pwszComputerName := pwszComputerName is String ? StrPtr(pwszComputerName) : pwszComputerName

        pvDataMarshal := pvData is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptSetKeyIdentifierProperty", "ptr", pKeyIdentifier, "uint", dwPropId, "uint", dwFlags, "ptr", pwszComputerName, "ptr", pvReserved, pvDataMarshal, pvData, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CryptEnumKeyIdentifierProperties function enumerates key identifiers and their properties.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pKeyIdentifier A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a> structure that contains the key identifier. 
     * 
     * 
     * 
     * 
     * If <i>pKeyIdentifier</i> is <b>NULL</b>, the function enumerates all key identifiers.
     * 
     * If <i>pKeyIdentifier</i> is not <b>NULL</b>, the callback function <i>pfnEnum</i> is only called for the specified key identifier.
     * @param {Integer} dwPropId Indicates the property identifier to be listed. 
     * 
     * 
     * 
     * 
     * If <i>dwPropId</i> is set to zero, this function calls the callback function with all the properties.
     * 
     * If <i>dwPropId</i> is not zero and <i>pKeyIdentifier</i> is <b>NULL</b>, the callback function is called only for those key identifiers that have the specified property (sets the <i>cProp</i> parameter of <i>pfnEnum</i> to one). All key identifiers that do not have the property are skipped.
     * 
     * Any certificate property identifier can be used.
     * @param {Integer} dwFlags By default, the list of key identifiers for the CurrentUser is searched. If CRYPT_KEYID_MACHINE_FLAG is set, the list of key identifiers of the LocalMachine (if <i>pwszComputerName</i> is <b>NULL</b>) or of a remote computer (if <i>pwszComputerName</i> is not <b>NULL</b>) is searched. For more information, see <i>pwszComputerName</i>.
     * @param {PWSTR} pwszComputerName A pointer to the name of a remote computer to be searched. If CRYPT_KEYID_MACHINE_FLAG is set in <i>dwFlags</i>, the remote computer is searched for a list of key identifiers. If the local computer is to be searched and not a remote computer, <i>pwszComputerName</i> is set to <b>NULL</b>.
     * @param {Pointer<Void>} pvArg A pointer to data to be passed to the callback function. The type is a void that allows the application to declare, define, and initialize a structure or argument to hold any information.
     * @param {Pointer<PFN_CRYPT_ENUM_KEYID_PROP>} pfnEnum A pointer to an application-defined callback function that is executed for each key identifier entry that matches the input parameters. For details about the callback functions parameters, see <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nc-wincrypt-pfn_crypt_enum_keyid_prop">CRYPT_ENUM_KEYID_PROP</a>.
     * @returns {BOOL} The <b>CryptEnumKeyIdentifierProperties</b> function repeatedly calls the <a href="/windows/desktop/api/wincrypt/nc-wincrypt-pfn_crypt_enum_keyid_prop">CRYPT_ENUM_KEYID_PROP</a> callback function until the last key identifier is enumerated or the callback function returns <b>FALSE</b>.
     * 
     * If the main function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * To continue enumeration, the function returns <b>TRUE</b>.
     * 
     * To stop enumeration, the function returns <b>FALSE</b> and sets the last error code.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptenumkeyidentifierproperties
     * @since windows5.1.2600
     */
    static CryptEnumKeyIdentifierProperties(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvArg, pfnEnum) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        pwszComputerName := pwszComputerName is String ? StrPtr(pwszComputerName) : pwszComputerName

        pvArgMarshal := pvArg is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptEnumKeyIdentifierProperties", "ptr", pKeyIdentifier, "uint", dwPropId, "uint", dwFlags, "ptr", pwszComputerName, "ptr", pvReserved, pvArgMarshal, pvArg, "ptr", pfnEnum, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * ImportantThis API is deprecated.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {PSTR} pszPubKeyOID A pointer to the public key <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID). A value that is not <b>NULL</b> overrides the default OID obtained from the <b>aiKeyAlg</b> member of the structure pointed to by <i>pPubKeyStruc</i>. To use the default OID, set <i>pszPubKeyOID</i> to <b>NULL</b>.
     * @param {Pointer} pPubKeyStruc A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-publickeystruc">PUBLICKEYSTRUC</a> structure. In the default case, the <b>aiKeyAlg</b> member of the structure pointed to by <i>pPubKeyStruc</i> is used to find the public key OID. When the value of <i>pszPubKeyOID</i> is not <b>NULL</b>, it overrides the default.
     * @param {Integer} cbPubKeyStruc The size, in bytes, of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-publickeystruc">PUBLICKEYSTRUC</a>.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer} pbHash A pointer to a buffer to receive the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> of the public key and the key identifier.
     * 
     * To get the size of this information for memory allocation purposes, set this parameter to <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<Integer>} pcbHash A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pbHash</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer. Using SHA1 hashing, the length of the required buffer is twenty.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptcreatekeyidentifierfromcsp
     * @since windows5.1.2600
     */
    static CryptCreateKeyIdentifierFromCSP(dwCertEncodingType, pszPubKeyOID, pPubKeyStruc, cbPubKeyStruc, dwFlags, pbHash, pcbHash) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        pszPubKeyOID := pszPubKeyOID is String ? StrPtr(pszPubKeyOID) : pszPubKeyOID

        pcbHashMarshal := pcbHash is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptCreateKeyIdentifierFromCSP", "uint", dwCertEncodingType, "ptr", pszPubKeyOID, "ptr", pPubKeyStruc, "uint", cbPubKeyStruc, "uint", dwFlags, "ptr", pvReserved, "ptr", pbHash, pcbHashMarshal, pcbHash, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertCreateCertificateChainEngine function creates a new, nondefault chain engine for an application.
     * @param {Pointer<CERT_CHAIN_ENGINE_CONFIG>} pConfig A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_engine_config">CERT_CHAIN_ENGINE_CONFIG</a> data structure that specifies the parameters for the chain engine.
     * @param {Pointer<HCERTCHAINENGINE>} phChainEngine A pointer to the handle of the chain engine created. When you have finished using the chain engine, release the chain engine by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatechainengine">CertFreeCertificateChainEngine</a> function.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The <i>phChainEngine</i> parameter returns the chain engine handle.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certcreatecertificatechainengine
     * @since windows5.1.2600
     */
    static CertCreateCertificateChainEngine(pConfig, phChainEngine) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertCreateCertificateChainEngine", "ptr", pConfig, "ptr", phChainEngine, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertFreeCertificateChainEngine function frees a certificate trust engine.
     * @param {HCERTCHAINENGINE} hChainEngine Handle of the chain engine to be freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certfreecertificatechainengine
     * @since windows5.1.2600
     */
    static CertFreeCertificateChainEngine(hChainEngine) {
        hChainEngine := hChainEngine is Win32Handle ? NumGet(hChainEngine, "ptr") : hChainEngine

        DllCall("CRYPT32.dll\CertFreeCertificateChainEngine", "ptr", hChainEngine)
    }

    /**
     * Resyncs the certificate chain engine, which resynchronizes the stores the store's engine and updates the engine caches.
     * @param {HCERTCHAINENGINE} hChainEngine The chain engine to resynchronize.
     * @returns {BOOL} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certresynccertificatechainengine
     * @since windows10.0.10240
     */
    static CertResyncCertificateChainEngine(hChainEngine) {
        hChainEngine := hChainEngine is Win32Handle ? NumGet(hChainEngine, "ptr") : hChainEngine

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertResyncCertificateChainEngine", "ptr", hChainEngine, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Builds a certificate chain context starting from an end certificate and going back, if possible, to a trusted root certificate.
     * @param {HCERTCHAINENGINE} hChainEngine A handle of the chain engine (namespace and cache) to be used. If <i>hChainEngine</i> is <b>NULL</b>, the default chain engine, HCCE_CURRENT_USER, is used. This parameter can be set to HCCE_LOCAL_MACHINE.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> of the end certificate, the certificate for which a chain is being built. This certificate context will be the zero-index element in the first simple chain.
     * @param {Pointer<FILETIME>} pTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> variable that indicates the time for which the chain is to be validated. Note that the time does not affect trust list, revocation, or root store checking. The current system time is used if <b>NULL</b> is passed to this parameter. Trust in a particular certificate being a trusted root is based on the current <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">state</a> of the root store and not the state of the root store at a time passed in by this parameter. For revocation, a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate revocation list</a> (CRL), itself, must be valid at the current time. The value of this parameter is used to determine whether a certificate listed in a CRL has been revoked.
     * @param {HCERTSTORE} hAdditionalStore A handle to any additional store to search for supporting certificates and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate trust lists</a> (CTLs). This parameter can be <b>NULL</b> if no additional store is to be searched.
     * @param {Pointer<CERT_CHAIN_PARA>} pChainPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_para">CERT_CHAIN_PARA</a> structure that includes chain-building parameters.
     * @param {Integer} dwFlags Flag values that indicate special processing. This parameter can be a combination of one or more of the  following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_CACHE_END_CERT"></a><a id="cert_chain_cache_end_cert"></a><dl>
     * <dt><b>CERT_CHAIN_CACHE_END_CERT</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When this flag is set, the end certificate is cached, which might speed up the chain-building process. By default, the end certificate is not cached, and it would need to be verified each time a chain is built for it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY"></a><a id="cert_chain_revocation_check_cache_only"></a><dl>
     * <dt><b>CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY</b></dt>
     * <dt>0x80000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Revocation checking only accesses cached URLs.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_REVOCATION_CHECK_OCSP_CERT"></a><a id="cert_chain_revocation_check_ocsp_cert"></a><dl>
     * <dt><b>CERT_CHAIN_REVOCATION_CHECK_OCSP_CERT</b></dt>
     * <dt>0x04000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is used internally during chain building for an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">online certificate status protocol</a> (OCSP) signer certificate to prevent cyclic revocation checks. During chain building, if the OCSP response is signed by an independent OCSP signer, then, in addition to the original chain build, there is a second chain built for the OCSP signer certificate itself. This flag is used during this second chain build to inhibit a recursive independent OCSP signer certificate. If the signer certificate contains the
     * <b>szOID_PKIX_OCSP_NOCHECK</b> extension, revocation checking is skipped
     * for the leaf signer certificate. Both OCSP and CRL checking are allowed.
     * 
     * <b>Windows Server2003 and WindowsXP:</b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL"></a><a id="cert_chain_cache_only_url_retrieval"></a><dl>
     * <dt><b>CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uses only cached URLs in building a certificate chain. The Internet and intranet are not searched for URL-based objects. 
     * 
     * <b>Note</b>This flag is not applicable to revocation checking. Set CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY to use only cached URLs for revocation checking.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING"></a><a id="cert_chain_disable_pass1_quality_filtering"></a><dl>
     * <dt><b>CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING</b></dt>
     * <dt>0x00000040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For performance reasons, the second pass of chain building only considers potential chain paths that have quality greater than or equal to the highest quality determined during the first pass. The first pass only considers valid signature, complete chain, and trusted roots to calculate chain quality. This flag can be set to disable this optimization and consider all potential chain paths during the second pass.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_DISABLE_MY_PEER_TRUST"></a><a id="cert_chain_disable_my_peer_trust"></a><dl>
     * <dt><b>CERT_CHAIN_DISABLE_MY_PEER_TRUST</b></dt>
     * <dt>0x00000800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not supported. Certificates in the "My" store are never considered for peer trust.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_ENABLE_PEER_TRUST"></a><a id="cert_chain_enable_peer_trust"></a><dl>
     * <dt><b>CERT_CHAIN_ENABLE_PEER_TRUST</b></dt>
     * <dt>0x00000400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * End entity certificates in the "TrustedPeople" store are trusted without performing any chain building. This function does not set the <b>CERT_TRUST_IS_PARTIAL_CHAIN</b> or <b>CERT_TRUST_IS_UNTRUSTED_ROOT</b> <b>dwErrorStatus</b> member bits of the  <i>ppChainContext</i> parameter.
     * 
     * <b>
     *                     Windows Server2003
     *                     WindowsXP
     *                   :</b>This flag is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_OPT_IN_WEAK_SIGNATURE"></a><a id="cert_chain_opt_in_weak_signature"></a><dl>
     * <dt><b>CERT_CHAIN_OPT_IN_WEAK_SIGNATURE</b></dt>
     * <dt>0x00010000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Setting this flag indicates the caller wishes to opt into weak signature checks.
     * 
     * This flag is available in the rollup update for each OS starting with Windows7 and Windows Server2008R2.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS"></a><a id="cert_chain_return_lower_quality_contexts"></a><dl>
     * <dt><b>CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS</b></dt>
     * <dt>0x00000080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The default is to return only the highest quality chain path. Setting this flag will return the lower quality chains. These are returned in the <b>cLowerQualityChainContext</b> and <b>rgpLowerQualityChainContext</b> fields of the chain context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE"></a><a id="cert_chain_disable_auth_root_auto_update"></a><dl>
     * <dt><b>CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE</b></dt>
     * <dt>0x00000100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Setting this flag inhibits the auto update of third-party roots from the Windows Update Web Server.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT"></a><a id="cert_chain_revocation_accumulative_timeout"></a><dl>
     * <dt><b>CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT</b></dt>
     * <dt>0x08000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When you set CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT and you also specify a value for the <i>dwUrlRetrievalTimeout</i> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_para">CERT_CHAIN_PARA</a> structure, the value you specify in <i>dwUrlRetrievalTimeout</i> represents the cumulative timeout across all revocation URL retrievals.
     * 
     * If you set CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT but do not specify a <i>dwUrlRetrievalTimeout</i> value, the maximum cumulative timeout is set, by default, to 20 seconds. Each URL tested will timeout after half of the remaining cumulative balance has passed. That is, the first URL times out after 10 seconds, the second after 5 seconds, the third after 2.5 seconds and so on until a URL succeeds, 20 seconds has passed, or there are no more URLs to test.
     * 
     * If you do not set CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT, each revocation URL in the chain is assigned a maximum timeout equal to the value specified in <i>dwUrlRetrievalTimeout</i>. If you do not specify a value for the <i>dwUrlRetrievalTimeout</i> member, each revocation URL is assigned a maximum default timeout of 15 seconds.  If no URL succeeds, the maximum cumulative timeout value is 15 seconds multiplied by the number of URLs in the chain.
     * 
     * You can set the default values by using Group Policy.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_TIMESTAMP_TIME"></a><a id="cert_chain_timestamp_time"></a><dl>
     * <dt><b>CERT_CHAIN_TIMESTAMP_TIME</b></dt>
     * <dt>0x00000200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When this flag is set, <i>pTime</i> is used as the time stamp time to determine whether the end certificate was time valid. Current time can also be used to determine whether the end certificate remains time valid. All other <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certification authority</a> (CA) and root certificates in the chain are checked by using current time and not <i>pTime</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_DISABLE_AIA"></a><a id="cert_chain_disable_aia"></a><dl>
     * <dt><b>CERT_CHAIN_DISABLE_AIA</b></dt>
     * <dt>0x00002000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Setting this flag explicitly turns off  Authority Information Access (AIA) retrievals.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * You can also set the following revocation flags, but only one flag from this group may be set at a time.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_REVOCATION_CHECK_END_CERT"></a><a id="cert_chain_revocation_check_end_cert"></a><dl>
     * <dt><b>CERT_CHAIN_REVOCATION_CHECK_END_CERT</b></dt>
     * <dt>0x10000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Revocation checking is done on the end certificate and only the end certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_REVOCATION_CHECK_CHAIN"></a><a id="cert_chain_revocation_check_chain"></a><dl>
     * <dt><b>CERT_CHAIN_REVOCATION_CHECK_CHAIN</b></dt>
     * <dt>0x20000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Revocation checking is done on all of the certificates in every chain.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT"></a><a id="cert_chain_revocation_check_chain_exclude_root"></a><dl>
     * <dt><b>CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT</b></dt>
     * <dt>0x40000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Revocation checking is done on all certificates in all of the chains except the root certificate.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Pointer<CERT_CHAIN_CONTEXT>>} ppChainContext The address of a pointer to the chain context created. When you have finished using the chain context, release the chain by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatechain">CertFreeCertificateChain</a> function.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns  zero (<b>FALSE</b>). For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certgetcertificatechain
     * @since windows5.1.2600
     */
    static CertGetCertificateChain(hChainEngine, pCertContext, pTime, hAdditionalStore, pChainPara, dwFlags, ppChainContext) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        hChainEngine := hChainEngine is Win32Handle ? NumGet(hChainEngine, "ptr") : hChainEngine
        hAdditionalStore := hAdditionalStore is Win32Handle ? NumGet(hAdditionalStore, "ptr") : hAdditionalStore

        ppChainContextMarshal := ppChainContext is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetCertificateChain", "ptr", hChainEngine, "ptr", pCertContext, "ptr", pTime, "ptr", hAdditionalStore, "ptr", pChainPara, "uint", dwFlags, "ptr", pvReserved, ppChainContextMarshal, ppChainContext, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * The CertFreeCertificateChain function frees a certificate chain by reducing its reference count. If the reference count becomes zero, memory allocated for the chain is released.
     * @param {Pointer<CERT_CHAIN_CONTEXT>} pChainContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> certificate chain context to be freed. If the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> on the context reaches zero, the storage allocated for the context is freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certfreecertificatechain
     * @since windows5.1.2600
     */
    static CertFreeCertificateChain(pChainContext) {
        DllCall("CRYPT32.dll\CertFreeCertificateChain", "ptr", pChainContext)
    }

    /**
     * The CertDuplicateCertificateChain function duplicates a pointer to a certificate chain by incrementing the chain's reference count.
     * @param {Pointer<CERT_CHAIN_CONTEXT>} pChainContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> chain context to be duplicated.
     * @returns {Pointer<CERT_CHAIN_CONTEXT>} If the function succeeds, a pointer is returned to the chain context. This pointer has the same value as the <i>pChainContext</i> passed into the function. When you have finished using the chain context, release the chain context by calling the <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatechain">CertFreeCertificateChain</a> function.
     * 
     * If the function fails, <b>NULL</b> is returned.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certduplicatecertificatechain
     * @since windows5.1.2600
     */
    static CertDuplicateCertificateChain(pChainContext) {
        result := DllCall("CRYPT32.dll\CertDuplicateCertificateChain", "ptr", pChainContext, "ptr")
        return result
    }

    /**
     * Finds the first or next certificate in a store that meets the specified criteria.
     * @param {HCERTSTORE} hCertStore The handle of the store to be searched for a certificate upon which a chain is built. This handle is passed as an additional store to 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatechain">CertGetCertificateChain</a> function as the chain is built.
     * @param {Integer} dwCertEncodingType The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a>   that was used to encode the store. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> identifier, contained in the high <b>WORD</b> of this value, is ignored by this function.
     * 
     * 
     * This parameter can be the following currently defined certificate encoding type.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies X.509 certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFindFlags Contains additional options for the search. The possible values for this parameter depend on the value of the <i>dwFindType</i> parameter.
     * @param {Integer} dwFindType Determines what criteria to use to find a certificate in the store.
     * 
     * 
     * This parameter can be the following currently defined value.
     * @param {Pointer<Void>} pvFindPara A pointer that contains additional search criteria. The type and format of the data this parameter points to depends on the value of the <i>dwFindType</i> parameter.
     * @param {Pointer<CERT_CHAIN_CONTEXT>} pPrevChainContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> structure returned from a previous call to this function. The search is begun from this certificate. For the first call to this function, this parameter must be <b>NULL</b>. In subsequent calls, it is the pointer returned by the previous call to the function.  If this parameter is not <b>NULL</b>, this function will free this structure.
     * @returns {Pointer<CERT_CHAIN_CONTEXT>} If the first or next chain context is not built, <b>NULL</b> is returned. Otherwise, a pointer to a read-only <a href="/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> structure is returned. The <b>CERT_CHAIN_CONTEXT</b> structure is freed when passed as the <i>pPrevChainContext</i> parameter on a subsequent call to this function. Otherwise, the <b>CERT_CHAIN_CONTEXT</b> structure must be freed explicitly by calling 
     * the <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatechain">CertFreeCertificateChain</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certfindchaininstore
     * @since windows5.1.2600
     */
    static CertFindChainInStore(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevChainContext) {
        hCertStore := hCertStore is Win32Handle ? NumGet(hCertStore, "ptr") : hCertStore

        pvFindParaMarshal := pvFindPara is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPT32.dll\CertFindChainInStore", "ptr", hCertStore, "uint", dwCertEncodingType, "uint", dwFindFlags, "uint", dwFindType, pvFindParaMarshal, pvFindPara, "ptr", pPrevChainContext, "ptr")
        return result
    }

    /**
     * Checks a certificate chain to verify its validity, including its compliance with any specified validity policy criteria.
     * @param {PSTR} pszPolicyOID Current predefined verify chain policy structures are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_BASE"></a><a id="cert_chain_policy_base"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_BASE</b></dt>
     * <dt>(LPCSTR) 1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Implements the base chain policy verification checks. The <b>dwFlags</b> member of the structure pointed to by <i>pPolicyPara</i> can be set to alter the default policy checking behavior.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_AUTHENTICODE"></a><a id="cert_chain_policy_authenticode"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_AUTHENTICODE</b></dt>
     * <dt>(LPCSTR) 2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Implements the Authenticode chain policy verification checks. The <b>pvExtraPolicyPara</b> member of the structure pointed to by <i>pPolicyPara</i> can be set to point to an 
     * <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-authenticode_extra_cert_chain_policy_para">AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA</a> structure.
     * 
     * The <b>pvExtraPolicyStatus</b> member of the structure pointed to by <i>pPolicyStatus</i> can be set to point to an <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-authenticode_extra_cert_chain_policy_status">AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_AUTHENTICODE_TS"></a><a id="cert_chain_policy_authenticode_ts"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_AUTHENTICODE_TS</b></dt>
     * <dt>(LPCSTR) 3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Implements Authenticode Time Stamp chain policy verification checks. The <b>pvExtraPolicyPara</b> member of the data structure pointed to by <i>pPolicyPara</i> can be set to point to an <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-authenticode_ts_extra_cert_chain_policy_para">AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA</a> structure.
     * 
     * The <b>pvExtraPolicyStatus</b> member of the data structure pointed to by <i>pPolicyStatus</i> is not used and must be set to <b>NULL</b>
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_SSL"></a><a id="cert_chain_policy_ssl"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_SSL</b></dt>
     * <dt>(LPCSTR) 4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Implements the SSL client/server chain policy verification checks. The <b>pvExtraPolicyPara</b> member in the data structure pointed to by <i>pPolicyPara</i> can be set to point to an <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-httpspolicycallbackdata">SSL_EXTRA_CERT_CHAIN_POLICY_PARA</a> structure initialized with additional policy criteria.
     * 
     * <div class="alert"><b>Note</b>To differentiate between server and client authorization certificates,  the call to the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatechain">CertGetCertificateChain</a> function to get the chain context should specify the  certificate type by setting the expected usage. Set the expected usage by setting the <b>RequestedUsage</b> member of the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_para">CERT_CHAIN_PARA</a> structure passed in the <i>pChainPara</i> input parameter of the <b>CertGetCertificateChain</b> function.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_BASIC_CONSTRAINTS"></a><a id="cert_chain_policy_basic_constraints"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_BASIC_CONSTRAINTS</b></dt>
     * <dt>(LPCSTR) 5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Implements the basic constraints chain policy. Iterates through all the certificates in the chain checking for either a szOID_BASIC_CONSTRAINTS or a szOID_BASIC_CONSTRAINTS2 extension. If neither extension is present, the certificate is assumed to have valid policy. Otherwise, for the first certificate element, checks if it matches the expected CA_FLAG or END_ENTITY_FLAG specified in the <b>dwFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_policy_para">CERT_CHAIN_POLICY_PARA</a> structure pointed to by the <i>pPolicyPara</i> parameter. If neither or both flags are set, then, the first element can be either a CA or END_ENTITY. All other elements must be a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certification authority</a> (CA). If the PathLenConstraint is present in the extension, it is checked.
     * 
     * The first elements in the remaining simple chains (that is, the certificates used to sign the CTL) are checked to be an END_ENTITY. If this verification fails, <b>dwError</b> will be set to TRUST_E_BASIC_CONSTRAINTS.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_NT_AUTH"></a><a id="cert_chain_policy_nt_auth"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_NT_AUTH</b></dt>
     * <dt>(LPCSTR) 6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Implements the WindowsNT Authentication chain policy, which consists of three distinct chain verifications in the following order: 
     * 
     * 
     * 
     * 
     * <ol>
     * <li>CERT_CHAIN_POLICY_BASEImplements the base chain policy verification checks. The LOWORD of <i>dwFlags</i> can be set in <i>pPolicyPara</i> to alter the default policy checking behavior. For more information, see CERT_CHAIN_POLICY_BASE.</li>
     * <li>CERT_CHAIN_POLICY_BASIC_CONSTRAINTSImplements the basic constraints chain policy. The HIWORD of <i>dwFlags</i> can be set to specify if the first element must be either a CA or END_ENTITY. For more information, see CERT_CHAIN_POLICY_BASIC_CONSTRAINTS.</li>
     * <li>Checks if the second element in the chain, the CA that issued the end certificate, is a trusted CA for WindowsNT Authentication. A CA is considered to be trusted if it exists in the "NTAuth" system registry store found in the CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE store location. If this verification fails, the CA is untrusted, and <i>dwError</i> is set to CERT_E_UNTRUSTEDCA.If CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG is set in the <b>Flags</b> value of the <b>HKEY_LOCAL_MACHINE</b> policy <b>ProtectedRoots</b> subkey, defined by CERT_PROT_ROOT_FLAGS_REGPATH and the above check fails, the chain is checked for CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS set in <i>dwInfoStatus</i>. This is set if there was a valid name constraint for all namespaces including UPN. If the chain does not have this info status set, <i>dwError</i> is set to CERT_E_UNTRUSTEDCA.
     * 
     * </li>
     * </ol>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_MICROSOFT_ROOT"></a><a id="cert_chain_policy_microsoft_root"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_MICROSOFT_ROOT</b></dt>
     * <dt>(LPCSTR) 7</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Checks the last element of the first simple chain for a Microsoft root public key. If that element does not contain a Microsoft root public key, the <b>dwError</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_policy_status">CERT_CHAIN_POLICY_STATUS</a> structure pointed to by the <i>pPolicyStatus</i> parameter is set to <b>CERT_E_UNTRUSTEDROOT</b>.
     * 
     * The <b>dwFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_policy_para">CERT_CHAIN_POLICY_PARA</a> structure pointed to by the <i>pPolicyStatus</i> parameter can contain the <b>MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG</b> flag, which causes this function to instead check for the Microsoft application root "Microsoft Root Certificate Authority 2011".
     * 
     * The <b>dwFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_policy_para">CERT_CHAIN_POLICY_PARA</a> structure pointed to by the <i>pPolicyPara</i> parameter can contain the <b>MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG</b> flag, which causes this function to also check for the Microsoft test roots.
     * 
     * <div class="alert"><b>Note</b>This policy <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) does not perform any policy verification checks by itself, it is meant to be used in conjunction with other policies.
     * </div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_EV"></a><a id="cert_chain_policy_ev"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_EV</b></dt>
     * <dt>(LPCSTR) 8</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies that extended validation of certificates is performed.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP:</b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_SSL_F12"></a><a id="cert_chain_policy_ssl_f12"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_SSL_F12</b></dt>
     * <dt>(LPCSTR) 9</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Checks if any certificates in the chain have weak crypto or if third party root certificate compliance and provide an error string. The <b>pvExtraPolicyStatus</b> member of the CERT_CHAIN_POLICY_STATUS structure pointed to by the <i>pPolicyStatus</i> parameter must point to <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-ssl_f12_extra_cert_chain_policy_status">SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS</a>, which is updated with the results of the weak crypto and root program compliance checks.
     * 
     * Before calling, the <b>cbSize</b> member of the 	CERT_CHAIN_POLICY_STATUS structure pointed to by the <i>pPolicyStatus</i> parameter must be set to a value greater than or equal to sizeof(SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS).
     * 
     * The <b>dwError</b> member in CERT_CHAIN_POLICY_STATUS structure pointed to by the <i>pPolicyStatus</i> parameter will be set to <b>TRUST_E_CERT_SIGNATURE</b> for potential weak crypto and set to <b>CERT_E_UNTRUSTEDROOT</b> for Third Party Roots not in compliance with the Microsoft Root Program. 
     * 
     * <b>Windows10, version 1607, Windows Server 2016, Windows10, version 1511 with KB3172985, Windows10 RTM with KB3163912, Windows8.1 and Windows Server2012R2 with KB3163912, and Windows7 with SP1 and Windows Server2008R2 SP1 with KB3161029</b>
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CERT_CHAIN_CONTEXT>} pChainContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> structure that contains a chain to be verified.
     * @param {Pointer<CERT_CHAIN_POLICY_PARA>} pPolicyPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_policy_para">CERT_CHAIN_POLICY_PARA</a> structure that provides the policy verification criteria for the chain. The <b>dwFlags</b> member of that structure can be set to change the default policy checking behavior. 
     * 
     * 
     * 
     * 
     * In addition, policy-specific parameters can also be passed in the <b>pvExtraPolicyPara</b> member of the structure.
     * @param {Pointer<CERT_CHAIN_POLICY_STATUS>} pPolicyStatus A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_policy_status">CERT_CHAIN_POLICY_STATUS</a> structure where status information on the chain is returned. OID-specific extra status can be returned in the <b>pvExtraPolicyStatus</b> member of this structure.
     * @returns {BOOL} The return value indicates whether the function was able to check for the policy, it does not indicate whether the policy check failed or passed. 
     * 
     * If the chain can be verified for the specified policy, <b>TRUE</b> is returned and the <b>dwError</b> member of the <i>pPolicyStatus</i> is updated. A <b>dwError</b> of 0 (ERROR_SUCCESS or S_OK) indicates the chain satisfies the specified policy.
     * 
     * If the chain cannot be validated, the return value is  <b>TRUE</b> and you need to verify the <i>pPolicyStatus</i> parameter for the actual error.
     * 
     * A value of <b>FALSE</b>  indicates that the function wasn't able to check for the policy.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certverifycertificatechainpolicy
     * @since windows5.1.2600
     */
    static CertVerifyCertificateChainPolicy(pszPolicyOID, pChainContext, pPolicyPara, pPolicyStatus) {
        pszPolicyOID := pszPolicyOID is String ? StrPtr(pszPolicyOID) : pszPolicyOID

        result := DllCall("CRYPT32.dll\CertVerifyCertificateChainPolicy", "ptr", pszPolicyOID, "ptr", pChainContext, "ptr", pPolicyPara, "ptr", pPolicyStatus, "int")
        return result
    }

    /**
     * Converts a formatted string into an array of bytes.
     * @param {PSTR} pszString A pointer to a string that contains the formatted string to be converted.
     * @param {Integer} cchString The number of characters of the formatted string to be converted, not including the terminating <b>NULL</b> character. If this parameter is zero,  <i>pszString</i> is considered to be a null-terminated string.
     * @param {Integer} dwFlags 
     * @param {Pointer} pbBinary A pointer to a buffer that receives the returned sequence of bytes. If this parameter is <b>NULL</b>, the function calculates the length of the buffer needed and returns the size, in bytes, of required memory in the <b>DWORD</b> pointed to by <i>pcbBinary</i>.
     * @param {Pointer<Integer>} pcbBinary A pointer to a <b>DWORD</b> variable that, on entry, contains the size, in bytes, of the <i>pbBinary</i> buffer. After the function returns, this variable contains the number of bytes copied to the buffer. If this value is not large enough to contain all of the data, the function fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_MORE_DATA</b>.
     * 
     * If <i>pbBinary</i> is <b>NULL</b>, the <b>DWORD</b> pointed to by <i>pcbBinary</i> is ignored.
     * @param {Pointer<Integer>} pdwSkip A pointer to a <b>DWORD</b> value that receives the number of characters skipped to reach the beginning of the
     * `-----BEGIN ...-----` header.
     * If no header is present, then the <b>DWORD</b> is set to zero.
     * This parameter is optional and can be <b>NULL</b> if it is not needed.
     * @param {Pointer<Integer>} pdwFlags A pointer to a <b>DWORD</b> value that receives the flags actually used in the conversion. These are the same flags used for the <i>dwFlags</i> parameter. In many cases, these will be the same flags that were passed in the <i>dwFlags</i> parameter. If <i>dwFlags</i> contains one of the following flags, this value will receive a flag that indicates the actual format of the string. This parameter is optional and can be <b>NULL</b> if it is not needed.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_STRING_ANY"></a><a id="crypt_string_any"></a><dl>
     * <dt><b>CRYPT_STRING_ANY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptstringtobinarya
     * @since windows5.1.2600
     */
    static CryptStringToBinaryA(pszString, cchString, dwFlags, pbBinary, pcbBinary, pdwSkip, pdwFlags) {
        pszString := pszString is String ? StrPtr(pszString) : pszString

        pcbBinaryMarshal := pcbBinary is VarRef ? "uint*" : "ptr"
        pdwSkipMarshal := pdwSkip is VarRef ? "uint*" : "ptr"
        pdwFlagsMarshal := pdwFlags is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptStringToBinaryA", "ptr", pszString, "uint", cchString, "uint", dwFlags, "ptr", pbBinary, pcbBinaryMarshal, pcbBinary, pdwSkipMarshal, pdwSkip, pdwFlagsMarshal, pdwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts a formatted string into an array of bytes.
     * @param {PWSTR} pszString A pointer to a string that contains the formatted string to be converted.
     * @param {Integer} cchString The number of characters of the formatted string to be converted, not including the terminating <b>NULL</b> character. If this parameter is zero,  <i>pszString</i> is considered to be a null-terminated string.
     * @param {Integer} dwFlags 
     * @param {Pointer} pbBinary A pointer to a buffer that receives the returned sequence of bytes. If this parameter is <b>NULL</b>, the function calculates the length of the buffer needed and returns the size, in bytes, of required memory in the <b>DWORD</b> pointed to by <i>pcbBinary</i>.
     * @param {Pointer<Integer>} pcbBinary A pointer to a <b>DWORD</b> variable that, on entry, contains the size, in bytes, of the <i>pbBinary</i> buffer. After the function returns, this variable contains the number of bytes copied to the buffer. If this value is not large enough to contain all of the data, the function fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_MORE_DATA</b>.
     * 
     * If <i>pbBinary</i> is <b>NULL</b>, the <b>DWORD</b> pointed to by <i>pcbBinary</i> is ignored.
     * @param {Pointer<Integer>} pdwSkip A pointer to a <b>DWORD</b> value that receives the number of characters skipped to reach the beginning of the
     * `-----BEGIN ...-----` header.
     * If no header is present, then the <b>DWORD</b> is set to zero.
     * This parameter is optional and can be <b>NULL</b> if it is not needed.
     * @param {Pointer<Integer>} pdwFlags A pointer to a <b>DWORD</b> value that receives the flags actually used in the conversion. These are the same flags used for the <i>dwFlags</i> parameter. In many cases, these will be the same flags that were passed in the <i>dwFlags</i> parameter. If <i>dwFlags</i> contains one of the following flags, this value will receive a flag that indicates the actual format of the string. This parameter is optional and can be <b>NULL</b> if it is not needed.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_STRING_ANY"></a><a id="crypt_string_any"></a><dl>
     * <dt><b>CRYPT_STRING_ANY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptstringtobinaryw
     * @since windows5.1.2600
     */
    static CryptStringToBinaryW(pszString, cchString, dwFlags, pbBinary, pcbBinary, pdwSkip, pdwFlags) {
        pszString := pszString is String ? StrPtr(pszString) : pszString

        pcbBinaryMarshal := pcbBinary is VarRef ? "uint*" : "ptr"
        pdwSkipMarshal := pdwSkip is VarRef ? "uint*" : "ptr"
        pdwFlagsMarshal := pdwFlags is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptStringToBinaryW", "ptr", pszString, "uint", cchString, "uint", dwFlags, "ptr", pbBinary, pcbBinaryMarshal, pcbBinary, pdwSkipMarshal, pdwSkip, pdwFlagsMarshal, pdwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Converts an array of bytes into a formatted string.
     * @param {Pointer} pbBinary A pointer to the array of bytes to be converted into a string.
     * @param {Integer} cbBinary The number of elements in the <i>pbBinary</i> array.
     * @param {Integer} dwFlags 
     * @param {PSTR} pszString A pointer to a buffer that receives the converted string. To calculate the number of characters that must be allocated to hold the returned string, set this parameter to <b>NULL</b>. The function will place the required number of characters, including the terminating <b>NULL</b> character, in the value pointed to by <i>pcchString</i>.
     * @param {Pointer<Integer>} pcchString A pointer to a <b>DWORD</b> variable that contains the size, in <b>TCHAR</b>s, of the <i>pszString</i> buffer. If <i>pszString</i> is <b>NULL</b>, the function calculates the length of the return string (including the terminating null character) in <b>TCHAR</b>s and returns it in this parameter. If <i>pszString</i> is not <b>NULL</b> and big enough, the function converts the binary data into a specified string format including the terminating null character, but <i>pcchString</i> receives the length in <b>TCHAR</b>s, not including the terminating null character.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptbinarytostringa
     * @since windows5.1.2600
     */
    static CryptBinaryToStringA(pbBinary, cbBinary, dwFlags, pszString, pcchString) {
        pszString := pszString is String ? StrPtr(pszString) : pszString

        pcchStringMarshal := pcchString is VarRef ? "uint*" : "ptr"

        result := DllCall("CRYPT32.dll\CryptBinaryToStringA", "ptr", pbBinary, "uint", cbBinary, "uint", dwFlags, "ptr", pszString, pcchStringMarshal, pcchString, "int")
        return result
    }

    /**
     * Converts an array of bytes into a formatted string.
     * @param {Pointer} pbBinary A pointer to the array of bytes to be converted into a string.
     * @param {Integer} cbBinary The number of elements in the <i>pbBinary</i> array.
     * @param {Integer} dwFlags 
     * @param {PWSTR} pszString A pointer to a buffer that receives the converted string. To calculate the number of characters that must be allocated to hold the returned string, set this parameter to <b>NULL</b>. The function will place the required number of characters, including the terminating <b>NULL</b> character, in the value pointed to by <i>pcchString</i>.
     * @param {Pointer<Integer>} pcchString A pointer to a <b>DWORD</b> variable that contains the size, in <b>TCHAR</b>s, of the <i>pszString</i> buffer. If <i>pszString</i> is <b>NULL</b>, the function calculates the length of the return string (including the terminating null character) in <b>TCHAR</b>s and returns it in this parameter. If <i>pszString</i> is not <b>NULL</b> and big enough, the function converts the binary data into a specified string format including the terminating null character, but <i>pcchString</i> receives the length in <b>TCHAR</b>s, not including the terminating null character.
     * @returns {BOOL} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptbinarytostringw
     * @since windows5.1.2600
     */
    static CryptBinaryToStringW(pbBinary, cbBinary, dwFlags, pszString, pcchString) {
        pszString := pszString is String ? StrPtr(pszString) : pszString

        pcchStringMarshal := pcchString is VarRef ? "uint*" : "ptr"

        result := DllCall("CRYPT32.dll\CryptBinaryToStringW", "ptr", pbBinary, "uint", cbBinary, "uint", dwFlags, "ptr", pszString, pcchStringMarshal, pcchString, "int")
        return result
    }

    /**
     * Imports a PFX BLOB and returns the handle of a store that contains certificates and any associated private keys.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pPFX A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure that contains a PFX packet with the exported and encrypted certificates and keys.
     * @param {PWSTR} szPassword A string password used to decrypt and verify the PFX packet. Whether set to a string of length greater than zero or set to an empty string or to <b>NULL</b>,  this value must be exactly the same as the value that was used to encrypt the packet.
     * 
     * Beginning with Windows8 and Windows Server2012, if the PFX packet was created in the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-pfxexportcertstoreex">PFXExportCertStoreEx</a> function by using the <b>PKCS12_PROTECT_TO_DOMAIN_SIDS</b> flag, the <b>PFXImportCertStore</b> function attempts to decrypt the password by using the Active Directory (AD) principal that was used to encrypt it. The AD principal is specified in the <i>pvPara</i> parameter. If the <i>szPassword</i> parameter in the <b>PFXExportCertStoreEx</b> function was an empty string or <b>NULL</b> and the <i>dwFlags</i> parameter was set to <b>PKCS12_PROTECT_TO_DOMAIN_SIDS</b>, that function randomly generated a password and encrypted it to the AD principal specified in the <i>pvPara</i> parameter. In that case you should set the password to the value, empty string or <b>NULL</b>, that was used when the PFX packet was created. The <b>PFXImportCertStore</b> function will use the AD principal to decrypt the random password, and the randomly generated password will be used to decrypt the PFX certificate.
     * 
     * When you have finished using the password, clear it from memory by calling the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com/windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.
     * @param {Integer} dwFlags 
     * @returns {HCERTSTORE} If the function succeeds, the function returns a handle to a certificate store that contains the imported certificates, including available private keys.
     * 
     * If the function fails, that is, if the password parameter does not contain an exact match with the password used to encrypt the exported packet or if there were any other problems decoding the PFX BLOB, the function returns <b>NULL</b>, and an error code can be found by calling the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-pfximportcertstore
     * @since windows5.1.2600
     */
    static PFXImportCertStore(pPFX, szPassword, dwFlags) {
        szPassword := szPassword is String ? StrPtr(szPassword) : szPassword

        A_LastError := 0

        result := DllCall("CRYPT32.dll\PFXImportCertStore", "ptr", pPFX, "ptr", szPassword, "uint", dwFlags, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        resultHandle := HCERTSTORE({Value: result}, True)
        return resultHandle
    }

    /**
     * The PFXIsPFXBlob function attempts to decode the outer layer of a BLOB as a PFX packet.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pPFX A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure that the function will attempt to decode as a PFX packet.
     * @returns {BOOL} The function returns <b>TRUE</b> if the BLOB can be decoded as a PFX packet. If the outer layer of the BLOB cannot be decoded as a PFX packet, the function returns <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-pfxispfxblob
     * @since windows5.1.2600
     */
    static PFXIsPFXBlob(pPFX) {
        result := DllCall("CRYPT32.dll\PFXIsPFXBlob", "ptr", pPFX, "int")
        return result
    }

    /**
     * The PFXVerifyPassword function attempts to decode the outer layer of a BLOB as a Personal Information Exchange (PFX) packet and to decrypt it with the given password. No data from the BLOB is imported.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pPFX A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure that the function will attempt to decode as a PFX packet.
     * @param {PWSTR} szPassword String password to be checked. For this function to succeed, this password must be exactly the same as the password used to encrypt the packet.
     * 
     * If you set this value to an empty string or <b>NULL</b>, this function typically attempts to decrypt the password embedded in the PFX BLOB by using the empty string or <b>NULL</b>.
     * 
     * However, beginning with Windows8 and Windows Server2012, if a <b>NULL</b> or empty password was specified when the PFX BLOB was created and the application also specified  that the password should be protected to an Active Directory (AD) principal, the Cryptography API (CAPI) randomly generates a password, encrypts it to the AD principal and embeds it in the PFX BLOB. The <b>PFXVerifyPassword</b> function will then try to use the specified AD principal (current user, computer, or AD group member) to decrypt the password. For more information about protecting PFX to an AD principal, see the <i>pvPara</i> parameter and the <b>PKCS12_PROTECT_TO_DOMAIN_SIDS</b> flag of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-pfxexportcertstoreex">PFXExportCertStoreEx</a> function.
     * 
     * When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com/windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.
     * @param {Integer} dwFlags Reserved for future use.
     * @returns {BOOL} The function return <b>TRUE</b> if the password appears correct; otherwise, it returns <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-pfxverifypassword
     * @since windows5.1.2600
     */
    static PFXVerifyPassword(pPFX, szPassword, dwFlags) {
        szPassword := szPassword is String ? StrPtr(szPassword) : szPassword

        result := DllCall("CRYPT32.dll\PFXVerifyPassword", "ptr", pPFX, "ptr", szPassword, "uint", dwFlags, "int")
        return result
    }

    /**
     * Exports the certificates and, if available, their associated private keys from the referenced certificate store.
     * @param {HCERTSTORE} hStore Handle of the certificate store containing the certificates to be exported.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pPFX A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure to contain the PFX packet with the exported certificates and keys. If <i>pPFX</i>-&gt;<i>pbData</i> is <b>NULL</b>, the function calculates the number of bytes needed for the encoded BLOB and returns this in <i>pPFX</i>-&gt;<i>cbData</i>. When the function is called with <i>pPFX</i>-&gt;<i>pbData</i> pointing to an allocated buffer of the needed size, the function copies the encoded bytes into the buffer and updates <i>pPFX</i>-&gt;<i>cbData</i> with the encode byte length.
     * @param {PWSTR} szPassword String password used to encrypt and verify the PFX packet. When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com/windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.
     * @param {Pointer<Void>} pvPara This parameter must be <b>NULL</b> if the <i>dwFlags</i> parameter does not contain <b>PKCS12_PROTECT_TO_DOMAIN_SIDS</b>. Prior to Windows8 and Windows Server2012, therefore, this parameter must be <b>NULL</b>.
     * 
     * Beginning with Windows8 and Windows Server2012, if the <i>dwFlags</i> parameter contains <b>PKCS12_PROTECT_TO_DOMAIN_SIDS</b>, you can set the <i>pvPara</i> parameter to point to an <b>NCRYPT_DESCRIPTOR_HANDLE</b> value to identify which Active Directory principal the PFX password will be protected to inside of the PFX BLOB. Currently, the password can be protected to an Active Directory user, computer, or group. For more information about protection descriptors, see <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptcreateprotectiondescriptor">NCryptCreateProtectionDescriptor</a>.
     * @param {Integer} dwFlags Flag values can be set to any combination of the following.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="EXPORT_PRIVATE_KEYS"></a><a id="export_private_keys"></a><dl>
     * <dt><b>EXPORT_PRIVATE_KEYS</b></dt>
     * <dt>0x0004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Private keys are exported as well as the certificates.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="REPORT_NO_PRIVATE_KEY"></a><a id="report_no_private_key"></a><dl>
     * <dt><b>REPORT_NO_PRIVATE_KEY</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a certificate is encountered that has no associated private key, the function returns FALSE with the last error set to either CRYPT_E_NOT_FOUND or NTE_NO_KEY.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY"></a><a id="report_not_able_to_export_private_key"></a><dl>
     * <dt><b>REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a certificate is encountered that has a non-exportable private key, the function returns FALSE and the last error set to NTE_BAD_KEY, NTE_BAD_KEY_STATE, or NTE_PERM.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PKCS12_INCLUDE_EXTENDED_PROPERTIES"></a><a id="pkcs12_include_extended_properties"></a><dl>
     * <dt><b>PKCS12_INCLUDE_EXTENDED_PROPERTIES</b></dt>
     * <dt>0x0010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Export all extended
     * properties on the certificate.
     * 
     *  
     * 
     * 
     * <b>Windows Server2003 and WindowsXP:</b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PKCS12_PROTECT_TO_DOMAIN_SIDS"></a><a id="pkcs12_protect_to_domain_sids"></a><dl>
     * <dt><b>PKCS12_PROTECT_TO_DOMAIN_SIDS</b></dt>
     * <dt>0x0020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The PFX BLOB contains an embedded password that will be protected to the Active Directory (AD) protection descriptor pointed to by the <i>pvPara</i> parameter. If the <i>szPassword</i> parameter is not  <b>NULL</b> or empty, the specified password is protected. If, however,  the <i>szPassword</i> parameter is <b>NULL</b> or an empty string, a random forty (40)  character password is created and protected.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-pfximportcertstore">PFXImportCertStore</a> uses the specified protection descriptor to decrypt the embedded password, whether specified by the user or randomly generated, and then uses the password to decrypt the PFX BLOB.
     * 
     * <b>Windows8 and Windows Server2012:</b>Support for this flag begins.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} Returns <b>TRUE</b> (nonzero) if the function succeeds, and <b>FALSE</b> (zero) if the function fails. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-pfxexportcertstoreex
     * @since windows5.1.2600
     */
    static PFXExportCertStoreEx(hStore, pPFX, szPassword, pvPara, dwFlags) {
        hStore := hStore is Win32Handle ? NumGet(hStore, "ptr") : hStore
        szPassword := szPassword is String ? StrPtr(szPassword) : szPassword

        pvParaMarshal := pvPara is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\PFXExportCertStoreEx", "ptr", hStore, "ptr", pPFX, "ptr", szPassword, pvParaMarshal, pvPara, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Exports the certificates and, if available, the associated private keys from the referenced certificate store.
     * @param {HCERTSTORE} hStore Handle of the certificate store containing the certificates to be exported.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pPFX A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure to contain the PFX packet with the exported certificates and keys. If <i>pPFX</i>-&gt;<i>pbData</i> is <b>NULL</b>, the function calculates the number of bytes needed for the encoded BLOB and returns this in <i>pPFX</i>-&gt;<i>cbData</i>. When the function is called with <i>pPFX</i>-&gt;<i>pbData</i> pointing to an allocated buffer of the needed size, the function copies the encoded bytes into the buffer and updates <i>pPFX</i>-&gt;<i>cbData</i> with the encode byte length.
     * @param {PWSTR} szPassword String password used to encrypt and verify the PFX packet. When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com/windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.
     * @param {Integer} dwFlags Flag values can be set to any combination of the following.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="EXPORT_PRIVATE_KEYS"></a><a id="export_private_keys"></a><dl>
     * <dt><b>EXPORT_PRIVATE_KEYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Private keys are exported as well as the certificates.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="REPORT_NO_PRIVATE_KEY"></a><a id="report_no_private_key"></a><dl>
     * <dt><b>REPORT_NO_PRIVATE_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a certificate is encountered that has no associated private key, the function returns <b>FALSE</b> with the last error set to either CRYPT_E_NOT_FOUND or NTE_NO_KEY.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY"></a><a id="report_not_able_to_export_private_key"></a><dl>
     * <dt><b>REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a certificate is encountered that has a non-exportable private key, the function returns <b>FALSE</b> and the last error set to NTE_BAD_KEY, NTE_BAD_KEY_STATE, or NTE_PERM.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} Returns <b>TRUE</b> (nonzero) if the function succeeds, and <b>FALSE</b> (zero) if the function fails. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-pfxexportcertstore
     * @since windows5.1.2600
     */
    static PFXExportCertStore(hStore, pPFX, szPassword, dwFlags) {
        hStore := hStore is Win32Handle ? NumGet(hStore, "ptr") : hStore
        szPassword := szPassword is String ? StrPtr(szPassword) : szPassword

        A_LastError := 0

        result := DllCall("CRYPT32.dll\PFXExportCertStore", "ptr", hStore, "ptr", pPFX, "ptr", szPassword, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Opens a handle to an online certificate status protocol (OCSP) response associated with a server certificate chain.
     * @param {Pointer<CERT_CHAIN_CONTEXT>} pChainContext The address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> structure that contains the certificate chain.
     * @param {Integer} dwFlags This parameter is not used and must be zero.
     * @param {Pointer<CERT_SERVER_OCSP_RESPONSE_OPEN_PARA>} pOpenPara This parameter is not used and must be <b>NULL</b>.
     * @returns {Pointer<Void>} Returns a handle to the OCSP response associated with a server certificate chain if successful; otherwise, <b>NULL</b>. This handle must be passed to the <a href="/windows/desktop/api/wincrypt/nf-wincrypt-certcloseserverocspresponse">CertCloseServerOcspResponse</a> function when it is no longer needed.
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes returned by the 
     * 		       <b>GetLastError</b> function include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_IN_REVOCATION_DATABASE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end certificate does not contain an OCSP authority information access (AIA) URL.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certopenserverocspresponse
     * @since windows6.0.6000
     */
    static CertOpenServerOcspResponse(pChainContext, dwFlags, pOpenPara) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertOpenServerOcspResponse", "ptr", pChainContext, "uint", dwFlags, "ptr", pOpenPara, "ptr")
        if(A_LastError) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Increments the reference count for an HCERT_SERVER_OCSP_RESPONSE handle.
     * @remarks
     * 
     * Each <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenserverocspresponse">CertOpenServerOcspResponse</a> and <b>CertAddRefServerOcspResponse</b> requires a corresponding <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certcloseserverocspresponse">CertCloseServerOcspResponse</a>.
     * 
     * @param {Pointer<Void>} hServerOcspResponse A handle to an <b>HCERT_SERVER_OCSP_RESPONSE</b> returned by <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenserverocspresponse">CertOpenServerOcspResponse</a>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certaddrefserverocspresponse
     * @since windows6.0.6000
     */
    static CertAddRefServerOcspResponse(hServerOcspResponse) {
        hServerOcspResponseMarshal := hServerOcspResponse is VarRef ? "ptr" : "ptr"

        DllCall("CRYPT32.dll\CertAddRefServerOcspResponse", hServerOcspResponseMarshal, hServerOcspResponse)
    }

    /**
     * Closes an online certificate status protocol (OCSP) server response handle.
     * @remarks
     * 
     * The <b>CertCloseServerOcspResponse</b> function closes a handle returned by either the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenserverocspresponse">CertOpenServerOcspResponse</a> or <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddrefserverocspresponse">CertAddRefServerOcspResponse</a> function.
     * 
     * 
     * @param {Pointer<Void>} hServerOcspResponse The handle to close for an OCSP server response.
     * @param {Integer} dwFlags This parameter is not used and must be zero.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certcloseserverocspresponse
     * @since windows6.0.6000
     */
    static CertCloseServerOcspResponse(hServerOcspResponse, dwFlags) {
        hServerOcspResponseMarshal := hServerOcspResponse is VarRef ? "ptr" : "ptr"

        DllCall("CRYPT32.dll\CertCloseServerOcspResponse", hServerOcspResponseMarshal, hServerOcspResponse, "uint", dwFlags)
    }

    /**
     * Retrieves a non-blocking, time valid online certificate status protocol (OCSP) response context for the specified handle.
     * @param {Pointer<Void>} hServerOcspResponse The OCSP server response handle for which to retrieve a response context. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenserverocspresponse">CertOpenServerOcspResponse</a> function.
     * @param {Integer} dwFlags This parameter is reserved for future use and must be zero.
     * @returns {Pointer<CERT_SERVER_OCSP_RESPONSE_CONTEXT>} If the function succeeds, it returns a pointer to a <a href="/windows/win32/api/wincrypt/ns-wincrypt-cert_server_ocsp_response_context">CERT_SERVER_OCSP_RESPONSE_CONTEXT</a> structure.
     * 
     * For a response to be time valid, the current time on the system hosting this function call must be less than the next update time for the <a href="/windows/desktop/SecGloss/c-gly">certificate revocation list</a> (CRL) context. When a time valid OCSP response
     * is not available, this function returns <b>NULL</b> with the last error set to
     * CRYPT_E_REVOCATION_OFFLINE.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certgetserverocspresponsecontext
     * @since windows6.0.6000
     */
    static CertGetServerOcspResponseContext(hServerOcspResponse, dwFlags) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        hServerOcspResponseMarshal := hServerOcspResponse is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPT32.dll\CertGetServerOcspResponseContext", hServerOcspResponseMarshal, hServerOcspResponse, "uint", dwFlags, "ptr", pvReserved, "ptr")
        return result
    }

    /**
     * Increments the reference count for a CERT_SERVER_OCSP_RESPONSE_CONTEXT structure.
     * @remarks
     * 
     * Each call to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetserverocspresponsecontext">CertGetServerOcspResponseContext</a> and <b>CertAddRefServerOcspResponseContext</b> requires a corresponding call to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreeserverocspresponsecontext">CertFreeServerOcspResponseContext</a>.
     * 
     * @param {Pointer<CERT_SERVER_OCSP_RESPONSE_CONTEXT>} pServerOcspResponseContext A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-cert_server_ocsp_response_context">CERT_SERVER_OCSP_RESPONSE_CONTEXT</a> returned by <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetserverocspresponsecontext">CertGetServerOcspResponseContext</a>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certaddrefserverocspresponsecontext
     * @since windows6.0.6000
     */
    static CertAddRefServerOcspResponseContext(pServerOcspResponseContext) {
        DllCall("CRYPT32.dll\CertAddRefServerOcspResponseContext", "ptr", pServerOcspResponseContext)
    }

    /**
     * Decrements the reference count for a CERT_SERVER_OCSP_RESPONSE_CONTEXT structure.
     * @param {Pointer<CERT_SERVER_OCSP_RESPONSE_CONTEXT>} pServerOcspResponseContext A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-cert_server_ocsp_response_context">CERT_SERVER_OCSP_RESPONSE_CONTEXT</a> structure that contains a value returned by the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetserverocspresponsecontext">CertGetServerOcspResponseContext</a> function.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certfreeserverocspresponsecontext
     * @since windows6.0.6000
     */
    static CertFreeServerOcspResponseContext(pServerOcspResponseContext) {
        DllCall("CRYPT32.dll\CertFreeServerOcspResponseContext", "ptr", pServerOcspResponseContext)
    }

    /**
     * Performs a URL retrieval of logo or biometric information specified in either the szOID_LOGOTYPE_EXT or szOID_BIOMETRIC_EXT certificate extension.
     * @param {Pointer<CERT_CONTEXT>} pCertContext The address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure that contains the certificate.
     * @param {PSTR} lpszLogoOrBiometricType The address of a null-terminated ANSI string that contains an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) string that identifies the type of information to retrieve.
     * 
     * 
     * This parameter may also contain one of the following predefined values.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_RETRIEVE_ISSUER_LOGO"></a><a id="cert_retrieve_issuer_logo"></a><dl>
     * <dt><b>CERT_RETRIEVE_ISSUER_LOGO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the certificate issuer logotype.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_RETRIEVE_SUBJECT_LOGO"></a><a id="cert_retrieve_subject_logo"></a><dl>
     * <dt><b>CERT_RETRIEVE_SUBJECT_LOGO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the certificate subject logotype.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_RETRIEVE_COMMUNITY_LOGO"></a><a id="cert_retrieve_community_logo"></a><dl>
     * <dt><b>CERT_RETRIEVE_COMMUNITY_LOGO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the certificate community logotype.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_RETRIEVE_BIOMETRIC_PICTURE_TYPE"></a><a id="cert_retrieve_biometric_picture_type"></a><dl>
     * <dt><b>CERT_RETRIEVE_BIOMETRIC_PICTURE_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the picture associated with the certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_RETRIEVE_BIOMETRIC_SIGNATURE_TYPE"></a><a id="cert_retrieve_biometric_signature_type"></a><dl>
     * <dt><b>CERT_RETRIEVE_BIOMETRIC_SIGNATURE_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the signature associated with the certificate.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwRetrievalFlags A set of flags that specify how the information should be retrieved. This parameter is passed as the <i>dwRetrievalFlags</i> in the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptretrieveobjectbyurla">CryptRetrieveObjectByUrl</a> function.
     * @param {Integer} dwTimeout The maximum amount of time, in milliseconds, to wait for the retrieval.
     * @param {Integer} dwFlags This parameter is not used and must be zero.
     * @param {Pointer<Pointer<Integer>>} ppbData The address of a <b>BYTE</b> pointer that receives the logotype or biometric data. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmemfree">CryptMemFree</a> function.
     * @param {Pointer<Integer>} pcbData The address of a <b>DWORD</b> variable that receives the number of bytes in the <i>ppbData</i> buffer.
     * @param {Pointer<PWSTR>} ppwszMimeType The address of a pointer to a null-terminated Unicode string that receives the Multipurpose Internet Mail Extensions (MIME) type of the data. This parameter can be <b>NULL</b> if this information is not needed. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmemfree">CryptMemFree</a> function.
     * 
     * This address always receives <b>NULL</b> for biometric types. You must always ensure that this parameter contains a valid memory address before attempting to access the memory.
     * @returns {BOOL} Returns nonzero if successful or zero otherwise.
     * 
     * For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes returned by the 
     * 		       <b>GetLastError</b> function include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b> CRYPT_E_HASH_VALUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The computed hash value does not match the hash value in the certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The certificate does not contain the <b>szOID_LOGOTYPE_EXT</b> or <b>szOID_BIOMETRIC_EXT</b> extension, or the specified <i>lpszLogoOrBiometricType</i> was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b> ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No data could be retrieved from the URL specified by the certificate extension.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b> ERROR_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The certificate does not support the required extension.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b> NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash algorithm OID is unknown.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certretrievelogoorbiometricinfo
     * @since windows6.0.6000
     */
    static CertRetrieveLogoOrBiometricInfo(pCertContext, lpszLogoOrBiometricType, dwRetrievalFlags, dwTimeout, dwFlags, ppbData, pcbData, ppwszMimeType) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        lpszLogoOrBiometricType := lpszLogoOrBiometricType is String ? StrPtr(lpszLogoOrBiometricType) : lpszLogoOrBiometricType

        ppbDataMarshal := ppbData is VarRef ? "ptr*" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"
        ppwszMimeTypeMarshal := ppwszMimeType is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertRetrieveLogoOrBiometricInfo", "ptr", pCertContext, "ptr", lpszLogoOrBiometricType, "uint", dwRetrievalFlags, "uint", dwTimeout, "uint", dwFlags, "ptr", pvReserved, ppbDataMarshal, ppbData, pcbDataMarshal, pcbData, ppwszMimeTypeMarshal, ppwszMimeType, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves certificate chains based on specified selection criteria.
     * @param {Pointer<Guid>} pSelectionContext A pointer to the GUID of the certificate selection scenario to use for this call.
     * @param {Integer} dwFlags Flags for controlling the certificate selection process. This parameter can be a combination of zero or more of the following flags:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SELECT_ALLOW_EXPIRED"></a><a id="cert_select_allow_expired"></a><dl>
     * <dt><b>CERT_SELECT_ALLOW_EXPIRED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Select expired certificates that meet selection criteria. By default expired certificates are rejected from selection.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SELECT_TRUSTED_ROOT"></a><a id="cert_select_trusted_root"></a><dl>
     * <dt><b>CERT_SELECT_TRUSTED_ROOT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Select certificates on which the error bit in the certificate chain trust status is not set to <b>CERT_TRUST_IS_UNTRUSTED_ROOT</b>, <b>CERT_TRUST_IS_PARTIAL_CHAIN</b>, or <b>CERT_TRUST_IS_NOT_TIME_VALID</b>. 
     * 
     * In addition, certificates that have one of the following invalid constraint errors are not selected:
     * 
     * <ul>
     * <li><b>CERT_TRUST_INVALID_POLICY_CONSTRAINTS</b></li>
     * <li><b>CERT_TRUST_INVALID_BASIC_CONSTRAINTS</b></li>
     * <li><b>CERT_TRUST_INVALID_NAME_CONSTRAINTS</b></li>
     * </ul>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SELECT_DISALLOW_SELFSIGNED"></a><a id="cert_select_disallow_selfsigned"></a><dl>
     * <dt><b>CERT_SELECT_DISALLOW_SELFSIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Select certificates that are not self-issued and self-signed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SELECT_HAS_PRIVATE_KEY"></a><a id="cert_select_has_private_key"></a><dl>
     * <dt><b>CERT_SELECT_HAS_PRIVATE_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Select  certificates that have a value set for the <b>CERT_KEY_PROV_INFO_PROP_ID</b>  property of the certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SELECT_HAS_KEY_FOR_SIGNATURE"></a><a id="cert_select_has_key_for_signature"></a><dl>
     * <dt><b>CERT_SELECT_HAS_KEY_FOR_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Select certificates on which the value of the <b>dwKeySpec</b> member of  the  <b>CERT_KEY_PROV_INFO_PROP_ID</b> property is set to <b>AT_SIGNATURE</b>. 
     * 
     * If this function is being called as part of  a CNG enabled application and the <b>dwKeySpec</b> member of  the  <b>CERT_KEY_PROV_INFO_PROP_ID</b> property is set to -1, select certificates on which the value of the <b>NCRYPT_KEY_USAGE_PROPERTY</b> property of the associated private key has the <b>NCRYPT_ALLOW_SIGNING_FLAG</b> set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SELECT_HAS_KEY_FOR_KEY_EXCHANGE"></a><a id="cert_select_has_key_for_key_exchange"></a><dl>
     * <dt><b>CERT_SELECT_HAS_KEY_FOR_KEY_EXCHANGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Select certificates on which the value of the <b>dwKeySpec</b> member of  the  <b>CERT_KEY_PROV_INFO_PROP_ID</b> property is set to <b>AT_KEYEXCHANGE</b>. 
     * 
     * If this function is being called as part of  a CNG enabled application and the <b>dwKeySpec</b> member of  the  <b>CERT_KEY_PROV_INFO_PROP_ID</b> property is set to -1, select certificates on which either <b>NCRYPT_ALLOW_DECRYPT_FLAG</b> or <b>NCRYPT_ALLOW_KEY_AGREEMENT_FLAG</b> is set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SELECT_HARDWARE_ONLY"></a><a id="cert_select_hardware_only"></a><dl>
     * <dt><b>CERT_SELECT_HARDWARE_ONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Select certificates on which the value of the <b>PP_IMPTYPE</b> property of the associated private key provider is set to either <b>  CRYPT_IMPL_HARDWARE</b> or <b>CRYPT_IMPL_REMOVABLE</b>. (For CNG providers, NCRYPT_IMPL_TYPE_PROPERTY property value MUST have either the NCRYPT_IMPL_HARDWARE_FLAG or NCRYPT_IMPL_REMOVABLE_FLAG bit set).
     * 
     * If this function is being called as part of  a CNG enabled application, select certificates on which the <b>NCRYPT_IMPL_TYPE_PROPERTY</b> property is set to <b> NCRYPT_IMPL_HARDWARE_FLAG</b> or <b>NCRYPT_IMPL_REMOVABLE_FLAG</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SELECT_ALLOW_DUPLICATES"></a><a id="cert_select_allow_duplicates"></a><dl>
     * <dt><b>CERT_SELECT_ALLOW_DUPLICATES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Allow the selection of certificates on which the Subject and Subject Alt Name contain the same information  and the certificate template extension value is equivalent.  By default when certificates match this criteria, only the most recent certificate is selected.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CERT_SELECT_CHAIN_PARA>} pChainParameters A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_select_chain_para">CERT_SELECT_CHAIN_PARA</a> structure to specify parameters for chain building. If <b>NULL</b>, default parameters will be used.
     * 
     * The <b>pChainPara</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_select_chain_para">CERT_SELECT_CHAIN_PARA</a> structure points to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_para">CERT_CHAIN_PARA</a> structure that can be used to enable strong signing.
     * @param {Integer} cCriteria The number of elements in the array pointed to by the <i>rgpCriteria</i> array.
     * @param {Pointer<CERT_SELECT_CRITERIA>} rgpCriteria A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_select_criteria">CERT_SELECT_CRITERIA</a> structures that define the selection criteria. If this parameter is set to <b>NULL</b>, the value of the <i>cCriteria</i> parameter must be zero.
     * @param {HCERTSTORE} hStore The handle to a store from which to select the certificates.
     * @param {Pointer<Integer>} pcSelection A pointer to a <b>DWORD</b> value to receive the number of elements in the array pointed to by the <i>pprgpSelection</i> parameter.
     * @param {Pointer<Pointer<Pointer<CERT_CHAIN_CONTEXT>>>} pprgpSelection A pointer to a pointer to a location to receive an array of <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> structure. The <b>CertSelectCertificateChains</b> function only returns certificate chains that match all the selection criteria. The entries in the array are ordered by quality, i.e. the chain with the highest quality is the first entry. 
     * 
     * Storage for the array is allocated by the <b>CertSelectCertificateChains</b> function. To free the allocated memory you must first release each individual chain context in the array by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatechain">CertFreeCertificateChain</a> function. Then you must  free the memory by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatechainlist">CertFreeCertificateChainList</a> function.
     * @returns {BOOL} If the function succeeds, the function returns <b>TRUE</b>. 
     * 
     * If the function fails, it returns zero (FALSE). For extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * <div class="alert"><b>Note</b>If the selection does not yield any results, the <b>CertSelectCertificateChains</b> function returns <b>TRUE</b>, but the value pointed to by <i>pcSelection</i> parameter is set to zero.
     * </div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certselectcertificatechains
     * @since windows6.1
     */
    static CertSelectCertificateChains(pSelectionContext, dwFlags, pChainParameters, cCriteria, rgpCriteria, hStore, pcSelection, pprgpSelection) {
        hStore := hStore is Win32Handle ? NumGet(hStore, "ptr") : hStore

        pcSelectionMarshal := pcSelection is VarRef ? "uint*" : "ptr"
        pprgpSelectionMarshal := pprgpSelection is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSelectCertificateChains", "ptr", pSelectionContext, "uint", dwFlags, "ptr", pChainParameters, "uint", cCriteria, "ptr", rgpCriteria, "ptr", hStore, pcSelectionMarshal, pcSelection, pprgpSelectionMarshal, pprgpSelection, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Frees the array of pointers to chain contexts.
     * @remarks
     * 
     *  Before calling the <b>CertFreeCertificateChainList</b> function, you must call the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatechain">CertFreeCertificateChain</a> function on each chain context within the array pointed to by the <i>prgpSelection</i> parameter.
     * 
     * @param {Pointer<Pointer<CERT_CHAIN_CONTEXT>>} prgpSelection A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">PCCERT_CHAIN_CONTEXT</a> structure returned by the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certselectcertificatechains">CertSelectCertificateChains</a> function.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-certfreecertificatechainlist
     * @since windows6.1
     */
    static CertFreeCertificateChainList(prgpSelection) {
        prgpSelectionMarshal := prgpSelection is VarRef ? "ptr*" : "ptr"

        DllCall("CRYPT32.dll\CertFreeCertificateChainList", prgpSelectionMarshal, prgpSelection)
    }

    /**
     * Encodes a time stamp request and retrieves the time stamp token from a location specified by a URL to a Time Stamping Authority (TSA).
     * @param {PWSTR} wszUrl A pointer to a null-terminated wide character string that contains the URL of the TSA to which to send the request.
     * @param {Integer} dwRetrievalFlags A set of flags that specify how the time stamp is retrieved.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TIMESTAMP_DONT_HASH_DATA"></a><a id="timestamp_dont_hash_data"></a><dl>
     * <dt><b>TIMESTAMP_DONT_HASH_DATA</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Inhibit hash calculation on the array of bytes pointed to by the <i>pbData</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TIMESTAMP_VERIFY_CONTEXT_SIGNATURE"></a><a id="timestamp_verify_context_signature"></a><dl>
     * <dt><b>TIMESTAMP_VERIFY_CONTEXT_SIGNATURE</b></dt>
     * <dt>0x00000020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enforce signature validation on the retrieved time stamp.
     * 
     * 
     * <div class="alert"><b>Note</b>The <b>TIMESTAMP_VERIFY_CONTEXT_SIGNATURE</b> flag is valid only      if the <b>fRequestCerts</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_timestamp_para">CRYPT_TIMESTAMP_PARA</a> pointed to by the <i>pPara</i> parameter is set to <b>TRUE</b>.</div>
     * <div></div>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TIMESTAMP_NO_AUTH_RETRIEVAL"></a><a id="timestamp_no_auth_retrieval"></a><dl>
     * <dt><b>TIMESTAMP_NO_AUTH_RETRIEVAL</b></dt>
     * <dt>0x00020000 </dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Set this flag to inhibit automatic authentication handling.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwTimeout A <b>DWORD</b> value that specifies the maximum number of milliseconds to wait for retrieval. If this parameter is set to zero, this function does not time out.
     * @param {PSTR} pszHashId A pointer to a null-terminated character string that contains the hash algorithm <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID).
     * @param {Pointer<CRYPT_TIMESTAMP_PARA>} pPara A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_timestamp_para">CRYPT_TIMESTAMP_PARA</a> structure that contains additional parameters for the request.
     * @param {Pointer} pbData A pointer to an array of bytes to be time stamped.
     * @param {Integer} cbData The size, in bytes, of the array pointed to by the <i>pbData</i> parameter.
     * @param {Pointer<Pointer<CRYPT_TIMESTAMP_CONTEXT>>} ppTsContext A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_timestamp_context">PCRYPT_TIMESTAMP_CONTEXT</a> structure. When you have finished using the context, you must free it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmemfree">CryptMemFree</a> function.
     * @param {Pointer<Pointer<CERT_CONTEXT>>} ppTsSigner A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">PCERT_CONTEXT</a> that
     * receives the certificate of the signer.
     *      When you have finished using this structure, you must free it by passing this
     * pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function.
     * 
     * 
     * Set this parameter to <b>NULL</b> if the TSA signer's certificate is not needed.
     * @param {Pointer<HCERTSTORE>} phStore The handle of a certificate store initialized with certificates from the time stamp response. This store can be used for validating the signer certificate of the time stamp response.
     * 
     * This parameter can be <b>NULL</b> if the TSA supporting certificates are not needed. When you have finished using this handle,  release it by passing it to  the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a> function.
     * @returns {BOOL} If the function is unable to retrieve, decode, and validate the time stamp context, it returns <b>FALSE</b>. For extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptretrievetimestamp
     * @since windows6.1
     */
    static CryptRetrieveTimeStamp(wszUrl, dwRetrievalFlags, dwTimeout, pszHashId, pPara, pbData, cbData, ppTsContext, ppTsSigner, phStore) {
        wszUrl := wszUrl is String ? StrPtr(wszUrl) : wszUrl
        pszHashId := pszHashId is String ? StrPtr(pszHashId) : pszHashId

        ppTsContextMarshal := ppTsContext is VarRef ? "ptr*" : "ptr"
        ppTsSignerMarshal := ppTsSigner is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptRetrieveTimeStamp", "ptr", wszUrl, "uint", dwRetrievalFlags, "uint", dwTimeout, "ptr", pszHashId, "ptr", pPara, "ptr", pbData, "uint", cbData, ppTsContextMarshal, ppTsContext, ppTsSignerMarshal, ppTsSigner, "ptr", phStore, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Validates the time stamp signature on a specified array of bytes.
     * @param {Pointer} pbTSContentInfo A pointer to a buffer that contains time stamp content.
     * @param {Integer} cbTSContentInfo The size, in bytes, of the buffer pointed to by the <i>pbTSContentInfo</i> parameter.
     * @param {Pointer} pbData A pointer to an array of bytes on which to validate the time stamp signature.
     * @param {Integer} cbData The size, in bytes, of the array pointed to by the <i>pbData</i> parameter.
     * @param {HCERTSTORE} hAdditionalStore The handle of an additional store to search for supporting
     * Time Stamping Authority (TSA) signing certificates and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate trust lists</a> (CTLs).
     *     This parameter can be <b>NULL</b> if no additional store is to be searched.
     * @param {Pointer<Pointer<CRYPT_TIMESTAMP_CONTEXT>>} ppTsContext A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_timestamp_context">PCRYPT_TIMESTAMP_CONTEXT</a> structure. When you have finished using the context, you must free it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmemfree">CryptMemFree</a> function.
     * @param {Pointer<Pointer<CERT_CONTEXT>>} ppTsSigner A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">PCERT_CONTEXT</a> that
     * receives the certificate of the signer.
     *      When you have finished using this structure, you must free it by passing this
     * pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function.
     * 
     * Set this parameter to <b>NULL</b> if the TSA signer's certificate is not needed.
     * @param {Pointer<HCERTSTORE>} phStore A pointer to a handle that receives the certificate store opened  on CMS to search for supporting certificates.
     * 
     * This parameter can be <b>NULL</b> if the TSA supporting certificates are not needed. When you have finished using this handle,  you  must release it by passing it to  the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a> function.
     * @returns {BOOL} If the function succeeds, the function returns <b>TRUE</b>. For extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//wincrypt/nf-wincrypt-cryptverifytimestampsignature
     * @since windows6.1
     */
    static CryptVerifyTimeStampSignature(pbTSContentInfo, cbTSContentInfo, pbData, cbData, hAdditionalStore, ppTsContext, ppTsSigner, phStore) {
        hAdditionalStore := hAdditionalStore is Win32Handle ? NumGet(hAdditionalStore, "ptr") : hAdditionalStore

        ppTsContextMarshal := ppTsContext is VarRef ? "ptr*" : "ptr"
        ppTsSignerMarshal := ppTsSigner is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptVerifyTimeStampSignature", "ptr", pbTSContentInfo, "uint", cbTSContentInfo, "ptr", pbData, "uint", cbData, "ptr", hAdditionalStore, ppTsContextMarshal, ppTsContext, ppTsSignerMarshal, ppTsSigner, "ptr", phStore, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {Integer} dwHashUseType 
     * @param {PWSTR} pwszCNGHashAlgid 
     * @param {Integer} dwChainFlags 
     * @param {Pointer<CERT_CHAIN_CONTEXT>} pSignerChainContext 
     * @param {Pointer<FILETIME>} pTimeStamp 
     * @param {PWSTR} pwszFileName 
     * @returns {BOOL} 
     */
    static CertIsWeakHash(dwHashUseType, pwszCNGHashAlgid, dwChainFlags, pSignerChainContext, pTimeStamp, pwszFileName) {
        pwszCNGHashAlgid := pwszCNGHashAlgid is String ? StrPtr(pwszCNGHashAlgid) : pwszCNGHashAlgid
        pwszFileName := pwszFileName is String ? StrPtr(pwszFileName) : pwszFileName

        result := DllCall("CRYPT32.dll\CertIsWeakHash", "uint", dwHashUseType, "ptr", pwszCNGHashAlgid, "uint", dwChainFlags, "ptr", pSignerChainContext, "ptr", pTimeStamp, "ptr", pwszFileName, "int")
        return result
    }

    /**
     * Performs encryption on the data in a DATA_BLOB structure.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pDataIn A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">DATA_BLOB</a> structure that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">plaintext</a> to be encrypted.
     * @param {PWSTR} szDataDescr A string with a readable description of the data to be encrypted. This description string is included with the encrypted data. This parameter is optional and can be set to <b>NULL</b>.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pOptionalEntropy A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">DATA_BLOB</a> structure that contains a password or other additional entropy used to encrypt the data. The <b>DATA_BLOB</b> structure used in the encryption phase must also be used in the decryption phase. This parameter can be set to <b>NULL</b> for no additional entropy. For information about protecting passwords, see <a href="https://docs.microsoft.com/windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.
     * @param {Pointer<CRYPTPROTECT_PROMPTSTRUCT>} pPromptStruct A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/dpapi/ns-dpapi-cryptprotect_promptstruct">CRYPTPROTECT_PROMPTSTRUCT</a> structure that provides information about where and when prompts are to be displayed and what the content of those prompts should be. This parameter can be set to <b>NULL</b> in both the encryption and decryption phases.
     * @param {Integer} dwFlags This parameter can be one of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECT_LOCAL_MACHINE"></a><a id="cryptprotect_local_machine"></a><dl>
     * <dt><b>CRYPTPROTECT_LOCAL_MACHINE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When this flag is set, it associates the data encrypted with the current computer instead of with an individual user. Any user on the computer on which <b>CryptProtectData</b> is called can use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/dpapi/nf-dpapi-cryptunprotectdata">CryptUnprotectData</a> to decrypt the data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECT_UI_FORBIDDEN"></a><a id="cryptprotect_ui_forbidden"></a><dl>
     * <dt><b>CRYPTPROTECT_UI_FORBIDDEN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is used for remote situations where presenting a user interface (UI) is not an option. When this flag is set and a UI is specified for either the protect or unprotect operation, the operation fails and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the ERROR_PASSWORD_RESTRICTION code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECT_AUDIT"></a><a id="cryptprotect_audit"></a><dl>
     * <dt><b>CRYPTPROTECT_AUDIT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag generates an audit on protect and unprotect operations. Audit log entries are recorded only if szDataDescr is not <b>NULL</b> and not empty.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pDataOut A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">DATA_BLOB</a> structure that receives the encrypted data. When you have finished using the <b>DATA_BLOB</b> structure, free its <b>pbData</b> member by calling the   <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> function.
     * @returns {BOOL} If the function succeeds, the function returns <b>TRUE</b>.
     * 						
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//dpapi/nf-dpapi-cryptprotectdata
     * @since windows5.1.2600
     */
    static CryptProtectData(pDataIn, szDataDescr, pOptionalEntropy, pPromptStruct, dwFlags, pDataOut) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        szDataDescr := szDataDescr is String ? StrPtr(szDataDescr) : szDataDescr

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptProtectData", "ptr", pDataIn, "ptr", szDataDescr, "ptr", pOptionalEntropy, "ptr", pvReserved, "ptr", pPromptStruct, "uint", dwFlags, "ptr", pDataOut, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Decrypts and does an integrity check of the data in a DATA_BLOB structure.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pDataIn A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">DATA_BLOB</a> structure that holds the encrypted data. The <b>DATA_BLOB</b> structure's <b>cbData</b> member holds the length of the <b>pbData</b> member's byte string that contains the text to be encrypted.
     * @param {Pointer<PWSTR>} ppszDataDescr A pointer to a string-readable description of the encrypted data included with the encrypted data. This parameter can be set to <b>NULL</b>.  When you have finished using <i>ppszDataDescr</i>, free it by calling the  <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> function.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pOptionalEntropy A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">DATA_BLOB</a> structure that contains a password or other additional entropy used when the data was encrypted. This parameter can be set to <b>NULL</b>; however, if an optional entropy <b>DATA_BLOB</b> structure was used in the encryption phase, that same <b>DATA_BLOB</b> structure must be used for the decryption phase. For information about protecting passwords, see <a href="https://docs.microsoft.com/windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.
     * @param {Pointer<CRYPTPROTECT_PROMPTSTRUCT>} pPromptStruct A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/dpapi/ns-dpapi-cryptprotect_promptstruct">CRYPTPROTECT_PROMPTSTRUCT</a> structure that provides information about where and when prompts are to be displayed and what the content of those prompts should be. This parameter can be set to <b>NULL</b>.
     * @param {Integer} dwFlags A <b>DWORD</b> value that specifies options for this function. This parameter can be zero, in which case no option is set, or the following flag.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECT_UI_FORBIDDEN"></a><a id="cryptprotect_ui_forbidden"></a><dl>
     * <dt><b>CRYPTPROTECT_UI_FORBIDDEN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is used for remote situations where the user interface (UI) is not an option. When this flag is set and UI is specified for either the protect or unprotect operation, the operation fails and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the ERROR_PASSWORD_RESTRICTION code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECT_VERIFY_PROTECTION"></a><a id="cryptprotect_verify_protection"></a><dl>
     * <dt><b>CRYPTPROTECT_VERIFY_PROTECTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag verifies the protection of a protected <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a>. If the default protection level configured of the host is higher than the current protection level for the BLOB, the function returns <b>CRYPT_I_NEW_PROTECTION_REQUIRED</b> to advise the caller to again protect the plaintext contained in the BLOB.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pDataOut A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">DATA_BLOB</a> structure where the function stores the decrypted data. When you have finished using the <b>DATA_BLOB</b> structure, free its <b>pbData</b> member by calling the  <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> function.
     * @returns {BOOL} If the function succeeds, the function returns  <b>TRUE</b>.
     * 
     * If the function fails, it returns  <b>FALSE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//dpapi/nf-dpapi-cryptunprotectdata
     * @since windows5.1.2600
     */
    static CryptUnprotectData(pDataIn, ppszDataDescr, pOptionalEntropy, pPromptStruct, dwFlags, pDataOut) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        ppszDataDescrMarshal := ppszDataDescr is VarRef ? "ptr*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptUnprotectData", "ptr", pDataIn, ppszDataDescrMarshal, ppszDataDescr, "ptr", pOptionalEntropy, "ptr", pvReserved, "ptr", pPromptStruct, "uint", dwFlags, "ptr", pDataOut, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Migrates the current user's master keys after the user's security identifier (SID) has changed.
     * @param {PSID} pOldSid The address of a <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-sid">SID</a> structure that contains the user's previous SID. This SID is used to locate the old master keys. If this parameter is <b>NULL</b>, the master keys for the current user SID are migrated.
     * 
     * Either this parameter or the <i>pwszOldPassword</i> parameter may be <b>NULL</b>, but not both.
     * @param {PWSTR} pwszOldPassword A pointer to a null-terminated Unicode string that contains the user's password before the SID was changed. This password is used to decrypt the old master keys. If this parameter is <b>NULL</b>, the password of the current user will be used.
     * 
     * Either this parameter or the <i>pOldSid</i> parameter may be <b>NULL</b>, but not both.
     * @param {Integer} dwFlags Not used. Must be zero.
     * @param {Pointer<Integer>} pdwSuccessCount The address of a <b>DWORD</b> variable that receives the number of master keys that were successfully migrated.
     * @param {Pointer<Integer>} pdwFailureCount The address of a <b>DWORD</b> variable that receives the number of master keys that could not be decrypted.
     * 
     * It is not necessarily an error if one or more master keys cannot be decrypted. Some users may possess master keys that are stagnant and could not have been decrypted for a long time. One way that this can happen is when the password of a local user has been administratively reset.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes include the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ENCRYPTION_FAILED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The old password could not be encrypted.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//dpapi/nf-dpapi-cryptupdateprotectedstate
     * @since windows6.0.6000
     */
    static CryptUpdateProtectedState(pOldSid, pwszOldPassword, dwFlags, pdwSuccessCount, pdwFailureCount) {
        pwszOldPassword := pwszOldPassword is String ? StrPtr(pwszOldPassword) : pwszOldPassword

        pdwSuccessCountMarshal := pdwSuccessCount is VarRef ? "uint*" : "ptr"
        pdwFailureCountMarshal := pdwFailureCount is VarRef ? "uint*" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptUpdateProtectedState", "ptr", pOldSid, "ptr", pwszOldPassword, "uint", dwFlags, pdwSuccessCountMarshal, pdwSuccessCount, pdwFailureCountMarshal, pdwFailureCount, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * encrypts memory to prevent others from viewing sensitive information in your process.
     * @param {Pointer<Void>} pDataIn A pointer to the block of memory to encrypt. The <i>cbData</i> parameter specifies the number of bytes that will be encrypted. If the data contained in the memory space is smaller than the number of bytes specified, data outside of the intended block will be encrypted. If it is larger than <i>cbData</i> bytes, then only the first <i>cbData</i> bytes will be encrypted.
     * @param {Integer} cbDataIn Number of bytes of memory pointed to by the <i>pData</i> parameter to encrypt. The number of bytes must be a multiple of the <b>CRYPTPROTECTMEMORY_BLOCK_SIZE</b> constant defined in Wincrypt.h.
     * @param {Integer} dwFlags This parameter can be one of the following flags. You must specify the same flag when encrypting and decrypting the memory.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECTMEMORY_SAME_PROCESS"></a><a id="cryptprotectmemory_same_process"></a><dl>
     * <dt><b>CRYPTPROTECTMEMORY_SAME_PROCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encrypt and decrypt memory in the same process. An application running in a different process will not be able to decrypt the data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECTMEMORY_CROSS_PROCESS"></a><a id="cryptprotectmemory_cross_process"></a><dl>
     * <dt><b>CRYPTPROTECTMEMORY_CROSS_PROCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encrypt and decrypt memory in different processes. An application running in a different process will be able to decrypt the data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECTMEMORY_SAME_LOGON"></a><a id="cryptprotectmemory_same_logon"></a><dl>
     * <dt><b>CRYPTPROTECTMEMORY_SAME_LOGON</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the same logon credentials to encrypt and decrypt memory in different processes. An application running in a different process will be able to decrypt the data. However, the process must run as the same user that encrypted the data and in the same logon session. 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//dpapi/nf-dpapi-cryptprotectmemory
     * @since windows6.0.6000
     */
    static CryptProtectMemory(pDataIn, cbDataIn, dwFlags) {
        pDataInMarshal := pDataIn is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptProtectMemory", pDataInMarshal, pDataIn, "uint", cbDataIn, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Decrypts memory that was encrypted using the CryptProtectMemory function.
     * @param {Pointer<Void>} pDataIn A pointer to the block of memory to decrypt. The <i>cbData</i> parameter specifies the number of bytes that the function will attempt to decrypt. If the data contained in the memory space is smaller than the number of bytes specified, the function will attempt to decrypt data outside of the intended block. If it is larger than <i>cbData</i> bytes, then only the first <i>cbData</i> bytes will be decrypted.
     * @param {Integer} cbDataIn Number of bytes of memory pointed to by the <i>pData</i> parameter to decrypt. The number of bytes must be a multiple of the <b>CRYPTPROTECTMEMORY_BLOCK_SIZE</b> constant defined in Wincrypt.h.
     * @param {Integer} dwFlags This parameter can be one of the following flags. You must specify the same flag when encrypting and decrypting the memory.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECTMEMORY_SAME_PROCESS"></a><a id="cryptprotectmemory_same_process"></a><dl>
     * <dt><b>CRYPTPROTECTMEMORY_SAME_PROCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encrypt and decrypt memory in the same process. An application running in a different process will not be able to decrypt the data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECTMEMORY_CROSS_PROCESS"></a><a id="cryptprotectmemory_cross_process"></a><dl>
     * <dt><b>CRYPTPROTECTMEMORY_CROSS_PROCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encrypt and decrypt memory in different processes. An application running in a different process will be able to decrypt the data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECTMEMORY_SAME_LOGON"></a><a id="cryptprotectmemory_same_logon"></a><dl>
     * <dt><b>CRYPTPROTECTMEMORY_SAME_LOGON</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the same logon credentials to encrypt and decrypt memory in different processes. An application running in a different process will be able to decrypt the data. However, the process must run as the same user that encrypted the data and in the same logon session.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//dpapi/nf-dpapi-cryptunprotectmemory
     * @since windows6.0.6000
     */
    static CryptUnprotectMemory(pDataIn, cbDataIn, dwFlags) {
        pDataInMarshal := pDataIn is VarRef ? "ptr" : "ptr"

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptUnprotectMemory", pDataInMarshal, pDataIn, "uint", cbDataIn, "uint", dwFlags, "int")
        if((!result && A_LastError)) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Registers the display name and the associated rule string for a protection descriptor.
     * @param {PWSTR} pwszName Pointer to a null-terminated Unicode string that contains the display name of the descriptor to be registered.
     * @param {PWSTR} pwszDescriptorString Pointer to a null-terminated Unicode string that contains a protection descriptor rule. If this parameter is <b>NULL</b> or the string is empty, the registry value previously created for the <i>pwszName</i> parameter will be deleted.
     * @param {Integer} dwFlags A constant that indicates the registry hive under which to register the new entry. If this value is zero (0), the registry root is <b>HKEY_CURRENT_USER</b>. If this value is <b>NCRYPT_MACHINE_KEY_FLAG</b>, the root is <b>HKEY_LOCAL_MACHINE</b>.
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pwszName</i> parameter cannot be <b>NULL</b>, and the value pointed to by the parameter cannot be an empty string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter must be zero or <b>NCRYPT_MACHINE_KEY_FLAG</b>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncryptprotect/nf-ncryptprotect-ncryptregisterprotectiondescriptorname
     * @since windows8.0
     */
    static NCryptRegisterProtectionDescriptorName(pwszName, pwszDescriptorString, dwFlags) {
        pwszName := pwszName is String ? StrPtr(pwszName) : pwszName
        pwszDescriptorString := pwszDescriptorString is String ? StrPtr(pwszDescriptorString) : pwszDescriptorString

        result := DllCall("ncrypt.dll\NCryptRegisterProtectionDescriptorName", "ptr", pwszName, "ptr", pwszDescriptorString, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves the protection descriptor rule string associated with a registered descriptor display name.
     * @param {PWSTR} pwszName The registered display name for the protection descriptor. Register a name by calling the <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptregisterprotectiondescriptorname">NCryptRegisterProtectionDescriptorName</a> function.
     * @param {PWSTR} pwszDescriptorString A null-terminated Unicode string that contains the protection descriptor rule. Set this value to <b>NULL</b> and set the size of the descriptor string pointed to by <i>pcDescriptorString</i> argument to zero on your initial call to this function. For more information, see Remarks.
     * @param {Pointer<Pointer>} pcDescriptorString Pointer to a variable that contains the number  of characters in the string retrieved in the <i>pwszDescriptorString</i> parameter. Set the variable to zero on your initial call to this function. For more information, see Remarks.
     * @param {Integer} dwFlags Flag that specifies which registry hive to query for the registered name. This can be zero to look in the <b>HKEY_CURRENT_USER</b> hive or you can specify <b>NCRYPT_MACHINE_KEY_FLAG</b> to query the <b>HKEY_LOCAL_MACHINE</b> hive.
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pwszName</i> parameter cannot be <b>NULL</b>, and the value pointed to by the parameter cannot be an empty string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter must be zero or <b>NCRYPT_MACHINE_KEY_FLAG</b>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncryptprotect/nf-ncryptprotect-ncryptqueryprotectiondescriptorname
     * @since windows8.0
     */
    static NCryptQueryProtectionDescriptorName(pwszName, pwszDescriptorString, pcDescriptorString, dwFlags) {
        pwszName := pwszName is String ? StrPtr(pwszName) : pwszName
        pwszDescriptorString := pwszDescriptorString is String ? StrPtr(pwszDescriptorString) : pwszDescriptorString

        pcDescriptorStringMarshal := pcDescriptorString is VarRef ? "ptr*" : "ptr"

        result := DllCall("ncrypt.dll\NCryptQueryProtectionDescriptorName", "ptr", pwszName, "ptr", pwszDescriptorString, pcDescriptorStringMarshal, pcDescriptorString, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves a handle to a protection descriptor object.
     * @param {PWSTR} pwszDescriptorString Null-terminated Unicode string that contains a protection descriptor rule string or a registered display name for the rule.
     * 
     * If you specify the display name and you want this function to look in the registry for the associated protection descriptor rule string, you must set the <i>dwFlags</i> parameter to <b>NCRYPT_NAMED_DESCRIPTOR_FLAG</b>.
     * @param {Integer} dwFlags Flag that specifies whether the string in <i>pwszDescriptorString</i> represents the display name of a  protection descriptor and, if so, where in the registry the function should search for the associated protection rule string. The following value combinations can be set:
     * 
     * <ul>
     * <li>To indicate that the value set in the <i>pwszDescriptorString</i> parameter is a complete protection descriptor rule string rather than a display name, set the <i>dwFlags</i> parameter to zero (0).</li>
     * <li>To indicate that the string is a display name and that it is saved, along with its associated descriptor rule string, in the <b>HKEY_LOCAL_MACHINE</b> registry hive, bitwise-OR  the <b>NCRYPT_NAMED_DESCRIPTOR_FLAG</b> value and the <b>NCRYPT_MACHINE_KEY_FLAG</b> value.</li>
     * <li>To indicate that the string is a display name and that it is saved, along with its associated descriptor string rule, in the <b>HKEY_CURRENT_USER</b> registry hive, set only the <b>NCRYPT_NAMED_DESCRIPTOR_FLAG</b> value. That is, there is no unique  flag to specify the current user registry hive.</li>
     * </ul>
     * <div class="alert"><b>Note</b>To associate a descriptor rule with a display name and save both in the registry, call the <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptregisterprotectiondescriptorname">NCryptRegisterProtectionDescriptorName</a> function.</div>
     * <div></div>
     * @returns {NCRYPT_DESCRIPTOR_HANDLE} Pointer to a protection descriptor object handle.
     * @see https://docs.microsoft.com/windows/win32/api//ncryptprotect/nf-ncryptprotect-ncryptcreateprotectiondescriptor
     * @since windows8.0
     */
    static NCryptCreateProtectionDescriptor(pwszDescriptorString, dwFlags) {
        pwszDescriptorString := pwszDescriptorString is String ? StrPtr(pwszDescriptorString) : pwszDescriptorString

        phDescriptor := NCRYPT_DESCRIPTOR_HANDLE()
        result := DllCall("ncrypt.dll\NCryptCreateProtectionDescriptor", "ptr", pwszDescriptorString, "uint", dwFlags, "ptr", phDescriptor, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phDescriptor
    }

    /**
     * Zeros and frees a protection descriptor object and releases its handle.
     * @param {NCRYPT_DESCRIPTOR_HANDLE} hDescriptor Handle of a protection descriptor created by calling <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptcreateprotectiondescriptor">NCryptCreateProtectionDescriptor</a>.
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle specified by the <i>hDescriptor</i> parameter cannot be <b>NULL</b> and it must represent a valid descriptor.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncryptprotect/nf-ncryptprotect-ncryptcloseprotectiondescriptor
     * @since windows8.0
     */
    static NCryptCloseProtectionDescriptor(hDescriptor) {
        hDescriptor := hDescriptor is Win32Handle ? NumGet(hDescriptor, "ptr") : hDescriptor

        result := DllCall("ncrypt.dll\NCryptCloseProtectionDescriptor", "ptr", hDescriptor, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Retrieves a protection descriptor rule string.
     * @param {NCRYPT_DESCRIPTOR_HANDLE} hDescriptor Protection descriptor handle created by calling <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptcreateprotectiondescriptor">NCryptCreateProtectionDescriptor</a>.
     * @param {Pointer<NCRYPT_ALLOC_PARA>} pMemPara Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/ns-ncrypt-ncrypt_alloc_para">NCRYPT_ALLOC_PARA</a> structure that you can use to specify custom memory management functions. If you set this argument to <b>NULL</b>, the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> function is used internally to allocate memory and your application must call <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> to release memory pointed to by the <i>ppvInfo</i> parameter.
     * @param {Integer} dwInfoType Specifies how to return descriptor information to the  <i>ppvInfo</i> parameter. This can be the following value:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_PROTECTION_INFO_TYPE_DESCRIPTOR_STRING"></a><a id="ncrypt_protection_info_type_descriptor_string"></a><dl>
     * <dt><b>NCRYPT_PROTECTION_INFO_TYPE_DESCRIPTOR_STRING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>ppvInfo</i> argument returns the descriptor rule string.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Pointer<Void>} Pointer to the descriptor information.
     * @see https://docs.microsoft.com/windows/win32/api//ncryptprotect/nf-ncryptprotect-ncryptgetprotectiondescriptorinfo
     * @since windows8.0
     */
    static NCryptGetProtectionDescriptorInfo(hDescriptor, pMemPara, dwInfoType) {
        hDescriptor := hDescriptor is Win32Handle ? NumGet(hDescriptor, "ptr") : hDescriptor

        result := DllCall("ncrypt.dll\NCryptGetProtectionDescriptorInfo", "ptr", hDescriptor, "ptr", pMemPara, "uint", dwInfoType, "ptr*", &ppvInfo := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppvInfo
    }

    /**
     * Encrypts data to a specified protection descriptor.
     * @param {NCRYPT_DESCRIPTOR_HANDLE} hDescriptor Handle of the protection descriptor object. Create the handle by calling <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptcreateprotectiondescriptor">NCryptCreateProtectionDescriptor</a>.
     * @param {Integer} dwFlags The flag can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider not display a user interface.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} pbData Pointer to the byte array to be protected.
     * @param {Integer} cbData Number of bytes in the binary array specified by the <i>pbData</i> parameter.
     * @param {Pointer<NCRYPT_ALLOC_PARA>} pMemPara Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/ns-ncrypt-ncrypt_alloc_para">NCRYPT_ALLOC_PARA</a> structure that you can use to specify custom memory management functions. If you set this argument to <b>NULL</b>, the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> function is used internally to allocate memory and your application must call <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> to release memory pointed to by the <i>ppbProtectedBlob</i> parameter.
     * @param {HWND} hWnd Handle to the parent window of the user interface, if any, to be displayed.
     * @param {Pointer<Pointer<Integer>>} ppbProtectedBlob Address of a variable that receives a pointer to the encrypted data.
     * @param {Pointer<Integer>} pcbProtectedBlob Pointer to a <b>ULONG</b> variable that contains the size, in bytes, of the encrypted data pointed to by the <i>ppbProtectedBlob</i> variable.
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pbData</i>, <i>ppbProtectedBlob</i>, and <i>pcbProtectedBlob</i> parameters cannot be <b>NULL</b>.
     * 
     * The <i>cbData</i> parameter cannot be less than one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory exists to allocate the content encryption key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle specified by the <i>hDescriptor</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncryptprotect/nf-ncryptprotect-ncryptprotectsecret
     * @since windows8.0
     */
    static NCryptProtectSecret(hDescriptor, dwFlags, pbData, cbData, pMemPara, hWnd, ppbProtectedBlob, pcbProtectedBlob) {
        hDescriptor := hDescriptor is Win32Handle ? NumGet(hDescriptor, "ptr") : hDescriptor
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd

        ppbProtectedBlobMarshal := ppbProtectedBlob is VarRef ? "ptr*" : "ptr"
        pcbProtectedBlobMarshal := pcbProtectedBlob is VarRef ? "uint*" : "ptr"

        result := DllCall("ncrypt.dll\NCryptProtectSecret", "ptr", hDescriptor, "uint", dwFlags, "ptr", pbData, "uint", cbData, "ptr", pMemPara, "ptr", hWnd, ppbProtectedBlobMarshal, ppbProtectedBlob, pcbProtectedBlobMarshal, pcbProtectedBlob, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Decrypts data to a specified protection descriptor.
     * @param {Pointer<NCRYPT_DESCRIPTOR_HANDLE>} phDescriptor Pointer to the protection descriptor handle.
     * @param {Integer} dwFlags 
     * @param {Pointer} pbProtectedBlob Pointer to an array of bytes that contains the data to decrypt.
     * @param {Integer} cbProtectedBlob The number of bytes in the array pointed to by the <i>pbProtectedBlob</i> parameter.
     * @param {Pointer<NCRYPT_ALLOC_PARA>} pMemPara Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/ns-ncrypt-ncrypt_alloc_para">NCRYPT_ALLOC_PARA</a> structure that you can use to specify custom memory management functions. If you set this argument to <b>NULL</b>, the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> function is used internally to allocate memory and your application must call <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> to release memory pointed to by the <i>ppbData</i> parameter.
     * @param {HWND} hWnd Handle to the parent window of the user interface, if any, to be displayed.
     * @param {Pointer<Pointer<Integer>>} ppbData Address of a variable that receives a pointer to the decrypted data.
     * @param {Pointer<Integer>} pcbData Pointer to a <b>ULONG</b> variable that contains the size, in bytes, of the decrypted data pointed to by the <i>ppbData</i> variable.
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The dwFlags parameter can only contain <b>NCRYPT_SILENT_FLAG</b> or <b>NCRYPT_UNPROTECT_NO_DECRYPT</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pbProtectedBlob</i>, <i>ppbData</i>, and <i>pcbData</i> parameters cannot be <b>NULL</b>.
     * 
     * The <i>cbData</i> parameter cannot be less than one.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncryptprotect/nf-ncryptprotect-ncryptunprotectsecret
     * @since windows8.0
     */
    static NCryptUnprotectSecret(phDescriptor, dwFlags, pbProtectedBlob, cbProtectedBlob, pMemPara, hWnd, ppbData, pcbData) {
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd

        ppbDataMarshal := ppbData is VarRef ? "ptr*" : "ptr"
        pcbDataMarshal := pcbData is VarRef ? "uint*" : "ptr"

        result := DllCall("ncrypt.dll\NCryptUnprotectSecret", "ptr", phDescriptor, "uint", dwFlags, "ptr", pbProtectedBlob, "uint", cbProtectedBlob, "ptr", pMemPara, "ptr", hWnd, ppbDataMarshal, ppbData, pcbDataMarshal, pcbData, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Opens a stream object that can be used to encrypt large amounts of data to a given protection descriptor.
     * @param {NCRYPT_DESCRIPTOR_HANDLE} hDescriptor Handle of the protection descriptor. Create the handle by calling <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptcreateprotectiondescriptor">NCryptCreateProtectionDescriptor</a>.
     * @param {Integer} dwFlags The flag can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider not display a user interface.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {HWND} hWnd Handle to the parent window of the user interface, if any, to be displayed.
     * @param {Pointer<NCRYPT_PROTECT_STREAM_INFO>} pStreamInfo Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/ns-ncryptprotect-ncrypt_protect_stream_info">NCRYPT_PROTECT_STREAM_INFO</a> structure that contains the address of a user defined callback function to receive the encrypted data and a pointer to user-defined context data.
     * @returns {NCRYPT_STREAM_HANDLE} Pointer to the stream object handle.
     * @see https://docs.microsoft.com/windows/win32/api//ncryptprotect/nf-ncryptprotect-ncryptstreamopentoprotect
     * @since windows8.0
     */
    static NCryptStreamOpenToProtect(hDescriptor, dwFlags, hWnd, pStreamInfo) {
        hDescriptor := hDescriptor is Win32Handle ? NumGet(hDescriptor, "ptr") : hDescriptor
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd

        phStream := NCRYPT_STREAM_HANDLE()
        result := DllCall("ncrypt.dll\NCryptStreamOpenToProtect", "ptr", hDescriptor, "uint", dwFlags, "ptr", hWnd, "ptr", pStreamInfo, "ptr", phStream, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phStream
    }

    /**
     * Opens a stream object that can be used to decrypt large amounts of data to the same protection descriptor used for encryption.
     * @param {Pointer<NCRYPT_PROTECT_STREAM_INFO>} pStreamInfo Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/ns-ncryptprotect-ncrypt_protect_stream_info">NCRYPT_PROTECT_STREAM_INFO</a> structure that contains the address of a user defined callback function to receive the decrypted data and a pointer to user-defined context data.
     * @param {Integer} dwFlags A flag that specifies additional information for the key service provider. This can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider not display a user interface.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {HWND} hWnd Handle to the parent window of the user interface, if any, to be displayed.
     * @returns {NCRYPT_STREAM_HANDLE} Pointer to the handle of the decrypted stream of data.
     * @see https://docs.microsoft.com/windows/win32/api//ncryptprotect/nf-ncryptprotect-ncryptstreamopentounprotect
     * @since windows8.0
     */
    static NCryptStreamOpenToUnprotect(pStreamInfo, dwFlags, hWnd) {
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd

        phStream := NCRYPT_STREAM_HANDLE()
        result := DllCall("ncrypt.dll\NCryptStreamOpenToUnprotect", "ptr", pStreamInfo, "uint", dwFlags, "ptr", hWnd, "ptr", phStream, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phStream
    }

    /**
     * Opens a stream object that can be used to decrypt large amounts of data to the same protection descriptor used for encryption.
     * @param {Pointer<NCRYPT_PROTECT_STREAM_INFO_EX>} pStreamInfo A pointer to NCRYPT_PROTECT_STREAM_INFO_EX.
     * @param {Integer} dwFlags Only the NCRYPT_SILENT_FLAG is supported.
     * @param {HWND} hWnd A window handle to be used as the parent of any user
     *         interface that is displayed.
     * @returns {NCRYPT_STREAM_HANDLE} Receives a pointer to a stream handle.
     * @see https://docs.microsoft.com/windows/win32/api//ncryptprotect/nf-ncryptprotect-ncryptstreamopentounprotectex
     */
    static NCryptStreamOpenToUnprotectEx(pStreamInfo, dwFlags, hWnd) {
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd

        phStream := NCRYPT_STREAM_HANDLE()
        result := DllCall("ncrypt.dll\NCryptStreamOpenToUnprotectEx", "ptr", pStreamInfo, "uint", dwFlags, "ptr", hWnd, "ptr", phStream, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phStream
    }

    /**
     * Encrypts and decrypts blocks of data.
     * @param {NCRYPT_STREAM_HANDLE} hStream Handle to the stream object created by calling <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamopentoprotect">NCryptStreamOpenToProtect</a> or <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamopentounprotect">NCryptStreamOpenToUnprotect</a>.
     * @param {Pointer} pbData Pointer to the byte array to be processed.
     * @param {Pointer} cbData Number of bytes in the binary array specified by the <i>pbData</i> parameter.
     * @param {BOOL} fFinal A Boolean value that specifies whether the last block of data has been processed.
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The content could not be decoded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The stream handle pointed to by the <i>hStream</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory available to process the content.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncryptprotect/nf-ncryptprotect-ncryptstreamupdate
     * @since windows8.0
     */
    static NCryptStreamUpdate(hStream, pbData, cbData, fFinal) {
        hStream := hStream is Win32Handle ? NumGet(hStream, "ptr") : hStream

        result := DllCall("ncrypt.dll\NCryptStreamUpdate", "ptr", hStream, "ptr", pbData, "ptr", cbData, "int", fFinal, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Closes a data protection stream object opened by using the NCryptStreamOpenToProtect or NCryptStreamOpenToUnprotect functions.
     * @param {NCRYPT_STREAM_HANDLE} hStream Data stream handle returned by <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamopentoprotect">NCryptStreamOpenToProtect</a> or <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamopentounprotect">NCryptStreamOpenToUnprotect</a>.
     * @returns {HRESULT} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle specified by the <i>hStream</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ncryptprotect/nf-ncryptprotect-ncryptstreamclose
     * @since windows8.0
     */
    static NCryptStreamClose(hStream) {
        hStream := hStream is Win32Handle ? NumGet(hStream, "ptr") : hStream

        result := DllCall("ncrypt.dll\NCryptStreamClose", "ptr", hStream, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signerror
     */
    static SignError() {
        result := DllCall("Mssign32.dll\SignError", "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {Pointer<SIGNER_CONTEXT>} pSignerContext 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signerfreesignercontext
     */
    static SignerFreeSignerContext(pSignerContext) {
        result := DllCall("Mssign32.dll\SignerFreeSignerContext", "ptr", pSignerContext, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {Pointer<SIGNER_SUBJECT_INFO>} pSubjectInfo 
     * @param {Pointer<SIGNER_CERT>} pSignerCert 
     * @param {Pointer<SIGNER_SIGNATURE_INFO>} pSignatureInfo 
     * @param {Pointer<SIGNER_PROVIDER_INFO>} pProviderInfo 
     * @param {PWSTR} pwszHttpTimeStamp 
     * @param {Pointer<CRYPT_ATTRIBUTES>} psRequest 
     * @param {Pointer<Void>} pSipData 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signersign
     */
    static SignerSign(pSubjectInfo, pSignerCert, pSignatureInfo, pProviderInfo, pwszHttpTimeStamp, psRequest, pSipData) {
        pwszHttpTimeStamp := pwszHttpTimeStamp is String ? StrPtr(pwszHttpTimeStamp) : pwszHttpTimeStamp

        pSipDataMarshal := pSipData is VarRef ? "ptr" : "ptr"

        result := DllCall("Mssign32.dll\SignerSign", "ptr", pSubjectInfo, "ptr", pSignerCert, "ptr", pSignatureInfo, "ptr", pProviderInfo, "ptr", pwszHttpTimeStamp, "ptr", psRequest, pSipDataMarshal, pSipData, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {Integer} dwFlags 
     * @param {Pointer<SIGNER_SUBJECT_INFO>} pSubjectInfo 
     * @param {Pointer<SIGNER_CERT>} pSignerCert 
     * @param {Pointer<SIGNER_SIGNATURE_INFO>} pSignatureInfo 
     * @param {Pointer<SIGNER_PROVIDER_INFO>} pProviderInfo 
     * @param {PWSTR} pwszHttpTimeStamp 
     * @param {Pointer<CRYPT_ATTRIBUTES>} psRequest 
     * @param {Pointer<Void>} pSipData 
     * @returns {Pointer<SIGNER_CONTEXT>} 
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signersignex
     */
    static SignerSignEx(dwFlags, pSubjectInfo, pSignerCert, pSignatureInfo, pProviderInfo, pwszHttpTimeStamp, psRequest, pSipData) {
        pwszHttpTimeStamp := pwszHttpTimeStamp is String ? StrPtr(pwszHttpTimeStamp) : pwszHttpTimeStamp

        pSipDataMarshal := pSipData is VarRef ? "ptr" : "ptr"

        result := DllCall("Mssign32.dll\SignerSignEx", "uint", dwFlags, "ptr", pSubjectInfo, "ptr", pSignerCert, "ptr", pSignatureInfo, "ptr", pProviderInfo, "ptr", pwszHttpTimeStamp, "ptr", psRequest, pSipDataMarshal, pSipData, "ptr*", &ppSignerContext := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppSignerContext
    }

    /**
     * 
     * @param {Integer} dwFlags 
     * @param {Pointer<SIGNER_SUBJECT_INFO>} pSubjectInfo 
     * @param {Pointer<SIGNER_CERT>} pSignerCert 
     * @param {Pointer<SIGNER_SIGNATURE_INFO>} pSignatureInfo 
     * @param {Pointer<SIGNER_PROVIDER_INFO>} pProviderInfo 
     * @param {Integer} dwTimestampFlags 
     * @param {PSTR} pszTimestampAlgorithmOid 
     * @param {PWSTR} pwszHttpTimeStamp 
     * @param {Pointer<CRYPT_ATTRIBUTES>} psRequest 
     * @param {Pointer<Void>} pSipData 
     * @param {Pointer<CERT_STRONG_SIGN_PARA>} pCryptoPolicy 
     * @returns {Pointer<SIGNER_CONTEXT>} 
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signersignex2
     */
    static SignerSignEx2(dwFlags, pSubjectInfo, pSignerCert, pSignatureInfo, pProviderInfo, dwTimestampFlags, pszTimestampAlgorithmOid, pwszHttpTimeStamp, psRequest, pSipData, pCryptoPolicy) {
        static pReserved := 0 ;Reserved parameters must always be NULL

        pszTimestampAlgorithmOid := pszTimestampAlgorithmOid is String ? StrPtr(pszTimestampAlgorithmOid) : pszTimestampAlgorithmOid
        pwszHttpTimeStamp := pwszHttpTimeStamp is String ? StrPtr(pwszHttpTimeStamp) : pwszHttpTimeStamp

        pSipDataMarshal := pSipData is VarRef ? "ptr" : "ptr"

        result := DllCall("Mssign32.dll\SignerSignEx2", "uint", dwFlags, "ptr", pSubjectInfo, "ptr", pSignerCert, "ptr", pSignatureInfo, "ptr", pProviderInfo, "uint", dwTimestampFlags, "ptr", pszTimestampAlgorithmOid, "ptr", pwszHttpTimeStamp, "ptr", psRequest, pSipDataMarshal, pSipData, "ptr*", &ppSignerContext := 0, "ptr", pCryptoPolicy, "ptr", pReserved, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppSignerContext
    }

    /**
     * 
     * @param {Integer} dwFlags 
     * @param {Pointer<SIGNER_SUBJECT_INFO>} pSubjectInfo 
     * @param {Pointer<SIGNER_CERT>} pSignerCert 
     * @param {Pointer<SIGNER_SIGNATURE_INFO>} pSignatureInfo 
     * @param {Pointer<SIGNER_PROVIDER_INFO>} pProviderInfo 
     * @param {Integer} dwTimestampFlags 
     * @param {PSTR} pszTimestampAlgorithmOid 
     * @param {PWSTR} pwszHttpTimeStamp 
     * @param {Pointer<CRYPT_ATTRIBUTES>} psRequest 
     * @param {Pointer<Void>} pSipData 
     * @param {Pointer<CERT_STRONG_SIGN_PARA>} pCryptoPolicy 
     * @param {Pointer<SIGNER_DIGEST_SIGN_INFO>} pDigestSignInfo 
     * @returns {Pointer<SIGNER_CONTEXT>} 
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signersignex3
     */
    static SignerSignEx3(dwFlags, pSubjectInfo, pSignerCert, pSignatureInfo, pProviderInfo, dwTimestampFlags, pszTimestampAlgorithmOid, pwszHttpTimeStamp, psRequest, pSipData, pCryptoPolicy, pDigestSignInfo) {
        static pReserved := 0 ;Reserved parameters must always be NULL

        pszTimestampAlgorithmOid := pszTimestampAlgorithmOid is String ? StrPtr(pszTimestampAlgorithmOid) : pszTimestampAlgorithmOid
        pwszHttpTimeStamp := pwszHttpTimeStamp is String ? StrPtr(pwszHttpTimeStamp) : pwszHttpTimeStamp

        pSipDataMarshal := pSipData is VarRef ? "ptr" : "ptr"

        result := DllCall("Mssign32.dll\SignerSignEx3", "uint", dwFlags, "ptr", pSubjectInfo, "ptr", pSignerCert, "ptr", pSignatureInfo, "ptr", pProviderInfo, "uint", dwTimestampFlags, "ptr", pszTimestampAlgorithmOid, "ptr", pwszHttpTimeStamp, "ptr", psRequest, pSipDataMarshal, pSipData, "ptr*", &ppSignerContext := 0, "ptr", pCryptoPolicy, "ptr", pDigestSignInfo, "ptr", pReserved, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppSignerContext
    }

    /**
     * 
     * @param {Pointer<SIGNER_SUBJECT_INFO>} pSubjectInfo 
     * @param {PWSTR} pwszHttpTimeStamp 
     * @param {Pointer<CRYPT_ATTRIBUTES>} psRequest 
     * @param {Pointer<Void>} pSipData 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signertimestamp
     */
    static SignerTimeStamp(pSubjectInfo, pwszHttpTimeStamp, psRequest, pSipData) {
        pwszHttpTimeStamp := pwszHttpTimeStamp is String ? StrPtr(pwszHttpTimeStamp) : pwszHttpTimeStamp

        pSipDataMarshal := pSipData is VarRef ? "ptr" : "ptr"

        result := DllCall("Mssign32.dll\SignerTimeStamp", "ptr", pSubjectInfo, "ptr", pwszHttpTimeStamp, "ptr", psRequest, pSipDataMarshal, pSipData, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {Pointer<SIGNER_SUBJECT_INFO>} pSubjectInfo 
     * @param {PWSTR} pwszHttpTimeStamp 
     * @param {Pointer<CRYPT_ATTRIBUTES>} psRequest 
     * @param {Pointer<Void>} pSipData 
     * @returns {Pointer<SIGNER_CONTEXT>} 
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signertimestampex
     */
    static SignerTimeStampEx(pSubjectInfo, pwszHttpTimeStamp, psRequest, pSipData) {
        static dwFlags := 0 ;Reserved parameters must always be NULL

        pwszHttpTimeStamp := pwszHttpTimeStamp is String ? StrPtr(pwszHttpTimeStamp) : pwszHttpTimeStamp

        pSipDataMarshal := pSipData is VarRef ? "ptr" : "ptr"

        result := DllCall("Mssign32.dll\SignerTimeStampEx", "uint", dwFlags, "ptr", pSubjectInfo, "ptr", pwszHttpTimeStamp, "ptr", psRequest, pSipDataMarshal, pSipData, "ptr*", &ppSignerContext := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppSignerContext
    }

    /**
     * 
     * @param {Pointer<SIGNER_SUBJECT_INFO>} pSubjectInfo 
     * @param {PWSTR} pwszHttpTimeStamp 
     * @param {Integer} dwAlgId 
     * @param {Pointer<CRYPT_ATTRIBUTES>} psRequest 
     * @param {Pointer<Void>} pSipData 
     * @returns {Pointer<SIGNER_CONTEXT>} 
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signertimestampex2
     */
    static SignerTimeStampEx2(pSubjectInfo, pwszHttpTimeStamp, dwAlgId, psRequest, pSipData) {
        static dwFlags := 0 ;Reserved parameters must always be NULL

        pwszHttpTimeStamp := pwszHttpTimeStamp is String ? StrPtr(pwszHttpTimeStamp) : pwszHttpTimeStamp

        pSipDataMarshal := pSipData is VarRef ? "ptr" : "ptr"

        result := DllCall("Mssign32.dll\SignerTimeStampEx2", "uint", dwFlags, "ptr", pSubjectInfo, "ptr", pwszHttpTimeStamp, "uint", dwAlgId, "ptr", psRequest, pSipDataMarshal, pSipData, "ptr*", &ppSignerContext := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppSignerContext
    }

    /**
     * 
     * @param {Integer} dwFlags 
     * @param {Integer} dwIndex 
     * @param {Pointer<SIGNER_SUBJECT_INFO>} pSubjectInfo 
     * @param {PWSTR} pwszHttpTimeStamp 
     * @param {PWSTR} pszAlgorithmOid 
     * @param {Pointer<CRYPT_ATTRIBUTES>} psRequest 
     * @param {Pointer<Void>} pSipData 
     * @param {Pointer<CERT_STRONG_SIGN_PARA>} pCryptoPolicy 
     * @returns {Pointer<SIGNER_CONTEXT>} 
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signertimestampex3
     */
    static SignerTimeStampEx3(dwFlags, dwIndex, pSubjectInfo, pwszHttpTimeStamp, pszAlgorithmOid, psRequest, pSipData, pCryptoPolicy) {
        static pReserved := 0 ;Reserved parameters must always be NULL

        pwszHttpTimeStamp := pwszHttpTimeStamp is String ? StrPtr(pwszHttpTimeStamp) : pwszHttpTimeStamp
        pszAlgorithmOid := pszAlgorithmOid is String ? StrPtr(pszAlgorithmOid) : pszAlgorithmOid

        pSipDataMarshal := pSipData is VarRef ? "ptr" : "ptr"

        result := DllCall("Mssign32.dll\SignerTimeStampEx3", "uint", dwFlags, "uint", dwIndex, "ptr", pSubjectInfo, "ptr", pwszHttpTimeStamp, "ptr", pszAlgorithmOid, "ptr", psRequest, pSipDataMarshal, pSipData, "ptr*", &ppSignerContext := 0, "ptr", pCryptoPolicy, "ptr", pReserved, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppSignerContext
    }

    /**
     * Closes a cryptographic XML object handle.
     * @param {Pointer<Void>} hCryptXml The handle of the cryptographic XML object to be closed.
     * @returns {HRESULT} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://docs.microsoft.com/windows/win32/api//cryptxml/nf-cryptxml-cryptxmlclose
     * @since windows6.1
     */
    static CryptXmlClose(hCryptXml) {
        hCryptXmlMarshal := hCryptXml is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPTXML.dll\CryptXmlClose", hCryptXmlMarshal, hCryptXml, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Returns information about the default transform chain engine.
     * @returns {Pointer<CRYPT_XML_TRANSFORM_CHAIN_CONFIG>} A pointer to a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_transform_chain_config">CRYPT_XML_TRANSFORM_CHAIN_CONFIG</a> structure to receive the returned transform information.
     * @see https://docs.microsoft.com/windows/win32/api//cryptxml/nf-cryptxml-cryptxmlgettransforms
     * @since windows6.1
     */
    static CryptXmlGetTransforms() {
        result := DllCall("CRYPTXML.dll\CryptXmlGetTransforms", "ptr*", &ppConfig := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppConfig
    }

    /**
     * Opens an XML digital signature to encode and returns a handle of the opened Signature element. The handle encapsulates a document context with a single CRYPT_XML_SIGNATURE structure and remains open until the CryptXmlClose function is called.
     * @param {Pointer<CRYPT_XML_TRANSFORM_CHAIN_CONFIG>} pConfig The handle of the transform chain engine. If this parameter is <b>NULL</b>, then a default engine is used to apply transforms.
     * @param {Integer} dwFlags 
     * @param {PWSTR} wszId A pointer to a null-terminated Unicode string that contains the <b>Id</b> attribute of the <b>Signature</b> element.
     * If this parameter is <b>NULL</b>, then a new GUID is generated. If this parameter is an empty string, then no <b>Id</b> attribute is produced.
     * @param {Pointer<CRYPT_XML_PROPERTY>} rgProperty A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_property">CRYPT_XML_PROPERTY</a> structures that specify additional properties.
     * @param {Integer} cProperty The number of elements in the array pointed to by the <i>rgProperty</i> parameter.
     * @param {Pointer<CRYPT_XML_BLOB>} pEncoded A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_blob">CRYPT_XML_BLOB</a> structure that contains the signature to encode.
     * @returns {Pointer<Void>} The handle to the <b>Signature</b> element.
     * @see https://docs.microsoft.com/windows/win32/api//cryptxml/nf-cryptxml-cryptxmlopentoencode
     * @since windows6.1
     */
    static CryptXmlOpenToEncode(pConfig, dwFlags, wszId, rgProperty, cProperty, pEncoded) {
        wszId := wszId is String ? StrPtr(wszId) : wszId

        result := DllCall("CRYPTXML.dll\CryptXmlOpenToEncode", "ptr", pConfig, "uint", dwFlags, "ptr", wszId, "ptr", rgProperty, "uint", cProperty, "ptr", pEncoded, "ptr*", &phSignature := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phSignature
    }

    /**
     * Opens an XML digital signature to decode and returns the handle of the document context that encapsulates a CRYPT_XML_SIGNATURE structure. The document context can include one or more Signature elements.
     * @param {Pointer<CRYPT_XML_TRANSFORM_CHAIN_CONFIG>} pConfig The handle of the transform chain engine. 
     *     If this parameter is <b>NULL</b>, then a default engine will be 
     *     used to apply transforms.
     * @param {Integer} dwFlags 
     * @param {Pointer<CRYPT_XML_PROPERTY>} rgProperty A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_property">CRYPT_XML_PROPERTY</a> structures that contain additional properties.
     * @param {Integer} cProperty The number of items in the array pointed to by the <i>rgProperty</i> parameter.
     * @param {Pointer<CRYPT_XML_BLOB>} pEncoded A pointer to <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_blob">CRYPT_XML_BLOB</a> structure that contains the signature to decode.
     * @returns {Pointer<Void>} The handle of a Document Context object.  When you have finished using the handle, release it by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/nf-cryptxml-cryptxmlclose">CryptXmlClose</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//cryptxml/nf-cryptxml-cryptxmlopentodecode
     * @since windows6.1
     */
    static CryptXmlOpenToDecode(pConfig, dwFlags, rgProperty, cProperty, pEncoded) {
        result := DllCall("CRYPTXML.dll\CryptXmlOpenToDecode", "ptr", pConfig, "uint", dwFlags, "ptr", rgProperty, "uint", cProperty, "ptr", pEncoded, "ptr*", &phCryptXml := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phCryptXml
    }

    /**
     * Adds the Object element to the Signature in the Document Context opened for encoding.
     * @param {Pointer<Void>} hSignatureOrObject The handle of a Signature returned by the <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/nf-cryptxml-cryptxmlopentoencode">CryptXmlOpenToEncode</a> function or the handle of a Reference returned by the <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/nf-cryptxml-cryptxmlcreatereference">CryptXmlCreateReference</a> function with     the <b>CRYPT_XML_FLAG_CREATE_REFERENCE_AS_OBJECT</b> flag set.
     * @param {Integer} dwFlags Specifies flags that control the manner in which the object is added.
     * 
     * 
     * Currently defined <i>dwFlags</i> values are shown in the following table .
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_XML_ADD_OBJECT_CREATE_REFERENCE"></a><a id="crypt_xml_add_object_create_reference"></a><dl>
     * <dt><b>CRYPT_XML_ADD_OBJECT_CREATE_REFERENCE</b></dt>
     * <dt></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When set, an in-memory copy of the XML part is created and included in the <b>Object</b> element.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CRYPT_XML_PROPERTY>} rgProperty A pointer to  a  <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_property">CRYPT_XML_PROPERTY</a> structure that specifies additional properties used to decode the <b>Object</b> element.
     * @param {Integer} cProperty The number of elements in the array pointed to by the <i>rgProperty</i> property.
     * @param {Pointer<CRYPT_XML_BLOB>} pEncoded A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_blob">CRYPT_XML_BLOB</a> structure that contains the <b>Object</b> element.
     * @returns {Pointer<CRYPT_XML_OBJECT>} A pointer to  a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_object">CRYPT_XML_OBJECT</a> structure to receive the decoded structure.
     *     This parameter must be <b>NULL</b> when the <i>hSignatureOrObject</i> parameter contains a handle to the Object.
     * @see https://docs.microsoft.com/windows/win32/api//cryptxml/nf-cryptxml-cryptxmladdobject
     * @since windows6.1
     */
    static CryptXmlAddObject(hSignatureOrObject, dwFlags, rgProperty, cProperty, pEncoded) {
        hSignatureOrObjectMarshal := hSignatureOrObject is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPTXML.dll\CryptXmlAddObject", hSignatureOrObjectMarshal, hSignatureOrObject, "uint", dwFlags, "ptr", rgProperty, "uint", cProperty, "ptr", pEncoded, "ptr*", &ppObject := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppObject
    }

    /**
     * Creates a reference to an XML signature.
     * @param {Pointer<Void>} hCryptXml The handle of the XML signature.
     * @param {Integer} dwFlags Specifies flags that affect how the reference is created.
     * 
     * 
     * Currently defined <i>dwFlags</i> values are shown in the following table.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_XML_FLAG_CREATE_REFERENCE_AS_OBJECT"></a><a id="crypt_xml_flag_create_reference_as_object"></a><dl>
     * <dt><b>CRYPT_XML_FLAG_CREATE_REFERENCE_AS_OBJECT</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Set this flag to create an <b>Object</b> node and add it to the <b>Signature</b> element. A reference to the <b>Object</b>  node is created in the <b>SignedInfo</b> element.
     * 
     * The returned handle is an encapsulated <b>Object</b> node and can be used in subsequent calls to the <b>CryptXmlCreateReference</b> function to create references in the <b>Manifest</b> node.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} wszId A pointer to a <b>null</b>-terminated Unicode string that contains the value of the ID attribute of the <b>Reference</b> element of the signature.
     * 	If this parameter is <b>NULL</b>, then the <b>ID</b> attribute is not created.
     * 	If this parameter is an empty string, then the <b>ID</b> attribute with empty
     *         value is created.
     * @param {PWSTR} wszURI A pointer to a <b>null</b>-terminated Unicode string that contains the value of the URI attribute of the <b>Reference</b> element of the signature.
     *     If this parameter is an empty string,
     *     then the URI attribute with an empty value is created.
     * @param {PWSTR} wszType A pointer to a <b>null</b>-terminated Unicode string that contains the value of the Type attribute of the <b>Reference</b> element of the signature.
     *     The processing engine does not check or use this attribute.
     * @param {Pointer<CRYPT_XML_ALGORITHM>} pDigestMethod A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_algorithm">CRYPT_XML_ALGORITHM</a> structure that contains the digest method.
     * @param {Integer} cTransform The number of elements in the array pointed to by the <i>rgTransform</i> parameter.
     * @param {Pointer<CRYPT_XML_ALGORITHM>} rgTransform A pointer to an ordered array of <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_algorithm">CRYPT_XML_ALGORITHM</a> structures that contain transform algorithms to be applied to
     *     the reference data before the digest calculation.
     * @returns {Pointer<Void>} A pointer to a reference handle.
     * @see https://docs.microsoft.com/windows/win32/api//cryptxml/nf-cryptxml-cryptxmlcreatereference
     * @since windows6.1
     */
    static CryptXmlCreateReference(hCryptXml, dwFlags, wszId, wszURI, wszType, pDigestMethod, cTransform, rgTransform) {
        wszId := wszId is String ? StrPtr(wszId) : wszId
        wszURI := wszURI is String ? StrPtr(wszURI) : wszURI
        wszType := wszType is String ? StrPtr(wszType) : wszType

        hCryptXmlMarshal := hCryptXml is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPTXML.dll\CryptXmlCreateReference", hCryptXmlMarshal, hCryptXml, "uint", dwFlags, "ptr", wszId, "ptr", wszURI, "ptr", wszType, "ptr", pDigestMethod, "uint", cTransform, "ptr", rgTransform, "ptr*", &phReference := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phReference
    }

    /**
     * Is used by an application to digest the resolved reference. This function applies transforms before updating the digest.
     * @param {Pointer<Void>} hReference The  handle of a <b>Reference</b> element.
     * @param {Integer} dwFlags Specifies values that control how the process applies transforms.
     * 
     * 
     * Currently defined <i>dwFlags</i> are shown in the following table.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_XML_REFERENCE_DATA_TRANSFORMED"></a><a id="crypt_xml_reference_data_transformed"></a><dl>
     * <dt><b>CRYPT_XML_REFERENCE_DATA_TRANSFORMED</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies that the processing engine will create the digest without applying the transform chain engine.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CRYPT_XML_DATA_PROVIDER>} pDataProviderIn A pointer to a    <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_data_provider">CRYPT_XML_DATA_PROVIDER</a> structure that specifies the data provider. The <b>CryptXmlDigestReference</b> function always calls the <b>fpnClose</b> function on the data provider.
     * @returns {HRESULT} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://docs.microsoft.com/windows/win32/api//cryptxml/nf-cryptxml-cryptxmldigestreference
     * @since windows6.1
     */
    static CryptXmlDigestReference(hReference, dwFlags, pDataProviderIn) {
        hReferenceMarshal := hReference is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPTXML.dll\CryptXmlDigestReference", hReferenceMarshal, hReference, "uint", dwFlags, "ptr", pDataProviderIn, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Sets the HMAC secret on the handle before calling the CryptXmlSign or CryptXmlVerify function.
     * @param {Pointer<Void>} hSignature The handle of the XML <b>Signature</b> element.
     * @param {Pointer} pbSecret A pointer to a buffer that contains a block of bytes. 
     *     The pointer must be valid during the call to the <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/nf-cryptxml-cryptxmlsign">CryptXmlSign</a> or <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/nf-cryptxml-cryptxmlverifysignature">CryptXmlVerify</a> function.
     * @param {Integer} cbSecret The size, in bytes, of the buffer pointed to by the <i>pbSecret</i> parameter.
     * @returns {HRESULT} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://docs.microsoft.com/windows/win32/api//cryptxml/nf-cryptxml-cryptxmlsethmacsecret
     * @since windows6.1
     */
    static CryptXmlSetHMACSecret(hSignature, pbSecret, cbSecret) {
        hSignatureMarshal := hSignature is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPTXML.dll\CryptXmlSetHMACSecret", hSignatureMarshal, hSignature, "ptr", pbSecret, "uint", cbSecret, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Creates a cryptographic signature of a SignedInfo element.
     * @param {Pointer<Void>} hSignature The handle to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_signature">CRYPT_XML_SIGNATURE</a> structure.
     * @param {HCRYPTPROV_OR_NCRYPT_KEY_HANDLE} hKey The handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key</a> used to sign the <b>SignedInfo</b> element.
     *     This parameter must be <b>NULL</b> for HMAC-based signature algorithms.
     * @param {Integer} dwKeySpec 
     * @param {Integer} dwFlags 
     * @param {Integer} dwKeyInfoSpec The type of data structure pointed to by the <i>pvKeyInfoSpec</i> parameter. Here are some possible combinations.
     * 
     * <table>
     * <tr>
     * <th><i>dwKeyInfec</i></th>
     * <th><i>pvKeyInfoSpec</i></th>
     * </tr>
     * <tr>
     * <td>
     * <b>CRYPT_XML_KEYINFO_SPEC_NONE</b>
     * 
     * </td>
     * <td>
     * Is set to  <b>NULL</b>
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>CRYPT_XML_KEYINFO_SPEC_ENCODED</b>
     * 
     * </td>
     * <td>
     * Points to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_blob">CRYPT_XML_BLOB</a> structure
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>CRYPT_XML_KEYINFO_SPEC_PARAM</b>
     * 
     * </td>
     * <td>
     * Points to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_keyinfo_param">CRYPT_XML_KEYINFO_PARAM</a> structure
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvKeyInfoSpec A pointer to a structure, the type of which is determined by the value of the <i>dwKeyInfoSpec</i> parameter.
     * @param {Pointer<CRYPT_XML_ALGORITHM>} pSignatureMethod A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_algorithm">CRYPT_XML_ALGORITHM</a>     structure that specifies the signature method.
     * @param {Pointer<CRYPT_XML_ALGORITHM>} pCanonicalization A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_algorithm">CRYPT_XML_ALGORITHM</a>     structure that specifies the canonicalization method.
     * @returns {HRESULT} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://docs.microsoft.com/windows/win32/api//cryptxml/nf-cryptxml-cryptxmlsign
     * @since windows6.1
     */
    static CryptXmlSign(hSignature, hKey, dwKeySpec, dwFlags, dwKeyInfoSpec, pvKeyInfoSpec, pSignatureMethod, pCanonicalization) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        hSignatureMarshal := hSignature is VarRef ? "ptr" : "ptr"
        pvKeyInfoSpecMarshal := pvKeyInfoSpec is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPTXML.dll\CryptXmlSign", hSignatureMarshal, hSignature, "ptr", hKey, "uint", dwKeySpec, "uint", dwFlags, "int", dwKeyInfoSpec, pvKeyInfoSpecMarshal, pvKeyInfoSpec, "ptr", pSignatureMethod, "ptr", pCanonicalization, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Imports the public key specified by the supplied handle.
     * @param {Integer} dwFlags 
     * @param {Pointer<CRYPT_XML_KEY_VALUE>} pKeyValue A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_key_value">CRYPT_XML_KEY_VALUE</a> structure to receive the imported key.
     * @returns {BCRYPT_KEY_HANDLE} A pointer to the handle of the key to import.
     * @see https://docs.microsoft.com/windows/win32/api//cryptxml/nf-cryptxml-cryptxmlimportpublickey
     * @since windows6.1
     */
    static CryptXmlImportPublicKey(dwFlags, pKeyValue) {
        phKey := BCRYPT_KEY_HANDLE()
        result := DllCall("CRYPTXML.dll\CryptXmlImportPublicKey", "uint", dwFlags, "ptr", pKeyValue, "ptr", phKey, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phKey
    }

    /**
     * Performs a cryptographic signature validation of a SignedInfo element.
     * @param {Pointer<Void>} hSignature The handle of a <b>Signature</b> element.
     * @param {BCRYPT_KEY_HANDLE} hKey The handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key</a> to use to verify the signature value on 
     *     the <b>SignedInfo</b> element.
     *     This parameter must be <b>NULL</b> for HMAC-based signature algorithms.
     * @param {Integer} dwFlags 
     * @returns {HRESULT} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://docs.microsoft.com/windows/win32/api//cryptxml/nf-cryptxml-cryptxmlverifysignature
     * @since windows6.1
     */
    static CryptXmlVerifySignature(hSignature, hKey, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        hSignatureMarshal := hSignature is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPTXML.dll\CryptXmlVerifySignature", hSignatureMarshal, hSignature, "ptr", hKey, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Returns the document context specified by the supplied handle.
     * @param {Pointer<Void>} hCryptXml The handle of the document context to retrieve.
     * @returns {Pointer<CRYPT_XML_DOC_CTXT>} A pointer to a pointer to a  <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_doc_ctxt">CRYPT_XML_DOC_CTXT</a> structure that contains the returned document context.
     * @see https://docs.microsoft.com/windows/win32/api//cryptxml/nf-cryptxml-cryptxmlgetdoccontext
     * @since windows6.1
     */
    static CryptXmlGetDocContext(hCryptXml) {
        hCryptXmlMarshal := hCryptXml is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPTXML.dll\CryptXmlGetDocContext", hCryptXmlMarshal, hCryptXml, "ptr*", &ppStruct := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppStruct
    }

    /**
     * Returns an XML Signature element.
     * @param {Pointer<Void>} hCryptXml The handle of the <b>Signature</b> element.
     * @returns {Pointer<CRYPT_XML_SIGNATURE>} A pointer to a  pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_signature">CRYPT_XML_SIGNATURE</a> structure to receive the signature.
     * @see https://docs.microsoft.com/windows/win32/api//cryptxml/nf-cryptxml-cryptxmlgetsignature
     * @since windows6.1
     */
    static CryptXmlGetSignature(hCryptXml) {
        hCryptXmlMarshal := hCryptXml is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPTXML.dll\CryptXmlGetSignature", hCryptXmlMarshal, hCryptXml, "ptr*", &ppStruct := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppStruct
    }

    /**
     * Returns the Reference element specified by the supplied handle.
     * @param {Pointer<Void>} hCryptXml The handle of the <b>Reference</b> element to retrieve.
     * @returns {Pointer<CRYPT_XML_REFERENCE>} A pointer to a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_reference">CRYPT_XML_REFERENCE</a> structure that contains the returned <b>Reference</b> element.
     * @see https://docs.microsoft.com/windows/win32/api//cryptxml/nf-cryptxml-cryptxmlgetreference
     * @since windows6.1
     */
    static CryptXmlGetReference(hCryptXml) {
        hCryptXmlMarshal := hCryptXml is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPTXML.dll\CryptXmlGetReference", hCryptXmlMarshal, hCryptXml, "ptr*", &ppStruct := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppStruct
    }

    /**
     * Returns a CRYPT_XML_STATUS structure that contains status information about the object specified by the supplied handle.
     * @param {Pointer<Void>} hCryptXml A handle to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_signature">CRYPT_XML_SIGNATURE</a> structure, an array 
     * of <b>CRYPT_XML_SIGNATURE</b> structures , a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_reference">CRYPT_XML_REFERENCE</a> structure, or a  Manifest object about which to get status information.
     * @param {Pointer<CRYPT_XML_STATUS>} pStatus A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_status">CRYPT_XML_STATUS</a> structure to receive the returned status information.
     * @returns {HRESULT} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://docs.microsoft.com/windows/win32/api//cryptxml/nf-cryptxml-cryptxmlgetstatus
     * @since windows6.1
     */
    static CryptXmlGetStatus(hCryptXml, pStatus) {
        hCryptXmlMarshal := hCryptXml is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPTXML.dll\CryptXmlGetStatus", hCryptXmlMarshal, hCryptXml, "ptr", pStatus, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Encodes signature data by using the supplied XML writer callback function.
     * @param {Pointer<Void>} hCryptXml The handle of the object to be serialized. The handle can be of <b>Signature</b>, <b>Object</b>, or <b>Reference</b> types.
     * @param {Integer} dwCharset A value of the <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ne-cryptxml-crypt_xml_charset">CRYPT_XML_CHARSET</a> enumeration that specifies the character set of the encoded XML.
     * @param {Pointer<CRYPT_XML_PROPERTY>} rgProperty A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_property">CRYPT_XML_PROPERTY</a> structures that contain additional properties.
     * @param {Integer} cProperty A <b>ULONG</b> value that specifies the number of entries in the array pointed to by the <i>rgProperty</i> parameter.
     * @param {Pointer<Void>} pvCallbackState A pointer to an application defined argument that is passed to the XML writer callback function pointed to by the <i>pfnWrite</i> parameter.
     * @param {Pointer<PFN_CRYPT_XML_WRITE_CALLBACK>} pfnWrite An XML writer callback function to receive the application defined argument pointed to by the <i>pvCallbackState</i> parameter.
     * @returns {HRESULT} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://docs.microsoft.com/windows/win32/api//cryptxml/nf-cryptxml-cryptxmlencode
     * @since windows6.1
     */
    static CryptXmlEncode(hCryptXml, dwCharset, rgProperty, cProperty, pvCallbackState, pfnWrite) {
        hCryptXmlMarshal := hCryptXml is VarRef ? "ptr" : "ptr"
        pvCallbackStateMarshal := pvCallbackState is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPTXML.dll\CryptXmlEncode", hCryptXmlMarshal, hCryptXml, "int", dwCharset, "ptr", rgProperty, "uint", cProperty, pvCallbackStateMarshal, pvCallbackState, "ptr", pfnWrite, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * Decodes the CRYPT_XML_ALGORITHM structure and returns information about the algorithm.
     * @param {Pointer<CRYPT_XML_ALGORITHM>} pXmlAlgorithm A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_algorithm">CRYPT_XML_ALGORITHM</a> structure that specifies the algorithm about which to return information.
     * @param {Integer} dwFlags 
     * @returns {Pointer<CRYPT_XML_ALGORITHM_INFO>} A pointer to a pointer to a  <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_algorithm_info">CRYPT_XML_ALGORITHM_INFO</a> structure. When you have finished using the memory pointed to by the <i>ppAlgInfo</i> parameter, free it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//cryptxml/nf-cryptxml-cryptxmlgetalgorithminfo
     * @since windows6.1
     */
    static CryptXmlGetAlgorithmInfo(pXmlAlgorithm, dwFlags) {
        result := DllCall("CRYPTXML.dll\CryptXmlGetAlgorithmInfo", "ptr", pXmlAlgorithm, "uint", dwFlags, "ptr*", &ppAlgInfo := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppAlgInfo
    }

    /**
     * 
     * @param {Integer} dwFindByType 
     * @param {Pointer<Void>} pvFindBy 
     * @param {Integer} dwGroupId 
     * @param {Integer} dwFlags 
     * @returns {Pointer<CRYPT_XML_ALGORITHM_INFO>} 
     */
    static CryptXmlFindAlgorithmInfo(dwFindByType, pvFindBy, dwGroupId, dwFlags) {
        pvFindByMarshal := pvFindBy is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPTXML.dll\CryptXmlFindAlgorithmInfo", "uint", dwFindByType, pvFindByMarshal, pvFindBy, "uint", dwGroupId, "uint", dwFlags, "ptr")
        return result
    }

    /**
     * 
     * @param {Integer} dwGroupId 
     * @param {Integer} dwFlags 
     * @param {Pointer<Void>} pvArg 
     * @param {Pointer<PFN_CRYPT_XML_ENUM_ALG_INFO>} pfnEnumAlgInfo 
     * @returns {HRESULT} 
     */
    static CryptXmlEnumAlgorithmInfo(dwGroupId, dwFlags, pvArg, pfnEnumAlgInfo) {
        pvArgMarshal := pvArg is VarRef ? "ptr" : "ptr"

        result := DllCall("CRYPTXML.dll\CryptXmlEnumAlgorithmInfo", "uint", dwGroupId, "uint", dwFlags, pvArgMarshal, pvArg, "ptr", pfnEnumAlgInfo, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {Integer} cPolicyChain 
     * @param {Pointer<POLICY_ELEMENT>} pPolicyChain 
     * @param {Pointer<Pointer<GENERIC_XML_TOKEN>>} securityToken 
     * @param {Pointer<Pointer<INFORMATIONCARD_CRYPTO_HANDLE>>} phProofTokenCrypto 
     * @returns {HRESULT} 
     */
    static GetToken(cPolicyChain, pPolicyChain, securityToken, phProofTokenCrypto) {
        securityTokenMarshal := securityToken is VarRef ? "ptr*" : "ptr"
        phProofTokenCryptoMarshal := phProofTokenCrypto is VarRef ? "ptr*" : "ptr"

        result := DllCall("infocardapi.dll\GetToken", "uint", cPolicyChain, "ptr", pPolicyChain, securityTokenMarshal, securityToken, phProofTokenCryptoMarshal, phProofTokenCrypto, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @returns {HRESULT} 
     */
    static ManageCardSpace() {
        result := DllCall("infocardapi.dll\ManageCardSpace", "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {PWSTR} fileName 
     * @returns {HRESULT} 
     */
    static ImportInformationCard(fileName) {
        fileName := fileName is String ? StrPtr(fileName) : fileName

        result := DllCall("infocardapi.dll\ImportInformationCard", "ptr", fileName, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {BOOL} fOAEP 
     * @param {Integer} cbInData 
     * @param {Pointer} pInData 
     * @param {Pointer} ppOutData 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/SecProv/encrypt-win32-encryptablevolume
     */
    static Encrypt(hCrypto, fOAEP, cbInData, pInData, ppOutData) {
        result := DllCall("infocardapi.dll\Encrypt", "ptr", hCrypto, "int", fOAEP, "uint", cbInData, "ptr", pInData, "uint*", &pcbOutData := 0, "ptr", ppOutData, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbOutData
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {BOOL} fOAEP 
     * @param {Integer} cbInData 
     * @param {Pointer} pInData 
     * @param {Pointer} ppOutData 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/SecProv/decrypt-win32-encryptablevolume
     */
    static Decrypt(hCrypto, fOAEP, cbInData, pInData, ppOutData) {
        result := DllCall("infocardapi.dll\Decrypt", "ptr", hCrypto, "int", fOAEP, "uint", cbInData, "ptr", pInData, "uint*", &pcbOutData := 0, "ptr", ppOutData, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbOutData
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {Integer} cbHash 
     * @param {Pointer} pHash 
     * @param {PWSTR} hashAlgOid 
     * @param {Pointer} ppSig 
     * @returns {Integer} 
     */
    static SignHash(hCrypto, cbHash, pHash, hashAlgOid, ppSig) {
        hashAlgOid := hashAlgOid is String ? StrPtr(hashAlgOid) : hashAlgOid

        result := DllCall("infocardapi.dll\SignHash", "ptr", hCrypto, "uint", cbHash, "ptr", pHash, "ptr", hashAlgOid, "uint*", &pcbSig := 0, "ptr", ppSig, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbSig
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {Integer} cbHash 
     * @param {Pointer} pHash 
     * @param {PWSTR} hashAlgOid 
     * @param {Integer} cbSig 
     * @param {Pointer} pSig 
     * @returns {BOOL} 
     */
    static VerifyHash(hCrypto, cbHash, pHash, hashAlgOid, cbSig, pSig) {
        hashAlgOid := hashAlgOid is String ? StrPtr(hashAlgOid) : hashAlgOid

        result := DllCall("infocardapi.dll\VerifyHash", "ptr", hCrypto, "uint", cbHash, "ptr", pHash, "ptr", hashAlgOid, "uint", cbSig, "ptr", pSig, "int*", &pfVerified := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pfVerified
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hSymmetricCrypto 
     * @param {Integer} mode 
     * @param {Integer} padding 
     * @param {Integer} feedbackSize 
     * @param {Integer} direction 
     * @param {Integer} cbIV 
     * @param {Pointer} pIV 
     * @returns {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} 
     */
    static GetCryptoTransform(hSymmetricCrypto, mode, padding, feedbackSize, direction, cbIV, pIV) {
        result := DllCall("infocardapi.dll\GetCryptoTransform", "ptr", hSymmetricCrypto, "uint", mode, "int", padding, "uint", feedbackSize, "int", direction, "uint", cbIV, "ptr", pIV, "ptr*", &pphTransform := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pphTransform
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hSymmetricCrypto 
     * @returns {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} 
     */
    static GetKeyedHash(hSymmetricCrypto) {
        result := DllCall("infocardapi.dll\GetKeyedHash", "ptr", hSymmetricCrypto, "ptr*", &pphHash := 0, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pphHash
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {Integer} cbInData 
     * @param {Pointer} pInData 
     * @param {Pointer} ppOutData 
     * @returns {Integer} 
     */
    static TransformBlock(hCrypto, cbInData, pInData, ppOutData) {
        result := DllCall("infocardapi.dll\TransformBlock", "ptr", hCrypto, "uint", cbInData, "ptr", pInData, "uint*", &pcbOutData := 0, "ptr", ppOutData, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbOutData
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {Integer} cbInData 
     * @param {Pointer} pInData 
     * @param {Pointer} ppOutData 
     * @returns {Integer} 
     */
    static TransformFinalBlock(hCrypto, cbInData, pInData, ppOutData) {
        result := DllCall("infocardapi.dll\TransformFinalBlock", "ptr", hCrypto, "uint", cbInData, "ptr", pInData, "uint*", &pcbOutData := 0, "ptr", ppOutData, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbOutData
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {Integer} cbInData 
     * @param {Pointer} pInData 
     * @returns {HRESULT} 
     */
    static HashCore(hCrypto, cbInData, pInData) {
        result := DllCall("infocardapi.dll\HashCore", "ptr", hCrypto, "uint", cbInData, "ptr", pInData, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {Integer} cbInData 
     * @param {Pointer} pInData 
     * @param {Pointer} ppOutData 
     * @returns {Integer} 
     */
    static HashFinal(hCrypto, cbInData, pInData, ppOutData) {
        result := DllCall("infocardapi.dll\HashFinal", "ptr", hCrypto, "uint", cbInData, "ptr", pInData, "uint*", &pcbOutData := 0, "ptr", ppOutData, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbOutData
    }

    /**
     * 
     * @param {Pointer<GENERIC_XML_TOKEN>} pAllocMemory 
     * @returns {BOOL} 
     */
    static FreeToken(pAllocMemory) {
        result := DllCall("infocardapi.dll\FreeToken", "ptr", pAllocMemory, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @returns {HRESULT} 
     */
    static CloseCryptoHandle(hCrypto) {
        result := DllCall("infocardapi.dll\CloseCryptoHandle", "ptr", hCrypto, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {Integer} cbLabel 
     * @param {Pointer} pLabel 
     * @param {Integer} cbNonce 
     * @param {Pointer} pNonce 
     * @param {Integer} derivedKeyLength 
     * @param {Integer} offset 
     * @param {PWSTR} algId 
     * @param {Pointer} ppKey 
     * @returns {Integer} 
     */
    static GenerateDerivedKey(hCrypto, cbLabel, pLabel, cbNonce, pNonce, derivedKeyLength, offset, algId, ppKey) {
        algId := algId is String ? StrPtr(algId) : algId

        result := DllCall("infocardapi.dll\GenerateDerivedKey", "ptr", hCrypto, "uint", cbLabel, "ptr", pLabel, "uint", cbNonce, "ptr", pNonce, "uint", derivedKeyLength, "uint", offset, "ptr", algId, "uint*", &pcbKey := 0, "ptr", ppKey, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbKey
    }

    /**
     * 
     * @param {Integer} dwParamType 
     * @param {Pointer<Void>} pParam 
     * @param {Pointer} ppToken 
     * @returns {Integer} 
     */
    static GetBrowserToken(dwParamType, pParam, ppToken) {
        pParamMarshal := pParam is VarRef ? "ptr" : "ptr"

        result := DllCall("infocardapi.dll\GetBrowserToken", "uint", dwParamType, pParamMarshal, pParam, "uint*", &pcbToken := 0, "ptr", ppToken, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbToken
    }

    /**
     * 
     * @param {PWSTR} pszProviderName 
     * @param {PWSTR} pszAlgId 
     * @param {Pointer<Pointer<BCRYPT_CIPHER_FUNCTION_TABLE>>} ppFunctionTable 
     * @param {Integer} dwFlags 
     * @returns {NTSTATUS} 
     */
    static GetCipherInterface(pszProviderName, pszAlgId, ppFunctionTable, dwFlags) {
        pszProviderName := pszProviderName is String ? StrPtr(pszProviderName) : pszProviderName
        pszAlgId := pszAlgId is String ? StrPtr(pszAlgId) : pszAlgId

        ppFunctionTableMarshal := ppFunctionTable is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcryptprimitives.dll\GetCipherInterface", "ptr", pszProviderName, "ptr", pszAlgId, ppFunctionTableMarshal, ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {PWSTR} pszProviderName 
     * @param {PWSTR} pszAlgId 
     * @param {Pointer<Pointer<BCRYPT_HASH_FUNCTION_TABLE>>} ppFunctionTable 
     * @param {Integer} dwFlags 
     * @returns {NTSTATUS} 
     */
    static GetHashInterface(pszProviderName, pszAlgId, ppFunctionTable, dwFlags) {
        pszProviderName := pszProviderName is String ? StrPtr(pszProviderName) : pszProviderName
        pszAlgId := pszAlgId is String ? StrPtr(pszAlgId) : pszAlgId

        ppFunctionTableMarshal := ppFunctionTable is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcryptprimitives.dll\GetHashInterface", "ptr", pszProviderName, "ptr", pszAlgId, ppFunctionTableMarshal, ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {PWSTR} pszProviderName 
     * @param {PWSTR} pszAlgId 
     * @param {Pointer<Pointer<BCRYPT_ASYMMETRIC_ENCRYPTION_FUNCTION_TABLE>>} ppFunctionTable 
     * @param {Integer} dwFlags 
     * @returns {NTSTATUS} 
     */
    static GetAsymmetricEncryptionInterface(pszProviderName, pszAlgId, ppFunctionTable, dwFlags) {
        pszProviderName := pszProviderName is String ? StrPtr(pszProviderName) : pszProviderName
        pszAlgId := pszAlgId is String ? StrPtr(pszAlgId) : pszAlgId

        ppFunctionTableMarshal := ppFunctionTable is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcryptprimitives.dll\GetAsymmetricEncryptionInterface", "ptr", pszProviderName, "ptr", pszAlgId, ppFunctionTableMarshal, ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {PWSTR} pszProviderName 
     * @param {PWSTR} pszAlgId 
     * @param {Pointer<Pointer<BCRYPT_SECRET_AGREEMENT_FUNCTION_TABLE>>} ppFunctionTable 
     * @param {Integer} dwFlags 
     * @returns {NTSTATUS} 
     */
    static GetSecretAgreementInterface(pszProviderName, pszAlgId, ppFunctionTable, dwFlags) {
        pszProviderName := pszProviderName is String ? StrPtr(pszProviderName) : pszProviderName
        pszAlgId := pszAlgId is String ? StrPtr(pszAlgId) : pszAlgId

        ppFunctionTableMarshal := ppFunctionTable is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcryptprimitives.dll\GetSecretAgreementInterface", "ptr", pszProviderName, "ptr", pszAlgId, ppFunctionTableMarshal, ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {PWSTR} pszProviderName 
     * @param {PWSTR} pszAlgId 
     * @param {Pointer<Pointer<BCRYPT_SIGNATURE_FUNCTION_TABLE>>} ppFunctionTable 
     * @param {Integer} dwFlags 
     * @returns {NTSTATUS} 
     */
    static GetSignatureInterface(pszProviderName, pszAlgId, ppFunctionTable, dwFlags) {
        pszProviderName := pszProviderName is String ? StrPtr(pszProviderName) : pszProviderName
        pszAlgId := pszAlgId is String ? StrPtr(pszAlgId) : pszAlgId

        ppFunctionTableMarshal := ppFunctionTable is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcryptprimitives.dll\GetSignatureInterface", "ptr", pszProviderName, "ptr", pszAlgId, ppFunctionTableMarshal, ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {PWSTR} pszProviderName 
     * @param {Pointer<Pointer<BCRYPT_RNG_FUNCTION_TABLE>>} ppFunctionTable 
     * @param {Integer} dwFlags 
     * @returns {NTSTATUS} 
     */
    static GetRngInterface(pszProviderName, ppFunctionTable, dwFlags) {
        pszProviderName := pszProviderName is String ? StrPtr(pszProviderName) : pszProviderName

        ppFunctionTableMarshal := ppFunctionTable is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcryptprimitives.dll\GetRngInterface", "ptr", pszProviderName, ppFunctionTableMarshal, ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {PWSTR} pszProviderName 
     * @param {PWSTR} pszAlgId 
     * @param {Pointer<Pointer<BCRYPT_KEY_DERIVATION_FUNCTION_TABLE>>} ppFunctionTable 
     * @param {Integer} dwFlags 
     * @returns {NTSTATUS} 
     */
    static GetKeyDerivationInterface(pszProviderName, pszAlgId, ppFunctionTable, dwFlags) {
        pszProviderName := pszProviderName is String ? StrPtr(pszProviderName) : pszProviderName
        pszAlgId := pszAlgId is String ? StrPtr(pszAlgId) : pszAlgId

        ppFunctionTableMarshal := ppFunctionTable is VarRef ? "ptr*" : "ptr"

        result := DllCall("bcryptprimitives.dll\GetKeyDerivationInterface", "ptr", pszProviderName, "ptr", pszAlgId, ppFunctionTableMarshal, ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {PWSTR} pszProvider 
     * @param {Integer} dwFlags 
     * @param {Pointer<CRYPT_PROVIDER_REG>} pReg 
     * @returns {NTSTATUS} 
     */
    static BCryptRegisterProvider(pszProvider, dwFlags, pReg) {
        pszProvider := pszProvider is String ? StrPtr(pszProvider) : pszProvider

        result := DllCall("bcrypt.dll\BCryptRegisterProvider", "ptr", pszProvider, "uint", dwFlags, "ptr", pReg, "int")
        return result
    }

    /**
     * 
     * @param {PWSTR} pszProvider 
     * @returns {NTSTATUS} 
     */
    static BCryptUnregisterProvider(pszProvider) {
        pszProvider := pszProvider is String ? StrPtr(pszProvider) : pszProvider

        result := DllCall("bcrypt.dll\BCryptUnregisterProvider", "ptr", pszProvider, "int")
        return result
    }

    /**
     * 
     * @param {Integer} dwTable 
     * @param {PWSTR} pszContext 
     * @param {Integer} dwInterface 
     * @param {PWSTR} pszFunction 
     * @param {PWSTR} pszProvider 
     * @param {Integer} dwPosition 
     * @returns {NTSTATUS} 
     */
    static BCryptAddContextFunctionProvider(dwTable, pszContext, dwInterface, pszFunction, pszProvider, dwPosition) {
        pszContext := pszContext is String ? StrPtr(pszContext) : pszContext
        pszFunction := pszFunction is String ? StrPtr(pszFunction) : pszFunction
        pszProvider := pszProvider is String ? StrPtr(pszProvider) : pszProvider

        result := DllCall("bcrypt.dll\BCryptAddContextFunctionProvider", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "ptr", pszProvider, "uint", dwPosition, "int")
        return result
    }

    /**
     * 
     * @param {Integer} dwTable 
     * @param {PWSTR} pszContext 
     * @param {Integer} dwInterface 
     * @param {PWSTR} pszFunction 
     * @param {PWSTR} pszProvider 
     * @returns {NTSTATUS} 
     */
    static BCryptRemoveContextFunctionProvider(dwTable, pszContext, dwInterface, pszFunction, pszProvider) {
        pszContext := pszContext is String ? StrPtr(pszContext) : pszContext
        pszFunction := pszFunction is String ? StrPtr(pszFunction) : pszFunction
        pszProvider := pszProvider is String ? StrPtr(pszProvider) : pszProvider

        result := DllCall("bcrypt.dll\BCryptRemoveContextFunctionProvider", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "ptr", pszProvider, "int")
        return result
    }

    /**
     * 
     * @param {PWSTR} pszProviderName 
     * @param {Pointer<Pointer<NCRYPT_KEY_STORAGE_FUNCTION_TABLE>>} ppFunctionTable 
     * @param {Integer} dwFlags 
     * @returns {NTSTATUS} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/ncrypt/nf-ncrypt-getkeystorageinterface
     */
    static GetKeyStorageInterface(pszProviderName, ppFunctionTable, dwFlags) {
        pszProviderName := pszProviderName is String ? StrPtr(pszProviderName) : pszProviderName

        ppFunctionTableMarshal := ppFunctionTable is VarRef ? "ptr*" : "ptr"

        result := DllCall("ncrypt.dll\GetKeyStorageInterface", "ptr", pszProviderName, ppFunctionTableMarshal, ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {HANDLE} hEvent 
     * @param {Integer} dwFlags 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslchangenotify
     */
    static SslChangeNotify(hEvent, dwFlags) {
        hEvent := hEvent is Win32Handle ? NumGet(hEvent, "ptr") : hEvent

        result := DllCall("ncrypt.dll\SslChangeNotify", "ptr", hEvent, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hMasterKey 
     * @param {NCRYPT_HASH_HANDLE} hHandshakeHash 
     * @param {PWSTR} pszAlgId 
     * @param {Pointer} pbOutput 
     * @param {Integer} cbOutput 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslcomputeclientauthhash
     */
    static SslComputeClientAuthHash(hSslProvider, hMasterKey, hHandshakeHash, pszAlgId, pbOutput, cbOutput, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hMasterKey := hMasterKey is Win32Handle ? NumGet(hMasterKey, "ptr") : hMasterKey
        hHandshakeHash := hHandshakeHash is Win32Handle ? NumGet(hHandshakeHash, "ptr") : hHandshakeHash
        pszAlgId := pszAlgId is String ? StrPtr(pszAlgId) : pszAlgId

        result := DllCall("ncrypt.dll\SslComputeClientAuthHash", "ptr", hSslProvider, "ptr", hMasterKey, "ptr", hHandshakeHash, "ptr", pszAlgId, "ptr", pbOutput, "uint", cbOutput, "uint*", &pcbResult := 0, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbResult
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hMasterKey 
     * @param {Pointer} pbRandoms 
     * @param {Integer} cbRandoms 
     * @param {Pointer} pbOutput 
     * @param {Integer} cbOutput 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslcomputeeapkeyblock
     */
    static SslComputeEapKeyBlock(hSslProvider, hMasterKey, pbRandoms, cbRandoms, pbOutput, cbOutput, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hMasterKey := hMasterKey is Win32Handle ? NumGet(hMasterKey, "ptr") : hMasterKey

        result := DllCall("ncrypt.dll\SslComputeEapKeyBlock", "ptr", hSslProvider, "ptr", hMasterKey, "ptr", pbRandoms, "uint", cbRandoms, "ptr", pbOutput, "uint", cbOutput, "uint*", &pcbResult := 0, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbResult
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hMasterKey 
     * @param {NCRYPT_HASH_HANDLE} hHandshakeHash 
     * @param {Pointer} pbOutput 
     * @param {Integer} cbOutput 
     * @param {Integer} dwFlags 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslcomputefinishedhash
     */
    static SslComputeFinishedHash(hSslProvider, hMasterKey, hHandshakeHash, pbOutput, cbOutput, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hMasterKey := hMasterKey is Win32Handle ? NumGet(hMasterKey, "ptr") : hMasterKey
        hHandshakeHash := hHandshakeHash is Win32Handle ? NumGet(hHandshakeHash, "ptr") : hHandshakeHash

        result := DllCall("ncrypt.dll\SslComputeFinishedHash", "ptr", hSslProvider, "ptr", hMasterKey, "ptr", hHandshakeHash, "ptr", pbOutput, "uint", cbOutput, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {Integer} dwProtocol 
     * @param {Integer} dwCipherSuite 
     * @param {Integer} dwKeyType 
     * @param {Integer} dwKeyBitLen 
     * @param {Pointer} pbParams 
     * @param {Integer} cbParams 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_KEY_HANDLE} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslcreateephemeralkey
     */
    static SslCreateEphemeralKey(hSslProvider, dwProtocol, dwCipherSuite, dwKeyType, dwKeyBitLen, pbParams, cbParams, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider

        phEphemeralKey := NCRYPT_KEY_HANDLE()
        result := DllCall("ncrypt.dll\SslCreateEphemeralKey", "ptr", hSslProvider, "ptr", phEphemeralKey, "uint", dwProtocol, "uint", dwCipherSuite, "uint", dwKeyType, "uint", dwKeyBitLen, "ptr", pbParams, "uint", cbParams, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phEphemeralKey
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {Integer} dwProtocol 
     * @param {Integer} dwCipherSuite 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_HASH_HANDLE} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslcreatehandshakehash
     */
    static SslCreateHandshakeHash(hSslProvider, dwProtocol, dwCipherSuite, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider

        phHandshakeHash := NCRYPT_HASH_HANDLE()
        result := DllCall("ncrypt.dll\SslCreateHandshakeHash", "ptr", hSslProvider, "ptr", phHandshakeHash, "uint", dwProtocol, "uint", dwCipherSuite, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phHandshakeHash
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hKey 
     * @param {Pointer} pbInput 
     * @param {Integer} cbInput 
     * @param {Pointer} pbOutput 
     * @param {Integer} cbOutput 
     * @param {Integer} SequenceNumber 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/ssldecryptpacket
     */
    static SslDecryptPacket(hSslProvider, hKey, pbInput, cbInput, pbOutput, cbOutput, SequenceNumber, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        result := DllCall("ncrypt.dll\SslDecryptPacket", "ptr", hSslProvider, "ptr", hKey, "ptr", pbInput, "uint", cbInput, "ptr", pbOutput, "uint", cbOutput, "uint*", &pcbResult := 0, "uint", SequenceNumber, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbResult
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hKey 
     * @param {Pointer} pbInput 
     * @param {Integer} cbInput 
     * @param {Pointer} pbOutput 
     * @param {Integer} cbOutput 
     * @param {Integer} SequenceNumber 
     * @param {Integer} dwContentType 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslencryptpacket
     */
    static SslEncryptPacket(hSslProvider, hKey, pbInput, cbInput, pbOutput, cbOutput, SequenceNumber, dwContentType, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey

        result := DllCall("ncrypt.dll\SslEncryptPacket", "ptr", hSslProvider, "ptr", hKey, "ptr", pbInput, "uint", cbInput, "ptr", pbOutput, "uint", cbOutput, "uint*", &pcbResult := 0, "uint", SequenceNumber, "uint", dwContentType, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbResult
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hPrivateKey 
     * @param {Pointer<Pointer<Void>>} ppEnumState 
     * @param {Integer} dwFlags 
     * @returns {Pointer<NCRYPT_SSL_CIPHER_SUITE>} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslenumciphersuites
     */
    static SslEnumCipherSuites(hSslProvider, hPrivateKey, ppEnumState, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hPrivateKey := hPrivateKey is Win32Handle ? NumGet(hPrivateKey, "ptr") : hPrivateKey

        ppEnumStateMarshal := ppEnumState is VarRef ? "ptr*" : "ptr"

        result := DllCall("ncrypt.dll\SslEnumCipherSuites", "ptr", hSslProvider, "ptr", hPrivateKey, "ptr*", &ppCipherSuite := 0, ppEnumStateMarshal, ppEnumState, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppCipherSuite
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hPrivateKey 
     * @param {Pointer<Pointer<Void>>} ppEnumState 
     * @param {Integer} dwFlags 
     * @returns {Pointer<NCRYPT_SSL_CIPHER_SUITE_EX>} 
     */
    static SslEnumCipherSuitesEx(hSslProvider, hPrivateKey, ppEnumState, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hPrivateKey := hPrivateKey is Win32Handle ? NumGet(hPrivateKey, "ptr") : hPrivateKey

        ppEnumStateMarshal := ppEnumState is VarRef ? "ptr*" : "ptr"

        result := DllCall("ncrypt.dll\SslEnumCipherSuitesEx", "ptr", hSslProvider, "ptr", hPrivateKey, "ptr*", &ppCipherSuite := 0, ppEnumStateMarshal, ppEnumState, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return ppCipherSuite
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {Pointer<Integer>} pEccCurveCount 
     * @param {Pointer<Pointer<NCRYPT_SSL_ECC_CURVE>>} ppEccCurve 
     * @param {Integer} dwFlags 
     * @returns {HRESULT} 
     */
    static SslEnumEccCurves(hSslProvider, pEccCurveCount, ppEccCurve, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider

        pEccCurveCountMarshal := pEccCurveCount is VarRef ? "uint*" : "ptr"
        ppEccCurveMarshal := ppEccCurve is VarRef ? "ptr*" : "ptr"

        result := DllCall("ncrypt.dll\SslEnumEccCurves", "ptr", hSslProvider, pEccCurveCountMarshal, pEccCurveCount, ppEccCurveMarshal, ppEccCurve, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {Pointer<Integer>} pdwProviderCount 
     * @param {Pointer<Pointer<NCryptProviderName>>} ppProviderList 
     * @param {Integer} dwFlags 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslenumprotocolproviders
     */
    static SslEnumProtocolProviders(pdwProviderCount, ppProviderList, dwFlags) {
        pdwProviderCountMarshal := pdwProviderCount is VarRef ? "uint*" : "ptr"
        ppProviderListMarshal := ppProviderList is VarRef ? "ptr*" : "ptr"

        result := DllCall("ncrypt.dll\SslEnumProtocolProviders", pdwProviderCountMarshal, pdwProviderCount, ppProviderListMarshal, ppProviderList, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hKey 
     * @param {PWSTR} pszBlobType 
     * @param {Pointer} pbOutput 
     * @param {Integer} cbOutput 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslexportkey
     */
    static SslExportKey(hSslProvider, hKey, pszBlobType, pbOutput, cbOutput, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey
        pszBlobType := pszBlobType is String ? StrPtr(pszBlobType) : pszBlobType

        result := DllCall("ncrypt.dll\SslExportKey", "ptr", hSslProvider, "ptr", hKey, "ptr", pszBlobType, "ptr", pbOutput, "uint", cbOutput, "uint*", &pcbResult := 0, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbResult
    }

    /**
     * 
     * @param {Pointer<Void>} pvInput 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslfreebuffer
     */
    static SslFreeBuffer(pvInput) {
        pvInputMarshal := pvInput is VarRef ? "ptr" : "ptr"

        result := DllCall("ncrypt.dll\SslFreeBuffer", pvInputMarshal, pvInput, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_HANDLE} hObject 
     * @param {Integer} dwFlags 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslfreeobject
     */
    static SslFreeObject(hObject, dwFlags) {
        hObject := hObject is Win32Handle ? NumGet(hObject, "ptr") : hObject

        result := DllCall("ncrypt.dll\SslFreeObject", "ptr", hObject, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hPrivateKey 
     * @param {NCRYPT_KEY_HANDLE} hPublicKey 
     * @param {Pointer<NCRYPT_KEY_HANDLE>} phMasterKey 
     * @param {Integer} dwProtocol 
     * @param {Integer} dwCipherSuite 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Pointer} pbOutput 
     * @param {Integer} cbOutput 
     * @param {Pointer<Integer>} pcbResult 
     * @param {Integer} dwFlags 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslgeneratemasterkey
     */
    static SslGenerateMasterKey(hSslProvider, hPrivateKey, hPublicKey, phMasterKey, dwProtocol, dwCipherSuite, pParameterList, pbOutput, cbOutput, pcbResult, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hPrivateKey := hPrivateKey is Win32Handle ? NumGet(hPrivateKey, "ptr") : hPrivateKey
        hPublicKey := hPublicKey is Win32Handle ? NumGet(hPublicKey, "ptr") : hPublicKey

        pcbResultMarshal := pcbResult is VarRef ? "uint*" : "ptr"

        result := DllCall("ncrypt.dll\SslGenerateMasterKey", "ptr", hSslProvider, "ptr", hPrivateKey, "ptr", hPublicKey, "ptr", phMasterKey, "uint", dwProtocol, "uint", dwCipherSuite, "ptr", pParameterList, "ptr", pbOutput, "uint", cbOutput, pcbResultMarshal, pcbResult, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hMasterKey 
     * @param {Pointer<NCRYPT_KEY_HANDLE>} phReadKey 
     * @param {Pointer<NCRYPT_KEY_HANDLE>} phWriteKey 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslgeneratesessionkeys
     */
    static SslGenerateSessionKeys(hSslProvider, hMasterKey, phReadKey, phWriteKey, pParameterList, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hMasterKey := hMasterKey is Win32Handle ? NumGet(hMasterKey, "ptr") : hMasterKey

        result := DllCall("ncrypt.dll\SslGenerateSessionKeys", "ptr", hSslProvider, "ptr", hMasterKey, "ptr", phReadKey, "ptr", phWriteKey, "ptr", pParameterList, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_KEY_HANDLE} hKey 
     * @param {PWSTR} pszProperty 
     * @param {Pointer<Pointer<Integer>>} ppbOutput 
     * @param {Pointer<Integer>} pcbOutput 
     * @param {Integer} dwFlags 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslgetkeyproperty
     */
    static SslGetKeyProperty(hKey, pszProperty, ppbOutput, pcbOutput, dwFlags) {
        hKey := hKey is Win32Handle ? NumGet(hKey, "ptr") : hKey
        pszProperty := pszProperty is String ? StrPtr(pszProperty) : pszProperty

        ppbOutputMarshal := ppbOutput is VarRef ? "ptr*" : "ptr"
        pcbOutputMarshal := pcbOutput is VarRef ? "uint*" : "ptr"

        result := DllCall("ncrypt.dll\SslGetKeyProperty", "ptr", hKey, "ptr", pszProperty, ppbOutputMarshal, ppbOutput, pcbOutputMarshal, pcbOutput, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {PWSTR} pszProperty 
     * @param {Pointer<Pointer<Integer>>} ppbOutput 
     * @param {Pointer<Integer>} pcbOutput 
     * @param {Pointer<Pointer<Void>>} ppEnumState 
     * @param {Integer} dwFlags 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslgetproviderproperty
     */
    static SslGetProviderProperty(hSslProvider, pszProperty, ppbOutput, pcbOutput, ppEnumState, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        pszProperty := pszProperty is String ? StrPtr(pszProperty) : pszProperty

        ppbOutputMarshal := ppbOutput is VarRef ? "ptr*" : "ptr"
        pcbOutputMarshal := pcbOutput is VarRef ? "uint*" : "ptr"
        ppEnumStateMarshal := ppEnumState is VarRef ? "ptr*" : "ptr"

        result := DllCall("ncrypt.dll\SslGetProviderProperty", "ptr", hSslProvider, "ptr", pszProperty, ppbOutputMarshal, ppbOutput, pcbOutputMarshal, pcbOutput, ppEnumStateMarshal, ppEnumState, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_HASH_HANDLE} hHandshakeHash 
     * @param {Pointer} pbInput 
     * @param {Integer} cbInput 
     * @param {Integer} dwFlags 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslhashhandshake
     */
    static SslHashHandshake(hSslProvider, hHandshakeHash, pbInput, cbInput, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hHandshakeHash := hHandshakeHash is Win32Handle ? NumGet(hHandshakeHash, "ptr") : hHandshakeHash

        result := DllCall("ncrypt.dll\SslHashHandshake", "ptr", hSslProvider, "ptr", hHandshakeHash, "ptr", pbInput, "uint", cbInput, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {PWSTR} pszBlobType 
     * @param {Pointer} pbKeyBlob 
     * @param {Integer} cbKeyBlob 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_KEY_HANDLE} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslimportkey
     */
    static SslImportKey(hSslProvider, pszBlobType, pbKeyBlob, cbKeyBlob, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        pszBlobType := pszBlobType is String ? StrPtr(pszBlobType) : pszBlobType

        phKey := NCRYPT_KEY_HANDLE()
        result := DllCall("ncrypt.dll\SslImportKey", "ptr", hSslProvider, "ptr", phKey, "ptr", pszBlobType, "ptr", pbKeyBlob, "uint", cbKeyBlob, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phKey
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hPrivateKey 
     * @param {Integer} dwProtocol 
     * @param {Integer} dwCipherSuite 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Pointer} pbEncryptedKey 
     * @param {Integer} cbEncryptedKey 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_KEY_HANDLE} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslimportmasterkey
     */
    static SslImportMasterKey(hSslProvider, hPrivateKey, dwProtocol, dwCipherSuite, pParameterList, pbEncryptedKey, cbEncryptedKey, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hPrivateKey := hPrivateKey is Win32Handle ? NumGet(hPrivateKey, "ptr") : hPrivateKey

        phMasterKey := NCRYPT_KEY_HANDLE()
        result := DllCall("ncrypt.dll\SslImportMasterKey", "ptr", hSslProvider, "ptr", hPrivateKey, "ptr", phMasterKey, "uint", dwProtocol, "uint", dwCipherSuite, "ptr", pParameterList, "ptr", pbEncryptedKey, "uint", cbEncryptedKey, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phMasterKey
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {Integer} dwProtocol 
     * @param {Integer} dwCipherSuite 
     * @param {Integer} dwKeyType 
     * @param {Pointer<NCRYPT_SSL_CIPHER_SUITE>} pCipherSuite 
     * @param {Integer} dwFlags 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/ssllookupciphersuiteinfo
     */
    static SslLookupCipherSuiteInfo(hSslProvider, dwProtocol, dwCipherSuite, dwKeyType, pCipherSuite, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider

        result := DllCall("ncrypt.dll\SslLookupCipherSuiteInfo", "ptr", hSslProvider, "uint", dwProtocol, "uint", dwCipherSuite, "uint", dwKeyType, "ptr", pCipherSuite, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {Pointer<CERT_CONTEXT>} pCertContext 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_KEY_HANDLE} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslopenprivatekey
     */
    static SslOpenPrivateKey(hSslProvider, pCertContext, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider

        phPrivateKey := NCRYPT_KEY_HANDLE()
        result := DllCall("ncrypt.dll\SslOpenPrivateKey", "ptr", hSslProvider, "ptr", phPrivateKey, "ptr", pCertContext, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phPrivateKey
    }

    /**
     * 
     * @param {PWSTR} pszProviderName 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_PROV_HANDLE} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslopenprovider
     */
    static SslOpenProvider(pszProviderName, dwFlags) {
        pszProviderName := pszProviderName is String ? StrPtr(pszProviderName) : pszProviderName

        phSslProvider := NCRYPT_PROV_HANDLE()
        result := DllCall("ncrypt.dll\SslOpenProvider", "ptr", phSslProvider, "ptr", pszProviderName, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phSslProvider
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hPrivateKey 
     * @param {Pointer} pbHashValue 
     * @param {Integer} cbHashValue 
     * @param {Pointer} pbSignature 
     * @param {Integer} cbSignature 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslsignhash
     */
    static SslSignHash(hSslProvider, hPrivateKey, pbHashValue, cbHashValue, pbSignature, cbSignature, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hPrivateKey := hPrivateKey is Win32Handle ? NumGet(hPrivateKey, "ptr") : hPrivateKey

        result := DllCall("ncrypt.dll\SslSignHash", "ptr", hSslProvider, "ptr", hPrivateKey, "ptr", pbHashValue, "uint", cbHashValue, "ptr", pbSignature, "uint", cbSignature, "uint*", &pcbResult := 0, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbResult
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hPublicKey 
     * @param {Pointer} pbHashValue 
     * @param {Integer} cbHashValue 
     * @param {Pointer} pbSignature 
     * @param {Integer} cbSignature 
     * @param {Integer} dwFlags 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslverifysignature
     */
    static SslVerifySignature(hSslProvider, hPublicKey, pbHashValue, cbHashValue, pbSignature, cbSignature, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hPublicKey := hPublicKey is Win32Handle ? NumGet(hPublicKey, "ptr") : hPublicKey

        result := DllCall("ncrypt.dll\SslVerifySignature", "ptr", hSslProvider, "ptr", hPublicKey, "ptr", pbHashValue, "uint", cbHashValue, "ptr", pbSignature, "uint", cbSignature, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {Integer} dwProtocol 
     * @param {Integer} dwCipherSuite 
     * @param {Integer} dwKeyType 
     * @param {Pointer} pCipherLengths 
     * @param {Integer} cbCipherLengths 
     * @param {Integer} dwFlags 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/ssllookupcipherlengths
     */
    static SslLookupCipherLengths(hSslProvider, dwProtocol, dwCipherSuite, dwKeyType, pCipherLengths, cbCipherLengths, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider

        result := DllCall("ncrypt.dll\SslLookupCipherLengths", "ptr", hSslProvider, "uint", dwProtocol, "uint", dwCipherSuite, "uint", dwKeyType, "ptr", pCipherLengths, "uint", cbCipherLengths, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {Integer} dwProtocol 
     * @param {Integer} dwCipherSuite 
     * @param {PWSTR} pszHashAlgId 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_HASH_HANDLE} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslcreateclientauthhash
     */
    static SslCreateClientAuthHash(hSslProvider, dwProtocol, dwCipherSuite, pszHashAlgId, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        pszHashAlgId := pszHashAlgId is String ? StrPtr(pszHashAlgId) : pszHashAlgId

        phHandshakeHash := NCRYPT_HASH_HANDLE()
        result := DllCall("ncrypt.dll\SslCreateClientAuthHash", "ptr", hSslProvider, "ptr", phHandshakeHash, "uint", dwProtocol, "uint", dwCipherSuite, "ptr", pszHashAlgId, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phHandshakeHash
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {Integer} dwProtocol 
     * @param {Integer} dwCipherSuite 
     * @param {Integer} dwKeyType 
     * @param {PWSTR} szPRFHash 
     * @param {Integer} dwFlags 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslgetciphersuiteprfhashalgorithm
     */
    static SslGetCipherSuitePRFHashAlgorithm(hSslProvider, dwProtocol, dwCipherSuite, dwKeyType, szPRFHash, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        szPRFHash := szPRFHash is String ? StrPtr(szPRFHash) : szPRFHash

        result := DllCall("ncrypt.dll\SslGetCipherSuitePRFHashAlgorithm", "ptr", hSslProvider, "uint", dwProtocol, "uint", dwCipherSuite, "uint", dwKeyType, "ptr", szPRFHash, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_HASH_HANDLE} hHandshakeHash 
     * @param {Integer} dwProtocol 
     * @param {Pointer} pbOutput 
     * @param {Integer} cbOutput 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static SslComputeSessionHash(hSslProvider, hHandshakeHash, dwProtocol, pbOutput, cbOutput, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hHandshakeHash := hHandshakeHash is Win32Handle ? NumGet(hHandshakeHash, "ptr") : hHandshakeHash

        result := DllCall("ncrypt.dll\SslComputeSessionHash", "ptr", hSslProvider, "ptr", hHandshakeHash, "uint", dwProtocol, "ptr", pbOutput, "uint", cbOutput, "uint*", &pcbResult := 0, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return pcbResult
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hPublicKey 
     * @param {Pointer<NCRYPT_KEY_HANDLE>} phPreMasterKey 
     * @param {Integer} dwProtocol 
     * @param {Integer} dwCipherSuite 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Pointer} pbOutput 
     * @param {Integer} cbOutput 
     * @param {Pointer<Integer>} pcbResult 
     * @param {Integer} dwFlags 
     * @returns {HRESULT} 
     */
    static SslGeneratePreMasterKey(hSslProvider, hPublicKey, phPreMasterKey, dwProtocol, dwCipherSuite, pParameterList, pbOutput, cbOutput, pcbResult, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hPublicKey := hPublicKey is Win32Handle ? NumGet(hPublicKey, "ptr") : hPublicKey

        pcbResultMarshal := pcbResult is VarRef ? "uint*" : "ptr"

        result := DllCall("ncrypt.dll\SslGeneratePreMasterKey", "ptr", hSslProvider, "ptr", hPublicKey, "ptr", phPreMasterKey, "uint", dwProtocol, "uint", dwCipherSuite, "ptr", pParameterList, "ptr", pbOutput, "uint", cbOutput, pcbResultMarshal, pcbResult, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hMasterKey 
     * @param {PSTR} sLabel 
     * @param {Pointer} pbRandoms 
     * @param {Integer} cbRandoms 
     * @param {Pointer} pbContextValue 
     * @param {Integer} cbContextValue 
     * @param {Pointer} pbOutput 
     * @param {Integer} cbOutput 
     * @param {Integer} dwFlags 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslexportkeyingmaterial
     */
    static SslExportKeyingMaterial(hSslProvider, hMasterKey, sLabel, pbRandoms, cbRandoms, pbContextValue, cbContextValue, pbOutput, cbOutput, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hMasterKey := hMasterKey is Win32Handle ? NumGet(hMasterKey, "ptr") : hMasterKey
        sLabel := sLabel is String ? StrPtr(sLabel) : sLabel

        result := DllCall("ncrypt.dll\SslExportKeyingMaterial", "ptr", hSslProvider, "ptr", hMasterKey, "ptr", sLabel, "ptr", pbRandoms, "uint", cbRandoms, "ptr", pbContextValue, "ushort", cbContextValue, "ptr", pbOutput, "uint", cbOutput, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hPreSharedKey 
     * @param {Integer} dwProtocol 
     * @param {Integer} dwCipherSuite 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_KEY_HANDLE} 
     */
    static SslExtractEarlyKey(hSslProvider, hPreSharedKey, dwProtocol, dwCipherSuite, pParameterList, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hPreSharedKey := hPreSharedKey is Win32Handle ? NumGet(hPreSharedKey, "ptr") : hPreSharedKey

        phEarlyKey := NCRYPT_KEY_HANDLE()
        result := DllCall("ncrypt.dll\SslExtractEarlyKey", "ptr", hSslProvider, "ptr", hPreSharedKey, "ptr", phEarlyKey, "uint", dwProtocol, "uint", dwCipherSuite, "ptr", pParameterList, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phEarlyKey
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hPrivateKey 
     * @param {NCRYPT_KEY_HANDLE} hPublicKey 
     * @param {NCRYPT_KEY_HANDLE} hEarlyKey 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_KEY_HANDLE} 
     */
    static SslExtractHandshakeKey(hSslProvider, hPrivateKey, hPublicKey, hEarlyKey, pParameterList, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hPrivateKey := hPrivateKey is Win32Handle ? NumGet(hPrivateKey, "ptr") : hPrivateKey
        hPublicKey := hPublicKey is Win32Handle ? NumGet(hPublicKey, "ptr") : hPublicKey
        hEarlyKey := hEarlyKey is Win32Handle ? NumGet(hEarlyKey, "ptr") : hEarlyKey

        phHandshakeKey := NCRYPT_KEY_HANDLE()
        result := DllCall("ncrypt.dll\SslExtractHandshakeKey", "ptr", hSslProvider, "ptr", hPrivateKey, "ptr", hPublicKey, "ptr", hEarlyKey, "ptr", phHandshakeKey, "ptr", pParameterList, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phHandshakeKey
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hHandshakeKey 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_KEY_HANDLE} 
     */
    static SslExtractMasterKey(hSslProvider, hHandshakeKey, pParameterList, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hHandshakeKey := hHandshakeKey is Win32Handle ? NumGet(hHandshakeKey, "ptr") : hHandshakeKey

        phMasterKey := NCRYPT_KEY_HANDLE()
        result := DllCall("ncrypt.dll\SslExtractMasterKey", "ptr", hSslProvider, "ptr", hHandshakeKey, "ptr", phMasterKey, "ptr", pParameterList, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phMasterKey
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hBaseKey 
     * @param {NCRYPT_HASH_HANDLE} hHashValue 
     * @param {Pointer<NCRYPT_KEY_HANDLE>} phClientTrafficKey 
     * @param {Pointer<NCRYPT_KEY_HANDLE>} phServerTrafficKey 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {HRESULT} 
     */
    static SslExpandTrafficKeys(hSslProvider, hBaseKey, hHashValue, phClientTrafficKey, phServerTrafficKey, pParameterList, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hBaseKey := hBaseKey is Win32Handle ? NumGet(hBaseKey, "ptr") : hBaseKey
        hHashValue := hHashValue is Win32Handle ? NumGet(hHashValue, "ptr") : hHashValue

        result := DllCall("ncrypt.dll\SslExpandTrafficKeys", "ptr", hSslProvider, "ptr", hBaseKey, "ptr", hHashValue, "ptr", phClientTrafficKey, "ptr", phServerTrafficKey, "ptr", pParameterList, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hBaseTrafficKey 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_KEY_HANDLE} 
     */
    static SslExpandWriteKey(hSslProvider, hBaseTrafficKey, pParameterList, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hBaseTrafficKey := hBaseTrafficKey is Win32Handle ? NumGet(hBaseTrafficKey, "ptr") : hBaseTrafficKey

        phWriteKey := NCRYPT_KEY_HANDLE()
        result := DllCall("ncrypt.dll\SslExpandWriteKey", "ptr", hSslProvider, "ptr", hBaseTrafficKey, "ptr", phWriteKey, "ptr", pParameterList, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phWriteKey
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hBaseKey 
     * @param {NCRYPT_HASH_HANDLE} hHashValue 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_KEY_HANDLE} 
     */
    static SslExpandExporterMasterKey(hSslProvider, hBaseKey, hHashValue, pParameterList, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hBaseKey := hBaseKey is Win32Handle ? NumGet(hBaseKey, "ptr") : hBaseKey
        hHashValue := hHashValue is Win32Handle ? NumGet(hHashValue, "ptr") : hHashValue

        phExporterMasterKey := NCRYPT_KEY_HANDLE()
        result := DllCall("ncrypt.dll\SslExpandExporterMasterKey", "ptr", hSslProvider, "ptr", hBaseKey, "ptr", hHashValue, "ptr", phExporterMasterKey, "ptr", pParameterList, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phExporterMasterKey
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hMasterKey 
     * @param {NCRYPT_HASH_HANDLE} hHashValue 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_KEY_HANDLE} 
     */
    static SslExpandResumptionMasterKey(hSslProvider, hMasterKey, hHashValue, pParameterList, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hMasterKey := hMasterKey is Win32Handle ? NumGet(hMasterKey, "ptr") : hMasterKey
        hHashValue := hHashValue is Win32Handle ? NumGet(hHashValue, "ptr") : hHashValue

        phResumptionMasterKey := NCRYPT_KEY_HANDLE()
        result := DllCall("ncrypt.dll\SslExpandResumptionMasterKey", "ptr", hSslProvider, "ptr", hMasterKey, "ptr", hHashValue, "ptr", phResumptionMasterKey, "ptr", pParameterList, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phResumptionMasterKey
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_HASH_HANDLE} hTranscriptHash 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_HASH_HANDLE} 
     */
    static SslDuplicateTranscriptHash(hSslProvider, hTranscriptHash, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hTranscriptHash := hTranscriptHash is Win32Handle ? NumGet(hTranscriptHash, "ptr") : hTranscriptHash

        phTranscriptHash := NCRYPT_HASH_HANDLE()
        result := DllCall("ncrypt.dll\SslDuplicateTranscriptHash", "ptr", hSslProvider, "ptr", hTranscriptHash, "ptr", phTranscriptHash, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phTranscriptHash
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hEarlyKey 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_KEY_HANDLE} 
     */
    static SslExpandBinderKey(hSslProvider, hEarlyKey, pParameterList, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hEarlyKey := hEarlyKey is Win32Handle ? NumGet(hEarlyKey, "ptr") : hEarlyKey

        phBinderKey := NCRYPT_KEY_HANDLE()
        result := DllCall("ncrypt.dll\SslExpandBinderKey", "ptr", hSslProvider, "ptr", hEarlyKey, "ptr", phBinderKey, "ptr", pParameterList, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phBinderKey
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @param {NCRYPT_KEY_HANDLE} hResumptionMasterKey 
     * @param {Pointer} pbTicketNonce 
     * @param {Integer} cbTicketNonce 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {NCRYPT_KEY_HANDLE} 
     */
    static SslExpandPreSharedKey(hSslProvider, hResumptionMasterKey, pbTicketNonce, cbTicketNonce, pParameterList, dwFlags) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider
        hResumptionMasterKey := hResumptionMasterKey is Win32Handle ? NumGet(hResumptionMasterKey, "ptr") : hResumptionMasterKey

        phPreSharedKey := NCRYPT_KEY_HANDLE()
        result := DllCall("ncrypt.dll\SslExpandPreSharedKey", "ptr", hSslProvider, "ptr", hResumptionMasterKey, "ptr", pbTicketNonce, "uint", cbTicketNonce, "ptr", phPreSharedKey, "ptr", pParameterList, "uint", dwFlags, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return phPreSharedKey
    }

    /**
     * 
     * @param {PWSTR} pszProviderName 
     * @param {Pointer<Pointer<NCRYPT_SSL_FUNCTION_TABLE>>} ppFunctionTable 
     * @param {Integer} dwFlags 
     * @returns {NTSTATUS} 
     */
    static GetSChannelInterface(pszProviderName, ppFunctionTable, dwFlags) {
        pszProviderName := pszProviderName is String ? StrPtr(pszProviderName) : pszProviderName

        ppFunctionTableMarshal := ppFunctionTable is VarRef ? "ptr*" : "ptr"

        result := DllCall("ncrypt.dll\GetSChannelInterface", "ptr", pszProviderName, ppFunctionTableMarshal, ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslincrementproviderreferencecount
     */
    static SslIncrementProviderReferenceCount(hSslProvider) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider

        result := DllCall("ncrypt.dll\SslIncrementProviderReferenceCount", "ptr", hSslProvider, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

    /**
     * 
     * @param {NCRYPT_PROV_HANDLE} hSslProvider 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/SecCNG/ssldecrementproviderreferencecount
     */
    static SslDecrementProviderReferenceCount(hSslProvider) {
        hSslProvider := hSslProvider is Win32Handle ? NumGet(hSslProvider, "ptr") : hSslProvider

        result := DllCall("ncrypt.dll\SslDecrementProviderReferenceCount", "ptr", hSslProvider, "int")
        if(result != 0) {
            throw OSError(A_LastError || result)
        }

        return result
    }

;@endregion Methods
}
