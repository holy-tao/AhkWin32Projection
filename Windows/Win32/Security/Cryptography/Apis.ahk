#Requires AutoHotkey v2.0.0 64-bit

/**
 * @namespace Windows.Win32.Security.Cryptography
 * @version v4.0.30319
 */
class Cryptography {

;@region Constants

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_CURRENT_USER => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_LOCAL_MACHINE => 131072

    /**
     * @type {Integer (Int32)}
     */
    static CERT_COMPARE_SHIFT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_OBJECT_ALIGNMENT => 16

    /**
     * @type {String}
     */
    static BCRYPT_KDF_HASH => "HASH"

    /**
     * @type {String}
     */
    static BCRYPT_KDF_HMAC => "HMAC"

    /**
     * @type {String}
     */
    static BCRYPT_KDF_TLS_PRF => "TLS_PRF"

    /**
     * @type {String}
     */
    static BCRYPT_KDF_SP80056A_CONCAT => "SP800_56A_CONCAT"

    /**
     * @type {String}
     */
    static BCRYPT_KDF_RAW_SECRET => "TRUNCATE"

    /**
     * @type {String}
     */
    static BCRYPT_KDF_HKDF => "HKDF"

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_HASH_ALGORITHM => 0

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_SECRET_PREPEND => 1

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_SECRET_APPEND => 2

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_HMAC_KEY => 3

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_TLS_PRF_LABEL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_TLS_PRF_SEED => 5

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_SECRET_HANDLE => 6

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_TLS_PRF_PROTOCOL => 7

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_ALGORITHMID => 8

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_PARTYUINFO => 9

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_PARTYVINFO => 10

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_SUPPPUBINFO => 11

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_SUPPPRIVINFO => 12

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_LABEL => 13

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_CONTEXT => 14

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_SALT => 15

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_ITERATION_COUNT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_GENERIC_PARAMETER => 17

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_KEYBITLENGTH => 18

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_HKDF_SALT => 19

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_HKDF_INFO => 20

    /**
     * @type {Integer (UInt32)}
     */
    static KDF_USE_SECRET_AS_HMAC_KEY_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_AUTH_MODE_IN_PROGRESS_FLAG => 2

    /**
     * @type {String}
     */
    static BCRYPT_OPAQUE_KEY_BLOB => "OpaqueKeyBlob"

    /**
     * @type {String}
     */
    static BCRYPT_KEY_DATA_BLOB => "KeyDataBlob"

    /**
     * @type {String}
     */
    static BCRYPT_AES_WRAP_KEY_BLOB => "Rfc3565KeyWrapBlob"

    /**
     * @type {String}
     */
    static BCRYPT_OBJECT_LENGTH => "ObjectLength"

    /**
     * @type {String}
     */
    static BCRYPT_ALGORITHM_NAME => "AlgorithmName"

    /**
     * @type {String}
     */
    static BCRYPT_PROVIDER_HANDLE => "ProviderHandle"

    /**
     * @type {String}
     */
    static BCRYPT_CHAINING_MODE => "ChainingMode"

    /**
     * @type {String}
     */
    static BCRYPT_BLOCK_LENGTH => "BlockLength"

    /**
     * @type {String}
     */
    static BCRYPT_KEY_LENGTH => "KeyLength"

    /**
     * @type {String}
     */
    static BCRYPT_KEY_OBJECT_LENGTH => "KeyObjectLength"

    /**
     * @type {String}
     */
    static BCRYPT_KEY_STRENGTH => "KeyStrength"

    /**
     * @type {String}
     */
    static BCRYPT_KEY_LENGTHS => "KeyLengths"

    /**
     * @type {String}
     */
    static BCRYPT_BLOCK_SIZE_LIST => "BlockSizeList"

    /**
     * @type {String}
     */
    static BCRYPT_EFFECTIVE_KEY_LENGTH => "EffectiveKeyLength"

    /**
     * @type {String}
     */
    static BCRYPT_HASH_LENGTH => "HashDigestLength"

    /**
     * @type {String}
     */
    static BCRYPT_HASH_OID_LIST => "HashOIDList"

    /**
     * @type {String}
     */
    static BCRYPT_PADDING_SCHEMES => "PaddingSchemes"

    /**
     * @type {String}
     */
    static BCRYPT_SIGNATURE_LENGTH => "SignatureLength"

    /**
     * @type {String}
     */
    static BCRYPT_HASH_BLOCK_LENGTH => "HashBlockLength"

    /**
     * @type {String}
     */
    static BCRYPT_AUTH_TAG_LENGTH => "AuthTagLength"

    /**
     * @type {String}
     */
    static BCRYPT_PRIMITIVE_TYPE => "PrimitiveType"

    /**
     * @type {String}
     */
    static BCRYPT_IS_KEYED_HASH => "IsKeyedHash"

    /**
     * @type {String}
     */
    static BCRYPT_IS_REUSABLE_HASH => "IsReusableHash"

    /**
     * @type {String}
     */
    static BCRYPT_MESSAGE_BLOCK_LENGTH => "MessageBlockLength"

    /**
     * @type {String}
     */
    static BCRYPT_PUBLIC_KEY_LENGTH => "PublicKeyLength"

    /**
     * @type {String}
     */
    static BCRYPT_PCP_PLATFORM_TYPE_PROPERTY => "PCP_PLATFORM_TYPE"

    /**
     * @type {String}
     */
    static BCRYPT_PCP_PROVIDER_VERSION_PROPERTY => "PCP_PROVIDER_VERSION"

    /**
     * @type {String}
     */
    static BCRYPT_MULTI_OBJECT_LENGTH => "MultiObjectLength"

    /**
     * @type {String}
     */
    static BCRYPT_IS_IFX_TPM_WEAK_KEY => "IsIfxTpmWeakKey"

    /**
     * @type {String}
     */
    static BCRYPT_HKDF_HASH_ALGORITHM => "HkdfHashAlgorithm"

    /**
     * @type {String}
     */
    static BCRYPT_HKDF_SALT_AND_FINALIZE => "HkdfSaltAndFinalize"

    /**
     * @type {String}
     */
    static BCRYPT_HKDF_PRK_AND_FINALIZE => "HkdfPrkAndFinalize"

    /**
     * @type {String}
     */
    static BCRYPT_INITIALIZATION_VECTOR => "IV"

    /**
     * @type {String}
     */
    static BCRYPT_CHAIN_MODE_NA => "ChainingModeN/A"

    /**
     * @type {String}
     */
    static BCRYPT_CHAIN_MODE_CBC => "ChainingModeCBC"

    /**
     * @type {String}
     */
    static BCRYPT_CHAIN_MODE_ECB => "ChainingModeECB"

    /**
     * @type {String}
     */
    static BCRYPT_CHAIN_MODE_CFB => "ChainingModeCFB"

    /**
     * @type {String}
     */
    static BCRYPT_CHAIN_MODE_CCM => "ChainingModeCCM"

    /**
     * @type {String}
     */
    static BCRYPT_CHAIN_MODE_GCM => "ChainingModeGCM"

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_SUPPORTED_PAD_ROUTER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_SUPPORTED_PAD_PKCS1_ENC => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_SUPPORTED_PAD_PKCS1_SIG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_SUPPORTED_PAD_OAEP => 8

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_SUPPORTED_PAD_PSS => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_GENERATE_IV => 32

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_PAD_PKCS1_OPTIONAL_HASH_OID => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPTBUFFER_VERSION => 0

    /**
     * @type {String}
     */
    static BCRYPT_PUBLIC_KEY_BLOB => "PUBLICBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_PRIVATE_KEY_BLOB => "PRIVATEBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_RSAPUBLIC_BLOB => "RSAPUBLICBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_RSAPRIVATE_BLOB => "RSAPRIVATEBLOB"

    /**
     * @type {String}
     */
    static LEGACY_RSAPUBLIC_BLOB => "CAPIPUBLICBLOB"

    /**
     * @type {String}
     */
    static LEGACY_RSAPRIVATE_BLOB => "CAPIPRIVATEBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_RSAFULLPRIVATE_BLOB => "RSAFULLPRIVATEBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_GLOBAL_PARAMETERS => "SecretAgreementParam"

    /**
     * @type {String}
     */
    static BCRYPT_PRIVATE_KEY => "PrivKeyVal"

    /**
     * @type {String}
     */
    static BCRYPT_ECCPUBLIC_BLOB => "ECCPUBLICBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_ECCPRIVATE_BLOB => "ECCPRIVATEBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_ECCFULLPUBLIC_BLOB => "ECCFULLPUBLICBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_ECCFULLPRIVATE_BLOB => "ECCFULLPRIVATEBLOB"

    /**
     * @type {String}
     */
    static SSL_ECCPUBLIC_BLOB => "SSLECCPUBLICBLOB"

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_PUBLIC_P256_MAGIC => 827016005

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_PRIVATE_P256_MAGIC => 843793221

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_PUBLIC_P384_MAGIC => 860570437

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_PRIVATE_P384_MAGIC => 877347653

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_PUBLIC_P521_MAGIC => 894124869

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_PRIVATE_P521_MAGIC => 910902085

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_PUBLIC_GENERIC_MAGIC => 1347109701

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_PRIVATE_GENERIC_MAGIC => 1447772997

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_PUBLIC_P256_MAGIC => 827540293

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_PRIVATE_P256_MAGIC => 844317509

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_PUBLIC_P384_MAGIC => 861094725

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_PRIVATE_P384_MAGIC => 877871941

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_PUBLIC_P521_MAGIC => 894649157

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_PRIVATE_P521_MAGIC => 911426373

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_PUBLIC_GENERIC_MAGIC => 1346650949

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_PRIVATE_GENERIC_MAGIC => 1447314245

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECC_FULLKEY_BLOB_V1 => 1

    /**
     * @type {String}
     */
    static BCRYPT_DH_PUBLIC_BLOB => "DHPUBLICBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_DH_PRIVATE_BLOB => "DHPRIVATEBLOB"

    /**
     * @type {String}
     */
    static LEGACY_DH_PUBLIC_BLOB => "CAPIDHPUBLICBLOB"

    /**
     * @type {String}
     */
    static LEGACY_DH_PRIVATE_BLOB => "CAPIDHPRIVATEBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_DH_PARAMETERS => "DHParameters"

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DH_PARAMETERS_MAGIC => 1297107012

    /**
     * @type {String}
     */
    static BCRYPT_DSA_PUBLIC_BLOB => "DSAPUBLICBLOB"

    /**
     * @type {String}
     */
    static BCRYPT_DSA_PRIVATE_BLOB => "DSAPRIVATEBLOB"

    /**
     * @type {String}
     */
    static LEGACY_DSA_PUBLIC_BLOB => "CAPIDSAPUBLICBLOB"

    /**
     * @type {String}
     */
    static LEGACY_DSA_PRIVATE_BLOB => "CAPIDSAPRIVATEBLOB"

    /**
     * @type {String}
     */
    static LEGACY_DSA_V2_PUBLIC_BLOB => "V2CAPIDSAPUBLICBLOB"

    /**
     * @type {String}
     */
    static LEGACY_DSA_V2_PRIVATE_BLOB => "V2CAPIDSAPRIVATEBLOB"

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DSA_PUBLIC_MAGIC_V2 => 843206724

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DSA_PRIVATE_MAGIC_V2 => 844517444

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_KEY_DATA_BLOB_MAGIC => 1296188491

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_KEY_DATA_BLOB_VERSION1 => 1

    /**
     * @type {String}
     */
    static BCRYPT_DSA_PARAMETERS => "DSAParameters"

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DSA_PARAMETERS_MAGIC => 1297109828

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DSA_PARAMETERS_MAGIC_V2 => 843927620

    /**
     * @type {String}
     */
    static BCRYPT_ECC_PARAMETERS => "ECCParameters"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NAME => "ECCCurveName"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NAME_LIST => "ECCCurveNameList"

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECC_PARAMETERS_MAGIC => 1346585413

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP160R1 => "brainpoolP160r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP160T1 => "brainpoolP160t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP192R1 => "brainpoolP192r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP192T1 => "brainpoolP192t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP224R1 => "brainpoolP224r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP224T1 => "brainpoolP224t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP256R1 => "brainpoolP256r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP256T1 => "brainpoolP256t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP320R1 => "brainpoolP320r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP320T1 => "brainpoolP320t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP384R1 => "brainpoolP384r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP384T1 => "brainpoolP384t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP512R1 => "brainpoolP512r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_BRAINPOOLP512T1 => "brainpoolP512t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_25519 => "curve25519"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_EC192WAPI => "ec192wapi"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NISTP192 => "nistP192"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NISTP224 => "nistP224"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NISTP256 => "nistP256"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NISTP384 => "nistP384"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NISTP521 => "nistP521"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NUMSP256T1 => "numsP256t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NUMSP384T1 => "numsP384t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_NUMSP512T1 => "numsP512t1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP160K1 => "secP160k1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP160R1 => "secP160r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP160R2 => "secP160r2"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP192K1 => "secP192k1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP192R1 => "secP192r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP224K1 => "secP224k1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP224R1 => "secP224r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP256K1 => "secP256k1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP256R1 => "secP256r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP384R1 => "secP384r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_SECP521R1 => "secP521r1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_WTLS7 => "wtls7"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_WTLS9 => "wtls9"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_WTLS12 => "wtls12"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_X962P192V1 => "x962P192v1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_X962P192V2 => "x962P192v2"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_X962P192V3 => "x962P192v3"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_X962P239V1 => "x962P239v1"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_X962P239V2 => "x962P239v2"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_X962P239V3 => "x962P239v3"

    /**
     * @type {String}
     */
    static BCRYPT_ECC_CURVE_X962P256V1 => "x962P256v1"

    /**
     * @type {String}
     */
    static MS_PRIMITIVE_PROVIDER => "Microsoft Primitive Provider"

    /**
     * @type {String}
     */
    static MS_PLATFORM_CRYPTO_PROVIDER => "Microsoft Platform Crypto Provider"

    /**
     * @type {String}
     */
    static BCRYPT_RSA_ALGORITHM => "RSA"

    /**
     * @type {String}
     */
    static BCRYPT_RSA_SIGN_ALGORITHM => "RSA_SIGN"

    /**
     * @type {String}
     */
    static BCRYPT_DH_ALGORITHM => "DH"

    /**
     * @type {String}
     */
    static BCRYPT_DSA_ALGORITHM => "DSA"

    /**
     * @type {String}
     */
    static BCRYPT_RC2_ALGORITHM => "RC2"

    /**
     * @type {String}
     */
    static BCRYPT_RC4_ALGORITHM => "RC4"

    /**
     * @type {String}
     */
    static BCRYPT_AES_ALGORITHM => "AES"

    /**
     * @type {String}
     */
    static BCRYPT_DES_ALGORITHM => "DES"

    /**
     * @type {String}
     */
    static BCRYPT_DESX_ALGORITHM => "DESX"

    /**
     * @type {String}
     */
    static BCRYPT_3DES_ALGORITHM => "3DES"

    /**
     * @type {String}
     */
    static BCRYPT_3DES_112_ALGORITHM => "3DES_112"

    /**
     * @type {String}
     */
    static BCRYPT_MD2_ALGORITHM => "MD2"

    /**
     * @type {String}
     */
    static BCRYPT_MD4_ALGORITHM => "MD4"

    /**
     * @type {String}
     */
    static BCRYPT_MD5_ALGORITHM => "MD5"

    /**
     * @type {String}
     */
    static BCRYPT_SHA1_ALGORITHM => "SHA1"

    /**
     * @type {String}
     */
    static BCRYPT_SHA256_ALGORITHM => "SHA256"

    /**
     * @type {String}
     */
    static BCRYPT_SHA384_ALGORITHM => "SHA384"

    /**
     * @type {String}
     */
    static BCRYPT_SHA512_ALGORITHM => "SHA512"

    /**
     * @type {String}
     */
    static BCRYPT_AES_GMAC_ALGORITHM => "AES-GMAC"

    /**
     * @type {String}
     */
    static BCRYPT_AES_CMAC_ALGORITHM => "AES-CMAC"

    /**
     * @type {String}
     */
    static BCRYPT_ECDSA_P256_ALGORITHM => "ECDSA_P256"

    /**
     * @type {String}
     */
    static BCRYPT_ECDSA_P384_ALGORITHM => "ECDSA_P384"

    /**
     * @type {String}
     */
    static BCRYPT_ECDSA_P521_ALGORITHM => "ECDSA_P521"

    /**
     * @type {String}
     */
    static BCRYPT_ECDH_P256_ALGORITHM => "ECDH_P256"

    /**
     * @type {String}
     */
    static BCRYPT_ECDH_P384_ALGORITHM => "ECDH_P384"

    /**
     * @type {String}
     */
    static BCRYPT_ECDH_P521_ALGORITHM => "ECDH_P521"

    /**
     * @type {String}
     */
    static BCRYPT_RNG_ALGORITHM => "RNG"

    /**
     * @type {String}
     */
    static BCRYPT_RNG_FIPS186_DSA_ALGORITHM => "FIPS186DSARNG"

    /**
     * @type {String}
     */
    static BCRYPT_RNG_DUAL_EC_ALGORITHM => "DUALECRNG"

    /**
     * @type {String}
     */
    static BCRYPT_SP800108_CTR_HMAC_ALGORITHM => "SP800_108_CTR_HMAC"

    /**
     * @type {String}
     */
    static BCRYPT_SP80056A_CONCAT_ALGORITHM => "SP800_56A_CONCAT"

    /**
     * @type {String}
     */
    static BCRYPT_PBKDF2_ALGORITHM => "PBKDF2"

    /**
     * @type {String}
     */
    static BCRYPT_CAPI_KDF_ALGORITHM => "CAPI_KDF"

    /**
     * @type {String}
     */
    static BCRYPT_TLS1_1_KDF_ALGORITHM => "TLS1_1_KDF"

    /**
     * @type {String}
     */
    static BCRYPT_TLS1_2_KDF_ALGORITHM => "TLS1_2_KDF"

    /**
     * @type {String}
     */
    static BCRYPT_ECDSA_ALGORITHM => "ECDSA"

    /**
     * @type {String}
     */
    static BCRYPT_ECDH_ALGORITHM => "ECDH"

    /**
     * @type {String}
     */
    static BCRYPT_XTS_AES_ALGORITHM => "XTS-AES"

    /**
     * @type {String}
     */
    static BCRYPT_HKDF_ALGORITHM => "HKDF"

    /**
     * @type {String}
     */
    static BCRYPT_CHACHA20_POLY1305_ALGORITHM => "CHACHA20_POLY1305"

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_KEY_DERIVATION_INTERFACE => 7

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_MD2_ALG_HANDLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_MD4_ALG_HANDLE => 17

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_MD5_ALG_HANDLE => 33

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_SHA1_ALG_HANDLE => 49

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_SHA256_ALG_HANDLE => 65

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_SHA384_ALG_HANDLE => 81

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_SHA512_ALG_HANDLE => 97

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_RC4_ALG_HANDLE => 113

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_RNG_ALG_HANDLE => 129

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_HMAC_MD5_ALG_HANDLE => 145

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_HMAC_SHA1_ALG_HANDLE => 161

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_HMAC_SHA256_ALG_HANDLE => 177

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_HMAC_SHA384_ALG_HANDLE => 193

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_HMAC_SHA512_ALG_HANDLE => 209

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_RSA_ALG_HANDLE => 225

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_ALG_HANDLE => 241

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_AES_CMAC_ALG_HANDLE => 257

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_AES_GMAC_ALG_HANDLE => 273

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_HMAC_MD2_ALG_HANDLE => 289

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_HMAC_MD4_ALG_HANDLE => 305

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_3DES_CBC_ALG_HANDLE => 321

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_3DES_ECB_ALG_HANDLE => 337

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_3DES_CFB_ALG_HANDLE => 353

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_3DES_112_CBC_ALG_HANDLE => 369

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_3DES_112_ECB_ALG_HANDLE => 385

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_3DES_112_CFB_ALG_HANDLE => 401

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_AES_CBC_ALG_HANDLE => 417

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_AES_ECB_ALG_HANDLE => 433

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_AES_CFB_ALG_HANDLE => 449

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_AES_CCM_ALG_HANDLE => 465

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_AES_GCM_ALG_HANDLE => 481

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DES_CBC_ALG_HANDLE => 497

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DES_ECB_ALG_HANDLE => 513

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DES_CFB_ALG_HANDLE => 529

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DESX_CBC_ALG_HANDLE => 545

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DESX_ECB_ALG_HANDLE => 561

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DESX_CFB_ALG_HANDLE => 577

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_RC2_CBC_ALG_HANDLE => 593

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_RC2_ECB_ALG_HANDLE => 609

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_RC2_CFB_ALG_HANDLE => 625

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DH_ALG_HANDLE => 641

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_ALG_HANDLE => 657

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_P256_ALG_HANDLE => 673

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_P384_ALG_HANDLE => 689

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDH_P521_ALG_HANDLE => 705

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_DSA_ALG_HANDLE => 721

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_P256_ALG_HANDLE => 737

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_P384_ALG_HANDLE => 753

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECDSA_P521_ALG_HANDLE => 769

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_RSA_SIGN_ALG_HANDLE => 785

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_CAPI_KDF_ALG_HANDLE => 801

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_PBKDF2_ALG_HANDLE => 817

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_SP800108_CTR_HMAC_ALG_HANDLE => 833

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_SP80056A_CONCAT_ALG_HANDLE => 849

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_TLS1_1_KDF_ALG_HANDLE => 865

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_TLS1_2_KDF_ALG_HANDLE => 881

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_XTS_AES_ALG_HANDLE => 897

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_HKDF_ALG_HANDLE => 913

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_CHACHA20_POLY1305_ALG_HANDLE => 929

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_CAPI_AES_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_MULTI_FLAG => 64

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_TLS_CBC_HMAC_VERIFY_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_BUFFERS_LOCKED_FLAG => 64

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_EXTENDED_KEYSIZE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ENABLE_INCOMPATIBLE_FIPS_CHECKS => 256

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_KEY_DERIVATION_OPERATION => 64

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_PUBLIC_KEY_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_PRIVATE_KEY_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_NO_KEY_VALIDATION => 8

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_KEY_VALIDATION_RANGE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_KEY_VALIDATION_RANGE_AND_ORDER => 24

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_KEY_VALIDATION_REGENERATE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_HASH_INTERFACE_MAJORVERSION_2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OVERWRITE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_PRIORITY_TOP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_PRIORITY_BOTTOM => 4294967295

    /**
     * @type {String}
     */
    static CRYPT_DEFAULT_CONTEXT => "Default"

    /**
     * @type {String}
     */
    static wszXMLNS_DIGSIG => "http://www.w3.org/2000/09/xmldsig#"

    /**
     * @type {String}
     */
    static wszXMLNS_DIGSIG_SignatureProperties => "http://www.w3.org/2000/09/xmldsig#SignatureProperties"

    /**
     * @type {String}
     */
    static wszXMLNS_DIGSIG_Id => "Id"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_BASE64 => "http://www.w3.org/2000/09/xmldsig#base64"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_SHA1 => "http://www.w3.org/2000/09/xmldsig#sha1"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_SHA256 => "http://www.w3.org/2001/04/xmlenc#sha256"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_SHA384 => "http://www.w3.org/2001/04/xmldsig-more#sha384"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_SHA512 => "http://www.w3.org/2001/04/xmlenc#sha512"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_RSA_SHA1 => "http://www.w3.org/2000/09/xmldsig#rsa-sha1"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_DSA_SHA1 => "http://www.w3.org/2000/09/xmldsig#dsa-sha1"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_RSA_SHA256 => "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_RSA_SHA384 => "http://www.w3.org/2001/04/xmldsig-more#rsa-sha384"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_RSA_SHA512 => "http://www.w3.org/2001/04/xmldsig-more#rsa-sha512"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_ECDSA_SHA1 => "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha1"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_ECDSA_SHA256 => "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_ECDSA_SHA384 => "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_ECDSA_SHA512 => "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_HMAC_SHA1 => "http://www.w3.org/2000/09/xmldsig#hmac-sha1"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_HMAC_SHA256 => "http://www.w3.org/2001/04/xmldsig-more#hmac-sha256"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_HMAC_SHA384 => "http://www.w3.org/2001/04/xmldsig-more#hmac-sha384"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_DIGSIG_HMAC_SHA512 => "http://www.w3.org/2001/04/xmldsig-more#hmac-sha512"

    /**
     * @type {String}
     */
    static wszURI_CANONICALIZATION_C14N => "http://www.w3.org/TR/2001/REC-xml-c14n-20010315"

    /**
     * @type {String}
     */
    static wszURI_CANONICALIZATION_C14NC => "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments"

    /**
     * @type {String}
     */
    static wszURI_CANONICALIZATION_EXSLUSIVE_C14N => "http://www.w3.org/2001/10/xml-exc-c14n#"

    /**
     * @type {String}
     */
    static wszURI_CANONICALIZATION_EXSLUSIVE_C14NC => "http://www.w3.org/2001/10/xml-exc-c14n#WithComments"

    /**
     * @type {String}
     */
    static wszURI_TRANSFORM_XPATH => "http://www.w3.org/TR/1999/REC-xpath-19991116"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_TRANSFORM_BASE64 => "http://www.w3.org/2000/09/xmldsig#base64"

    /**
     * @type {String}
     */
    static wszURI_XMLNS_TRANSFORM_ENVELOPED => "http://www.w3.org/2000/09/xmldsig#enveloped-signature"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_BLOB_MAX => 2147483640

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_ID_MAX => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_SIGNATURES_MAX => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_TRANSFORM_MAX => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_SIGNATURE_VALUE_MAX => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_DIGEST_VALUE_MAX => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_OBJECTS_MAX => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_REFERENCES_MAX => 32760

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_BASE => -2146885376

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_LARGE => -2146885375

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_TOO_MANY_TRANSFORMS => -2146885374

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_ENCODING => -2146885373

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_ALGORITHM => -2146885372

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_TRANSFORM => -2146885371

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_HANDLE => -2146885370

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_OPERATION => -2146885369

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_UNRESOLVED_REFERENCE => -2146885368

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_INVALID_DIGEST => -2146885367

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_INVALID_SIGNATURE => -2146885366

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_HASH_FAILED => -2146885365

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_SIGN_FAILED => -2146885364

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_VERIFY_FAILED => -2146885363

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_TOO_MANY_SIGNATURES => -2146885362

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_INVALID_KEYVALUE => -2146885361

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_UNEXPECTED_XML => -2146885360

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_SIGNER => -2146885359

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_NON_UNIQUE_ID => -2146885358

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_XML_E_LAST => -2146885358

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_FLAG_ALWAYS_RETURN_ENCODED_OBJECT => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_FLAG_ENFORCE_ID_NCNAME_FORMAT => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_FLAG_ENFORCE_ID_NAME_FORMAT => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_FLAG_ECDSA_DSIG11 => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_STATUS_NO_ERROR => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_FLAG_ADD_OBJECT_CREATE_COPY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_FLAG_CREATE_REFERENCE_AS_OBJECT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_DIGEST_REFERENCE_DATA_TRANSFORMED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_ALGORITHM_INFO_FIND_BY_URI => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_ALGORITHM_INFO_FIND_BY_NAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_ALGORITHM_INFO_FIND_BY_CNG_ALGID => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_XML_ALGORITHM_INFO_FIND_BY_CNG_SIGN_ALGID => 4

    /**
     * @type {String}
     */
    static szFORCE_KEY_PROTECTION => "ForceKeyProtection"

    /**
     * @type {Integer (UInt32)}
     */
    static dwFORCE_KEY_PROTECTION_DISABLED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static dwFORCE_KEY_PROTECTION_USER_SELECT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static dwFORCE_KEY_PROTECTION_HIGH => 2

    /**
     * @type {String}
     */
    static CRYPTPROTECT_DEFAULT_PROVIDER => "{df9d8cd0-1501-11d1-8c7a-00c04fc297eb}"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_PROMPT_ON_UNPROTECT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_PROMPT_ON_PROTECT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_PROMPT_RESERVED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_PROMPT_STRONG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_PROMPT_REQUIRE_STRONG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_UI_FORBIDDEN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_LOCAL_MACHINE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_CRED_SYNC => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_AUDIT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_NO_RECOVERY => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_VERIFY_PROTECTION => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_CRED_REGENERATE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_FIRST_RESERVED_FLAGVAL => 268435455

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECT_LAST_RESERVED_FLAGVAL => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECTMEMORY_BLOCK_SIZE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECTMEMORY_SAME_PROCESS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECTMEMORY_CROSS_PROCESS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTPROTECTMEMORY_SAME_LOGON => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_MAX_KEY_NAME_LENGTH => 512

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_MAX_ALG_ID_LENGTH => 512

    /**
     * @type {String}
     */
    static MS_KEY_STORAGE_PROVIDER => "Microsoft Software Key Storage Provider"

    /**
     * @type {String}
     */
    static MS_SMART_CARD_KEY_STORAGE_PROVIDER => "Microsoft Smart Card Key Storage Provider"

    /**
     * @type {String}
     */
    static MS_PLATFORM_KEY_STORAGE_PROVIDER => "Microsoft Platform Crypto Provider"

    /**
     * @type {String}
     */
    static MS_NGC_KEY_STORAGE_PROVIDER => "Microsoft Passport Key Storage Provider"

    /**
     * @type {String}
     */
    static TPM_RSA_SRK_SEAL_KEY => "MICROSOFT_PCP_KSP_RSA_SEAL_KEY_3BD1C4BF-004E-4E2F-8A4D-0BF633DCB074"

    /**
     * @type {String}
     */
    static NCRYPT_RSA_ALGORITHM => "RSA"

    /**
     * @type {String}
     */
    static NCRYPT_RSA_SIGN_ALGORITHM => "RSA_SIGN"

    /**
     * @type {String}
     */
    static NCRYPT_DH_ALGORITHM => "DH"

    /**
     * @type {String}
     */
    static NCRYPT_DSA_ALGORITHM => "DSA"

    /**
     * @type {String}
     */
    static NCRYPT_MD2_ALGORITHM => "MD2"

    /**
     * @type {String}
     */
    static NCRYPT_MD4_ALGORITHM => "MD4"

    /**
     * @type {String}
     */
    static NCRYPT_MD5_ALGORITHM => "MD5"

    /**
     * @type {String}
     */
    static NCRYPT_SHA1_ALGORITHM => "SHA1"

    /**
     * @type {String}
     */
    static NCRYPT_SHA256_ALGORITHM => "SHA256"

    /**
     * @type {String}
     */
    static NCRYPT_SHA384_ALGORITHM => "SHA384"

    /**
     * @type {String}
     */
    static NCRYPT_SHA512_ALGORITHM => "SHA512"

    /**
     * @type {String}
     */
    static NCRYPT_ECDSA_P256_ALGORITHM => "ECDSA_P256"

    /**
     * @type {String}
     */
    static NCRYPT_ECDSA_P384_ALGORITHM => "ECDSA_P384"

    /**
     * @type {String}
     */
    static NCRYPT_ECDSA_P521_ALGORITHM => "ECDSA_P521"

    /**
     * @type {String}
     */
    static NCRYPT_ECDH_P256_ALGORITHM => "ECDH_P256"

    /**
     * @type {String}
     */
    static NCRYPT_ECDH_P384_ALGORITHM => "ECDH_P384"

    /**
     * @type {String}
     */
    static NCRYPT_ECDH_P521_ALGORITHM => "ECDH_P521"

    /**
     * @type {String}
     */
    static NCRYPT_AES_ALGORITHM => "AES"

    /**
     * @type {String}
     */
    static NCRYPT_RC2_ALGORITHM => "RC2"

    /**
     * @type {String}
     */
    static NCRYPT_3DES_ALGORITHM => "3DES"

    /**
     * @type {String}
     */
    static NCRYPT_DES_ALGORITHM => "DES"

    /**
     * @type {String}
     */
    static NCRYPT_DESX_ALGORITHM => "DESX"

    /**
     * @type {String}
     */
    static NCRYPT_3DES_112_ALGORITHM => "3DES_112"

    /**
     * @type {String}
     */
    static NCRYPT_SP800108_CTR_HMAC_ALGORITHM => "SP800_108_CTR_HMAC"

    /**
     * @type {String}
     */
    static NCRYPT_SP80056A_CONCAT_ALGORITHM => "SP800_56A_CONCAT"

    /**
     * @type {String}
     */
    static NCRYPT_PBKDF2_ALGORITHM => "PBKDF2"

    /**
     * @type {String}
     */
    static NCRYPT_CAPI_KDF_ALGORITHM => "CAPI_KDF"

    /**
     * @type {String}
     */
    static NCRYPT_ECDSA_ALGORITHM => "ECDSA"

    /**
     * @type {String}
     */
    static NCRYPT_ECDH_ALGORITHM => "ECDH"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_STORAGE_ALGORITHM => "KEY_STORAGE"

    /**
     * @type {String}
     */
    static NCRYPT_HMAC_SHA256_ALGORITHM => "HMAC-SHA256"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_KEY_DERIVATION_INTERFACE => 7

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_KEY_PROTECTION_INTERFACE => 65540

    /**
     * @type {String}
     */
    static NCRYPT_RSA_ALGORITHM_GROUP => "RSA"

    /**
     * @type {String}
     */
    static NCRYPT_DH_ALGORITHM_GROUP => "DH"

    /**
     * @type {String}
     */
    static NCRYPT_DSA_ALGORITHM_GROUP => "DSA"

    /**
     * @type {String}
     */
    static NCRYPT_ECDSA_ALGORITHM_GROUP => "ECDSA"

    /**
     * @type {String}
     */
    static NCRYPT_ECDH_ALGORITHM_GROUP => "ECDH"

    /**
     * @type {String}
     */
    static NCRYPT_AES_ALGORITHM_GROUP => "AES"

    /**
     * @type {String}
     */
    static NCRYPT_RC2_ALGORITHM_GROUP => "RC2"

    /**
     * @type {String}
     */
    static NCRYPT_DES_ALGORITHM_GROUP => "DES"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_DERIVATION_GROUP => "KEY_DERIVATION"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_EMPTY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_DATA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PROTECTION_DESCRIPTOR_STRING => 3

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PROTECTION_FLAGS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_SSL_CLIENT_RANDOM => 20

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_SSL_SERVER_RANDOM => 21

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_SSL_HIGHEST_VERSION => 22

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_SSL_CLEAR_KEY => 23

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_SSL_KEY_ARG_DATA => 24

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_SSL_SESSION_HASH => 25

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PKCS_OID => 40

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PKCS_ALG_OID => 41

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PKCS_ALG_PARAM => 42

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PKCS_ALG_ID => 43

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PKCS_ATTRS => 44

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PKCS_KEY_NAME => 45

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_PKCS_SECRET => 46

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_CERT_BLOB => 47

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_CLAIM_IDBINDING_NONCE => 48

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_CLAIM_KEYATTESTATION_NONCE => 49

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_KEY_PROPERTY_FLAGS => 50

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_ATTESTATIONSTATEMENT_BLOB => 51

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_ATTESTATION_CLAIM_TYPE => 52

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_ATTESTATION_CLAIM_CHALLENGE_REQUIRED => 53

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS => 54

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_ECC_CURVE_NAME => 60

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_ECC_PARAMETERS => 61

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_TPM_SEAL_PASSWORD => 70

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_TPM_SEAL_POLICYINFO => 71

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_TPM_SEAL_TICKET => 72

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_TPM_SEAL_NO_DA_PROTECTION => 73

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_TPM_PLATFORM_CLAIM_PCR_MASK => 80

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_TPM_PLATFORM_CLAIM_NONCE => 81

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPTBUFFER_TPM_PLATFORM_CLAIM_STATIC_CREATE => 82

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CIPHER_NO_PADDING_FLAG => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CIPHER_BLOCK_PADDING_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CIPHER_OTHER_PADDING_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PLATFORM_ATTEST_MAGIC => 1146110288

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_KEY_ATTEST_MAGIC => 1146110283

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CLAIM_AUTHORITY_ONLY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CLAIM_SUBJECT_ONLY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CLAIM_WEB_AUTH_SUBJECT_ONLY => 258

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CLAIM_AUTHORITY_AND_SUBJECT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CLAIM_VSM_KEY_ATTESTATION_STATEMENT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CLAIM_UNKNOWN => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CLAIM_PLATFORM => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ISOLATED_KEY_FLAG_CREATED_IN_ISOLATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ISOLATED_KEY_FLAG_IMPORT_ONLY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_V0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VSM_KEY_ATTESTATION_STATEMENT_V0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VSM_KEY_ATTESTATION_STATEMENT_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS_V0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_V0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_V0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PAD_CIPHER_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ATTESTATION_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SEALING_FLAG => 256

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_DO_NOT_FINALIZE_FLAG => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_EXPORT_LEGACY_FLAG => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_IGNORE_DEVICE_STATE_FLAG => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TREAT_NIST_AS_GENERIC_ECC_FLAG => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_NO_CACHED_PASSWORD => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PROTECT_TO_LOCAL_SYSTEM => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_REQUIRE_KDS_LRPC_BIND_FLAG => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PREFER_VIRTUAL_ISOLATION_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_USE_VIRTUAL_ISOLATION_FLAG => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_USE_PER_BOOT_KEY_FLAG => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_KEY_DERIVATION_OPERATION => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_AUTHORITY_KEY_FLAG => 256

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_EXTENDED_ERRORS_FLAG => 268435456

    /**
     * @type {String}
     */
    static NCRYPT_NAME_PROPERTY => "Name"

    /**
     * @type {String}
     */
    static NCRYPT_UNIQUE_NAME_PROPERTY => "Unique Name"

    /**
     * @type {String}
     */
    static NCRYPT_ALGORITHM_PROPERTY => "Algorithm Name"

    /**
     * @type {String}
     */
    static NCRYPT_LENGTH_PROPERTY => "Length"

    /**
     * @type {String}
     */
    static NCRYPT_LENGTHS_PROPERTY => "Lengths"

    /**
     * @type {String}
     */
    static NCRYPT_BLOCK_LENGTH_PROPERTY => "Block Length"

    /**
     * @type {String}
     */
    static NCRYPT_PUBLIC_LENGTH_PROPERTY => "PublicKeyLength"

    /**
     * @type {String}
     */
    static NCRYPT_SIGNATURE_LENGTH_PROPERTY => "SignatureLength"

    /**
     * @type {String}
     */
    static NCRYPT_CHAINING_MODE_PROPERTY => "Chaining Mode"

    /**
     * @type {String}
     */
    static NCRYPT_AUTH_TAG_LENGTH => "AuthTagLength"

    /**
     * @type {String}
     */
    static NCRYPT_UI_POLICY_PROPERTY => "UI Policy"

    /**
     * @type {String}
     */
    static NCRYPT_EXPORT_POLICY_PROPERTY => "Export Policy"

    /**
     * @type {String}
     */
    static NCRYPT_WINDOW_HANDLE_PROPERTY => "HWND Handle"

    /**
     * @type {String}
     */
    static NCRYPT_USE_CONTEXT_PROPERTY => "Use Context"

    /**
     * @type {String}
     */
    static NCRYPT_IMPL_TYPE_PROPERTY => "Impl Type"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_USAGE_PROPERTY => "Key Usage"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_TYPE_PROPERTY => "Key Type"

    /**
     * @type {String}
     */
    static NCRYPT_VERSION_PROPERTY => "Version"

    /**
     * @type {String}
     */
    static NCRYPT_SECURITY_DESCR_SUPPORT_PROPERTY => "Security Descr Support"

    /**
     * @type {String}
     */
    static NCRYPT_SECURITY_DESCR_PROPERTY => "Security Descr"

    /**
     * @type {String}
     */
    static NCRYPT_USE_COUNT_ENABLED_PROPERTY => "Enabled Use Count"

    /**
     * @type {String}
     */
    static NCRYPT_USE_COUNT_PROPERTY => "Use Count"

    /**
     * @type {String}
     */
    static NCRYPT_LAST_MODIFIED_PROPERTY => "Modified"

    /**
     * @type {String}
     */
    static NCRYPT_MAX_NAME_LENGTH_PROPERTY => "Max Name Length"

    /**
     * @type {String}
     */
    static NCRYPT_ALGORITHM_GROUP_PROPERTY => "Algorithm Group"

    /**
     * @type {String}
     */
    static NCRYPT_DH_PARAMETERS_PROPERTY => "DHParameters"

    /**
     * @type {String}
     */
    static NCRYPT_ECC_PARAMETERS_PROPERTY => "ECCParameters"

    /**
     * @type {String}
     */
    static NCRYPT_ECC_CURVE_NAME_PROPERTY => "ECCCurveName"

    /**
     * @type {String}
     */
    static NCRYPT_ECC_CURVE_NAME_LIST_PROPERTY => "ECCCurveNameList"

    /**
     * @type {String}
     */
    static NCRYPT_USE_VIRTUAL_ISOLATION_PROPERTY => "Virtual Iso"

    /**
     * @type {String}
     */
    static NCRYPT_USE_PER_BOOT_KEY_PROPERTY => "Per Boot Key"

    /**
     * @type {String}
     */
    static NCRYPT_PROVIDER_HANDLE_PROPERTY => "Provider Handle"

    /**
     * @type {String}
     */
    static NCRYPT_PIN_PROPERTY => "SmartCardPin"

    /**
     * @type {String}
     */
    static NCRYPT_READER_PROPERTY => "SmartCardReader"

    /**
     * @type {String}
     */
    static NCRYPT_SMARTCARD_GUID_PROPERTY => "SmartCardGuid"

    /**
     * @type {String}
     */
    static NCRYPT_CERTIFICATE_PROPERTY => "SmartCardKeyCertificate"

    /**
     * @type {String}
     */
    static NCRYPT_PIN_PROMPT_PROPERTY => "SmartCardPinPrompt"

    /**
     * @type {String}
     */
    static NCRYPT_USER_CERTSTORE_PROPERTY => "SmartCardUserCertStore"

    /**
     * @type {String}
     */
    static NCRYPT_ROOT_CERTSTORE_PROPERTY => "SmartcardRootCertStore"

    /**
     * @type {String}
     */
    static NCRYPT_SECURE_PIN_PROPERTY => "SmartCardSecurePin"

    /**
     * @type {String}
     */
    static NCRYPT_ASSOCIATED_ECDH_KEY => "SmartCardAssociatedECDHKey"

    /**
     * @type {String}
     */
    static NCRYPT_SCARD_PIN_ID => "SmartCardPinId"

    /**
     * @type {String}
     */
    static NCRYPT_SCARD_PIN_INFO => "SmartCardPinInfo"

    /**
     * @type {String}
     */
    static NCRYPT_READER_ICON_PROPERTY => "SmartCardReaderIcon"

    /**
     * @type {String}
     */
    static NCRYPT_KDF_SECRET_VALUE => "KDFKeySecret"

    /**
     * @type {String}
     */
    static NCRYPT_DISMISS_UI_TIMEOUT_SEC_PROPERTY => "SmartCardDismissUITimeoutSeconds"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PLATFORM_TYPE_PROPERTY => "PCP_PLATFORM_TYPE"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PROVIDER_VERSION_PROPERTY => "PCP_PROVIDER_VERSION"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_EKPUB_PROPERTY => "PCP_EKPUB"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_EKCERT_PROPERTY => "PCP_EKCERT"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_EKNVCERT_PROPERTY => "PCP_EKNVCERT"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_RSA_EKPUB_PROPERTY => "PCP_RSA_EKPUB"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_RSA_EKCERT_PROPERTY => "PCP_RSA_EKCERT"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_RSA_EKNVCERT_PROPERTY => "PCP_RSA_EKNVCERT"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_ECC_EKPUB_PROPERTY => "PCP_ECC_EKPUB"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_ECC_EKCERT_PROPERTY => "PCP_ECC_EKCERT"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_ECC_EKNVCERT_PROPERTY => "PCP_ECC_EKNVCERT"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_SRKPUB_PROPERTY => "PCP_SRKPUB"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PCRTABLE_PROPERTY => "PCP_PCRTABLE"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_CHANGEPASSWORD_PROPERTY => "PCP_CHANGEPASSWORD"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PASSWORD_REQUIRED_PROPERTY => "PCP_PASSWORD_REQUIRED"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_USAGEAUTH_PROPERTY => "PCP_USAGEAUTH"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_MIGRATIONPASSWORD_PROPERTY => "PCP_MIGRATIONPASSWORD"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_EXPORT_ALLOWED_PROPERTY => "PCP_EXPORT_ALLOWED"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_STORAGEPARENT_PROPERTY => "PCP_STORAGEPARENT"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PROVIDERHANDLE_PROPERTY => "PCP_PROVIDERMHANDLE"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PLATFORMHANDLE_PROPERTY => "PCP_PLATFORMHANDLE"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PLATFORM_BINDING_PCRMASK_PROPERTY => "PCP_PLATFORM_BINDING_PCRMASK"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PLATFORM_BINDING_PCRDIGESTLIST_PROPERTY => "PCP_PLATFORM_BINDING_PCRDIGESTLIST"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PLATFORM_BINDING_PCRDIGEST_PROPERTY => "PCP_PLATFORM_BINDING_PCRDIGEST"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_KEY_USAGE_POLICY_PROPERTY => "PCP_KEY_USAGE_POLICY"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_RSA_SCHEME_PROPERTY => "PCP_RSA_SCHEME"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM12_IDBINDING_PROPERTY => "PCP_TPM12_IDBINDING"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM12_IDBINDING_DYNAMIC_PROPERTY => "PCP_TPM12_IDBINDING_DYNAMIC"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM12_IDACTIVATION_PROPERTY => "PCP_TPM12_IDACTIVATION"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_KEYATTESTATION_PROPERTY => "PCP_TPM12_KEYATTESTATION"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_ALTERNATE_KEY_STORAGE_LOCATION_PROPERTY => "PCP_ALTERNATE_KEY_STORAGE_LOCATION"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PLATFORM_BINDING_PCRALGID_PROPERTY => "PCP_PLATFORM_BINDING_PCRALGID"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_HMAC_AUTH_POLICYREF => "PCP_HMAC_AUTH_POLICYREF"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_HMAC_AUTH_POLICYINFO => "PCP_HMAC_AUTH_POLICYINFO"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_HMAC_AUTH_NONCE => "PCP_HMAC_AUTH_NONCE"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_HMAC_AUTH_SIGNATURE => "PCP_HMAC_AUTH_SIGNATURE"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_HMAC_AUTH_TICKET => "PCP_HMAC_AUTH_TICKET"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_NO_DA_PROTECTION_PROPERTY => "PCP_NO_DA_PROTECTION"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM_MANUFACTURER_ID_PROPERTY => "PCP_TPM_MANUFACTURER_ID"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM_FW_VERSION_PROPERTY => "PCP_TPM_FW_VERSION"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM2BNAME_PROPERTY => "PCP_TPM2BNAME"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM_VERSION_PROPERTY => "PCP_TPM_VERSION"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_RAW_POLICYDIGEST_PROPERTY => "PCP_RAW_POLICYDIGEST"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_KEY_CREATIONHASH_PROPERTY => "PCP_KEY_CREATIONHASH"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_KEY_CREATIONTICKET_PROPERTY => "PCP_KEY_CREATIONTICKET"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_RSA_SCHEME_HASH_ALG_PROPERTY => "PCP_RSA_SCHEME_HASH_ALG"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM_IFX_RSA_KEYGEN_PROHIBITED_PROPERTY => "PCP_TPM_IFX_RSA_KEYGEN_PROHIBITED"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_TPM_IFX_RSA_KEYGEN_VULNERABILITY_PROPERTY => "PCP_TPM_IFX_RSA_KEYGEN_VULNERABILITY"

    /**
     * @type {Integer (UInt32)}
     */
    static IFX_RSA_KEYGEN_VUL_NOT_AFFECTED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_2 => 2

    /**
     * @type {String}
     */
    static NCRYPT_PCP_SESSIONID_PROPERTY => "PCP_SESSIONID"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PSS_SALT_SIZE_PROPERTY => "PSS Salt Size"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TPM_PSS_SALT_SIZE_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TPM_PSS_SALT_SIZE_MAXIMUM => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TPM_PSS_SALT_SIZE_HASHSIZE => 2

    /**
     * @type {String}
     */
    static NCRYPT_PCP_INTERMEDIATE_CA_EKCERT_PROPERTY => "PCP_INTERMEDIATE_CA_EKCERT"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_PCRTABLE_ALGORITHM_PROPERTY => "PCP_PCRTABLE_ALGORITHM"

    /**
     * @type {String}
     */
    static NCRYPT_PCP_SYMMETRIC_KEYBITS_PROPERTY => "PCP_SYMMETRIC_KEYBITS"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TPM_PAD_PSS_IGNORE_SALT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TPM12_PROVIDER => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PCP_SIGNATURE_KEY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PCP_ENCRYPTION_KEY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PCP_STORAGE_KEY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PCP_IDENTITY_KEY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PCP_HMACVERIFICATION_KEY => 16

    /**
     * @type {String}
     */
    static NCRYPT_SCARD_NGC_KEY_NAME => "SmartCardNgcKeyName"

    /**
     * @type {String}
     */
    static NCRYPT_INITIALIZATION_VECTOR => "IV"

    /**
     * @type {String}
     */
    static NCRYPT_CHANGEPASSWORD_PROPERTY => "PCP_CHANGEPASSWORD"

    /**
     * @type {String}
     */
    static NCRYPT_ALTERNATE_KEY_STORAGE_LOCATION_PROPERTY => "PCP_ALTERNATE_KEY_STORAGE_LOCATION"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_ACCESS_POLICY_PROPERTY => "Key Access Policy"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_MAX_PROPERTY_NAME => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_MAX_PROPERTY_DATA => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_EXPORT_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_ARCHIVING_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_PLAINTEXT_ARCHIVING_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_IMPL_HARDWARE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_IMPL_SOFTWARE_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_IMPL_REMOVABLE_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_IMPL_HARDWARE_RNG_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_IMPL_VIRTUAL_ISOLATION_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_DECRYPT_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_SIGNING_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_KEY_AGREEMENT_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_KEY_IMPORT_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_ALL_USAGES => 16777215

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_UI_PROTECT_KEY_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_UI_FORCE_HIGH_PROTECTION_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_UI_FINGERPRINT_PROTECTION_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_UI_APPCONTAINER_ACCESS_MEDIUM_FLAG => 8

    /**
     * @type {String}
     */
    static NCRYPT_PIN_CACHE_FREE_APPLICATION_TICKET_PROPERTY => "PinCacheFreeApplicationTicket"

    /**
     * @type {String}
     */
    static NCRYPT_PIN_CACHE_FLAGS_PROPERTY => "PinCacheFlags"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PIN_CACHE_DISABLE_DPL_FLAG => 1

    /**
     * @type {String}
     */
    static NCRYPT_PIN_CACHE_APPLICATION_TICKET_PROPERTY => "PinCacheApplicationTicket"

    /**
     * @type {String}
     */
    static NCRYPT_PIN_CACHE_APPLICATION_IMAGE_PROPERTY => "PinCacheApplicationImage"

    /**
     * @type {String}
     */
    static NCRYPT_PIN_CACHE_APPLICATION_STATUS_PROPERTY => "PinCacheApplicationStatus"

    /**
     * @type {String}
     */
    static NCRYPT_PIN_CACHE_PIN_PROPERTY => "PinCachePin"

    /**
     * @type {String}
     */
    static NCRYPT_PIN_CACHE_IS_GESTURE_REQUIRED_PROPERTY => "PinCacheIsGestureRequired"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PIN_CACHE_REQUIRE_GESTURE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PIN_CACHE_APPLICATION_TICKET_BYTE_LENGTH => 90

    /**
     * @type {String}
     */
    static NCRYPT_PIN_CACHE_CLEAR_PROPERTY => "PinCacheClear"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PIN_CACHE_CLEAR_FOR_CALLING_PROCESS_OPTION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_KEY_ACCESS_POLICY_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_ALLOW_SILENT_KEY_ACCESS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_CIPHER_KEY_BLOB_MAGIC => 1380470851

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_KDF_KEY_BLOB_MAGIC => 826688587

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PROTECTED_KEY_BLOB_MAGIC => 1263817296

    /**
     * @type {String}
     */
    static NCRYPT_CIPHER_KEY_BLOB => "CipherKeyBlob"

    /**
     * @type {String}
     */
    static NCRYPT_KDF_KEY_BLOB => "KDFKeyBlob"

    /**
     * @type {String}
     */
    static NCRYPT_PROTECTED_KEY_BLOB => "ProtectedKeyBlob"

    /**
     * @type {String}
     */
    static NCRYPT_TPM_LOADABLE_KEY_BLOB => "PcpTpmProtectedKeyBlob"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_TPM_LOADABLE_KEY_BLOB_MAGIC => 1297371211

    /**
     * @type {String}
     */
    static NCRYPT_PKCS7_ENVELOPE_BLOB => "PKCS7_ENVELOPE"

    /**
     * @type {String}
     */
    static NCRYPT_PKCS8_PRIVATE_KEY_BLOB => "PKCS8_PRIVATEKEY"

    /**
     * @type {String}
     */
    static NCRYPT_OPAQUETRANSPORT_BLOB => "OpaqueTransport"

    /**
     * @type {String}
     */
    static NCRYPT_ISOLATED_KEY_ENVELOPE_BLOB => "ISOLATED_KEY_ENVELOPE"

    /**
     * @type {String}
     */
    static NCRYPT_DESCR_DELIMITER_OR => "OR"

    /**
     * @type {String}
     */
    static NCRYPT_DESCR_DELIMITER_AND => "AND"

    /**
     * @type {String}
     */
    static NCRYPT_DESCR_EQUAL => "="

    /**
     * @type {String}
     */
    static MS_KEY_PROTECTION_PROVIDER => "Microsoft Key Protection Provider"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_ALGORITHM_SID => "SID"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_ALGORITHM_LOCAL => "LOCAL"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_LOCAL_LOGON => "logon"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_LOCAL_USER => "user"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_LOCAL_MACHINE => "machine"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_ALGORITHM_SDDL => "SDDL"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_ALGORITHM_WEBCREDENTIALS => "WEBCREDENTIALS"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_ALGORITHM_LOCKEDCREDENTIALS => "LOCKEDCREDENTIALS"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_ALGORITHM_CERTIFICATE => "CERTIFICATE"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_CERT_HASHID => "HashId"

    /**
     * @type {String}
     */
    static NCRYPT_KEY_PROTECTION_CERT_CERTBLOB => "CertBlob"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_NAMED_DESCRIPTOR_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_PROTECTION_INFO_TYPE_DESCRIPTOR_STRING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_CLASS_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_CLASS_SIGNATURE => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_CLASS_MSG_ENCRYPT => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_CLASS_DATA_ENCRYPT => 24576

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_CLASS_HASH => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_CLASS_KEY_EXCHANGE => 40960

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_CLASS_ALL => 57344

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_DSS => 512

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_RSA => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_BLOCK => 1536

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_STREAM => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_DH => 2560

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_SECURECHANNEL => 3072

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_ECDH => 3584

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_TYPE_THIRDPARTY => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_THIRDPARTY_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RSA_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RSA_PKCS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RSA_MSATWORK => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RSA_ENTRUST => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RSA_PGP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_DSS_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_DSS_PKCS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_DSS_DMS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_ECDSA => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_DES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_3DES => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_DESX => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_IDEA => 5

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_CAST => 6

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SAFERSK64 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SAFERSK128 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_3DES_112 => 9

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_CYLINK_MEK => 12

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RC5 => 13

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_AES_128 => 14

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_AES_192 => 15

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_AES_256 => 16

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_AES => 17

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SKIPJACK => 10

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_TEK => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_CBCI => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_CFBP => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_OFBP => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_CBCOFM => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_CBCOFMI => 10

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RC2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RC4 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SEAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_DH_SANDF => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_DH_EPHEM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_AGREED_KEY_ANY => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_KEA => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_ECDH => 5

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_ECDH_EPHEM => 6

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_MD2 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_MD4 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_MD5 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SHA => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SHA1 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_MAC => 5

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RIPEMD => 6

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_RIPEMD160 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SSL3SHAMD5 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_HMAC => 9

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_TLS1PRF => 10

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_HASH_REPLACE_OWF => 11

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SHA_256 => 12

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SHA_384 => 13

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SHA_512 => 14

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SSL3_MASTER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SCHANNEL_MASTER_HASH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SCHANNEL_MAC_KEY => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_PCT1_MASTER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SSL2_MASTER => 5

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_TLS1_MASTER => 6

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_SCHANNEL_ENC_KEY => 7

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_ECMQV => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ALG_SID_EXAMPLE => 80

    /**
     * @type {Integer (UInt32)}
     */
    static SIGNATURE_RESOURCE_NUMBER => 666

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFYCONTEXT => 4026531840

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_NEWKEYSET => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DELETEKEYSET => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SILENT => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DEFAULT_CONTAINER_OPTIONAL => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_UPDATE_KEY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_USER_PROTECTED_STRONG => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static RSA1024BIT_KEY => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SERVER => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static KEY_LENGTH_MASK => 4294901760

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECRYPT_RSA_NO_PADDING_CHECK => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SECRETDIGEST => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OWF_REPL_LM_HASH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_LITTLE_ENDIAN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_NOHASHOID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_TYPE2_FORMAT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_X931_FORMAT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MACHINE_DEFAULT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_USER_DEFAULT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DELETE_DEFAULT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SIMPLEBLOB => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PUBLICKEYBLOB => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PRIVATEKEYBLOB => 7

    /**
     * @type {Integer (UInt32)}
     */
    static PLAINTEXTKEYBLOB => 8

    /**
     * @type {Integer (UInt32)}
     */
    static OPAQUEKEYBLOB => 9

    /**
     * @type {Integer (UInt32)}
     */
    static PUBLICKEYBLOBEX => 10

    /**
     * @type {Integer (UInt32)}
     */
    static SYMMETRICWRAPKEYBLOB => 11

    /**
     * @type {Integer (UInt32)}
     */
    static KEYSTATEBLOB => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_USERDATA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static KP_IV => 1

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PADDING => 3

    /**
     * @type {Integer (UInt32)}
     */
    static KP_MODE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static KP_MODE_BITS => 5

    /**
     * @type {Integer (UInt32)}
     */
    static KP_P => 11

    /**
     * @type {Integer (UInt32)}
     */
    static KP_G => 12

    /**
     * @type {Integer (UInt32)}
     */
    static KP_Q => 13

    /**
     * @type {Integer (UInt32)}
     */
    static KP_X => 14

    /**
     * @type {Integer (UInt32)}
     */
    static KP_Y => 15

    /**
     * @type {Integer (UInt32)}
     */
    static KP_RA => 16

    /**
     * @type {Integer (UInt32)}
     */
    static KP_RB => 17

    /**
     * @type {Integer (UInt32)}
     */
    static KP_INFO => 18

    /**
     * @type {Integer (UInt32)}
     */
    static KP_EFFECTIVE_KEYLEN => 19

    /**
     * @type {Integer (UInt32)}
     */
    static KP_SCHANNEL_ALG => 20

    /**
     * @type {Integer (UInt32)}
     */
    static KP_CLIENT_RANDOM => 21

    /**
     * @type {Integer (UInt32)}
     */
    static KP_SERVER_RANDOM => 22

    /**
     * @type {Integer (UInt32)}
     */
    static KP_RP => 23

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PRECOMP_MD5 => 24

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PRECOMP_SHA => 25

    /**
     * @type {Integer (UInt32)}
     */
    static KP_CLEAR_KEY => 27

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PUB_EX_LEN => 28

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PUB_EX_VAL => 29

    /**
     * @type {Integer (UInt32)}
     */
    static KP_KEYVAL => 30

    /**
     * @type {Integer (UInt32)}
     */
    static KP_ADMIN_PIN => 31

    /**
     * @type {Integer (UInt32)}
     */
    static KP_KEYEXCHANGE_PIN => 32

    /**
     * @type {Integer (UInt32)}
     */
    static KP_SIGNATURE_PIN => 33

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PREHASH => 34

    /**
     * @type {Integer (UInt32)}
     */
    static KP_ROUNDS => 35

    /**
     * @type {Integer (UInt32)}
     */
    static KP_OAEP_PARAMS => 36

    /**
     * @type {Integer (UInt32)}
     */
    static KP_CMS_KEY_INFO => 37

    /**
     * @type {Integer (UInt32)}
     */
    static KP_CMS_DH_KEY_INFO => 38

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PUB_PARAMS => 39

    /**
     * @type {Integer (UInt32)}
     */
    static KP_VERIFY_PARAMS => 40

    /**
     * @type {Integer (UInt32)}
     */
    static KP_HIGHEST_VERSION => 41

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PIN_ID => 43

    /**
     * @type {Integer (UInt32)}
     */
    static KP_PIN_INFO => 44

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS5_PADDING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RANDOM_PADDING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ZERO_PADDING => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_CBC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_ECB => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_OFB => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_CFB => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MODE_CTS => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ENCRYPT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECRYPT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_EXPORT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_READ => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_WRITE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MAC => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_EXPORT_KEY => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_IMPORT_KEY => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ARCHIVE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static HP_ALGID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static HP_HASHSIZE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static HP_TLS1PRF_LABEL => 6

    /**
     * @type {Integer (UInt32)}
     */
    static HP_TLS1PRF_SEED => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FAILED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SUCCEED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PP_ENUMALGS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PP_ENUMCONTAINERS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PP_IMPTYPE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PP_NAME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PP_VERSION => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PP_CONTAINER => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PP_CHANGE_PASSWORD => 7

    /**
     * @type {Integer (UInt32)}
     */
    static PP_CERTCHAIN => 9

    /**
     * @type {Integer (UInt32)}
     */
    static PP_KEY_TYPE_SUBTYPE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static PP_PROVTYPE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static PP_KEYSTORAGE => 17

    /**
     * @type {Integer (UInt32)}
     */
    static PP_APPLI_CERT => 18

    /**
     * @type {Integer (UInt32)}
     */
    static PP_SYM_KEYSIZE => 19

    /**
     * @type {Integer (UInt32)}
     */
    static PP_SESSION_KEYSIZE => 20

    /**
     * @type {Integer (UInt32)}
     */
    static PP_ENUMALGS_EX => 22

    /**
     * @type {Integer (UInt32)}
     */
    static PP_ENUMMANDROOTS => 25

    /**
     * @type {Integer (UInt32)}
     */
    static PP_ENUMELECTROOTS => 26

    /**
     * @type {Integer (UInt32)}
     */
    static PP_KEYSET_TYPE => 27

    /**
     * @type {Integer (UInt32)}
     */
    static PP_ADMIN_PIN => 31

    /**
     * @type {Integer (UInt32)}
     */
    static PP_SIG_KEYSIZE_INC => 34

    /**
     * @type {Integer (UInt32)}
     */
    static PP_KEYX_KEYSIZE_INC => 35

    /**
     * @type {Integer (UInt32)}
     */
    static PP_UNIQUE_CONTAINER => 36

    /**
     * @type {Integer (UInt32)}
     */
    static PP_SGC_INFO => 37

    /**
     * @type {Integer (UInt32)}
     */
    static PP_KEYSPEC => 39

    /**
     * @type {Integer (UInt32)}
     */
    static PP_ENUMEX_SIGNING_PROT => 40

    /**
     * @type {Integer (UInt32)}
     */
    static PP_CRYPT_COUNT_KEY_USE => 41

    /**
     * @type {Integer (UInt32)}
     */
    static PP_SMARTCARD_GUID => 45

    /**
     * @type {Integer (UInt32)}
     */
    static PP_SMARTCARD_READER_ICON => 47

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FIRST => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_NEXT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SGC_ENUM => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_IMPL_HARDWARE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_IMPL_SOFTWARE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_IMPL_MIXED => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_IMPL_UNKNOWN => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_IMPL_REMOVABLE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SEC_DESCR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_PSTORE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_UI_PROMPT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FLAG_PCT1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FLAG_SSL2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FLAG_SSL3 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FLAG_TLS1 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FLAG_IPSEC => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FLAG_SIGNING => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SGC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FASTSGC => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PP_CONTEXT_INFO => 11

    /**
     * @type {Integer (UInt32)}
     */
    static PP_DISMISS_PIN_UI_SEC => 49

    /**
     * @type {Integer (UInt32)}
     */
    static PP_IS_PFX_EPHEMERAL => 50

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_RSA_FULL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_RSA_SIG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_DSS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_FORTEZZA => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_MS_EXCHANGE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_SSL => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_RSA_SCHANNEL => 12

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_DSS_DH => 13

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_EC_ECDSA_SIG => 14

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_EC_ECNRA_SIG => 15

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_EC_ECDSA_FULL => 16

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_EC_ECNRA_FULL => 17

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_DH_SCHANNEL => 18

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_SPYRUS_LYNKS => 20

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_RNG => 21

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_INTEL_SEC => 22

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_REPLACE_OWF => 23

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_RSA_AES => 24

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_STT_MER => 7

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_STT_ACQ => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_STT_BRND => 9

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_STT_ROOT => 10

    /**
     * @type {Integer (UInt32)}
     */
    static PROV_STT_ISS => 11

    /**
     * @type {String}
     */
    static MS_DEF_PROV_A => "Microsoft Base Cryptographic Provider v1.0"

    /**
     * @type {String}
     */
    static MS_DEF_PROV_W => "Microsoft Base Cryptographic Provider v1.0"

    /**
     * @type {String}
     */
    static MS_DEF_PROV => "Microsoft Base Cryptographic Provider v1.0"

    /**
     * @type {String}
     */
    static MS_ENHANCED_PROV_A => "Microsoft Enhanced Cryptographic Provider v1.0"

    /**
     * @type {String}
     */
    static MS_ENHANCED_PROV_W => "Microsoft Enhanced Cryptographic Provider v1.0"

    /**
     * @type {String}
     */
    static MS_ENHANCED_PROV => "Microsoft Enhanced Cryptographic Provider v1.0"

    /**
     * @type {String}
     */
    static MS_STRONG_PROV_A => "Microsoft Strong Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_STRONG_PROV_W => "Microsoft Strong Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_STRONG_PROV => "Microsoft Strong Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_RSA_SIG_PROV_A => "Microsoft RSA Signature Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_RSA_SIG_PROV_W => "Microsoft RSA Signature Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_RSA_SIG_PROV => "Microsoft RSA Signature Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_RSA_SCHANNEL_PROV_A => "Microsoft RSA SChannel Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_RSA_SCHANNEL_PROV_W => "Microsoft RSA SChannel Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_RSA_SCHANNEL_PROV => "Microsoft RSA SChannel Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DSS_PROV_A => "Microsoft Base DSS Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DSS_PROV_W => "Microsoft Base DSS Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DSS_PROV => "Microsoft Base DSS Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DSS_DH_PROV_A => "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DSS_DH_PROV_W => "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DSS_DH_PROV => "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_ENH_DSS_DH_PROV_A => "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_ENH_DSS_DH_PROV_W => "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_ENH_DSS_DH_PROV => "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DH_SCHANNEL_PROV_A => "Microsoft DH SChannel Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DH_SCHANNEL_PROV_W => "Microsoft DH SChannel Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_DEF_DH_SCHANNEL_PROV => "Microsoft DH SChannel Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_SCARD_PROV_A => "Microsoft Base Smart Card Crypto Provider"

    /**
     * @type {String}
     */
    static MS_SCARD_PROV_W => "Microsoft Base Smart Card Crypto Provider"

    /**
     * @type {String}
     */
    static MS_SCARD_PROV => "Microsoft Base Smart Card Crypto Provider"

    /**
     * @type {String}
     */
    static MS_ENH_RSA_AES_PROV_A => "Microsoft Enhanced RSA and AES Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_ENH_RSA_AES_PROV_W => "Microsoft Enhanced RSA and AES Cryptographic Provider"

    /**
     * @type {String}
     */
    static MS_ENH_RSA_AES_PROV_XP_A => "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)"

    /**
     * @type {String}
     */
    static MS_ENH_RSA_AES_PROV_XP_W => "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)"

    /**
     * @type {String}
     */
    static MS_ENH_RSA_AES_PROV_XP => "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)"

    /**
     * @type {String}
     */
    static MS_ENH_RSA_AES_PROV => "Microsoft Enhanced RSA and AES Cryptographic Provider"

    /**
     * @type {Integer (UInt32)}
     */
    static MAXUIDLEN => 64

    /**
     * @type {String}
     */
    static EXPO_OFFLOAD_REG_VALUE => "ExpoOffload"

    /**
     * @type {String}
     */
    static EXPO_OFFLOAD_FUNC_NAME => "OffloadModExpo"

    /**
     * @type {String}
     */
    static szKEY_CRYPTOAPI_PRIVATE_KEY_OPTIONS => "Software\Policies\Microsoft\Cryptography"

    /**
     * @type {String}
     */
    static szKEY_CACHE_ENABLED => "CachePrivateKeys"

    /**
     * @type {String}
     */
    static szKEY_CACHE_SECONDS => "PrivateKeyLifetimeSeconds"

    /**
     * @type {String}
     */
    static szPRIV_KEY_CACHE_MAX_ITEMS => "PrivKeyCacheMaxItems"

    /**
     * @type {Integer (UInt32)}
     */
    static cPRIV_KEY_CACHE_MAX_ITEMS_DEFAULT => 20

    /**
     * @type {String}
     */
    static szPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS => "PrivKeyCachePurgeIntervalSeconds"

    /**
     * @type {Integer (UInt32)}
     */
    static cPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS_DEFAULT => 86400

    /**
     * @type {Integer (UInt32)}
     */
    static CUR_BLOB_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SCHANNEL_MAC_KEY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SCHANNEL_ENC_KEY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static INTERNATIONAL_USAGE => 1

    /**
     * @type {String}
     */
    static szOID_RSA => "1.2.840.113549"

    /**
     * @type {String}
     */
    static szOID_PKCS => "1.2.840.113549.1"

    /**
     * @type {String}
     */
    static szOID_RSA_HASH => "1.2.840.113549.2"

    /**
     * @type {String}
     */
    static szOID_RSA_ENCRYPT => "1.2.840.113549.3"

    /**
     * @type {String}
     */
    static szOID_PKCS_1 => "1.2.840.113549.1.1"

    /**
     * @type {String}
     */
    static szOID_PKCS_2 => "1.2.840.113549.1.2"

    /**
     * @type {String}
     */
    static szOID_PKCS_3 => "1.2.840.113549.1.3"

    /**
     * @type {String}
     */
    static szOID_PKCS_4 => "1.2.840.113549.1.4"

    /**
     * @type {String}
     */
    static szOID_PKCS_5 => "1.2.840.113549.1.5"

    /**
     * @type {String}
     */
    static szOID_PKCS_6 => "1.2.840.113549.1.6"

    /**
     * @type {String}
     */
    static szOID_PKCS_7 => "1.2.840.113549.1.7"

    /**
     * @type {String}
     */
    static szOID_PKCS_8 => "1.2.840.113549.1.8"

    /**
     * @type {String}
     */
    static szOID_PKCS_9 => "1.2.840.113549.1.9"

    /**
     * @type {String}
     */
    static szOID_PKCS_10 => "1.2.840.113549.1.10"

    /**
     * @type {String}
     */
    static szOID_PKCS_12 => "1.2.840.113549.1.12"

    /**
     * @type {String}
     */
    static szOID_RSA_RSA => "1.2.840.113549.1.1.1"

    /**
     * @type {String}
     */
    static szOID_RSA_MD2RSA => "1.2.840.113549.1.1.2"

    /**
     * @type {String}
     */
    static szOID_RSA_MD4RSA => "1.2.840.113549.1.1.3"

    /**
     * @type {String}
     */
    static szOID_RSA_MD5RSA => "1.2.840.113549.1.1.4"

    /**
     * @type {String}
     */
    static szOID_RSA_SHA1RSA => "1.2.840.113549.1.1.5"

    /**
     * @type {String}
     */
    static szOID_RSA_SETOAEP_RSA => "1.2.840.113549.1.1.6"

    /**
     * @type {String}
     */
    static szOID_RSAES_OAEP => "1.2.840.113549.1.1.7"

    /**
     * @type {String}
     */
    static szOID_RSA_MGF1 => "1.2.840.113549.1.1.8"

    /**
     * @type {String}
     */
    static szOID_RSA_PSPECIFIED => "1.2.840.113549.1.1.9"

    /**
     * @type {String}
     */
    static szOID_RSA_SSA_PSS => "1.2.840.113549.1.1.10"

    /**
     * @type {String}
     */
    static szOID_RSA_SHA256RSA => "1.2.840.113549.1.1.11"

    /**
     * @type {String}
     */
    static szOID_RSA_SHA384RSA => "1.2.840.113549.1.1.12"

    /**
     * @type {String}
     */
    static szOID_RSA_SHA512RSA => "1.2.840.113549.1.1.13"

    /**
     * @type {String}
     */
    static szOID_RSA_DH => "1.2.840.113549.1.3.1"

    /**
     * @type {String}
     */
    static szOID_RSA_data => "1.2.840.113549.1.7.1"

    /**
     * @type {String}
     */
    static szOID_RSA_signedData => "1.2.840.113549.1.7.2"

    /**
     * @type {String}
     */
    static szOID_RSA_envelopedData => "1.2.840.113549.1.7.3"

    /**
     * @type {String}
     */
    static szOID_RSA_signEnvData => "1.2.840.113549.1.7.4"

    /**
     * @type {String}
     */
    static szOID_RSA_digestedData => "1.2.840.113549.1.7.5"

    /**
     * @type {String}
     */
    static szOID_RSA_hashedData => "1.2.840.113549.1.7.5"

    /**
     * @type {String}
     */
    static szOID_RSA_encryptedData => "1.2.840.113549.1.7.6"

    /**
     * @type {String}
     */
    static szOID_RSA_emailAddr => "1.2.840.113549.1.9.1"

    /**
     * @type {String}
     */
    static szOID_RSA_unstructName => "1.2.840.113549.1.9.2"

    /**
     * @type {String}
     */
    static szOID_RSA_contentType => "1.2.840.113549.1.9.3"

    /**
     * @type {String}
     */
    static szOID_RSA_messageDigest => "1.2.840.113549.1.9.4"

    /**
     * @type {String}
     */
    static szOID_RSA_signingTime => "1.2.840.113549.1.9.5"

    /**
     * @type {String}
     */
    static szOID_RSA_counterSign => "1.2.840.113549.1.9.6"

    /**
     * @type {String}
     */
    static szOID_RSA_challengePwd => "1.2.840.113549.1.9.7"

    /**
     * @type {String}
     */
    static szOID_RSA_unstructAddr => "1.2.840.113549.1.9.8"

    /**
     * @type {String}
     */
    static szOID_RSA_extCertAttrs => "1.2.840.113549.1.9.9"

    /**
     * @type {String}
     */
    static szOID_RSA_certExtensions => "1.2.840.113549.1.9.14"

    /**
     * @type {String}
     */
    static szOID_RSA_SMIMECapabilities => "1.2.840.113549.1.9.15"

    /**
     * @type {String}
     */
    static szOID_RSA_preferSignedData => "1.2.840.113549.1.9.15.1"

    /**
     * @type {String}
     */
    static szOID_TIMESTAMP_TOKEN => "1.2.840.113549.1.9.16.1.4"

    /**
     * @type {String}
     */
    static szOID_RFC3161_counterSign => "1.3.6.1.4.1.311.3.3.1"

    /**
     * @type {String}
     */
    static szOID_RFC3161v21_counterSign => "1.3.6.1.4.1.311.3.3.2"

    /**
     * @type {String}
     */
    static szOID_RFC3161v21_thumbprints => "1.3.6.1.4.1.311.3.3.3"

    /**
     * @type {String}
     */
    static szOID_RSA_SMIMEalg => "1.2.840.113549.1.9.16.3"

    /**
     * @type {String}
     */
    static szOID_RSA_SMIMEalgESDH => "1.2.840.113549.1.9.16.3.5"

    /**
     * @type {String}
     */
    static szOID_RSA_SMIMEalgCMS3DESwrap => "1.2.840.113549.1.9.16.3.6"

    /**
     * @type {String}
     */
    static szOID_RSA_SMIMEalgCMSRC2wrap => "1.2.840.113549.1.9.16.3.7"

    /**
     * @type {String}
     */
    static szOID_RSA_MD2 => "1.2.840.113549.2.2"

    /**
     * @type {String}
     */
    static szOID_RSA_MD4 => "1.2.840.113549.2.4"

    /**
     * @type {String}
     */
    static szOID_RSA_MD5 => "1.2.840.113549.2.5"

    /**
     * @type {String}
     */
    static szOID_RSA_RC2CBC => "1.2.840.113549.3.2"

    /**
     * @type {String}
     */
    static szOID_RSA_RC4 => "1.2.840.113549.3.4"

    /**
     * @type {String}
     */
    static szOID_RSA_DES_EDE3_CBC => "1.2.840.113549.3.7"

    /**
     * @type {String}
     */
    static szOID_RSA_RC5_CBCPad => "1.2.840.113549.3.9"

    /**
     * @type {String}
     */
    static szOID_ANSI_X942 => "1.2.840.10046"

    /**
     * @type {String}
     */
    static szOID_ANSI_X942_DH => "1.2.840.10046.2.1"

    /**
     * @type {String}
     */
    static szOID_X957 => "1.2.840.10040"

    /**
     * @type {String}
     */
    static szOID_X957_DSA => "1.2.840.10040.4.1"

    /**
     * @type {String}
     */
    static szOID_X957_SHA1DSA => "1.2.840.10040.4.3"

    /**
     * @type {String}
     */
    static szOID_ECC_PUBLIC_KEY => "1.2.840.10045.2.1"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_P256 => "1.2.840.10045.3.1.7"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_P384 => "1.3.132.0.34"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_P521 => "1.3.132.0.35"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP160R1 => "1.3.36.3.3.2.8.1.1.1"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP160T1 => "1.3.36.3.3.2.8.1.1.2"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP192R1 => "1.3.36.3.3.2.8.1.1.3"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP192T1 => "1.3.36.3.3.2.8.1.1.4"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP224R1 => "1.3.36.3.3.2.8.1.1.5"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP224T1 => "1.3.36.3.3.2.8.1.1.6"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP256R1 => "1.3.36.3.3.2.8.1.1.7"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP256T1 => "1.3.36.3.3.2.8.1.1.8"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP320R1 => "1.3.36.3.3.2.8.1.1.9"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP320T1 => "1.3.36.3.3.2.8.1.1.10"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP384R1 => "1.3.36.3.3.2.8.1.1.11"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP384T1 => "1.3.36.3.3.2.8.1.1.12"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP512R1 => "1.3.36.3.3.2.8.1.1.13"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_BRAINPOOLP512T1 => "1.3.36.3.3.2.8.1.1.14"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_EC192WAPI => "1.2.156.11235.1.1.2.1"

    /**
     * @type {String}
     */
    static szOID_CN_ECDSA_SHA256 => "1.2.156.11235.1.1.1"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_NISTP192 => "1.2.840.10045.3.1.1"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_NISTP224 => "1.3.132.0.33"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_NISTP256 => "1.2.840.10045.3.1.7"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_NISTP384 => "1.3.132.0.34"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_NISTP521 => "1.3.132.0.35"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP160K1 => "1.3.132.0.9"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP160R1 => "1.3.132.0.8"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP160R2 => "1.3.132.0.30"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP192K1 => "1.3.132.0.31"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP192R1 => "1.2.840.10045.3.1.1"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP224K1 => "1.3.132.0.32"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP224R1 => "1.3.132.0.33"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP256K1 => "1.3.132.0.10"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP256R1 => "1.2.840.10045.3.1.7"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP384R1 => "1.3.132.0.34"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_SECP521R1 => "1.3.132.0.35"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_WTLS7 => "1.3.132.0.30"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_WTLS9 => "2.23.43.1.4.9"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_WTLS12 => "1.3.132.0.33"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_X962P192V1 => "1.2.840.10045.3.1.1"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_X962P192V2 => "1.2.840.10045.3.1.2"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_X962P192V3 => "1.2.840.10045.3.1.3"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_X962P239V1 => "1.2.840.10045.3.1.4"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_X962P239V2 => "1.2.840.10045.3.1.5"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_X962P239V3 => "1.2.840.10045.3.1.6"

    /**
     * @type {String}
     */
    static szOID_ECC_CURVE_X962P256V1 => "1.2.840.10045.3.1.7"

    /**
     * @type {String}
     */
    static szOID_ECDSA_SHA1 => "1.2.840.10045.4.1"

    /**
     * @type {String}
     */
    static szOID_ECDSA_SPECIFIED => "1.2.840.10045.4.3"

    /**
     * @type {String}
     */
    static szOID_ECDSA_SHA256 => "1.2.840.10045.4.3.2"

    /**
     * @type {String}
     */
    static szOID_ECDSA_SHA384 => "1.2.840.10045.4.3.3"

    /**
     * @type {String}
     */
    static szOID_ECDSA_SHA512 => "1.2.840.10045.4.3.4"

    /**
     * @type {String}
     */
    static szOID_NIST_AES128_CBC => "2.16.840.1.101.3.4.1.2"

    /**
     * @type {String}
     */
    static szOID_NIST_AES192_CBC => "2.16.840.1.101.3.4.1.22"

    /**
     * @type {String}
     */
    static szOID_NIST_AES256_CBC => "2.16.840.1.101.3.4.1.42"

    /**
     * @type {String}
     */
    static szOID_NIST_AES128_WRAP => "2.16.840.1.101.3.4.1.5"

    /**
     * @type {String}
     */
    static szOID_NIST_AES192_WRAP => "2.16.840.1.101.3.4.1.25"

    /**
     * @type {String}
     */
    static szOID_NIST_AES256_WRAP => "2.16.840.1.101.3.4.1.45"

    /**
     * @type {String}
     */
    static szOID_DH_SINGLE_PASS_STDDH_SHA1_KDF => "1.3.133.16.840.63.0.2"

    /**
     * @type {String}
     */
    static szOID_DH_SINGLE_PASS_STDDH_SHA256_KDF => "1.3.132.1.11.1"

    /**
     * @type {String}
     */
    static szOID_DH_SINGLE_PASS_STDDH_SHA384_KDF => "1.3.132.1.11.2"

    /**
     * @type {String}
     */
    static szOID_DS => "2.5"

    /**
     * @type {String}
     */
    static szOID_DSALG => "2.5.8"

    /**
     * @type {String}
     */
    static szOID_DSALG_CRPT => "2.5.8.1"

    /**
     * @type {String}
     */
    static szOID_DSALG_HASH => "2.5.8.2"

    /**
     * @type {String}
     */
    static szOID_DSALG_SIGN => "2.5.8.3"

    /**
     * @type {String}
     */
    static szOID_DSALG_RSA => "2.5.8.1.1"

    /**
     * @type {String}
     */
    static szOID_OIW => "1.3.14"

    /**
     * @type {String}
     */
    static szOID_OIWSEC => "1.3.14.3.2"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_md4RSA => "1.3.14.3.2.2"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_md5RSA => "1.3.14.3.2.3"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_md4RSA2 => "1.3.14.3.2.4"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_desECB => "1.3.14.3.2.6"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_desCBC => "1.3.14.3.2.7"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_desOFB => "1.3.14.3.2.8"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_desCFB => "1.3.14.3.2.9"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_desMAC => "1.3.14.3.2.10"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_rsaSign => "1.3.14.3.2.11"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_dsa => "1.3.14.3.2.12"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_shaDSA => "1.3.14.3.2.13"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_mdc2RSA => "1.3.14.3.2.14"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_shaRSA => "1.3.14.3.2.15"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_dhCommMod => "1.3.14.3.2.16"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_desEDE => "1.3.14.3.2.17"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_sha => "1.3.14.3.2.18"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_mdc2 => "1.3.14.3.2.19"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_dsaComm => "1.3.14.3.2.20"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_dsaCommSHA => "1.3.14.3.2.21"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_rsaXchg => "1.3.14.3.2.22"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_keyHashSeal => "1.3.14.3.2.23"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_md2RSASign => "1.3.14.3.2.24"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_md5RSASign => "1.3.14.3.2.25"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_sha1 => "1.3.14.3.2.26"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_dsaSHA1 => "1.3.14.3.2.27"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_dsaCommSHA1 => "1.3.14.3.2.28"

    /**
     * @type {String}
     */
    static szOID_OIWSEC_sha1RSASign => "1.3.14.3.2.29"

    /**
     * @type {String}
     */
    static szOID_OIWDIR => "1.3.14.7.2"

    /**
     * @type {String}
     */
    static szOID_OIWDIR_CRPT => "1.3.14.7.2.1"

    /**
     * @type {String}
     */
    static szOID_OIWDIR_HASH => "1.3.14.7.2.2"

    /**
     * @type {String}
     */
    static szOID_OIWDIR_SIGN => "1.3.14.7.2.3"

    /**
     * @type {String}
     */
    static szOID_OIWDIR_md2 => "1.3.14.7.2.2.1"

    /**
     * @type {String}
     */
    static szOID_OIWDIR_md2RSA => "1.3.14.7.2.3.1"

    /**
     * @type {String}
     */
    static szOID_INFOSEC => "2.16.840.1.101.2.1"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_sdnsSignature => "2.16.840.1.101.2.1.1.1"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicSignature => "2.16.840.1.101.2.1.1.2"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_sdnsConfidentiality => "2.16.840.1.101.2.1.1.3"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicConfidentiality => "2.16.840.1.101.2.1.1.4"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_sdnsIntegrity => "2.16.840.1.101.2.1.1.5"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicIntegrity => "2.16.840.1.101.2.1.1.6"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_sdnsTokenProtection => "2.16.840.1.101.2.1.1.7"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicTokenProtection => "2.16.840.1.101.2.1.1.8"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_sdnsKeyManagement => "2.16.840.1.101.2.1.1.9"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicKeyManagement => "2.16.840.1.101.2.1.1.10"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_sdnsKMandSig => "2.16.840.1.101.2.1.1.11"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicKMandSig => "2.16.840.1.101.2.1.1.12"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_SuiteASignature => "2.16.840.1.101.2.1.1.13"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_SuiteAConfidentiality => "2.16.840.1.101.2.1.1.14"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_SuiteAIntegrity => "2.16.840.1.101.2.1.1.15"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_SuiteATokenProtection => "2.16.840.1.101.2.1.1.16"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_SuiteAKeyManagement => "2.16.840.1.101.2.1.1.17"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_SuiteAKMandSig => "2.16.840.1.101.2.1.1.18"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicUpdatedSig => "2.16.840.1.101.2.1.1.19"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicKMandUpdSig => "2.16.840.1.101.2.1.1.20"

    /**
     * @type {String}
     */
    static szOID_INFOSEC_mosaicUpdatedInteg => "2.16.840.1.101.2.1.1.21"

    /**
     * @type {String}
     */
    static szOID_NIST_sha256 => "2.16.840.1.101.3.4.2.1"

    /**
     * @type {String}
     */
    static szOID_NIST_sha384 => "2.16.840.1.101.3.4.2.2"

    /**
     * @type {String}
     */
    static szOID_NIST_sha512 => "2.16.840.1.101.3.4.2.3"

    /**
     * @type {String}
     */
    static szOID_COMMON_NAME => "2.5.4.3"

    /**
     * @type {String}
     */
    static szOID_SUR_NAME => "2.5.4.4"

    /**
     * @type {String}
     */
    static szOID_DEVICE_SERIAL_NUMBER => "2.5.4.5"

    /**
     * @type {String}
     */
    static szOID_COUNTRY_NAME => "2.5.4.6"

    /**
     * @type {String}
     */
    static szOID_LOCALITY_NAME => "2.5.4.7"

    /**
     * @type {String}
     */
    static szOID_STATE_OR_PROVINCE_NAME => "2.5.4.8"

    /**
     * @type {String}
     */
    static szOID_STREET_ADDRESS => "2.5.4.9"

    /**
     * @type {String}
     */
    static szOID_ORGANIZATION_NAME => "2.5.4.10"

    /**
     * @type {String}
     */
    static szOID_ORGANIZATIONAL_UNIT_NAME => "2.5.4.11"

    /**
     * @type {String}
     */
    static szOID_TITLE => "2.5.4.12"

    /**
     * @type {String}
     */
    static szOID_DESCRIPTION => "2.5.4.13"

    /**
     * @type {String}
     */
    static szOID_SEARCH_GUIDE => "2.5.4.14"

    /**
     * @type {String}
     */
    static szOID_BUSINESS_CATEGORY => "2.5.4.15"

    /**
     * @type {String}
     */
    static szOID_POSTAL_ADDRESS => "2.5.4.16"

    /**
     * @type {String}
     */
    static szOID_POSTAL_CODE => "2.5.4.17"

    /**
     * @type {String}
     */
    static szOID_POST_OFFICE_BOX => "2.5.4.18"

    /**
     * @type {String}
     */
    static szOID_PHYSICAL_DELIVERY_OFFICE_NAME => "2.5.4.19"

    /**
     * @type {String}
     */
    static szOID_TELEPHONE_NUMBER => "2.5.4.20"

    /**
     * @type {String}
     */
    static szOID_TELEX_NUMBER => "2.5.4.21"

    /**
     * @type {String}
     */
    static szOID_TELETEXT_TERMINAL_IDENTIFIER => "2.5.4.22"

    /**
     * @type {String}
     */
    static szOID_FACSIMILE_TELEPHONE_NUMBER => "2.5.4.23"

    /**
     * @type {String}
     */
    static szOID_X21_ADDRESS => "2.5.4.24"

    /**
     * @type {String}
     */
    static szOID_INTERNATIONAL_ISDN_NUMBER => "2.5.4.25"

    /**
     * @type {String}
     */
    static szOID_REGISTERED_ADDRESS => "2.5.4.26"

    /**
     * @type {String}
     */
    static szOID_DESTINATION_INDICATOR => "2.5.4.27"

    /**
     * @type {String}
     */
    static szOID_PREFERRED_DELIVERY_METHOD => "2.5.4.28"

    /**
     * @type {String}
     */
    static szOID_PRESENTATION_ADDRESS => "2.5.4.29"

    /**
     * @type {String}
     */
    static szOID_SUPPORTED_APPLICATION_CONTEXT => "2.5.4.30"

    /**
     * @type {String}
     */
    static szOID_MEMBER => "2.5.4.31"

    /**
     * @type {String}
     */
    static szOID_OWNER => "2.5.4.32"

    /**
     * @type {String}
     */
    static szOID_ROLE_OCCUPANT => "2.5.4.33"

    /**
     * @type {String}
     */
    static szOID_SEE_ALSO => "2.5.4.34"

    /**
     * @type {String}
     */
    static szOID_USER_PASSWORD => "2.5.4.35"

    /**
     * @type {String}
     */
    static szOID_USER_CERTIFICATE => "2.5.4.36"

    /**
     * @type {String}
     */
    static szOID_CA_CERTIFICATE => "2.5.4.37"

    /**
     * @type {String}
     */
    static szOID_AUTHORITY_REVOCATION_LIST => "2.5.4.38"

    /**
     * @type {String}
     */
    static szOID_CERTIFICATE_REVOCATION_LIST => "2.5.4.39"

    /**
     * @type {String}
     */
    static szOID_CROSS_CERTIFICATE_PAIR => "2.5.4.40"

    /**
     * @type {String}
     */
    static szOID_GIVEN_NAME => "2.5.4.42"

    /**
     * @type {String}
     */
    static szOID_INITIALS => "2.5.4.43"

    /**
     * @type {String}
     */
    static szOID_DN_QUALIFIER => "2.5.4.46"

    /**
     * @type {String}
     */
    static szOID_DOMAIN_COMPONENT => "0.9.2342.19200300.100.1.25"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_FRIENDLY_NAME_ATTR => "1.2.840.113549.1.9.20"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_LOCAL_KEY_ID => "1.2.840.113549.1.9.21"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR => "1.3.6.1.4.1.311.17.1"

    /**
     * @type {String}
     */
    static szOID_LOCAL_MACHINE_KEYSET => "1.3.6.1.4.1.311.17.2"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_EXTENDED_ATTRIBUTES => "1.3.6.1.4.1.311.17.3"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_PROTECTED_PASSWORD_SECRET_BAG_TYPE_ID => "1.3.6.1.4.1.311.17.4"

    /**
     * @type {String}
     */
    static szOID_KEYID_RDN => "1.3.6.1.4.1.311.10.7.1"

    /**
     * @type {String}
     */
    static szOID_EV_RDN_LOCALE => "1.3.6.1.4.1.311.60.2.1.1"

    /**
     * @type {String}
     */
    static szOID_EV_RDN_STATE_OR_PROVINCE => "1.3.6.1.4.1.311.60.2.1.2"

    /**
     * @type {String}
     */
    static szOID_EV_RDN_COUNTRY => "1.3.6.1.4.1.311.60.2.1.3"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RDN_TYPE_MASK => 255

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RDN_FLAGS_MASK => 4278190080

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RDN_ENABLE_T61_UNICODE_FLAG => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RDN_ENABLE_UTF8_UNICODE_FLAG => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RDN_FORCE_UTF8_UNICODE_FLAG => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RDN_DISABLE_CHECK_TYPE_FLAG => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RDN_DISABLE_IE4_UTF8_FLAG => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RDN_ENABLE_PUNYCODE_FLAG => 33554432

    /**
     * @type {String}
     */
    static CERT_RSA_PUBLIC_KEY_OBJID => "1.2.840.113549.1.1.1"

    /**
     * @type {String}
     */
    static CERT_DEFAULT_OID_PUBLIC_KEY_SIGN => "1.2.840.113549.1.1.1"

    /**
     * @type {String}
     */
    static CERT_DEFAULT_OID_PUBLIC_KEY_XCHG => "1.2.840.113549.1.1.1"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ECC_PRIVATE_KEY_INFO_v1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_V1 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_V2 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_V3 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_VERSION_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_SERIAL_NUMBER_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_SIGNATURE_ALGORITHM_FLAG => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_ISSUER_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_NOT_BEFORE_FLAG => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_NOT_AFTER_FLAG => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_SUBJECT_FLAG => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_SUBJECT_PUBLIC_KEY_INFO_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_ISSUER_UNIQUE_ID_FLAG => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_SUBJECT_UNIQUE_ID_FLAG => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_INFO_EXTENSION_FLAG => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_V1 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_V2 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_BUNDLE_CERTIFICATE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_BUNDLE_CRL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REQUEST_V1 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEYGEN_REQUEST_V1 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CTL_V1 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ENCODING_TYPE_MASK => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENCODING_TYPE_MASK => 4294901760

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ASN_ENCODING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_NDR_ENCODING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static X509_NDR_ENCODING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS_7_NDR_ENCODING => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_STR_MULTI_LINE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_STR_NO_HEX => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_SIMPLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_X509 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_OID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_RDN_SEMICOLON => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_RDN_CRLF => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_RDN_UNQUOTE => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_RDN_REVERSE => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_COMMA => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_SEMICOLON => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FORMAT_CRLF => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ENCODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_UNICODE_NAME_ENCODE_FORCE_UTF8_UNICODE_FLAG => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SORTED_CTL_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ENCODE_ENABLE_UTF8PERCENT_FLAG => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECODE_NOCOPY_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECODE_TO_BE_SIGNED_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECODE_SHARE_OID_STRING_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECODE_ALLOC_FLAG => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECODE_ENABLE_PUNYCODE_FLAG => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DECODE_ENABLE_UTF8PERCENT_FLAG => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ENCODE_DECODE_NONE => 0

    /**
     * @type {Integer (Int32)}
     */
    static X509_CERT => 1

    /**
     * @type {Integer (Int32)}
     */
    static X509_CERT_TO_BE_SIGNED => 2

    /**
     * @type {Integer (Int32)}
     */
    static X509_CERT_CRL_TO_BE_SIGNED => 3

    /**
     * @type {Integer (Int32)}
     */
    static X509_CERT_REQUEST_TO_BE_SIGNED => 4

    /**
     * @type {Integer (Int32)}
     */
    static X509_EXTENSIONS => 5

    /**
     * @type {Integer (Int32)}
     */
    static X509_NAME_VALUE => 6

    /**
     * @type {Integer (Int32)}
     */
    static X509_NAME => 7

    /**
     * @type {Integer (Int32)}
     */
    static X509_PUBLIC_KEY_INFO => 8

    /**
     * @type {Integer (Int32)}
     */
    static X509_AUTHORITY_KEY_ID => 9

    /**
     * @type {Integer (Int32)}
     */
    static X509_KEY_ATTRIBUTES => 10

    /**
     * @type {Integer (Int32)}
     */
    static X509_KEY_USAGE_RESTRICTION => 11

    /**
     * @type {Integer (Int32)}
     */
    static X509_ALTERNATE_NAME => 12

    /**
     * @type {Integer (Int32)}
     */
    static X509_BASIC_CONSTRAINTS => 13

    /**
     * @type {Integer (Int32)}
     */
    static X509_KEY_USAGE => 14

    /**
     * @type {Integer (Int32)}
     */
    static X509_BASIC_CONSTRAINTS2 => 15

    /**
     * @type {Integer (Int32)}
     */
    static X509_CERT_POLICIES => 16

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_UTC_TIME => 17

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_TIME_REQUEST => 18

    /**
     * @type {Integer (Int32)}
     */
    static RSA_CSP_PUBLICKEYBLOB => 19

    /**
     * @type {Integer (Int32)}
     */
    static X509_UNICODE_NAME => 20

    /**
     * @type {Integer (Int32)}
     */
    static X509_KEYGEN_REQUEST_TO_BE_SIGNED => 21

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_ATTRIBUTE => 22

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_CONTENT_INFO_SEQUENCE_OF_ANY => 23

    /**
     * @type {Integer (Int32)}
     */
    static X509_UNICODE_NAME_VALUE => 24

    /**
     * @type {Integer (Int32)}
     */
    static X509_ANY_STRING => 6

    /**
     * @type {Integer (Int32)}
     */
    static X509_UNICODE_ANY_STRING => 24

    /**
     * @type {Integer (Int32)}
     */
    static X509_OCTET_STRING => 25

    /**
     * @type {Integer (Int32)}
     */
    static X509_BITS => 26

    /**
     * @type {Integer (Int32)}
     */
    static X509_INTEGER => 27

    /**
     * @type {Integer (Int32)}
     */
    static X509_MULTI_BYTE_INTEGER => 28

    /**
     * @type {Integer (Int32)}
     */
    static X509_ENUMERATED => 29

    /**
     * @type {Integer (Int32)}
     */
    static X509_CHOICE_OF_TIME => 30

    /**
     * @type {Integer (Int32)}
     */
    static X509_AUTHORITY_KEY_ID2 => 31

    /**
     * @type {Integer (Int32)}
     */
    static X509_AUTHORITY_INFO_ACCESS => 32

    /**
     * @type {Integer (Int32)}
     */
    static X509_SUBJECT_INFO_ACCESS => 32

    /**
     * @type {Integer (Int32)}
     */
    static X509_CRL_REASON_CODE => 29

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_CONTENT_INFO => 33

    /**
     * @type {Integer (Int32)}
     */
    static X509_SEQUENCE_OF_ANY => 34

    /**
     * @type {Integer (Int32)}
     */
    static X509_CRL_DIST_POINTS => 35

    /**
     * @type {Integer (Int32)}
     */
    static X509_ENHANCED_KEY_USAGE => 36

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_CTL => 37

    /**
     * @type {Integer (Int32)}
     */
    static X509_MULTI_BYTE_UINT => 38

    /**
     * @type {Integer (Int32)}
     */
    static X509_DSS_PUBLICKEY => 38

    /**
     * @type {Integer (Int32)}
     */
    static X509_DSS_PARAMETERS => 39

    /**
     * @type {Integer (Int32)}
     */
    static X509_DSS_SIGNATURE => 40

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_RC2_CBC_PARAMETERS => 41

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_SMIME_CAPABILITIES => 42

    /**
     * @type {Integer (Int32)}
     */
    static X509_QC_STATEMENTS_EXT => 42

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_RSA_PRIVATE_KEY => 43

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_PRIVATE_KEY_INFO => 44

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_ENCRYPTED_PRIVATE_KEY_INFO => 45

    /**
     * @type {Integer (Int32)}
     */
    static X509_PKIX_POLICY_QUALIFIER_USERNOTICE => 46

    /**
     * @type {Integer (Int32)}
     */
    static X509_DH_PUBLICKEY => 38

    /**
     * @type {Integer (Int32)}
     */
    static X509_DH_PARAMETERS => 47

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_ATTRIBUTES => 48

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_SORTED_CTL => 49

    /**
     * @type {Integer (Int32)}
     */
    static X509_ECC_SIGNATURE => 47

    /**
     * @type {Integer (Int32)}
     */
    static X942_DH_PARAMETERS => 50

    /**
     * @type {Integer (Int32)}
     */
    static X509_BITS_WITHOUT_TRAILING_ZEROES => 51

    /**
     * @type {Integer (Int32)}
     */
    static X942_OTHER_INFO => 52

    /**
     * @type {Integer (Int32)}
     */
    static X509_CERT_PAIR => 53

    /**
     * @type {Integer (Int32)}
     */
    static X509_ISSUING_DIST_POINT => 54

    /**
     * @type {Integer (Int32)}
     */
    static X509_NAME_CONSTRAINTS => 55

    /**
     * @type {Integer (Int32)}
     */
    static X509_POLICY_MAPPINGS => 56

    /**
     * @type {Integer (Int32)}
     */
    static X509_POLICY_CONSTRAINTS => 57

    /**
     * @type {Integer (Int32)}
     */
    static X509_CROSS_CERT_DIST_POINTS => 58

    /**
     * @type {Integer (Int32)}
     */
    static CMC_DATA => 59

    /**
     * @type {Integer (Int32)}
     */
    static CMC_RESPONSE => 60

    /**
     * @type {Integer (Int32)}
     */
    static CMC_STATUS => 61

    /**
     * @type {Integer (Int32)}
     */
    static CMC_ADD_EXTENSIONS => 62

    /**
     * @type {Integer (Int32)}
     */
    static CMC_ADD_ATTRIBUTES => 63

    /**
     * @type {Integer (Int32)}
     */
    static X509_CERTIFICATE_TEMPLATE => 64

    /**
     * @type {Integer (Int32)}
     */
    static OCSP_SIGNED_REQUEST => 65

    /**
     * @type {Integer (Int32)}
     */
    static OCSP_REQUEST => 66

    /**
     * @type {Integer (Int32)}
     */
    static OCSP_RESPONSE => 67

    /**
     * @type {Integer (Int32)}
     */
    static OCSP_BASIC_SIGNED_RESPONSE => 68

    /**
     * @type {Integer (Int32)}
     */
    static OCSP_BASIC_RESPONSE => 69

    /**
     * @type {Integer (Int32)}
     */
    static X509_LOGOTYPE_EXT => 70

    /**
     * @type {Integer (Int32)}
     */
    static X509_BIOMETRIC_EXT => 71

    /**
     * @type {Integer (Int32)}
     */
    static CNG_RSA_PUBLIC_KEY_BLOB => 72

    /**
     * @type {Integer (Int32)}
     */
    static X509_OBJECT_IDENTIFIER => 73

    /**
     * @type {Integer (Int32)}
     */
    static X509_ALGORITHM_IDENTIFIER => 74

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_RSA_SSA_PSS_PARAMETERS => 75

    /**
     * @type {Integer (Int32)}
     */
    static PKCS_RSAES_OAEP_PARAMETERS => 76

    /**
     * @type {Integer (Int32)}
     */
    static ECC_CMS_SHARED_INFO => 77

    /**
     * @type {Integer (Int32)}
     */
    static TIMESTAMP_REQUEST => 78

    /**
     * @type {Integer (Int32)}
     */
    static TIMESTAMP_RESPONSE => 79

    /**
     * @type {Integer (Int32)}
     */
    static TIMESTAMP_INFO => 80

    /**
     * @type {Integer (Int32)}
     */
    static X509_CERT_BUNDLE => 81

    /**
     * @type {Integer (Int32)}
     */
    static X509_ECC_PRIVATE_KEY => 82

    /**
     * @type {Integer (Int32)}
     */
    static CNG_RSA_PRIVATE_KEY_BLOB => 83

    /**
     * @type {Integer (Int32)}
     */
    static X509_SUBJECT_DIR_ATTRS => 84

    /**
     * @type {Integer (Int32)}
     */
    static X509_ECC_PARAMETERS => 85

    /**
     * @type {Integer (Int32)}
     */
    static PKCS7_SIGNER_INFO => 500

    /**
     * @type {Integer (Int32)}
     */
    static CMS_SIGNER_INFO => 501

    /**
     * @type {String}
     */
    static szOID_AUTHORITY_KEY_IDENTIFIER => "2.5.29.1"

    /**
     * @type {String}
     */
    static szOID_KEY_ATTRIBUTES => "2.5.29.2"

    /**
     * @type {String}
     */
    static szOID_CERT_POLICIES_95 => "2.5.29.3"

    /**
     * @type {String}
     */
    static szOID_KEY_USAGE_RESTRICTION => "2.5.29.4"

    /**
     * @type {String}
     */
    static szOID_SUBJECT_ALT_NAME => "2.5.29.7"

    /**
     * @type {String}
     */
    static szOID_ISSUER_ALT_NAME => "2.5.29.8"

    /**
     * @type {String}
     */
    static szOID_BASIC_CONSTRAINTS => "2.5.29.10"

    /**
     * @type {String}
     */
    static szOID_KEY_USAGE => "2.5.29.15"

    /**
     * @type {String}
     */
    static szOID_PRIVATEKEY_USAGE_PERIOD => "2.5.29.16"

    /**
     * @type {String}
     */
    static szOID_BASIC_CONSTRAINTS2 => "2.5.29.19"

    /**
     * @type {String}
     */
    static szOID_CERT_POLICIES => "2.5.29.32"

    /**
     * @type {String}
     */
    static szOID_ANY_CERT_POLICY => "2.5.29.32.0"

    /**
     * @type {String}
     */
    static szOID_INHIBIT_ANY_POLICY => "2.5.29.54"

    /**
     * @type {String}
     */
    static szOID_AUTHORITY_KEY_IDENTIFIER2 => "2.5.29.35"

    /**
     * @type {String}
     */
    static szOID_SUBJECT_KEY_IDENTIFIER => "2.5.29.14"

    /**
     * @type {String}
     */
    static szOID_SUBJECT_ALT_NAME2 => "2.5.29.17"

    /**
     * @type {String}
     */
    static szOID_ISSUER_ALT_NAME2 => "2.5.29.18"

    /**
     * @type {String}
     */
    static szOID_CRL_REASON_CODE => "2.5.29.21"

    /**
     * @type {String}
     */
    static szOID_REASON_CODE_HOLD => "2.5.29.23"

    /**
     * @type {String}
     */
    static szOID_CRL_DIST_POINTS => "2.5.29.31"

    /**
     * @type {String}
     */
    static szOID_ENHANCED_KEY_USAGE => "2.5.29.37"

    /**
     * @type {String}
     */
    static szOID_ANY_ENHANCED_KEY_USAGE => "2.5.29.37.0"

    /**
     * @type {String}
     */
    static szOID_CRL_NUMBER => "2.5.29.20"

    /**
     * @type {String}
     */
    static szOID_DELTA_CRL_INDICATOR => "2.5.29.27"

    /**
     * @type {String}
     */
    static szOID_ISSUING_DIST_POINT => "2.5.29.28"

    /**
     * @type {String}
     */
    static szOID_FRESHEST_CRL => "2.5.29.46"

    /**
     * @type {String}
     */
    static szOID_NAME_CONSTRAINTS => "2.5.29.30"

    /**
     * @type {String}
     */
    static szOID_POLICY_MAPPINGS => "2.5.29.33"

    /**
     * @type {String}
     */
    static szOID_LEGACY_POLICY_MAPPINGS => "2.5.29.5"

    /**
     * @type {String}
     */
    static szOID_POLICY_CONSTRAINTS => "2.5.29.36"

    /**
     * @type {String}
     */
    static szOID_RENEWAL_CERTIFICATE => "1.3.6.1.4.1.311.13.1"

    /**
     * @type {String}
     */
    static szOID_ENROLLMENT_NAME_VALUE_PAIR => "1.3.6.1.4.1.311.13.2.1"

    /**
     * @type {String}
     */
    static szOID_ENROLLMENT_CSP_PROVIDER => "1.3.6.1.4.1.311.13.2.2"

    /**
     * @type {String}
     */
    static szOID_OS_VERSION => "1.3.6.1.4.1.311.13.2.3"

    /**
     * @type {String}
     */
    static szOID_ENROLLMENT_AGENT => "1.3.6.1.4.1.311.20.2.1"

    /**
     * @type {String}
     */
    static szOID_PKIX => "1.3.6.1.5.5.7"

    /**
     * @type {String}
     */
    static szOID_PKIX_PE => "1.3.6.1.5.5.7.1"

    /**
     * @type {String}
     */
    static szOID_AUTHORITY_INFO_ACCESS => "1.3.6.1.5.5.7.1.1"

    /**
     * @type {String}
     */
    static szOID_SUBJECT_INFO_ACCESS => "1.3.6.1.5.5.7.1.11"

    /**
     * @type {String}
     */
    static szOID_BIOMETRIC_EXT => "1.3.6.1.5.5.7.1.2"

    /**
     * @type {String}
     */
    static szOID_QC_STATEMENTS_EXT => "1.3.6.1.5.5.7.1.3"

    /**
     * @type {String}
     */
    static szOID_LOGOTYPE_EXT => "1.3.6.1.5.5.7.1.12"

    /**
     * @type {String}
     */
    static szOID_TLS_FEATURES_EXT => "1.3.6.1.5.5.7.1.24"

    /**
     * @type {String}
     */
    static szOID_CERT_EXTENSIONS => "1.3.6.1.4.1.311.2.1.14"

    /**
     * @type {String}
     */
    static szOID_NEXT_UPDATE_LOCATION => "1.3.6.1.4.1.311.10.2"

    /**
     * @type {String}
     */
    static szOID_REMOVE_CERTIFICATE => "1.3.6.1.4.1.311.10.8.1"

    /**
     * @type {String}
     */
    static szOID_CROSS_CERT_DIST_POINTS => "1.3.6.1.4.1.311.10.9.1"

    /**
     * @type {String}
     */
    static szOID_CTL => "1.3.6.1.4.1.311.10.1"

    /**
     * @type {String}
     */
    static szOID_SORTED_CTL => "1.3.6.1.4.1.311.10.1.1"

    /**
     * @type {String}
     */
    static szOID_SERIALIZED => "1.3.6.1.4.1.311.10.3.3.1"

    /**
     * @type {String}
     */
    static szOID_NT_PRINCIPAL_NAME => "1.3.6.1.4.1.311.20.2.3"

    /**
     * @type {String}
     */
    static szOID_INTERNATIONALIZED_EMAIL_ADDRESS => "1.3.6.1.4.1.311.20.2.4"

    /**
     * @type {String}
     */
    static szOID_PRODUCT_UPDATE => "1.3.6.1.4.1.311.31.1"

    /**
     * @type {String}
     */
    static szOID_ANY_APPLICATION_POLICY => "1.3.6.1.4.1.311.10.12.1"

    /**
     * @type {String}
     */
    static szOID_AUTO_ENROLL_CTL_USAGE => "1.3.6.1.4.1.311.20.1"

    /**
     * @type {String}
     */
    static szOID_ENROLL_CERTTYPE_EXTENSION => "1.3.6.1.4.1.311.20.2"

    /**
     * @type {String}
     */
    static szOID_CERT_MANIFOLD => "1.3.6.1.4.1.311.20.3"

    /**
     * @type {String}
     */
    static szOID_CERTSRV_CA_VERSION => "1.3.6.1.4.1.311.21.1"

    /**
     * @type {String}
     */
    static szOID_CERTSRV_PREVIOUS_CERT_HASH => "1.3.6.1.4.1.311.21.2"

    /**
     * @type {String}
     */
    static szOID_CRL_VIRTUAL_BASE => "1.3.6.1.4.1.311.21.3"

    /**
     * @type {String}
     */
    static szOID_CRL_NEXT_PUBLISH => "1.3.6.1.4.1.311.21.4"

    /**
     * @type {String}
     */
    static szOID_KP_CA_EXCHANGE => "1.3.6.1.4.1.311.21.5"

    /**
     * @type {String}
     */
    static szOID_KP_PRIVACY_CA => "1.3.6.1.4.1.311.21.36"

    /**
     * @type {String}
     */
    static szOID_KP_KEY_RECOVERY_AGENT => "1.3.6.1.4.1.311.21.6"

    /**
     * @type {String}
     */
    static szOID_CERTIFICATE_TEMPLATE => "1.3.6.1.4.1.311.21.7"

    /**
     * @type {String}
     */
    static szOID_ENTERPRISE_OID_ROOT => "1.3.6.1.4.1.311.21.8"

    /**
     * @type {String}
     */
    static szOID_RDN_DUMMY_SIGNER => "1.3.6.1.4.1.311.21.9"

    /**
     * @type {String}
     */
    static szOID_APPLICATION_CERT_POLICIES => "1.3.6.1.4.1.311.21.10"

    /**
     * @type {String}
     */
    static szOID_APPLICATION_POLICY_MAPPINGS => "1.3.6.1.4.1.311.21.11"

    /**
     * @type {String}
     */
    static szOID_APPLICATION_POLICY_CONSTRAINTS => "1.3.6.1.4.1.311.21.12"

    /**
     * @type {String}
     */
    static szOID_ARCHIVED_KEY_ATTR => "1.3.6.1.4.1.311.21.13"

    /**
     * @type {String}
     */
    static szOID_CRL_SELF_CDP => "1.3.6.1.4.1.311.21.14"

    /**
     * @type {String}
     */
    static szOID_REQUIRE_CERT_CHAIN_POLICY => "1.3.6.1.4.1.311.21.15"

    /**
     * @type {String}
     */
    static szOID_ARCHIVED_KEY_CERT_HASH => "1.3.6.1.4.1.311.21.16"

    /**
     * @type {String}
     */
    static szOID_ISSUED_CERT_HASH => "1.3.6.1.4.1.311.21.17"

    /**
     * @type {String}
     */
    static szOID_DS_EMAIL_REPLICATION => "1.3.6.1.4.1.311.21.19"

    /**
     * @type {String}
     */
    static szOID_REQUEST_CLIENT_INFO => "1.3.6.1.4.1.311.21.20"

    /**
     * @type {String}
     */
    static szOID_ENCRYPTED_KEY_HASH => "1.3.6.1.4.1.311.21.21"

    /**
     * @type {String}
     */
    static szOID_CERTSRV_CROSSCA_VERSION => "1.3.6.1.4.1.311.21.22"

    /**
     * @type {String}
     */
    static szOID_NTDS_REPLICATION => "1.3.6.1.4.1.311.25.1"

    /**
     * @type {String}
     */
    static szOID_NTDS_CA_SECURITY_EXT => "1.3.6.1.4.1.311.25.2"

    /**
     * @type {String}
     */
    static szOID_NTDS_OBJECTSID => "1.3.6.1.4.1.311.25.2.1"

    /**
     * @type {String}
     */
    static wszURI_NTDS_OBJECTSID_PREFIX => "tag:microsoft.com,2022-09-14:sid:"

    /**
     * @type {String}
     */
    static szOID_SUBJECT_DIR_ATTRS => "2.5.29.9"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP => "1.3.6.1.5.5.7.3"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_SERVER_AUTH => "1.3.6.1.5.5.7.3.1"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_CLIENT_AUTH => "1.3.6.1.5.5.7.3.2"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_CODE_SIGNING => "1.3.6.1.5.5.7.3.3"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_EMAIL_PROTECTION => "1.3.6.1.5.5.7.3.4"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_IPSEC_END_SYSTEM => "1.3.6.1.5.5.7.3.5"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_IPSEC_TUNNEL => "1.3.6.1.5.5.7.3.6"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_IPSEC_USER => "1.3.6.1.5.5.7.3.7"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_TIMESTAMP_SIGNING => "1.3.6.1.5.5.7.3.8"

    /**
     * @type {String}
     */
    static szOID_PKIX_KP_OCSP_SIGNING => "1.3.6.1.5.5.7.3.9"

    /**
     * @type {String}
     */
    static szOID_PKIX_OCSP_NOCHECK => "1.3.6.1.5.5.7.48.1.5"

    /**
     * @type {String}
     */
    static szOID_PKIX_OCSP_NONCE => "1.3.6.1.5.5.7.48.1.2"

    /**
     * @type {String}
     */
    static szOID_IPSEC_KP_IKE_INTERMEDIATE => "1.3.6.1.5.5.8.2.2"

    /**
     * @type {String}
     */
    static szOID_PKINIT_KP_KDC => "1.3.6.1.5.2.3.5"

    /**
     * @type {String}
     */
    static szOID_KP_CTL_USAGE_SIGNING => "1.3.6.1.4.1.311.10.3.1"

    /**
     * @type {String}
     */
    static szOID_KP_TIME_STAMP_SIGNING => "1.3.6.1.4.1.311.10.3.2"

    /**
     * @type {String}
     */
    static szOID_SERVER_GATED_CRYPTO => "1.3.6.1.4.1.311.10.3.3"

    /**
     * @type {String}
     */
    static szOID_SGC_NETSCAPE => "2.16.840.1.113730.4.1"

    /**
     * @type {String}
     */
    static szOID_KP_EFS => "1.3.6.1.4.1.311.10.3.4"

    /**
     * @type {String}
     */
    static szOID_EFS_RECOVERY => "1.3.6.1.4.1.311.10.3.4.1"

    /**
     * @type {String}
     */
    static szOID_WHQL_CRYPTO => "1.3.6.1.4.1.311.10.3.5"

    /**
     * @type {String}
     */
    static szOID_ATTEST_WHQL_CRYPTO => "1.3.6.1.4.1.311.10.3.5.1"

    /**
     * @type {String}
     */
    static szOID_NT5_CRYPTO => "1.3.6.1.4.1.311.10.3.6"

    /**
     * @type {String}
     */
    static szOID_OEM_WHQL_CRYPTO => "1.3.6.1.4.1.311.10.3.7"

    /**
     * @type {String}
     */
    static szOID_EMBEDDED_NT_CRYPTO => "1.3.6.1.4.1.311.10.3.8"

    /**
     * @type {String}
     */
    static szOID_ROOT_LIST_SIGNER => "1.3.6.1.4.1.311.10.3.9"

    /**
     * @type {String}
     */
    static szOID_KP_QUALIFIED_SUBORDINATION => "1.3.6.1.4.1.311.10.3.10"

    /**
     * @type {String}
     */
    static szOID_KP_KEY_RECOVERY => "1.3.6.1.4.1.311.10.3.11"

    /**
     * @type {String}
     */
    static szOID_KP_DOCUMENT_SIGNING => "1.3.6.1.4.1.311.10.3.12"

    /**
     * @type {String}
     */
    static szOID_KP_LIFETIME_SIGNING => "1.3.6.1.4.1.311.10.3.13"

    /**
     * @type {String}
     */
    static szOID_KP_MOBILE_DEVICE_SOFTWARE => "1.3.6.1.4.1.311.10.3.14"

    /**
     * @type {String}
     */
    static szOID_KP_SMART_DISPLAY => "1.3.6.1.4.1.311.10.3.15"

    /**
     * @type {String}
     */
    static szOID_KP_CSP_SIGNATURE => "1.3.6.1.4.1.311.10.3.16"

    /**
     * @type {String}
     */
    static szOID_KP_FLIGHT_SIGNING => "1.3.6.1.4.1.311.10.3.27"

    /**
     * @type {String}
     */
    static szOID_PLATFORM_MANIFEST_BINARY_ID => "1.3.6.1.4.1.311.10.3.28"

    /**
     * @type {String}
     */
    static szOID_DRM => "1.3.6.1.4.1.311.10.5.1"

    /**
     * @type {String}
     */
    static szOID_DRM_INDIVIDUALIZATION => "1.3.6.1.4.1.311.10.5.2"

    /**
     * @type {String}
     */
    static szOID_LICENSES => "1.3.6.1.4.1.311.10.6.1"

    /**
     * @type {String}
     */
    static szOID_LICENSE_SERVER => "1.3.6.1.4.1.311.10.6.2"

    /**
     * @type {String}
     */
    static szOID_KP_SMARTCARD_LOGON => "1.3.6.1.4.1.311.20.2.2"

    /**
     * @type {String}
     */
    static szOID_KP_KERNEL_MODE_CODE_SIGNING => "1.3.6.1.4.1.311.61.1.1"

    /**
     * @type {String}
     */
    static szOID_KP_KERNEL_MODE_TRUSTED_BOOT_SIGNING => "1.3.6.1.4.1.311.61.4.1"

    /**
     * @type {String}
     */
    static szOID_REVOKED_LIST_SIGNER => "1.3.6.1.4.1.311.10.3.19"

    /**
     * @type {String}
     */
    static szOID_WINDOWS_KITS_SIGNER => "1.3.6.1.4.1.311.10.3.20"

    /**
     * @type {String}
     */
    static szOID_WINDOWS_RT_SIGNER => "1.3.6.1.4.1.311.10.3.21"

    /**
     * @type {String}
     */
    static szOID_PROTECTED_PROCESS_LIGHT_SIGNER => "1.3.6.1.4.1.311.10.3.22"

    /**
     * @type {String}
     */
    static szOID_WINDOWS_TCB_SIGNER => "1.3.6.1.4.1.311.10.3.23"

    /**
     * @type {String}
     */
    static szOID_PROTECTED_PROCESS_SIGNER => "1.3.6.1.4.1.311.10.3.24"

    /**
     * @type {String}
     */
    static szOID_WINDOWS_THIRD_PARTY_COMPONENT_SIGNER => "1.3.6.1.4.1.311.10.3.25"

    /**
     * @type {String}
     */
    static szOID_WINDOWS_SOFTWARE_EXTENSION_SIGNER => "1.3.6.1.4.1.311.10.3.26"

    /**
     * @type {String}
     */
    static szOID_DISALLOWED_LIST => "1.3.6.1.4.1.311.10.3.30"

    /**
     * @type {String}
     */
    static szOID_PIN_RULES_SIGNER => "1.3.6.1.4.1.311.10.3.31"

    /**
     * @type {String}
     */
    static szOID_PIN_RULES_CTL => "1.3.6.1.4.1.311.10.3.32"

    /**
     * @type {String}
     */
    static szOID_PIN_RULES_EXT => "1.3.6.1.4.1.311.10.3.33"

    /**
     * @type {String}
     */
    static szOID_PIN_RULES_DOMAIN_NAME => "1.3.6.1.4.1.311.10.3.34"

    /**
     * @type {String}
     */
    static szOID_PIN_RULES_LOG_END_DATE_EXT => "1.3.6.1.4.1.311.10.3.35"

    /**
     * @type {String}
     */
    static szOID_IUM_SIGNING => "1.3.6.1.4.1.311.10.3.37"

    /**
     * @type {String}
     */
    static szOID_EV_WHQL_CRYPTO => "1.3.6.1.4.1.311.10.3.39"

    /**
     * @type {String}
     */
    static szOID_BIOMETRIC_SIGNING => "1.3.6.1.4.1.311.10.3.41"

    /**
     * @type {String}
     */
    static szOID_ENCLAVE_SIGNING => "1.3.6.1.4.1.311.10.3.42"

    /**
     * @type {String}
     */
    static szOID_SYNC_ROOT_CTL_EXT => "1.3.6.1.4.1.311.10.3.50"

    /**
     * @type {String}
     */
    static szOID_HPKP_DOMAIN_NAME_CTL => "1.3.6.1.4.1.311.10.3.60"

    /**
     * @type {String}
     */
    static szOID_HPKP_HEADER_VALUE_CTL => "1.3.6.1.4.1.311.10.3.61"

    /**
     * @type {String}
     */
    static szOID_KP_KERNEL_MODE_HAL_EXTENSION_SIGNING => "1.3.6.1.4.1.311.61.5.1"

    /**
     * @type {String}
     */
    static szOID_WINDOWS_STORE_SIGNER => "1.3.6.1.4.1.311.76.3.1"

    /**
     * @type {String}
     */
    static szOID_DYNAMIC_CODE_GEN_SIGNER => "1.3.6.1.4.1.311.76.5.1"

    /**
     * @type {String}
     */
    static szOID_MICROSOFT_PUBLISHER_SIGNER => "1.3.6.1.4.1.311.76.8.1"

    /**
     * @type {String}
     */
    static szOID_YESNO_TRUST_ATTR => "1.3.6.1.4.1.311.10.4.1"

    /**
     * @type {String}
     */
    static szOID_SITE_PIN_RULES_INDEX_ATTR => "1.3.6.1.4.1.311.10.4.2"

    /**
     * @type {String}
     */
    static szOID_SITE_PIN_RULES_FLAGS_ATTR => "1.3.6.1.4.1.311.10.4.3"

    /**
     * @type {Integer (UInt32)}
     */
    static SITE_PIN_RULES_ALL_SUBDOMAINS_FLAG => 1

    /**
     * @type {String}
     */
    static szOID_PKIX_POLICY_QUALIFIER_CPS => "1.3.6.1.5.5.7.2.1"

    /**
     * @type {String}
     */
    static szOID_PKIX_POLICY_QUALIFIER_USERNOTICE => "1.3.6.1.5.5.7.2.2"

    /**
     * @type {String}
     */
    static szOID_ROOT_PROGRAM_FLAGS => "1.3.6.1.4.1.311.60.1.1"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ROOT_PROGRAM_FLAG_OU => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ROOT_PROGRAM_FLAG_ADDRESS => 8

    /**
     * @type {String}
     */
    static szOID_CERT_POLICIES_95_QUALIFIER1 => "2.16.840.1.113733.1.7.1.1"

    /**
     * @type {String}
     */
    static szOID_RDN_TPM_MANUFACTURER => "2.23.133.2.1"

    /**
     * @type {String}
     */
    static szOID_RDN_TPM_MODEL => "2.23.133.2.2"

    /**
     * @type {String}
     */
    static szOID_RDN_TPM_VERSION => "2.23.133.2.3"

    /**
     * @type {String}
     */
    static szOID_RDN_TCG_PLATFORM_MANUFACTURER => "2.23.133.2.4"

    /**
     * @type {String}
     */
    static szOID_RDN_TCG_PLATFORM_MODEL => "2.23.133.2.5"

    /**
     * @type {String}
     */
    static szOID_RDN_TCG_PLATFORM_VERSION => "2.23.133.2.6"

    /**
     * @type {String}
     */
    static szOID_CT_CERT_SCTLIST => "1.3.6.1.4.1.11129.2.4.2"

    /**
     * @type {String}
     */
    static szOID_ENROLL_EK_INFO => "1.3.6.1.4.1.311.21.23"

    /**
     * @type {String}
     */
    static szOID_ENROLL_AIK_INFO => "1.3.6.1.4.1.311.21.39"

    /**
     * @type {String}
     */
    static szOID_ENROLL_ATTESTATION_STATEMENT => "1.3.6.1.4.1.311.21.24"

    /**
     * @type {String}
     */
    static szOID_ENROLL_KSP_NAME => "1.3.6.1.4.1.311.21.25"

    /**
     * @type {String}
     */
    static szOID_ENROLL_EKPUB_CHALLENGE => "1.3.6.1.4.1.311.21.26"

    /**
     * @type {String}
     */
    static szOID_ENROLL_CAXCHGCERT_HASH => "1.3.6.1.4.1.311.21.27"

    /**
     * @type {String}
     */
    static szOID_ENROLL_ATTESTATION_CHALLENGE => "1.3.6.1.4.1.311.21.28"

    /**
     * @type {String}
     */
    static szOID_ENROLL_ENCRYPTION_ALGORITHM => "1.3.6.1.4.1.311.21.29"

    /**
     * @type {String}
     */
    static szOID_KP_TPM_EK_CERTIFICATE => "2.23.133.8.1"

    /**
     * @type {String}
     */
    static szOID_KP_TPM_PLATFORM_CERTIFICATE => "2.23.133.8.2"

    /**
     * @type {String}
     */
    static szOID_KP_TPM_AIK_CERTIFICATE => "2.23.133.8.3"

    /**
     * @type {String}
     */
    static szOID_ENROLL_EKVERIFYKEY => "1.3.6.1.4.1.311.21.30"

    /**
     * @type {String}
     */
    static szOID_ENROLL_EKVERIFYCERT => "1.3.6.1.4.1.311.21.31"

    /**
     * @type {String}
     */
    static szOID_ENROLL_EKVERIFYCREDS => "1.3.6.1.4.1.311.21.32"

    /**
     * @type {String}
     */
    static szOID_ENROLL_SCEP_ERROR => "1.3.6.1.4.1.311.21.33"

    /**
     * @type {String}
     */
    static szOID_ENROLL_SCEP_SERVER_STATE => "1.3.6.1.4.1.311.21.34"

    /**
     * @type {String}
     */
    static szOID_ENROLL_SCEP_CHALLENGE_ANSWER => "1.3.6.1.4.1.311.21.35"

    /**
     * @type {String}
     */
    static szOID_ENROLL_SCEP_CLIENT_REQUEST => "1.3.6.1.4.1.311.21.37"

    /**
     * @type {String}
     */
    static szOID_ENROLL_SCEP_SERVER_MESSAGE => "1.3.6.1.4.1.311.21.38"

    /**
     * @type {String}
     */
    static szOID_ENROLL_SCEP_SERVER_SECRET => "1.3.6.1.4.1.311.21.40"

    /**
     * @type {String}
     */
    static szOID_ENROLL_KEY_AFFINITY => "1.3.6.1.4.1.311.21.41"

    /**
     * @type {String}
     */
    static szOID_ENROLL_SCEP_SIGNER_HASH => "1.3.6.1.4.1.311.21.42"

    /**
     * @type {String}
     */
    static szOID_ENROLL_EK_CA_KEYID => "1.3.6.1.4.1.311.21.43"

    /**
     * @type {String}
     */
    static szOID_ATTR_SUPPORTED_ALGORITHMS => "2.5.4.52"

    /**
     * @type {String}
     */
    static szOID_ATTR_TPM_SPECIFICATION => "2.23.133.2.16"

    /**
     * @type {String}
     */
    static szOID_ATTR_PLATFORM_SPECIFICATION => "2.23.133.2.17"

    /**
     * @type {String}
     */
    static szOID_ATTR_TPM_SECURITY_ASSERTIONS => "2.23.133.2.18"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_UNICODE_RDN_ERR_INDEX_MASK => 1023

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_UNICODE_RDN_ERR_INDEX_SHIFT => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_UNICODE_ATTR_ERR_INDEX_MASK => 63

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_UNICODE_ATTR_ERR_INDEX_SHIFT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_UNICODE_VALUE_ERR_INDEX_MASK => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_UNICODE_VALUE_ERR_INDEX_SHIFT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DIGITAL_SIGNATURE_KEY_USAGE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NON_REPUDIATION_KEY_USAGE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_ENCIPHERMENT_KEY_USAGE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DATA_ENCIPHERMENT_KEY_USAGE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_AGREEMENT_KEY_USAGE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_CERT_SIGN_KEY_USAGE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_OFFLINE_CRL_SIGN_KEY_USAGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CRL_SIGN_KEY_USAGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ENCIPHER_ONLY_KEY_USAGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DECIPHER_ONLY_KEY_USAGE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ALT_NAME_X400_ADDRESS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ALT_NAME_EDI_PARTY_NAME => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ALT_NAME_ENTRY_ERR_INDEX_MASK => 255

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ALT_NAME_ENTRY_ERR_INDEX_SHIFT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ALT_NAME_VALUE_ERR_INDEX_MASK => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ALT_NAME_VALUE_ERR_INDEX_SHIFT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CA_SUBJECT_FLAG => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_END_ENTITY_SUBJECT_FLAG => 64

    /**
     * @type {String}
     */
    static szOID_PKIX_ACC_DESCR => "1.3.6.1.5.5.7.48"

    /**
     * @type {String}
     */
    static szOID_PKIX_OCSP => "1.3.6.1.5.5.7.48.1"

    /**
     * @type {String}
     */
    static szOID_PKIX_CA_ISSUERS => "1.3.6.1.5.5.7.48.2"

    /**
     * @type {String}
     */
    static szOID_PKIX_TIME_STAMPING => "1.3.6.1.5.5.7.48.3"

    /**
     * @type {String}
     */
    static szOID_PKIX_CA_REPOSITORY => "1.3.6.1.5.5.7.48.5"

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_PRIVILEGE_WITHDRAWN => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_AA_COMPROMISE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_DIST_POINT_NO_NAME => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_DIST_POINT_FULL_NAME => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_DIST_POINT_ISSUER_RDN_NAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_UNUSED_FLAG => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_KEY_COMPROMISE_FLAG => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_CA_COMPROMISE_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_AFFILIATION_CHANGED_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_SUPERSEDED_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_CESSATION_OF_OPERATION_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_CERTIFICATE_HOLD_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_PRIVILEGE_WITHDRAWN_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_REASON_AA_COMPROMISE_FLAG => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_DIST_POINT_ERR_INDEX_MASK => 127

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_DIST_POINT_ERR_INDEX_SHIFT => 24

    /**
     * @type {Integer (Int32)}
     */
    static CRL_DIST_POINT_ERR_CRL_ISSUER_BIT => -2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CROSS_CERT_DIST_POINT_ERR_INDEX_MASK => 255

    /**
     * @type {Integer (UInt32)}
     */
    static CROSS_CERT_DIST_POINT_ERR_INDEX_SHIFT => 24

    /**
     * @type {Integer (Int32)}
     */
    static CERT_EXCLUDED_SUBTREE_BIT => -2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static SORTED_CTL_EXT_HASHED_SUBJECT_IDENTIFIER_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DSS_R_LEN => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DSS_S_LEN => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_X942_COUNTER_BYTE_LENGTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_X942_KEY_LENGTH_BYTE_LENGTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ECC_CMS_SHARED_INFO_SUPPPUBINFO_BYTE_LENGTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_RC2_40BIT_VERSION => 160

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_RC2_56BIT_VERSION => 52

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_RC2_64BIT_VERSION => 120

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_RC2_128BIT_VERSION => 58

    /**
     * @type {String}
     */
    static szOID_QC_EU_COMPLIANCE => "0.4.0.1862.1.1"

    /**
     * @type {String}
     */
    static szOID_QC_SSCD => "0.4.0.1862.1.4"

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS_RSA_SSA_PSS_TRAILER_FIELD_BC => 1

    /**
     * @type {String}
     */
    static szOID_VERISIGN_PRIVATE_6_9 => "2.16.840.1.113733.1.6.9"

    /**
     * @type {String}
     */
    static szOID_VERISIGN_ONSITE_JURISDICTION_HASH => "2.16.840.1.113733.1.6.11"

    /**
     * @type {String}
     */
    static szOID_VERISIGN_BITSTRING_6_13 => "2.16.840.1.113733.1.6.13"

    /**
     * @type {String}
     */
    static szOID_VERISIGN_ISS_STRONG_CRYPTO => "2.16.840.1.113733.1.8.1"

    /**
     * @type {String}
     */
    static szOIDVerisign_MessageType => "2.16.840.1.113733.1.9.2"

    /**
     * @type {String}
     */
    static szOIDVerisign_PkiStatus => "2.16.840.1.113733.1.9.3"

    /**
     * @type {String}
     */
    static szOIDVerisign_FailInfo => "2.16.840.1.113733.1.9.4"

    /**
     * @type {String}
     */
    static szOIDVerisign_SenderNonce => "2.16.840.1.113733.1.9.5"

    /**
     * @type {String}
     */
    static szOIDVerisign_RecipientNonce => "2.16.840.1.113733.1.9.6"

    /**
     * @type {String}
     */
    static szOIDVerisign_TransactionID => "2.16.840.1.113733.1.9.7"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE => "2.16.840.1.113730"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_CERT_EXTENSION => "2.16.840.1.113730.1"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_CERT_TYPE => "2.16.840.1.113730.1.1"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_BASE_URL => "2.16.840.1.113730.1.2"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_REVOCATION_URL => "2.16.840.1.113730.1.3"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_CA_REVOCATION_URL => "2.16.840.1.113730.1.4"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_CERT_RENEWAL_URL => "2.16.840.1.113730.1.7"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_CA_POLICY_URL => "2.16.840.1.113730.1.8"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_SSL_SERVER_NAME => "2.16.840.1.113730.1.12"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_COMMENT => "2.16.840.1.113730.1.13"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_DATA_TYPE => "2.16.840.1.113730.2"

    /**
     * @type {String}
     */
    static szOID_NETSCAPE_CERT_SEQUENCE => "2.16.840.1.113730.2.5"

    /**
     * @type {Integer (UInt32)}
     */
    static NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static NETSCAPE_SSL_SERVER_AUTH_CERT_TYPE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NETSCAPE_SMIME_CERT_TYPE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NETSCAPE_SIGN_CERT_TYPE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static NETSCAPE_SSL_CA_CERT_TYPE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NETSCAPE_SMIME_CA_CERT_TYPE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NETSCAPE_SIGN_CA_CERT_TYPE => 1

    /**
     * @type {String}
     */
    static szOID_CT_PKI_DATA => "1.3.6.1.5.5.7.12.2"

    /**
     * @type {String}
     */
    static szOID_CT_PKI_RESPONSE => "1.3.6.1.5.5.7.12.3"

    /**
     * @type {String}
     */
    static szOID_PKIX_NO_SIGNATURE => "1.3.6.1.5.5.7.6.2"

    /**
     * @type {String}
     */
    static szOID_CMC => "1.3.6.1.5.5.7.7"

    /**
     * @type {String}
     */
    static szOID_CMC_STATUS_INFO => "1.3.6.1.5.5.7.7.1"

    /**
     * @type {String}
     */
    static szOID_CMC_IDENTIFICATION => "1.3.6.1.5.5.7.7.2"

    /**
     * @type {String}
     */
    static szOID_CMC_IDENTITY_PROOF => "1.3.6.1.5.5.7.7.3"

    /**
     * @type {String}
     */
    static szOID_CMC_DATA_RETURN => "1.3.6.1.5.5.7.7.4"

    /**
     * @type {String}
     */
    static szOID_CMC_TRANSACTION_ID => "1.3.6.1.5.5.7.7.5"

    /**
     * @type {String}
     */
    static szOID_CMC_SENDER_NONCE => "1.3.6.1.5.5.7.7.6"

    /**
     * @type {String}
     */
    static szOID_CMC_RECIPIENT_NONCE => "1.3.6.1.5.5.7.7.7"

    /**
     * @type {String}
     */
    static szOID_CMC_ADD_EXTENSIONS => "1.3.6.1.5.5.7.7.8"

    /**
     * @type {String}
     */
    static szOID_CMC_ENCRYPTED_POP => "1.3.6.1.5.5.7.7.9"

    /**
     * @type {String}
     */
    static szOID_CMC_DECRYPTED_POP => "1.3.6.1.5.5.7.7.10"

    /**
     * @type {String}
     */
    static szOID_CMC_LRA_POP_WITNESS => "1.3.6.1.5.5.7.7.11"

    /**
     * @type {String}
     */
    static szOID_CMC_GET_CERT => "1.3.6.1.5.5.7.7.15"

    /**
     * @type {String}
     */
    static szOID_CMC_GET_CRL => "1.3.6.1.5.5.7.7.16"

    /**
     * @type {String}
     */
    static szOID_CMC_REVOKE_REQUEST => "1.3.6.1.5.5.7.7.17"

    /**
     * @type {String}
     */
    static szOID_CMC_REG_INFO => "1.3.6.1.5.5.7.7.18"

    /**
     * @type {String}
     */
    static szOID_CMC_RESPONSE_INFO => "1.3.6.1.5.5.7.7.19"

    /**
     * @type {String}
     */
    static szOID_CMC_QUERY_PENDING => "1.3.6.1.5.5.7.7.21"

    /**
     * @type {String}
     */
    static szOID_CMC_ID_POP_LINK_RANDOM => "1.3.6.1.5.5.7.7.22"

    /**
     * @type {String}
     */
    static szOID_CMC_ID_POP_LINK_WITNESS => "1.3.6.1.5.5.7.7.23"

    /**
     * @type {String}
     */
    static szOID_CMC_ID_CONFIRM_CERT_ACCEPTANCE => "1.3.6.1.5.5.7.7.24"

    /**
     * @type {String}
     */
    static szOID_CMC_ADD_ATTRIBUTES => "1.3.6.1.4.1.311.10.10.1"

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_TAGGED_CERT_REQUEST_CHOICE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_OTHER_INFO_NO_CHOICE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_OTHER_INFO_FAIL_CHOICE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_OTHER_INFO_PEND_CHOICE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_STATUS_SUCCESS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_STATUS_FAILED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_STATUS_PENDING => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_STATUS_NO_SUPPORT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_STATUS_CONFIRM_REQUIRED => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_BAD_ALG => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_BAD_MESSAGE_CHECK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_BAD_REQUEST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_BAD_TIME => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_BAD_CERT_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_UNSUPORTED_EXT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_MUST_ARCHIVE_KEYS => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_BAD_IDENTITY => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_POP_REQUIRED => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_POP_FAILED => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_NO_KEY_REUSE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_INTERNAL_CA_ERROR => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CMC_FAIL_TRY_LATER => 12

    /**
     * @type {String}
     */
    static szOID_LOYALTY_OTHER_LOGOTYPE => "1.3.6.1.5.5.7.20.1"

    /**
     * @type {String}
     */
    static szOID_BACKGROUND_OTHER_LOGOTYPE => "1.3.6.1.5.5.7.20.2"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_BIOMETRIC_PICTURE_TYPE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_BIOMETRIC_SIGNATURE_TYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_REQUEST_V1 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_SUCCESSFUL_RESPONSE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_MALFORMED_REQUEST_RESPONSE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_INTERNAL_ERROR_RESPONSE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_TRY_LATER_RESPONSE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_SIG_REQUIRED_RESPONSE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_UNAUTHORIZED_RESPONSE => 6

    /**
     * @type {String}
     */
    static szOID_PKIX_OCSP_BASIC_SIGNED_RESPONSE => "1.3.6.1.5.5.7.48.1.1"

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_BASIC_GOOD_CERT_STATUS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_BASIC_REVOKED_CERT_STATUS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_BASIC_UNKNOWN_CERT_STATUS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_BASIC_RESPONSE_V1 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_BASIC_BY_NAME_RESPONDER_ID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static OCSP_BASIC_BY_KEY_RESPONDER_ID => 2

    /**
     * @type {String}
     */
    static CRYPT_OID_ENCODE_OBJECT_FUNC => "CryptDllEncodeObject"

    /**
     * @type {String}
     */
    static CRYPT_OID_DECODE_OBJECT_FUNC => "CryptDllDecodeObject"

    /**
     * @type {String}
     */
    static CRYPT_OID_ENCODE_OBJECT_EX_FUNC => "CryptDllEncodeObjectEx"

    /**
     * @type {String}
     */
    static CRYPT_OID_DECODE_OBJECT_EX_FUNC => "CryptDllDecodeObjectEx"

    /**
     * @type {String}
     */
    static CRYPT_OID_CREATE_COM_OBJECT_FUNC => "CryptDllCreateCOMObject"

    /**
     * @type {String}
     */
    static CRYPT_OID_VERIFY_REVOCATION_FUNC => "CertDllVerifyRevocation"

    /**
     * @type {String}
     */
    static CRYPT_OID_VERIFY_CTL_USAGE_FUNC => "CertDllVerifyCTLUsage"

    /**
     * @type {String}
     */
    static CRYPT_OID_FORMAT_OBJECT_FUNC => "CryptDllFormatObject"

    /**
     * @type {String}
     */
    static CRYPT_OID_FIND_OID_INFO_FUNC => "CryptDllFindOIDInfo"

    /**
     * @type {String}
     */
    static CRYPT_OID_FIND_LOCALIZED_NAME_FUNC => "CryptDllFindLocalizedName"

    /**
     * @type {String}
     */
    static CRYPT_OID_REGPATH => "Software\Microsoft\Cryptography\OID"

    /**
     * @type {String}
     */
    static CRYPT_OID_REG_ENCODING_TYPE_PREFIX => "EncodingType "

    /**
     * @type {String}
     */
    static CRYPT_OID_REG_DLL_VALUE_NAME => "Dll"

    /**
     * @type {String}
     */
    static CRYPT_OID_REG_FUNC_NAME_VALUE_NAME => "FuncName"

    /**
     * @type {String}
     */
    static CRYPT_OID_REG_FUNC_NAME_VALUE_NAME_A => "FuncName"

    /**
     * @type {String}
     */
    static CRYPT_OID_REG_FLAGS_VALUE_NAME => "CryptFlags"

    /**
     * @type {String}
     */
    static CRYPT_DEFAULT_OID => "DEFAULT"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_GET_INSTALLED_OID_FUNC_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_REGISTER_FIRST_INDEX => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_REGISTER_LAST_INDEX => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MATCH_ANY_ENCODING_TYPE => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CALG_OID_INFO_CNG_ONLY => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CALG_OID_INFO_PARAMETERS => 4294967294

    /**
     * @type {String}
     */
    static CRYPT_OID_INFO_HASH_PARAMETERS_ALGORITHM => "CryptOIDInfoHashParameters"

    /**
     * @type {String}
     */
    static CRYPT_OID_INFO_ECC_PARAMETERS_ALGORITHM => "CryptOIDInfoECCParameters"

    /**
     * @type {String}
     */
    static CRYPT_OID_INFO_MGF1_PARAMETERS_ALGORITHM => "CryptOIDInfoMgf1Parameters"

    /**
     * @type {String}
     */
    static CRYPT_OID_INFO_NO_SIGN_ALGORITHM => "CryptOIDInfoNoSign"

    /**
     * @type {String}
     */
    static CRYPT_OID_INFO_OAEP_PARAMETERS_ALGORITHM => "CryptOIDInfoOAEPParameters"

    /**
     * @type {String}
     */
    static CRYPT_OID_INFO_ECC_WRAP_PARAMETERS_ALGORITHM => "CryptOIDInfoECCWrapParameters"

    /**
     * @type {String}
     */
    static CRYPT_OID_INFO_NO_PARAMETERS_ALGORITHM => "CryptOIDInfoNoParameters"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_HASH_ALG_OID_GROUP_ID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ENCRYPT_ALG_OID_GROUP_ID => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_PUBKEY_ALG_OID_GROUP_ID => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SIGN_ALG_OID_GROUP_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_RDN_ATTR_OID_GROUP_ID => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_EXT_OR_ATTR_OID_GROUP_ID => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ENHKEY_USAGE_OID_GROUP_ID => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_POLICY_OID_GROUP_ID => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_TEMPLATE_OID_GROUP_ID => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_KDF_OID_GROUP_ID => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_LAST_OID_GROUP_ID => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_FIRST_ALG_OID_GROUP_ID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_LAST_ALG_OID_GROUP_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_PUBKEY_SIGN_ONLY_FLAG => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_PUBKEY_ENCRYPT_ONLY_FLAG => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_USE_CURVE_NAME_FOR_ENCODE_FLAG => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_USE_CURVE_PARAMETERS_FOR_ENCODE_FLAG => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_OID_KEY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_NAME_KEY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_ALGID_KEY => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_SIGN_KEY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_CNG_ALGID_KEY => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_CNG_SIGN_KEY => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_OID_KEY_FLAGS_MASK => 4294901760

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_DISABLE_SEARCH_DS_FLAG => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_PREFER_CNG_ALGID_FLAG => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_OID_GROUP_BIT_LEN_MASK => 268369920

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OID_INFO_OID_GROUP_BIT_LEN_SHIFT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_INSTALL_OID_INFO_BEFORE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_LOCALIZED_NAME_ENCODING_TYPE => 0

    /**
     * @type {String}
     */
    static CRYPT_LOCALIZED_NAME_OID => "LocalizedNames"

    /**
     * @type {String}
     */
    static CERT_STRONG_SIGN_ECDSA_ALGORITHM => "ECDSA"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STRONG_SIGN_SERIALIZED_INFO_CHOICE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STRONG_SIGN_OID_INFO_CHOICE => 2

    /**
     * @type {String}
     */
    static szOID_CERT_STRONG_SIGN_OS_PREFIX => "1.3.6.1.4.1.311.72.1."

    /**
     * @type {String}
     */
    static szOID_CERT_STRONG_SIGN_OS_1 => "1.3.6.1.4.1.311.72.1.1"

    /**
     * @type {String}
     */
    static szOID_CERT_STRONG_SIGN_OS_CURRENT => "1.3.6.1.4.1.311.72.1.1"

    /**
     * @type {String}
     */
    static szOID_CERT_STRONG_KEY_OS_PREFIX => "1.3.6.1.4.1.311.72.2."

    /**
     * @type {String}
     */
    static szOID_CERT_STRONG_KEY_OS_1 => "1.3.6.1.4.1.311.72.2.1"

    /**
     * @type {String}
     */
    static szOID_CERT_STRONG_KEY_OS_CURRENT => "1.3.6.1.4.1.311.72.2.1"

    /**
     * @type {String}
     */
    static szOID_PKCS_7_DATA => "1.2.840.113549.1.7.1"

    /**
     * @type {String}
     */
    static szOID_PKCS_7_SIGNED => "1.2.840.113549.1.7.2"

    /**
     * @type {String}
     */
    static szOID_PKCS_7_ENVELOPED => "1.2.840.113549.1.7.3"

    /**
     * @type {String}
     */
    static szOID_PKCS_7_SIGNEDANDENVELOPED => "1.2.840.113549.1.7.4"

    /**
     * @type {String}
     */
    static szOID_PKCS_7_DIGESTED => "1.2.840.113549.1.7.5"

    /**
     * @type {String}
     */
    static szOID_PKCS_7_ENCRYPTED => "1.2.840.113549.1.7.6"

    /**
     * @type {String}
     */
    static szOID_PKCS_9_CONTENT_TYPE => "1.2.840.113549.1.9.3"

    /**
     * @type {String}
     */
    static szOID_PKCS_9_MESSAGE_DIGEST => "1.2.840.113549.1.9.4"

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENCRYPTED => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_MAIL_LIST_HANDLE_KEY_CHOICE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_TRANS_RECIPIENT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_AGREE_RECIPIENT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_MAIL_LIST_RECIPIENT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_RC4_NO_SALT_FLAG => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_INDEFINITE_LENGTH => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_BARE_CONTENT_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_LENGTH_ONLY_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_DETACHED_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_AUTHENTICATED_ATTRIBUTES_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CONTENTS_OCTETS_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_MAX_LENGTH_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CMS_ENCAPSULATED_CONTENT_FLAG => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNED_DATA_NO_SIGN_FLAG => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CRYPT_RELEASE_CONTEXT_FLAG => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_TYPE_PARAM => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CONTENT_PARAM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_BARE_CONTENT_PARAM => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_INNER_CONTENT_TYPE_PARAM => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_COUNT_PARAM => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_INFO_PARAM => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_CERT_INFO_PARAM => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_HASH_ALGORITHM_PARAM => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_AUTH_ATTR_PARAM => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_UNAUTH_ATTR_PARAM => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CERT_COUNT_PARAM => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CERT_PARAM => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CRL_COUNT_PARAM => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CRL_PARAM => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPE_ALGORITHM_PARAM => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_RECIPIENT_COUNT_PARAM => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_RECIPIENT_INDEX_PARAM => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_RECIPIENT_INFO_PARAM => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_HASH_ALGORITHM_PARAM => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_HASH_DATA_PARAM => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_COMPUTED_HASH_PARAM => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENCRYPT_PARAM => 26

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENCRYPTED_DIGEST => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENCODED_SIGNER => 28

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENCODED_MESSAGE => 29

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_VERSION_PARAM => 30

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ATTR_CERT_COUNT_PARAM => 31

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ATTR_CERT_PARAM => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CMS_RECIPIENT_COUNT_PARAM => 33

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CMS_RECIPIENT_INDEX_PARAM => 34

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM => 35

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CMS_RECIPIENT_INFO_PARAM => 36

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_UNPROTECTED_ATTR_PARAM => 37

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_CERT_ID_PARAM => 38

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CMS_SIGNER_INFO_PARAM => 39

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNED_DATA_V1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNED_DATA_V3 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNED_DATA_PKCS_1_5_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNED_DATA_CMS_VERSION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_INFO_V1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_INFO_V3 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_INFO_PKCS_1_5_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_INFO_CMS_VERSION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_HASHED_DATA_V0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_HASHED_DATA_V2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_HASHED_DATA_PKCS_1_5_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_HASHED_DATA_CMS_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPED_DATA_V0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPED_DATA_V2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPED_DATA_CMS_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPED_RECIPIENT_V0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPED_RECIPIENT_V2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPED_RECIPIENT_V3 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENVELOPED_RECIPIENT_V4 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_TRANS_PKCS_1_5_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_TRANS_CMS_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_AGREE_VERSION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_MAIL_LIST_VERSION => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_VERIFY_SIGNATURE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_DECRYPT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_VERIFY_HASH => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_ADD_SIGNER => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_DEL_SIGNER => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_ADD_CERT => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_DEL_CERT => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_ADD_CRL => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_DEL_CRL => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_ADD_ATTR_CERT => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_DEL_ATTR_CERT => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_KEY_TRANS_DECRYPT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_KEY_AGREE_DECRYPT => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_MAIL_LIST_DECRYPT => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_VERIFY_SIGNATURE_EX => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_ADD_CMS_SIGNER_INFO => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CTRL_ENABLE_STRONG_SIGNATURE => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_VERIFY_SIGNER_PUBKEY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_VERIFY_SIGNER_CERT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_VERIFY_SIGNER_CHAIN => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_VERIFY_SIGNER_NULL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_VERIFY_COUNTER_SIGN_ENABLE_STRONG_FLAG => 1

    /**
     * @type {String}
     */
    static CMSG_OID_GEN_ENCRYPT_KEY_FUNC => "CryptMsgDllGenEncryptKey"

    /**
     * @type {String}
     */
    static CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC => "CryptMsgDllExportEncryptKey"

    /**
     * @type {String}
     */
    static CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC => "CryptMsgDllImportEncryptKey"

    /**
     * @type {Integer (Int32)}
     */
    static CMSG_DEFAULT_INSTALLABLE_FUNC_OID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CONTENT_ENCRYPT_FREE_OBJID_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG => 32768

    /**
     * @type {String}
     */
    static CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC => "CryptMsgDllGenContentEncryptKey"

    /**
     * @type {String}
     */
    static CMSG_OID_CAPI1_GEN_CONTENT_ENCRYPT_KEY_FUNC => "CryptMsgDllGenContentEncryptKey"

    /**
     * @type {String}
     */
    static CMSG_OID_CNG_GEN_CONTENT_ENCRYPT_KEY_FUNC => "CryptMsgDllCNGGenContentEncryptKey"

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_TRANS_ENCRYPT_FREE_PARA_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_TRANS_ENCRYPT_FREE_OBJID_FLAG => 2

    /**
     * @type {String}
     */
    static CMSG_OID_EXPORT_KEY_TRANS_FUNC => "CryptMsgDllExportKeyTrans"

    /**
     * @type {String}
     */
    static CMSG_OID_CAPI1_EXPORT_KEY_TRANS_FUNC => "CryptMsgDllExportKeyTrans"

    /**
     * @type {String}
     */
    static CMSG_OID_CNG_EXPORT_KEY_TRANS_FUNC => "CryptMsgDllCNGExportKeyTrans"

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_AGREE_ENCRYPT_FREE_MATERIAL_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_ALG_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_PARA_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_BITS_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_KEY_AGREE_ENCRYPT_FREE_OBJID_FLAG => 32

    /**
     * @type {String}
     */
    static CMSG_OID_EXPORT_KEY_AGREE_FUNC => "CryptMsgDllExportKeyAgree"

    /**
     * @type {String}
     */
    static CMSG_OID_CAPI1_EXPORT_KEY_AGREE_FUNC => "CryptMsgDllExportKeyAgree"

    /**
     * @type {String}
     */
    static CMSG_OID_CNG_EXPORT_KEY_AGREE_FUNC => "CryptMsgDllCNGExportKeyAgree"

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_MAIL_LIST_ENCRYPT_FREE_OBJID_FLAG => 2

    /**
     * @type {String}
     */
    static CMSG_OID_EXPORT_MAIL_LIST_FUNC => "CryptMsgDllExportMailList"

    /**
     * @type {String}
     */
    static CMSG_OID_CAPI1_EXPORT_MAIL_LIST_FUNC => "CryptMsgDllExportMailList"

    /**
     * @type {String}
     */
    static CMSG_OID_IMPORT_KEY_TRANS_FUNC => "CryptMsgDllImportKeyTrans"

    /**
     * @type {String}
     */
    static CMSG_OID_CAPI1_IMPORT_KEY_TRANS_FUNC => "CryptMsgDllImportKeyTrans"

    /**
     * @type {String}
     */
    static CMSG_OID_IMPORT_KEY_AGREE_FUNC => "CryptMsgDllImportKeyAgree"

    /**
     * @type {String}
     */
    static CMSG_OID_CAPI1_IMPORT_KEY_AGREE_FUNC => "CryptMsgDllImportKeyAgree"

    /**
     * @type {String}
     */
    static CMSG_OID_IMPORT_MAIL_LIST_FUNC => "CryptMsgDllImportMailList"

    /**
     * @type {String}
     */
    static CMSG_OID_CAPI1_IMPORT_MAIL_LIST_FUNC => "CryptMsgDllImportMailList"

    /**
     * @type {String}
     */
    static CMSG_OID_CNG_IMPORT_KEY_TRANS_FUNC => "CryptMsgDllCNGImportKeyTrans"

    /**
     * @type {String}
     */
    static CMSG_OID_CNG_IMPORT_KEY_AGREE_FUNC => "CryptMsgDllCNGImportKeyAgree"

    /**
     * @type {String}
     */
    static CMSG_OID_CNG_IMPORT_CONTENT_ENCRYPT_KEY_FUNC => "CryptMsgDllCNGImportContentEncryptKey"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_PROV_HANDLE_PROP_ID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_PROV_INFO_PROP_ID => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SHA1_HASH_PROP_ID => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_MD5_HASH_PROP_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_HASH_PROP_ID => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_CONTEXT_PROP_ID => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_SPEC_PROP_ID => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_IE30_RESERVED_PROP_ID => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PUBKEY_HASH_RESERVED_PROP_ID => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ENHKEY_USAGE_PROP_ID => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CTL_USAGE_PROP_ID => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NEXT_UPDATE_LOCATION_PROP_ID => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_FRIENDLY_NAME_PROP_ID => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PVK_FILE_PROP_ID => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DESCRIPTION_PROP_ID => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ACCESS_STATE_PROP_ID => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SIGNATURE_HASH_PROP_ID => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SMART_CARD_DATA_PROP_ID => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_EFS_PROP_ID => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_FORTEZZA_DATA_PROP_ID => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ARCHIVED_PROP_ID => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_IDENTIFIER_PROP_ID => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_AUTO_ENROLL_PROP_ID => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PUBKEY_ALG_PARA_PROP_ID => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CROSS_CERT_DIST_POINTS_PROP_ID => 23

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID => 24

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID => 25

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ENROLLMENT_PROP_ID => 26

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DATE_STAMP_PROP_ID => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID => 28

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SUBJECT_NAME_MD5_HASH_PROP_ID => 29

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_EXTENDED_ERROR_INFO_PROP_ID => 30

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_RENEWAL_PROP_ID => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ARCHIVED_KEY_HASH_PROP_ID => 65

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_AUTO_ENROLL_RETRY_PROP_ID => 66

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_AIA_URL_RETRIEVED_PROP_ID => 67

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_AUTHORITY_INFO_ACCESS_PROP_ID => 68

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_BACKED_UP_PROP_ID => 69

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_OCSP_RESPONSE_PROP_ID => 70

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REQUEST_ORIGINATOR_PROP_ID => 71

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SOURCE_LOCATION_PROP_ID => 72

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SOURCE_URL_PROP_ID => 73

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NEW_KEY_PROP_ID => 74

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_OCSP_CACHE_PREFIX_PROP_ID => 75

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SMART_CARD_ROOT_INFO_PROP_ID => 76

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NO_AUTO_EXPIRE_CHECK_PROP_ID => 77

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NCRYPT_KEY_HANDLE_PROP_ID => 78

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID => 79

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SUBJECT_INFO_ACCESS_PROP_ID => 80

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CA_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID => 81

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CA_DISABLE_CRL_PROP_ID => 82

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ROOT_PROGRAM_CERT_POLICIES_PROP_ID => 83

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID => 84

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SUBJECT_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID => 85

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SUBJECT_DISABLE_CRL_PROP_ID => 86

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CEP_PROP_ID => 87

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SIGN_HASH_CNG_ALG_PROP_ID => 89

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCARD_PIN_ID_PROP_ID => 90

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCARD_PIN_INFO_PROP_ID => 91

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SUBJECT_PUB_KEY_BIT_LENGTH_PROP_ID => 92

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID => 93

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID => 94

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID => 95

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID => 96

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NO_EXPIRE_NOTIFICATION_PROP_ID => 97

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_AUTH_ROOT_SHA256_HASH_PROP_ID => 98

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NCRYPT_KEY_HANDLE_TRANSFER_PROP_ID => 99

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_HCRYPTPROV_TRANSFER_PROP_ID => 100

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SMART_CARD_READER_PROP_ID => 101

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SEND_AS_TRUSTED_ISSUER_PROP_ID => 102

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_REPAIR_ATTEMPTED_PROP_ID => 103

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DISALLOWED_FILETIME_PROP_ID => 104

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ROOT_PROGRAM_CHAIN_POLICIES_PROP_ID => 105

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SMART_CARD_READER_NON_REMOVABLE_PROP_ID => 106

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SHA256_HASH_PROP_ID => 107

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_SERVER_CERTS_PROP_ID => 108

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_RA_SIGNATURE_CERT_PROP_ID => 109

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_RA_ENCRYPTION_CERT_PROP_ID => 110

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_CA_CERT_PROP_ID => 111

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_SIGNER_CERT_PROP_ID => 112

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_NONCE_PROP_ID => 113

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_ENCRYPT_HASH_CNG_ALG_PROP_ID => 114

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_FLAGS_PROP_ID => 115

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SCEP_GUID_PROP_ID => 116

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SERIALIZABLE_KEY_CONTEXT_PROP_ID => 117

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ISOLATED_KEY_PROP_ID => 118

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SERIAL_CHAIN_PROP_ID => 119

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_KEY_CLASSIFICATION_PROP_ID => 120

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_OCSP_MUST_STAPLE_PROP_ID => 121

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DISALLOWED_ENHKEY_USAGE_PROP_ID => 122

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NONCOMPLIANT_ROOT_URL_PROP_ID => 123

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PIN_SHA256_HASH_PROP_ID => 124

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CLR_DELETE_KEY_PROP_ID => 125

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NOT_BEFORE_FILETIME_PROP_ID => 126

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NOT_BEFORE_ENHKEY_USAGE_PROP_ID => 127

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_DISALLOWED_CA_FILETIME_PROP_ID => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_FIRST_RESERVED_PROP_ID => 129

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_LAST_RESERVED_PROP_ID => 32767

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_FIRST_USER_PROP_ID => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_LAST_USER_PROP_ID => 65535

    /**
     * @type {String}
     */
    static szOID_CERT_PROP_ID_PREFIX => "1.3.6.1.4.1.311.10.11."

    /**
     * @type {String}
     */
    static szOID_CERT_KEY_IDENTIFIER_PROP_ID => "1.3.6.1.4.1.311.10.11.20"

    /**
     * @type {String}
     */
    static szOID_CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID => "1.3.6.1.4.1.311.10.11.28"

    /**
     * @type {String}
     */
    static szOID_CERT_SUBJECT_NAME_MD5_HASH_PROP_ID => "1.3.6.1.4.1.311.10.11.29"

    /**
     * @type {String}
     */
    static szOID_CERT_MD5_HASH_PROP_ID => "1.3.6.1.4.1.311.10.11.4"

    /**
     * @type {String}
     */
    static szOID_CERT_SIGNATURE_HASH_PROP_ID => "1.3.6.1.4.1.311.10.11.15"

    /**
     * @type {String}
     */
    static szOID_DISALLOWED_HASH => "1.3.6.1.4.1.311.10.11.15"

    /**
     * @type {String}
     */
    static szOID_CERT_DISALLOWED_FILETIME_PROP_ID => "1.3.6.1.4.1.311.10.11.104"

    /**
     * @type {String}
     */
    static szOID_CERT_DISALLOWED_CA_FILETIME_PROP_ID => "1.3.6.1.4.1.311.10.11.128"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ACCESS_STATE_WRITE_PERSIST_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ACCESS_STATE_SYSTEM_STORE_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ACCESS_STATE_LM_SYSTEM_STORE_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ACCESS_STATE_GP_SYSTEM_STORE_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_ACCESS_STATE_SHARED_USER_FLAG => 16

    /**
     * @type {String}
     */
    static szOID_ROOT_PROGRAM_AUTO_UPDATE_CA_REVOCATION => "1.3.6.1.4.1.311.60.3.1"

    /**
     * @type {String}
     */
    static szOID_ROOT_PROGRAM_AUTO_UPDATE_END_REVOCATION => "1.3.6.1.4.1.311.60.3.2"

    /**
     * @type {String}
     */
    static szOID_ROOT_PROGRAM_NO_OCSP_FAILOVER_TO_CRL => "1.3.6.1.4.1.311.60.3.3"

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_MSG => 1

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_MEMORY => 2

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_FILE => 3

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_REG => 4

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_PKCS7 => 5

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SERIALIZED => 6

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_FILENAME_A => 7

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_FILENAME_W => 8

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_FILENAME => 8

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SYSTEM_A => 9

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SYSTEM_W => 10

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SYSTEM => 10

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_COLLECTION => 11

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SYSTEM_REGISTRY_A => 12

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SYSTEM_REGISTRY_W => 13

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SYSTEM_REGISTRY => 13

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_PHYSICAL_W => 14

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_PHYSICAL => 14

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SMART_CARD_W => 15

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_SMART_CARD => 15

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_LDAP_W => 16

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_LDAP => 16

    /**
     * @type {Integer (Int32)}
     */
    static CERT_STORE_PROV_PKCS12 => 17

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_MEMORY => "Memory"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_FILENAME_W => "File"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_FILENAME => "File"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_SYSTEM_W => "System"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_SYSTEM => "System"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_PKCS7 => "PKCS7"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_PKCS12 => "PKCS12"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_SERIALIZED => "Serialized"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_COLLECTION => "Collection"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W => "SystemRegistry"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_SYSTEM_REGISTRY => "SystemRegistry"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_PHYSICAL_W => "Physical"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_PHYSICAL => "Physical"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_SMART_CARD_W => "SmartCard"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_SMART_CARD => "SmartCard"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_LDAP_W => "Ldap"

    /**
     * @type {String}
     */
    static sz_CERT_STORE_PROV_LDAP => "Ldap"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_SIGNATURE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_TIME_VALIDITY_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_REVOCATION_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_NO_CRL_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_NO_ISSUER_FLAG => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_BASE_CRL_FLAG => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_DELTA_CRL_FLAG => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_UNSAFE_PHYSICAL_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_SHARE_STORE_FLAG => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_MANIFOLD_FLAG => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_MASK => 4294901760

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_UNPROTECTED_FLAG => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_DEFER_READ_FLAG => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_LOCATION_SHIFT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_CURRENT_USER_ID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_LOCAL_MACHINE_ID => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_CURRENT_SERVICE_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_SERVICES_ID => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_USERS_ID => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SYSTEM_STORE_LOCAL_MACHINE_WCOS_ID => 10

    /**
     * @type {String}
     */
    static CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH => "Software\Policies\Microsoft\SystemCertificates"

    /**
     * @type {String}
     */
    static CERT_EFSBLOB_VALUE_NAME => "EFSBlob"

    /**
     * @type {String}
     */
    static CERT_PROT_ROOT_FLAGS_VALUE_NAME => "Flags"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PROT_ROOT_INHIBIT_ADD_AT_INIT_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PROT_ROOT_ONLY_LM_GPT_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PROT_ROOT_DISABLE_NOT_DEFINED_NAME_CONSTRAINT_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PROT_ROOT_DISABLE_PEER_TRUST => 65536

    /**
     * @type {String}
     */
    static CERT_PROT_ROOT_PEER_USAGES_VALUE_NAME => "PeerUsages"

    /**
     * @type {String}
     */
    static CERT_PROT_ROOT_PEER_USAGES_VALUE_NAME_A => "PeerUsages"

    /**
     * @type {String}
     */
    static CERT_LOCAL_MACHINE_SYSTEM_STORE_REGPATH => "Software\Microsoft\SystemCertificates"

    /**
     * @type {String}
     */
    static CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME => "AuthenticodeFlags"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_PUB_ALLOW_TRUST_MASK => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_PUB_ALLOW_END_USER_TRUST => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_PUB_CHECK_PUBLISHER_REV_FLAG => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_PUB_CHECK_TIMESTAMP_REV_FLAG => 512

    /**
     * @type {String}
     */
    static CERT_OCM_SUBCOMPONENTS_LOCAL_MACHINE_REGPATH => "SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OC Manager\Subcomponents"

    /**
     * @type {String}
     */
    static CERT_OCM_SUBCOMPONENTS_ROOT_AUTO_UPDATE_VALUE_NAME => "RootAutoUpdate"

    /**
     * @type {String}
     */
    static CERT_DISABLE_ROOT_AUTO_UPDATE_VALUE_NAME => "DisableRootAutoUpdate"

    /**
     * @type {String}
     */
    static CERT_ENABLE_DISALLOWED_CERT_AUTO_UPDATE_VALUE_NAME => "EnableDisallowedCertAutoUpdate"

    /**
     * @type {String}
     */
    static CERT_DISABLE_PIN_RULES_AUTO_UPDATE_VALUE_NAME => "DisablePinRulesAutoUpdate"

    /**
     * @type {String}
     */
    static CERT_AUTO_UPDATE_ROOT_DIR_URL_VALUE_NAME => "RootDirUrl"

    /**
     * @type {String}
     */
    static CERT_AUTO_UPDATE_SYNC_FROM_DIR_URL_VALUE_NAME => "SyncFromDirUrl"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_AUTO_UPDATE_ROOT_DIR_URL_VALUE_NAME => "RootDirUrl"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME => "SyncDeltaTime"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_AUTO_UPDATE_FLAGS_VALUE_NAME => "Flags"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_AUTO_UPDATE_DISABLE_RANDOM_QUERY_STRING_FLAG => 4

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME => "LastSyncTime"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME => "EncodedCtl"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_CTL_FILENAME => "authroot.stl"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_CTL_FILENAME_A => "authroot.stl"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_CAB_FILENAME => "authrootstl.cab"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_SEQ_FILENAME => "authrootseq.txt"

    /**
     * @type {String}
     */
    static CERT_AUTH_ROOT_CERT_EXT => ".crt"

    /**
     * @type {String}
     */
    static CERT_DISALLOWED_CERT_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME => "DisallowedCertSyncDeltaTime"

    /**
     * @type {String}
     */
    static CERT_DISALLOWED_CERT_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME => "DisallowedCertLastSyncTime"

    /**
     * @type {String}
     */
    static CERT_DISALLOWED_CERT_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME => "DisallowedCertEncodedCtl"

    /**
     * @type {String}
     */
    static CERT_DISALLOWED_CERT_CTL_FILENAME => "disallowedcert.stl"

    /**
     * @type {String}
     */
    static CERT_DISALLOWED_CERT_CTL_FILENAME_A => "disallowedcert.stl"

    /**
     * @type {String}
     */
    static CERT_DISALLOWED_CERT_CAB_FILENAME => "disallowedcertstl.cab"

    /**
     * @type {String}
     */
    static CERT_DISALLOWED_CERT_AUTO_UPDATE_LIST_IDENTIFIER => "DisallowedCert_AutoUpdate_1"

    /**
     * @type {String}
     */
    static CERT_PIN_RULES_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME => "PinRulesSyncDeltaTime"

    /**
     * @type {String}
     */
    static CERT_PIN_RULES_AUTO_UPDATE_LAST_SYNC_TIME_VALUE_NAME => "PinRulesLastSyncTime"

    /**
     * @type {String}
     */
    static CERT_PIN_RULES_AUTO_UPDATE_ENCODED_CTL_VALUE_NAME => "PinRulesEncodedCtl"

    /**
     * @type {String}
     */
    static CERT_PIN_RULES_CTL_FILENAME => "pinrules.stl"

    /**
     * @type {String}
     */
    static CERT_PIN_RULES_CTL_FILENAME_A => "pinrules.stl"

    /**
     * @type {String}
     */
    static CERT_PIN_RULES_CAB_FILENAME => "pinrulesstl.cab"

    /**
     * @type {String}
     */
    static CERT_PIN_RULES_AUTO_UPDATE_LIST_IDENTIFIER => "PinRules_AutoUpdate_1"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REGISTRY_STORE_REMOTE_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REGISTRY_STORE_SERIALIZED_FLAG => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REGISTRY_STORE_CLIENT_GPT_FLAG => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REGISTRY_STORE_LM_GPT_FLAG => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REGISTRY_STORE_ROAMING_FLAG => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_REGISTRY_STORE_EXTERNAL_FLAG => 1048576

    /**
     * @type {String}
     */
    static CERT_IE_DIRTY_FLAGS_REGPATH => "Software\Microsoft\Cryptography\IEDirtyFlags"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_FILE_STORE_COMMIT_ENABLE_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_LDAP_STORE_SIGN_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_LDAP_STORE_AREC_EXCLUSIVE_FLAG => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_LDAP_STORE_OPENED_FLAG => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_LDAP_STORE_UNBIND_FLAG => 524288

    /**
     * @type {String}
     */
    static CRYPT_OID_OPEN_STORE_PROV_FUNC => "CertDllOpenStoreProv"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_GP_SYSTEM_STORE_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_SHARED_USER_FLAG => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_CLOSE_FUNC => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_READ_CERT_FUNC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_WRITE_CERT_FUNC => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_DELETE_CERT_FUNC => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_READ_CRL_FUNC => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_WRITE_CRL_FUNC => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_DELETE_CRL_FUNC => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_READ_CTL_FUNC => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_WRITE_CTL_FUNC => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_DELETE_CTL_FUNC => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_CONTROL_FUNC => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_FIND_CERT_FUNC => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_FREE_FIND_CERT_FUNC => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_GET_CERT_PROPERTY_FUNC => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_FIND_CRL_FUNC => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_FREE_FIND_CRL_FUNC => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_GET_CRL_PROPERTY_FUNC => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_FIND_CTL_FUNC => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_FREE_FIND_CTL_FUNC => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_GET_CTL_PROPERTY_FUNC => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_PROV_WRITE_ADD_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_SAVE_AS_PKCS12 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CLOSE_STORE_FORCE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CLOSE_STORE_CHECK_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_MASK => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_SHA1_HASH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_NAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_ATTR => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_MD5_HASH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_PROPERTY => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_PUBLIC_KEY => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_HASH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_NAME_STR_A => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_NAME_STR_W => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_KEY_SPEC => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_ENHKEY_USAGE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_CTL_USAGE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_SUBJECT_CERT => 11

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_ISSUER_OF => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_EXISTING => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_SIGNATURE_HASH => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_KEY_IDENTIFIER => 15

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_CERT_ID => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_CROSS_CERT_DIST_POINTS => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_PUBKEY_MD5_HASH => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_SUBJECT_INFO_ACCESS => 19

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_HASH_STR => 20

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_COMPARE_HAS_PRIVATE_KEY => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CTL_ENTRY_FROM_PROP_CHAIN_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_ISSUED_BY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_EXISTING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_ISSUED_FOR => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_ISSUED_BY_AKI_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_ISSUED_BY_SIGNATURE_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_ISSUED_BY_DELTA_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_ISSUED_BY_BASE_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRL_FIND_ISSUED_FOR_SET_STRONG_PROPERTIES_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_ADD_NEW => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_ADD_USE_EXISTING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_ADD_REPLACE_EXISTING => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_ADD_ALWAYS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_ADD_NEWER => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_CERTIFICATE_CONTEXT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_CRL_CONTEXT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_CTL_CONTEXT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CTL_ANY_SUBJECT_TYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTL_CERT_SUBJECT_TYPE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CTL_FIND_NO_LIST_ID_CBDATA => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_CTRL_RESYNC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_CTRL_NOTIFY_CHANGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_CTRL_COMMIT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_CTRL_AUTO_RESYNC => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_CTRL_CANCEL_NOTIFY => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_STORE_LOCALIZED_NAME_PROP_ID => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CREATE_CONTEXT_NOCOPY_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CREATE_CONTEXT_SORTED_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CREATE_CONTEXT_NO_ENTRY_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG => 1

    /**
     * @type {String}
     */
    static CERT_PHYSICAL_STORE_DEFAULT_NAME => ".Default"

    /**
     * @type {String}
     */
    static CERT_PHYSICAL_STORE_GROUP_POLICY_NAME => ".GroupPolicy"

    /**
     * @type {String}
     */
    static CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME => ".LocalMachine"

    /**
     * @type {String}
     */
    static CERT_PHYSICAL_STORE_DS_USER_CERTIFICATE_NAME => ".UserCertificate"

    /**
     * @type {String}
     */
    static CERT_PHYSICAL_STORE_LOCAL_MACHINE_GROUP_POLICY_NAME => ".LocalMachineGroupPolicy"

    /**
     * @type {String}
     */
    static CERT_PHYSICAL_STORE_ENTERPRISE_NAME => ".Enterprise"

    /**
     * @type {String}
     */
    static CERT_PHYSICAL_STORE_AUTH_ROOT_NAME => ".AuthRoot"

    /**
     * @type {String}
     */
    static CERT_PHYSICAL_STORE_SMART_CARD_NAME => ".SmartCard"

    /**
     * @type {String}
     */
    static CRYPT_OID_OPEN_SYSTEM_STORE_PROV_FUNC => "CertDllOpenSystemStoreProv"

    /**
     * @type {String}
     */
    static CRYPT_OID_REGISTER_SYSTEM_STORE_FUNC => "CertDllRegisterSystemStore"

    /**
     * @type {String}
     */
    static CRYPT_OID_UNREGISTER_SYSTEM_STORE_FUNC => "CertDllUnregisterSystemStore"

    /**
     * @type {String}
     */
    static CRYPT_OID_ENUM_SYSTEM_STORE_FUNC => "CertDllEnumSystemStore"

    /**
     * @type {String}
     */
    static CRYPT_OID_REGISTER_PHYSICAL_STORE_FUNC => "CertDllRegisterPhysicalStore"

    /**
     * @type {String}
     */
    static CRYPT_OID_UNREGISTER_PHYSICAL_STORE_FUNC => "CertDllUnregisterPhysicalStore"

    /**
     * @type {String}
     */
    static CRYPT_OID_ENUM_PHYSICAL_STORE_FUNC => "CertDllEnumPhysicalStore"

    /**
     * @type {String}
     */
    static CRYPT_OID_SYSTEM_STORE_LOCATION_VALUE_NAME => "SystemStoreLocation"

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_TRUSTED_SIGNER_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_SIGNER_ONLY_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_USE_SIGNER_INDEX_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_CMS_ENCAPSULATED_CTL_FLAG => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENCODE_SORTED_CTL_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_TRUSTED_SIGNERS_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_NO_TIME_CHECK_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_ALLOW_MORE_USAGE_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_UPDATED_CTL_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CONTEXT_REVOCATION_TYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_REV_CHAIN_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_REV_SERVER_OCSP_FLAG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_REV_NO_OCSP_FAILOVER_TO_CRL_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_VERIFY_REV_SERVER_OCSP_WIRE_ONLY_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_UNICODE_IS_RDN_ATTRS_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_SUBJECT_OCSP_BASIC_SIGNED_RESPONSE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CERT_SIGN_CHECK_WEAK_HASH_FLAG => 8

    /**
     * @type {String}
     */
    static CRYPT_OID_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC => "CryptDllExtractEncodedSignatureParameters"

    /**
     * @type {String}
     */
    static CRYPT_OID_SIGN_AND_ENCODE_HASH_FUNC => "CryptDllSignAndEncodeHash"

    /**
     * @type {String}
     */
    static CRYPT_OID_VERIFY_ENCODED_SIGNATURE_FUNC => "CryptDllVerifyEncodedSignature"

    /**
     * @type {String}
     */
    static CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC => "CryptDllExportPublicKeyInfoEx"

    /**
     * @type {String}
     */
    static CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC => "CryptDllExportPublicKeyInfoEx2"

    /**
     * @type {String}
     */
    static CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC => "CryptDllExportPublicKeyInfoFromBCryptKeyHandle"

    /**
     * @type {String}
     */
    static CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC => "CryptDllImportPublicKeyInfoEx"

    /**
     * @type {String}
     */
    static CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC => "CryptDllImportPublicKeyInfoEx2"

    /**
     * @type {String}
     */
    static CRYPT_OID_IMPORT_PRIVATE_KEY_INFO_FUNC => "CryptDllImportPrivateKeyInfoEx"

    /**
     * @type {String}
     */
    static CRYPT_OID_EXPORT_PRIVATE_KEY_INFO_FUNC => "CryptDllExportPrivateKeyInfoEx"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DELETE_KEYSET => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_XML_NAME_STR => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_SEMICOLON_FLAG => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_NO_PLUS_FLAG => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_NO_QUOTING_FLAG => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_CRLF_FLAG => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_COMMA_FLAG => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_REVERSE_FLAG => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_FORWARD_FLAG => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_DISABLE_UTF8_DIR_STR_FLAG => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_STR_ENABLE_PUNYCODE_FLAG => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_EMAIL_TYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_RDN_TYPE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_ATTR_TYPE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_SIMPLE_DISPLAY_TYPE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_FRIENDLY_DISPLAY_TYPE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_DNS_TYPE => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_URL_TYPE => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_UPN_TYPE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_ISSUER_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_DISABLE_IE4_UTF8_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_NAME_SEARCH_ALL_NAMES_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MESSAGE_KEYID_SIGNER_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MESSAGE_SILENT_KEYSET_FLAG => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG => 4

    /**
     * @type {Integer (Int32)}
     */
    static CREDENTIAL_OID_PASSWORD_CREDENTIALS_A => 1

    /**
     * @type {Integer (Int32)}
     */
    static CREDENTIAL_OID_PASSWORD_CREDENTIALS_W => 2

    /**
     * @type {Integer (Int32)}
     */
    static CREDENTIAL_OID_PASSWORD_CREDENTIALS => 2

    /**
     * @type {String}
     */
    static SCHEME_OID_RETRIEVE_ENCODED_OBJECT_FUNC => "SchemeDllRetrieveEncodedObject"

    /**
     * @type {String}
     */
    static SCHEME_OID_RETRIEVE_ENCODED_OBJECTW_FUNC => "SchemeDllRetrieveEncodedObjectW"

    /**
     * @type {String}
     */
    static CONTEXT_OID_CREATE_OBJECT_CONTEXT_FUNC => "ContextDllCreateObjectContext"

    /**
     * @type {Integer (Int32)}
     */
    static CONTEXT_OID_CERTIFICATE => 1

    /**
     * @type {Integer (Int32)}
     */
    static CONTEXT_OID_CRL => 2

    /**
     * @type {Integer (Int32)}
     */
    static CONTEXT_OID_CTL => 3

    /**
     * @type {Integer (Int32)}
     */
    static CONTEXT_OID_PKCS7 => 4

    /**
     * @type {Integer (Int32)}
     */
    static CONTEXT_OID_CAPI2_ANY => 5

    /**
     * @type {Integer (Int32)}
     */
    static CONTEXT_OID_OCSP_RESP => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_RETRIEVE_MULTIPLE_OBJECTS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_CACHE_ONLY_RETRIEVAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_WIRE_ONLY_RETRIEVAL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DONT_CACHE_RESULT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ASYNC_RETRIEVAL => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STICKY_CACHE_RETRIEVAL => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OFFLINE_CHECK_RETRIEVAL => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_LDAP_SIGN_RETRIEVAL => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_NO_AUTH_RETRIEVAL => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_AIA_RETRIEVAL => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_HTTP_POST_RETRIEVAL => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_PROXY_CACHE_RETRIEVAL => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_NOT_MODIFIED_RETRIEVAL => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ENABLE_SSL_REVOCATION_RETRIEVAL => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_RANDOM_QUERY_STRING_RETRIEVAL => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ENABLE_FILE_RETRIEVAL => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_CREATE_NEW_FLUSH_ENTRY => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_CONTEXT_SIGNATURE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_VERIFY_DATA_HASH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_KEEP_TIME_VALID => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DONT_VERIFY_SIGNATURE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_DONT_CHECK_TIME_VALIDITY => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_CHECK_FRESHNESS_TIME_VALIDITY => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_ACCUMULATIVE_TIMEOUT => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OCSP_ONLY_RETRIEVAL => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_NO_OCSP_FAILOVER_TO_CRL_RETRIEVAL => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_PRE_FETCH_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_PRE_FETCH_BLOB => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_PRE_FETCH_CRL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_PRE_FETCH_OCSP => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_PRE_FETCH_AUTOROOT_CAB => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_PRE_FETCH_DISALLOWED_CERT_CAB => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_PRE_FETCH_PIN_RULES_CAB => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_DEFAULT_FLUSH => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_DISABLE_FLUSH => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_RESPONSE_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_RESPONSE_HTTP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_URL_CACHE_RESPONSE_VALIDATED => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_RETRIEVE_MAX_ERROR_CONTENT_LENGTH => 4096

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_PARAM_ASYNC_RETRIEVAL_COMPLETION => 1

    /**
     * @type {Integer (Int32)}
     */
    static CRYPT_PARAM_CANCEL_ASYNC_RETRIEVAL => 2

    /**
     * @type {String}
     */
    static URL_OID_GET_OBJECT_URL_FUNC => "UrlDllGetObjectUrl"

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CERTIFICATE_ISSUER => 1

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CERTIFICATE_CRL_DIST_POINT => 2

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CTL_ISSUER => 3

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CTL_NEXT_UPDATE => 4

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CRL_ISSUER => 5

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CERTIFICATE_FRESHEST_CRL => 6

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CRL_FRESHEST_CRL => 7

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CROSS_CERT_DIST_POINT => 8

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CERTIFICATE_OCSP => 9

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CERTIFICATE_OCSP_AND_CRL_DIST_POINT => 10

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CERTIFICATE_CRL_DIST_POINT_AND_OCSP => 11

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CROSS_CERT_SUBJECT_INFO_ACCESS => 12

    /**
     * @type {Integer (Int32)}
     */
    static URL_OID_CERTIFICATE_ONLY_OCSP => 13

    /**
     * @type {String}
     */
    static TIME_VALID_OID_GET_OBJECT_FUNC => "TimeValidDllGetObject"

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_GET_CTL => 1

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_GET_CRL => 2

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_GET_CRL_FROM_CERT => 3

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CERT => 4

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CRL => 5

    /**
     * @type {String}
     */
    static TIME_VALID_OID_FLUSH_OBJECT_FUNC => "TimeValidDllFlushObject"

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_FLUSH_CTL => 1

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_FLUSH_CRL => 2

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_FLUSH_CRL_FROM_CERT => 3

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CERT => 4

    /**
     * @type {Integer (Int32)}
     */
    static TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CRL => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_KEYID_MACHINE_FLAG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_KEYID_ALLOC_FLAG => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_KEYID_DELETE_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_KEYID_SET_NEW_FLAG => 8192

    /**
     * @type {String}
     */
    static CERT_CHAIN_CONFIG_REGPATH => "Software\Microsoft\Cryptography\OID\EncodingType 0\CertDllCreateCertificateChainEngine\Config"

    /**
     * @type {String}
     */
    static CERT_CHAIN_MAX_URL_RETRIEVAL_BYTE_COUNT_VALUE_NAME => "MaxUrlRetrievalByteCount"

    /**
     * @type {String}
     */
    static CERT_CHAIN_CACHE_RESYNC_FILETIME_VALUE_NAME => "ChainCacheResyncFiletime"

    /**
     * @type {String}
     */
    static CERT_CHAIN_DISABLE_MANDATORY_BASIC_CONSTRAINTS_VALUE_NAME => "DisableMandatoryBasicConstraints"

    /**
     * @type {String}
     */
    static CERT_CHAIN_DISABLE_CA_NAME_CONSTRAINTS_VALUE_NAME => "DisableCANameConstraints"

    /**
     * @type {String}
     */
    static CERT_CHAIN_DISABLE_UNSUPPORTED_CRITICAL_EXTENSIONS_VALUE_NAME => "DisableUnsupportedCriticalExtensions"

    /**
     * @type {String}
     */
    static CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_VALUE_NAME => "MaxAIAUrlCountInCert"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_DEFAULT => 5

    /**
     * @type {String}
     */
    static CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_VALUE_NAME => "MaxAIAUrlRetrievalCountPerChain"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_DEFAULT => 3

    /**
     * @type {String}
     */
    static CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_VALUE_NAME => "MaxAIAUrlRetrievalByteCount"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_DEFAULT => 100000

    /**
     * @type {String}
     */
    static CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_VALUE_NAME => "MaxAIAUrlRetrievalCertCount"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_DEFAULT => 10

    /**
     * @type {String}
     */
    static CERT_CHAIN_OCSP_VALIDITY_SECONDS_VALUE_NAME => "OcspValiditySeconds"

    /**
     * @type {String}
     */
    static CERT_CHAIN_DISABLE_SERIAL_CHAIN_VALUE_NAME => "DisableSerialChain"

    /**
     * @type {String}
     */
    static CERT_CHAIN_SERIAL_CHAIN_LOG_FILE_NAME_VALUE_NAME => "SerialChainLogFileName"

    /**
     * @type {String}
     */
    static CERT_CHAIN_DISABLE_SYNC_WITH_SSL_TIME_VALUE_NAME => "DisableSyncWithSslTime"

    /**
     * @type {String}
     */
    static CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_VALUE_NAME => "MaxSslTimeUpdatedEventCount"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DEFAULT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DISABLE => 4294967295

    /**
     * @type {String}
     */
    static CERT_CHAIN_SSL_HANDSHAKE_LOG_FILE_NAME_VALUE_NAME => "SslHandshakeLogFileName"

    /**
     * @type {String}
     */
    static CERT_CHAIN_ENABLE_WEAK_SIGNATURE_FLAGS_VALUE_NAME => "EnableWeakSignatureFlags"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_MD2_MD4_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_WEAK_RSA_ROOT_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_WEAK_LOGGING_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_ONLY_WEAK_LOGGING_FLAG => 8

    /**
     * @type {String}
     */
    static CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_VALUE_NAME => "MinRsaPubKeyBitLength"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_DEFAULT => 1023

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_DISABLE => 4294967295

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_RSA_PUB_KEY_TIME_VALUE_NAME => "WeakRsaPubKeyTime"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_SIGNATURE_LOG_DIR_VALUE_NAME => "WeakSignatureLogDir"

    /**
     * @type {String}
     */
    static CERT_CHAIN_DEFAULT_CONFIG_SUBDIR => "Default"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_PREFIX_NAME => "Weak"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_THIRD_PARTY_CONFIG_NAME => "ThirdParty"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_ALL_CONFIG_NAME => "All"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_FLAGS_NAME => "Flags"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_HYGIENE_NAME => "Hygiene"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_AFTER_TIME_NAME => "AfterTime"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_FILE_HASH_AFTER_TIME_NAME => "FileHashAfterTime"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_TIMESTAMP_HASH_AFTER_TIME_NAME => "TimestampHashAfterTime"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_MIN_BIT_LENGTH_NAME => "MinBitLength"

    /**
     * @type {String}
     */
    static CERT_CHAIN_WEAK_SHA256_ALLOW_NAME => "Sha256Allow"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MIN_PUB_KEY_BIT_LENGTH_DISABLE => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_WEAK_SETTINGS_FLAG => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_ECC_PARA_FLAG => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_ALL_EKU_WEAK_FLAG => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_ALL_EKU_HYGIENE_FLAG => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_OPT_IN_SERVER_AUTH_WEAK_FLAG => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_SERVER_AUTH_WEAK_FLAG => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_SERVER_AUTH_HYGIENE_FLAG => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_CODE_SIGNING_WEAK_FLAG => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_MOTW_CODE_SIGNING_WEAK_FLAG => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_CODE_SIGNING_HYGIENE_FLAG => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_MOTW_CODE_SIGNING_HYGIENE_FLAG => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_TIMESTAMP_WEAK_FLAG => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_WEAK_FLAG => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_TIMESTAMP_HYGIENE_FLAG => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_MOTW_TIMESTAMP_HYGIENE_FLAG => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_MOTW_IGNORE_AFTER_TIME_WEAK_FLAG => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_FILE_HASH_WEAK_FLAG => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_MOTW_FILE_HASH_WEAK_FLAG => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_TIMESTAMP_HASH_WEAK_FLAG => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_HASH_WEAK_FLAG => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_OPT_IN_WEAK_FLAGS => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_CURRENT_USER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_LOCAL_MACHINE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_IMPERSONATED => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_PROCESS_INFO => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_PINRULE_INFO => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_NETWORK_INFO => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_SERIAL_LOCAL_MACHINE => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_HPKP_RULE_INFO => 8

    /**
     * @type {String}
     */
    static CERT_CHAIN_AUTO_FLAGS_VALUE_NAME => "AutoFlags"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_FLUSH_DISABLE_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_LOG_CREATE_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_LOG_FREE_FLAG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_AUTO_LOG_FLUSH_FLAG => 8

    /**
     * @type {String}
     */
    static CERT_CHAIN_AUTO_FLUSH_FIRST_DELTA_SECONDS_VALUE_NAME => "AutoFlushFirstDeltaSeconds"

    /**
     * @type {String}
     */
    static CERT_CHAIN_AUTO_FLUSH_NEXT_DELTA_SECONDS_VALUE_NAME => "AutoFlushNextDeltaSeconds"

    /**
     * @type {String}
     */
    static CERT_CHAIN_AUTO_LOG_FILE_NAME_VALUE_NAME => "AutoLogFileName"

    /**
     * @type {String}
     */
    static CERT_CHAIN_DISABLE_AUTO_FLUSH_PROCESS_NAME_LIST_VALUE_NAME => "DisableAutoFlushProcessNameList"

    /**
     * @type {String}
     */
    static CERT_SRV_OCSP_RESP_MIN_VALIDITY_SECONDS_VALUE_NAME => "SrvOcspRespMinValiditySeconds"

    /**
     * @type {String}
     */
    static CERT_SRV_OCSP_RESP_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME => "SrvOcspRespUrlRetrievalTimeoutMilliseconds"

    /**
     * @type {String}
     */
    static CERT_SRV_OCSP_RESP_MAX_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME => "SrvOcspRespMaxBeforeNextUpdateSeconds"

    /**
     * @type {String}
     */
    static CERT_SRV_OCSP_RESP_MIN_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME => "SrvOcspRespMinBeforeNextUpdateSeconds"

    /**
     * @type {String}
     */
    static CERT_SRV_OCSP_RESP_MIN_AFTER_NEXT_UPDATE_SECONDS_VALUE_NAME => "SrvOcspRespMinAfterNextUpdateSeconds"

    /**
     * @type {String}
     */
    static CERT_SRV_OCSP_RESP_MIN_SYNC_CERT_FILE_SECONDS_VALUE_NAME => "SrvOcspRespMinSyncCertFileSeconds"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SRV_OCSP_RESP_MIN_SYNC_CERT_FILE_SECONDS_DEFAULT => 5

    /**
     * @type {String}
     */
    static CERT_SRV_OCSP_RESP_MAX_SYNC_CERT_FILE_SECONDS_VALUE_NAME => "SrvOcspRespMaxSyncCertFileSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_MAX_CACHED_OCSP_PER_CRL_COUNT_VALUE_NAME => "CryptnetMaxCachedOcspPerCrlCount"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_MAX_CACHED_OCSP_PER_CRL_COUNT_DEFAULT => 500

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_OCSP_AFTER_CRL_DISABLE => 4294967295

    /**
     * @type {String}
     */
    static CRYPTNET_URL_CACHE_DEFAULT_FLUSH_EXEMPT_SECONDS_VALUE_NAME => "CryptnetDefaultFlushExemptSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_MIN_MAX_AGE_SECONDS_VALUE_NAME => "CryptnetPreFetchMinMaxAgeSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_MAX_MAX_AGE_SECONDS_VALUE_NAME => "CryptnetPreFetchMaxMaxAgeSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_MIN_OCSP_VALIDITY_PERIOD_SECONDS_VALUE_NAME => "CryptnetPreFetchMinOcspValidityPeriodSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_AFTER_PUBLISH_PRE_FETCH_DIVISOR_VALUE_NAME => "CryptnetPreFetchAfterPublishPreFetchDivisor"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_PRE_FETCH_AFTER_PUBLISH_PRE_FETCH_DIVISOR_DEFAULT => 10

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_BEFORE_NEXT_UPDATE_PRE_FETCH_DIVISOR_VALUE_NAME => "CryptnetPreFetchBeforeNextUpdatePreFetchDivisor"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_PRE_FETCH_BEFORE_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT => 20

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_MIN_BEFORE_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME => "CryptnetPreFetchMinBeforeNextUpdatePreFetchSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_VALIDITY_PERIOD_AFTER_NEXT_UPDATE_PRE_FETCH_DIVISOR_VALUE_NAME => "CryptnetPreFetchValidityPeriodAfterNextUpdatePreFetchDivisor"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_PRE_FETCH_VALIDITY_PERIOD_AFTER_NEXT_UPDATE_PRE_FETCH_DIVISOR_DEFAULT => 10

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_MAX_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME => "CryptnetPreFetchMaxAfterNextUpdatePreFetchPeriodSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_MIN_AFTER_NEXT_UPDATE_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME => "CryptnetPreFetchMinAfterNextUpdatePreFetchPeriodSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_AFTER_CURRENT_TIME_PRE_FETCH_PERIOD_SECONDS_VALUE_NAME => "CryptnetPreFetchAfterCurrentTimePreFetchPeriodSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_TRIGGER_PERIOD_SECONDS_VALUE_NAME => "CryptnetPreFetchTriggerPeriodSeconds"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_PRE_FETCH_TRIGGER_DISABLE => 4294967295

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_SCAN_AFTER_TRIGGER_DELAY_SECONDS_VALUE_NAME => "CryptnetPreFetchScanAfterTriggerDelaySeconds"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_PRE_FETCH_SCAN_AFTER_TRIGGER_DELAY_SECONDS_DEFAULT => 60

    /**
     * @type {String}
     */
    static CRYPTNET_PRE_FETCH_RETRIEVAL_TIMEOUT_SECONDS_VALUE_NAME => "CryptnetPreFetchRetrievalTimeoutSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_PROCESS_NAME_LIST_VALUE_NAME => "ProcessNameList"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_URL_LIST_VALUE_NAME => "PreFetchUrlList"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_DISABLE_INFORMATION_EVENTS_VALUE_NAME => "DisableInformationEvents"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_LOG_FILE_NAME_VALUE_NAME => "LogFileName"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_TIMEOUT_SECONDS_VALUE_NAME => "TimeoutSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_MAX_AGE_SECONDS_VALUE_NAME => "MaxAgeSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_PUBLISH_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME => "PublishBeforeNextUpdateSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_PUBLISH_RANDOM_INTERVAL_SECONDS_VALUE_NAME => "PublishRandomIntervalSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_MIN_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME => "MinBeforeNextUpdateSeconds"

    /**
     * @type {String}
     */
    static CRYPTNET_CRL_PRE_FETCH_MIN_AFTER_NEXT_UPDATE_SECONDS_VALUE_NAME => "MinAfterNextUpdateSeconds"

    /**
     * @type {String}
     */
    static CERT_CHAIN_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME => "ChainUrlRetrievalTimeoutMilliseconds"

    /**
     * @type {String}
     */
    static CERT_CHAIN_REV_ACCUMULATIVE_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME => "ChainRevAccumulativeUrlRetrievalTimeoutMilliseconds"

    /**
     * @type {String}
     */
    static CERT_RETR_BEHAVIOR_INET_AUTH_VALUE_NAME => "EnableInetUnknownAuth"

    /**
     * @type {String}
     */
    static CERT_RETR_BEHAVIOR_INET_STATUS_VALUE_NAME => "EnableInetLocal"

    /**
     * @type {String}
     */
    static CERT_RETR_BEHAVIOR_FILE_VALUE_NAME => "AllowFileUrlScheme"

    /**
     * @type {String}
     */
    static CERT_RETR_BEHAVIOR_LDAP_VALUE_NAME => "DisableLDAPSignAndEncrypt"

    /**
     * @type {String}
     */
    static CRYPTNET_CACHED_OCSP_SWITCH_TO_CRL_COUNT_VALUE_NAME => "CryptnetCachedOcspSwitchToCrlCount"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_CACHED_OCSP_SWITCH_TO_CRL_COUNT_DEFAULT => 50

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPTNET_CRL_BEFORE_OCSP_ENABLE => 4294967295

    /**
     * @type {String}
     */
    static CERT_CHAIN_DISABLE_AIA_URL_RETRIEVAL_VALUE_NAME => "DisableAIAUrlRetrieval"

    /**
     * @type {String}
     */
    static CERT_CHAIN_OPTIONS_VALUE_NAME => "Options"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_OPTION_DISABLE_AIA_URL_RETRIEVAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_OPTION_ENABLE_SIA_URL_RETRIEVAL => 4

    /**
     * @type {String}
     */
    static CERT_CHAIN_CROSS_CERT_DOWNLOAD_INTERVAL_HOURS_VALUE_NAME => "CrossCertDownloadIntervalHours"

    /**
     * @type {String}
     */
    static CERT_CHAIN_CRL_VALIDITY_EXT_PERIOD_HOURS_VALUE_NAME => "CRLValidityExtensionPeriod"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_CRL_VALIDITY_EXT_PERIOD_HOURS_DEFAULT => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_CACHE_END_CERT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_THREAD_STORE_SYNC => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_USE_LOCAL_MACHINE_STORE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_SHARE_STORE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_EXCLUSIVE_ENABLE_CA_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_NO_ERROR => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_NOT_TIME_VALID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_NOT_TIME_NESTED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_REVOKED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_NOT_SIGNATURE_VALID => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_NOT_VALID_FOR_USAGE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_UNTRUSTED_ROOT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_REVOCATION_STATUS_UNKNOWN => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_CYCLIC => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_INVALID_EXTENSION => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_INVALID_POLICY_CONSTRAINTS => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_INVALID_BASIC_CONSTRAINTS => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_INVALID_NAME_CONSTRAINTS => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_OFFLINE_REVOCATION => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_EXPLICIT_DISTRUST => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_WEAK_SIGNATURE => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_WEAK_HYGIENE => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_PARTIAL_CHAIN => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_CTL_IS_NOT_TIME_VALID => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_EXACT_MATCH_ISSUER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_KEY_MATCH_ISSUER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_NAME_MATCH_ISSUER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_SELF_SIGNED => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_AUTO_UPDATE_CA_REVOCATION => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_AUTO_UPDATE_END_REVOCATION => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_NO_OCSP_FAILOVER_TO_CRL => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_KEY_ROLLOVER => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_SSL_HANDSHAKE_OCSP => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_SSL_TIME_VALID_OCSP => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_SSL_RECONNECT_OCSP => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_PREFERRED_ISSUER => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_PEER_TRUSTED => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_CRL_VALIDITY_EXTENDED => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_FROM_EXCLUSIVE_TRUST_STORE => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_CA_TRUSTED => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_AUTO_UPDATE_WEAK_SIGNATURE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_HAS_ALLOW_WEAK_SIGNATURE => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_BEFORE_DISALLOWED_CA_FILETIME => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_IS_COMPLEX_CHAIN => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_SSL_TIME_VALID => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TRUST_NO_TIME_CHECK => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static USAGE_MATCH_TYPE_AND => 0

    /**
     * @type {Integer (UInt32)}
     */
    static USAGE_MATCH_TYPE_OR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_STRONG_SIGN_DISABLE_END_CHECK_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_REVOCATION_CHECK_END_CERT => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_REVOCATION_CHECK_CHAIN => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_REVOCATION_CHECK_OCSP_CERT => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_TIMESTAMP_TIME => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_PEER_TRUST => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_MY_PEER_TRUST => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_MD2_MD4 => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_DISABLE_AIA => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_HAS_MOTW => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ONLY_ADDITIONAL_AND_AUTH_ROOT => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_OPT_IN_WEAK_SIGNATURE => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_ENABLE_DISALLOWED_CA => 131072

    /**
     * @type {Integer (Int32)}
     */
    static REVOCATION_OID_CRL_REVOCATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_FIND_BY_ISSUER => 1

    /**
     * @type {String}
     */
    static CRYPT_OID_VERIFY_CERTIFICATE_CHAIN_POLICY_FUNC => "CertDllVerifyCertificateChainPolicy"

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_BASE => 1

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_AUTHENTICODE => 2

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_AUTHENTICODE_TS => 3

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_SSL => 4

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_BASIC_CONSTRAINTS => 5

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_NT_AUTH => 6

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_MICROSOFT_ROOT => 7

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_EV => 8

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_SSL_F12 => 9

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_SSL_HPKP_HEADER => 10

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_THIRD_PARTY_ROOT => 11

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_SSL_KEY_PIN => 12

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_F12_ERROR_TEXT_LENGTH => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_F12_SUCCESS_LEVEL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_F12_WARNING_LEVEL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_F12_ERROR_LEVEL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_F12_NONE_CATEGORY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_F12_WEAK_CRYPTO_CATEGORY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_F12_ROOT_PROGRAM_CATEGORY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_HPKP_PKP_HEADER_INDEX => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_HPKP_PKP_RO_HEADER_INDEX => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_HPKP_HEADER_COUNT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_KEY_PIN_ERROR_TEXT_LENGTH => 512

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_ERROR => -2

    /**
     * @type {Integer (Int32)}
     */
    static CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_ERROR => -1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_KEY_PIN_SUCCESS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_WARNING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_WARNING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STRING_BASE64URI => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STRING_ENCODEMASK => 255

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STRING_RESERVED100 => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STRING_RESERVED200 => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STRING_PERCENTESCAPE => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STRING_HASHDATA => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STRING_NOCRLF => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_STRING_NOCR => 2147483648

    /**
     * @type {String}
     */
    static szOID_PKCS_12_PbeIds => "1.2.840.113549.1.12.1"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_pbeWithSHA1And128BitRC4 => "1.2.840.113549.1.12.1.1"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_pbeWithSHA1And40BitRC4 => "1.2.840.113549.1.12.1.2"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES => "1.2.840.113549.1.12.1.3"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_pbeWithSHA1And2KeyTripleDES => "1.2.840.113549.1.12.1.4"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_pbeWithSHA1And128BitRC2 => "1.2.840.113549.1.12.1.5"

    /**
     * @type {String}
     */
    static szOID_PKCS_12_pbeWithSHA1And40BitRC2 => "1.2.840.113549.1.12.1.6"

    /**
     * @type {String}
     */
    static szOID_PKCS_5_PBKDF2 => "1.2.840.113549.1.5.12"

    /**
     * @type {String}
     */
    static szOID_PKCS_5_PBES2 => "1.2.840.113549.1.5.13"

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_IMPORT_SILENT => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_ONLY_CERTIFICATES => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_ONLY_NOT_ENCRYPTED_CERTIFICATES => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_VIRTUAL_ISOLATION_KEY => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_IMPORT_RESERVED_MASK => 4294901760

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_ONLY_CERTIFICATES_PROVIDER_TYPE => 0

    /**
     * @type {String}
     */
    static PKCS12_ONLY_CERTIFICATES_PROVIDER_NAME => "PfxProvider"

    /**
     * @type {String}
     */
    static PKCS12_ONLY_CERTIFICATES_CONTAINER_NAME => "PfxContainer"

    /**
     * @type {Integer (UInt32)}
     */
    static REPORT_NO_PRIVATE_KEY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static EXPORT_PRIVATE_KEYS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_PROTECT_TO_DOMAIN_SIDS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_EXPORT_SILENT => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_EXPORT_PBES2_PARAMS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_DISABLE_ENCRYPT_CERTIFICATES => 256

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_ENCRYPT_CERTIFICATES => 512

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_EXPORT_ECC_CURVE_PARAMETERS => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_EXPORT_ECC_CURVE_OID => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static PKCS12_EXPORT_RESERVED_MASK => 4294901760

    /**
     * @type {String}
     */
    static PKCS12_PBKDF2_ID_HMAC_SHA1 => "1.2.840.113549.2.7"

    /**
     * @type {String}
     */
    static PKCS12_PBKDF2_ID_HMAC_SHA256 => "1.2.840.113549.2.9"

    /**
     * @type {String}
     */
    static PKCS12_PBKDF2_ID_HMAC_SHA384 => "1.2.840.113549.2.10"

    /**
     * @type {String}
     */
    static PKCS12_PBKDF2_ID_HMAC_SHA512 => "1.2.840.113549.2.11"

    /**
     * @type {String}
     */
    static PKCS12_PBES2_ALG_AES256_SHA256 => "AES256-SHA256"

    /**
     * @type {String}
     */
    static PKCS12_CONFIG_REGPATH => "Software\Microsoft\Windows\CurrentVersion\PFX"

    /**
     * @type {String}
     */
    static PKCS12_ENCRYPT_CERTIFICATES_VALUE_NAME => "EncryptCertificates"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_READ_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_WRITE_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SERVER_OCSP_RESPONSE_ASYNC_FLAG => 1

    /**
     * @type {Integer (Int32)}
     */
    static CERT_RETRIEVE_ISSUER_LOGO => 1

    /**
     * @type {Integer (Int32)}
     */
    static CERT_RETRIEVE_SUBJECT_LOGO => 2

    /**
     * @type {Integer (Int32)}
     */
    static CERT_RETRIEVE_COMMUNITY_LOGO => 3

    /**
     * @type {Integer (Int32)}
     */
    static CERT_RETRIEVE_BIOMETRIC_PREDEFINED_BASE_TYPE => 1000

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_MAX_PARA => 500

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_BY_ISSUER_DISPLAYNAME => 12

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_BY_FRIENDLYNAME => 13

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_BY_THUMBPRINT => 14

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_ALLOW_EXPIRED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_TRUSTED_ROOT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_DISALLOW_SELFSIGNED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_HAS_PRIVATE_KEY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_HAS_KEY_FOR_SIGNATURE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_HAS_KEY_FOR_KEY_EXCHANGE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_HARDWARE_ONLY => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_ALLOW_DUPLICATES => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_SELECT_IGNORE_AUTOSELECT => 256

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_FAILURE_BAD_ALG => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_FAILURE_BAD_REQUEST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_FAILURE_BAD_FORMAT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_FAILURE_TIME_NOT_AVAILABLE => 14

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_FAILURE_POLICY_NOT_SUPPORTED => 15

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_FAILURE_EXTENSION_NOT_SUPPORTED => 16

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_FAILURE_INFO_NOT_AVAILABLE => 17

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_FAILURE_SYSTEM_FAILURE => 25

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_DONT_HASH_DATA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_VERIFY_CONTEXT_SIGNATURE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMP_NO_AUTH_RETRIEVAL => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OBJECT_LOCATOR_SPN_NAME_TYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OBJECT_LOCATOR_LAST_RESERVED_NAME_TYPE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OBJECT_LOCATOR_FIRST_RESERVED_USER_NAME_TYPE => 33

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_OBJECT_LOCATOR_LAST_RESERVED_USER_NAME_TYPE => 65535

    /**
     * @type {String}
     */
    static SSL_OBJECT_LOCATOR_PFX_FUNC => "SslObjectLocatorInitializePfx"

    /**
     * @type {String}
     */
    static SSL_OBJECT_LOCATOR_ISSUER_LIST_FUNC => "SslObjectLocatorInitializeIssuerList"

    /**
     * @type {String}
     */
    static SSL_OBJECT_LOCATOR_CERT_VALIDATION_CONFIG_FUNC => "SslObjectLocatorInitializeCertValidationConfig"

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_FILE_HASH_USE_TYPE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CERT_TIMESTAMP_HASH_USE_TYPE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RECIPIENTPOLICYV1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RECIPIENTPOLICYV2 => 2

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_COMMUNICATION => -1073413888

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_DATA_ACCESS => -1073413887

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_EXPORT => -1073413886

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_IDENTITY => -1073413885

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_IMPORT => -1073413884

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_ARGUMENT => -1073413883

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_REQUEST => -1073413882

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_INFORMATIONCARD => -1073413881

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_STOREKEY => -1073413880

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_LOGOVALIDATION => -1073413879

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_PASSWORDVALIDATION => -1073413878

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_POLICY => -1073413877

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_PROCESSDIED => -1073413876

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_SERVICEBUSY => -1073413875

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_SERVICE => -1073413874

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_SHUTTINGDOWN => -1073413873

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_TOKENCREATION => -1073413872

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_TRUSTEXCHANGE => -1073413871

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_UNTRUSTED => -1073413870

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_USERCANCELLED => -1073413869

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_STORE_IMPORT => -1073413868

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_FAIL => -1073413867

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_UI_INITIALIZATION => -1073413862

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_REFRESH_REQUIRED => -1073413760

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_MISSING_APPLIESTO => -1073413759

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_INVALID_PROOF_KEY => -1073413758

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_UNKNOWN_REFERENCE => -1073413757

    /**
     * @type {Integer (Int32)}
     */
    static E_ICARD_FAILED_REQUIRED_CLAIMS => -1073413756

    /**
     * @type {Integer (Int32)}
     */
    static AUDIT_CARD_WRITTEN => 1074070016

    /**
     * @type {Integer (Int32)}
     */
    static AUDIT_CARD_DELETE => 1074070017

    /**
     * @type {Integer (Int32)}
     */
    static AUDIT_CARD_IMPORT => 1074070018

    /**
     * @type {Integer (Int32)}
     */
    static AUDIT_STORE_IMPORT => 1074070019

    /**
     * @type {Integer (Int32)}
     */
    static AUDIT_STORE_EXPORT => 1074070020

    /**
     * @type {Integer (Int32)}
     */
    static AUDIT_STORE_DELETE => 1074070021

    /**
     * @type {Integer (Int32)}
     */
    static AUDIT_SERVICE_IDLE_STOP => 1074070022

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_ECC_PARAMETER_HEADER_V1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BCRYPT_COPY_AFTER_PADDING_CHECK_FAILURE_FLAG => 256

    /**
     * @type {String}
     */
    static MS_SCHANNEL_PROVIDER => "Microsoft SSL Protocol Provider"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_CLIENT_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_SERVER_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SSL2_PROTOCOL_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SSL3_PROTOCOL_VERSION => 768

    /**
     * @type {Integer (UInt32)}
     */
    static TLS1_PROTOCOL_VERSION => 769

    /**
     * @type {Integer (UInt32)}
     */
    static TLS1_0_PROTOCOL_VERSION => 769

    /**
     * @type {Integer (UInt32)}
     */
    static TLS1_1_PROTOCOL_VERSION => 770

    /**
     * @type {Integer (UInt32)}
     */
    static TLS1_2_PROTOCOL_VERSION => 771

    /**
     * @type {Integer (UInt32)}
     */
    static TLS1_3_PROTOCOL_VERSION => 772

    /**
     * @type {Integer (UInt32)}
     */
    static DTLS1_0_PROTOCOL_VERSION => 65279

    /**
     * @type {Integer (UInt32)}
     */
    static DTLS1_2_PROTOCOL_VERSION => 65277

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_NULL_MD5 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_NULL_SHA => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_EXPORT_WITH_RC4_40_MD5 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_RC4_128_MD5 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_RC4_128_SHA => 5

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_DES_CBC_SHA => 9

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_3DES_EDE_CBC_SHA => 10

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_DSS_WITH_DES_CBC_SHA => 18

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA => 19

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA => 22

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_AES_128_CBC_SHA => 47

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_DSS_WITH_AES_128_CBC_SHA => 50

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_RSA_WITH_AES_128_CBC_SHA => 51

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_AES_256_CBC_SHA => 53

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_DSS_WITH_AES_256_CBC_SHA => 56

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_RSA_WITH_AES_256_CBC_SHA => 57

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA => 98

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA => 99

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_EXPORT1024_WITH_RC4_56_SHA => 100

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_NULL_SHA256 => 59

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_AES_128_CBC_SHA256 => 60

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_AES_256_CBC_SHA256 => 61

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 => 64

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 => 106

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_AES_128_GCM_SHA256 => 156

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_RSA_WITH_AES_256_GCM_SHA384 => 157

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 => 158

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 => 159

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_PSK_WITH_AES_128_GCM_SHA256 => 168

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_PSK_WITH_AES_256_GCM_SHA384 => 169

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_PSK_WITH_AES_128_CBC_SHA256 => 174

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_PSK_WITH_AES_256_CBC_SHA384 => 175

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_PSK_WITH_NULL_SHA256 => 176

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_PSK_WITH_NULL_SHA384 => 177

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA => 49161

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA => 49171

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA => 49162

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA => 49172

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 => 49187

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 => 49188

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 => 49195

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 => 49196

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 => 49191

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 => 49192

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 => 49199

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 => 49200

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_AES_128_GCM_SHA256 => 4865

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_AES_256_GCM_SHA384 => 4866

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_CK_RC4_128_WITH_MD5 => 65664

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_CK_RC4_128_EXPORT40_WITH_MD5 => 131200

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_CK_RC2_128_CBC_WITH_MD5 => 196736

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5 => 262272

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_CK_IDEA_128_CBC_WITH_MD5 => 327808

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_CK_DES_64_CBC_WITH_MD5 => 393280

    /**
     * @type {Integer (UInt32)}
     */
    static SSL_CK_DES_192_EDE3_CBC_WITH_MD5 => 458944

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECC_P256_CURVE_KEY_TYPE => 23

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECC_P384_CURVE_KEY_TYPE => 24

    /**
     * @type {Integer (UInt32)}
     */
    static TLS_ECC_P521_CURVE_KEY_TYPE => 25

    /**
     * @type {String}
     */
    static SSL_ECDSA_ALGORITHM => "ECDSA"

    /**
     * @type {String}
     */
    static TLS_PSK_EXCHANGE => "PSK"

    /**
     * @type {String}
     */
    static TLS_RSA_PSK_EXCHANGE => "RSA_PSK"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_MAX_NAME_SIZE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_CIPHER_SUITE_EX_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_CIPHER_LENGTHS_BLOCK_PADDING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MSCRYPT_ECC_MAX_OID_LENGTH => 255

    /**
     * @type {Integer (UInt32)}
     */
    static MSCRYPT_ECC_MAX_CURVE_NAME_LENGTH => 255

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_EAP_PRF_FIELD => 255

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_EAP_ID => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_EAP_TTLSV0_ID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_EAP_TTLSV0_CHLNG_ID => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_EAP_FAST_ID => 3

    /**
     * @type {String}
     */
    static SSL_KEY_TYPE_PROPERTY => "KEYTYPE"

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_SIGN_INCLUDE_HASHOID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_SIGN_USE_PSS_PADDING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_EXTERNAL_PSK_FLAG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NCRYPT_SSL_RESUMPTION_PSK_FLAG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_PROVIDER_IOCTL__GET_SCHANNEL_INTERFACE => 4145180

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_PROVSTRUC_VERSION_V3 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MAX_PROVIDER_ID => 999

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SIG_RESOURCE_VERSION => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_EXTERNAL_SIGNATURE_LENGTH => 136

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_SIG_RESOURCE_NUMBER => 666

    /**
     * @type {String}
     */
    static CRYPT_SIG_RESOURCE => "#666"

    /**
     * @type {Integer (UInt32)}
     */
    static CRYPT_MAC_RESOURCE_NUMBER => 667

    /**
     * @type {String}
     */
    static CRYPT_MAC_RESOURCE => "#667"

    /**
     * @type {Integer (UInt32)}
     */
    static CUR_OFFLOAD_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ROLE_PIN_ALWAYS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ROLE_PUK => 4

    /**
     * @type {String}
     */
    static CP_PIV_CARD_CAPABILITY_CONTAINER => "PIV CCC"

    /**
     * @type {String}
     */
    static CP_PIV_CARD_HOLDER_UNIQUE_IDENTIFIER => "PIV CHUID"

    /**
     * @type {String}
     */
    static CP_PIV_CARD_HOLDER_UNSIGNED_UNIQUE_IDENTIFIER => "PIV UCHUID"

    /**
     * @type {String}
     */
    static CP_PIV_FINGERPRINT => "PIV Fingerprint"

    /**
     * @type {String}
     */
    static CP_PIV_SECURITY_OBJECT => "PIV Security Object"

    /**
     * @type {String}
     */
    static CP_PIV_FACIAL_IMAGE => "PIV Facial Image"

    /**
     * @type {String}
     */
    static CP_PIV_PRINTED_INFORMATION => "PIV Printed Information"

    /**
     * @type {String}
     */
    static CP_PIV_GENERATE_KEY => "PIV Generate Key"

    /**
     * @type {String}
     */
    static CP_CARD_PIV => "PIV Card"

    /**
     * @type {String}
     */
    static CP_PIV_CERTIFICATE => "PIV Certificate"

    /**
     * @type {String}
     */
    static CP_PIV_PUBLIC_KEY => "PIV Public Key"

    /**
     * @type {String}
     */
    static CP_PIV_KEY_HISTORY_OBJECT => "PIV Key History Object"

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_PIV_CERT_DATA_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_PIV_GENERATE_ASYMMETRIC_KEY_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_PIV_PUBLIC_KEY_DATA_CURRENT_VERSION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_PIV_AUTH_CERT => 6275333

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_SIG_CERT => 6275338

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_KEY_MGMT_CERT => 6275339

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_CARD_AUTH_CERT => 6275329

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_CHUID => 6275330

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_CARD_CAPABILITY_CONTAINER => 6275335

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_UNSIGNED_CHUID => 6275332

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_FINGERPRINT => 6275331

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_SECURITY_OBJECT => 6275334

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_FACIAL_IMAGE => 6275336

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_PRINTED_INFORMATION => 6275337

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_KEY_HISTORY => 6275340

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_FIRST_RETIRED_KEY_MGMT_KEY => 6275341

    /**
     * @type {Integer (UInt32)}
     */
    static CLMD_FILE_TAG_LAST_RETIRED_KEY_MGMT_KEY => 6275360

    /**
     * @type {Integer (UInt32)}
     */
    static SCARD_PROVIDER_CARD_MODULE => 2147483649

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DATA_VALUE_UNKNOWN => 4294967295

    /**
     * @type {String}
     */
    static szBASE_CSP_DIR => "mscp"

    /**
     * @type {String}
     */
    static szINTERMEDIATE_CERTS_DIR => "mscerts"

    /**
     * @type {String}
     */
    static szCACHE_FILE => "cardcf"

    /**
     * @type {String}
     */
    static szCARD_IDENTIFIER_FILE => "cardid"

    /**
     * @type {String}
     */
    static szCONTAINER_MAP_FILE => "cmapfile"

    /**
     * @type {String}
     */
    static szROOT_STORE_FILE => "msroots"

    /**
     * @type {String}
     */
    static szUSER_SIGNATURE_CERT_PREFIX => "ksc"

    /**
     * @type {String}
     */
    static szUSER_KEYEXCHANGE_CERT_PREFIX => "kxc"

    /**
     * @type {String}
     */
    static szUSER_SIGNATURE_PRIVATE_KEY_PREFIX => "kss"

    /**
     * @type {String}
     */
    static szUSER_SIGNATURE_PUBLIC_KEY_PREFIX => "ksp"

    /**
     * @type {String}
     */
    static szUSER_KEYEXCHANGE_PRIVATE_KEY_PREFIX => "kxs"

    /**
     * @type {String}
     */
    static szUSER_KEYEXCHANGE_PUBLIC_KEY_PREFIX => "kxp"

    /**
     * @type {String}
     */
    static wszCARD_USER_EVERYONE => "anonymous"

    /**
     * @type {String}
     */
    static wszCARD_USER_USER => "user"

    /**
     * @type {String}
     */
    static wszCARD_USER_ADMIN => "admin"

    /**
     * @type {Integer (UInt32)}
     */
    static AT_ECDSA_P256 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static AT_ECDSA_P384 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static AT_ECDSA_P521 => 5

    /**
     * @type {Integer (UInt32)}
     */
    static AT_ECDHE_P256 => 6

    /**
     * @type {Integer (UInt32)}
     */
    static AT_ECDHE_P384 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static AT_ECDHE_P521 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CACHE_FILE_CURRENT_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_CONTAINER_NAME_LEN => 39

    /**
     * @type {Integer (UInt32)}
     */
    static CONTAINER_MAP_VALID_CONTAINER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CONTAINER_MAP_DEFAULT_CONTAINER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CAPABILITIES_CURRENT_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_PINS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ROLE_EVERYONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ROLE_USER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ROLE_ADMIN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PIN_SET_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PIN_SET_ALL_ROLES => 255

    /**
     * @type {Integer (UInt32)}
     */
    static PIN_CHANGE_FLAG_UNBLOCK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PIN_CHANGE_FLAG_CHANGEPIN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CP_CACHE_MODE_GLOBAL_CACHE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CP_CACHE_MODE_SESSION_ONLY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CP_CACHE_MODE_NO_CACHE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_AUTHENTICATE_GENERATE_SESSION_PIN => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_AUTHENTICATE_SESSION_PIN => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_PIN_STRENGTH_PLAINTEXT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_PIN_STRENGTH_SESSION_PIN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_PIN_SILENT_CONTEXT => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PIN_CACHE_POLICY_CURRENT_VERSION => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PIN_INFO_CURRENT_VERSION => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PIN_INFO_REQUIRE_SECURE_ENTRY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CREATE_CONTAINER_KEY_GEN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CREATE_CONTAINER_KEY_IMPORT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CONTAINER_INFO_CURRENT_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_AUTHENTICATE_PIN_CHALLENGE_RESPONSE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_AUTHENTICATE_PIN_PIN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_FILE_INFO_CURRENT_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_FREE_SPACE_INFO_CURRENT_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_KEY_SIZES_CURRENT_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_RSA_KEY_DECRYPT_INFO_VERSION_ONE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_RSA_KEY_DECRYPT_INFO_VERSION_TWO => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_RSA_KEY_DECRYPT_INFO_CURRENT_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_PADDING_INFO_PRESENT => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_BUFFER_SIZE_ONLY => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_PADDING_NONE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_PADDING_PKCS1 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_PADDING_PSS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_PADDING_OAEP => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_SIGNING_INFO_BASIC_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_SIGNING_INFO_CURRENT_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DH_AGREEMENT_INFO_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DERIVE_KEY_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DERIVE_KEY_VERSION_TWO => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DERIVE_KEY_CURRENT_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_RETURN_KEY_HANDLE => 16777216

    /**
     * @type {String}
     */
    static CCP_CONTAINER_INFO => "Container Info"

    /**
     * @type {String}
     */
    static CCP_PIN_IDENTIFIER => "PIN Identifier"

    /**
     * @type {String}
     */
    static CCP_ASSOCIATED_ECDH_KEY => "Associated ECDH Key"

    /**
     * @type {String}
     */
    static CP_CARD_FREE_SPACE => "Free Space"

    /**
     * @type {String}
     */
    static CP_CARD_CAPABILITIES => "Capabilities"

    /**
     * @type {String}
     */
    static CP_CARD_KEYSIZES => "Key Sizes"

    /**
     * @type {String}
     */
    static CP_CARD_READ_ONLY => "Read Only Mode"

    /**
     * @type {String}
     */
    static CP_CARD_CACHE_MODE => "Cache Mode"

    /**
     * @type {String}
     */
    static CP_SUPPORTS_WIN_X509_ENROLLMENT => "Supports Windows x.509 Enrollment"

    /**
     * @type {String}
     */
    static CP_CARD_GUID => "Card Identifier"

    /**
     * @type {String}
     */
    static CP_CARD_SERIAL_NO => "Card Serial Number"

    /**
     * @type {String}
     */
    static CP_CARD_PIN_INFO => "PIN Information"

    /**
     * @type {String}
     */
    static CP_CARD_LIST_PINS => "PIN List"

    /**
     * @type {String}
     */
    static CP_CARD_AUTHENTICATED_STATE => "Authenticated State"

    /**
     * @type {String}
     */
    static CP_CARD_PIN_STRENGTH_VERIFY => "PIN Strength Verify"

    /**
     * @type {String}
     */
    static CP_CARD_PIN_STRENGTH_CHANGE => "PIN Strength Change"

    /**
     * @type {String}
     */
    static CP_CARD_PIN_STRENGTH_UNBLOCK => "PIN Strength Unblock"

    /**
     * @type {String}
     */
    static CP_PARENT_WINDOW => "Parent Window"

    /**
     * @type {String}
     */
    static CP_PIN_CONTEXT_STRING => "PIN Context String"

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_SECURE_KEY_INJECTION_NO_CARD_MODE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_KEY_IMPORT_PLAIN_TEXT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_KEY_IMPORT_RSA_KEYEST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_KEY_IMPORT_ECC_KEYEST => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_KEY_IMPORT_SHARED_SYMMETRIC => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CIPHER_OPERATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_ASYMMETRIC_OPERATION => 2

    /**
     * @type {String}
     */
    static CARD_3DES_112_ALGORITHM => "3DES_112"

    /**
     * @type {String}
     */
    static CARD_3DES_ALGORITHM => "3DES"

    /**
     * @type {String}
     */
    static CARD_AES_ALGORITHM => "AES"

    /**
     * @type {String}
     */
    static CARD_CHAIN_MODE_CBC => "ChainingModeCBC"

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_IMPORT_KEYPAIR_VERSION_SEVEN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_IMPORT_KEYPAIR_CURRENT_VERSION => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CHANGE_AUTHENTICATOR_VERSION_SEVEN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CHANGE_AUTHENTICATOR_CURRENT_VERSION => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CHANGE_AUTHENTICATOR_RESPONSE_VERSION_SEVEN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_CHANGE_AUTHENTICATOR_RESPONSE_CURRENT_VERSION => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_AUTHENTICATE_VERSION_SEVEN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_AUTHENTICATE_CURRENT_VERSION => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_AUTHENTICATE_RESPONSE_VERSION_SEVEN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_AUTHENTICATE_RESPONSE_CURRENT_VERSION => 7

    /**
     * @type {String}
     */
    static CP_KEY_IMPORT_SUPPORT => "Key Import Support"

    /**
     * @type {String}
     */
    static CP_ENUM_ALGORITHMS => "Algorithms"

    /**
     * @type {String}
     */
    static CP_PADDING_SCHEMES => "Padding Schemes"

    /**
     * @type {String}
     */
    static CP_CHAINING_MODES => "Chaining Modes"

    /**
     * @type {String}
     */
    static CSF_IMPORT_KEYPAIR => "Import Key Pair"

    /**
     * @type {String}
     */
    static CSF_CHANGE_AUTHENTICATOR => "Change Authenticator"

    /**
     * @type {String}
     */
    static CSF_AUTHENTICATE => "Authenticate"

    /**
     * @type {String}
     */
    static CKP_CHAINING_MODE => "ChainingMode"

    /**
     * @type {String}
     */
    static CKP_INITIALIZATION_VECTOR => "IV"

    /**
     * @type {String}
     */
    static CKP_BLOCK_LENGTH => "BlockLength"

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DATA_VERSION_SEVEN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DATA_VERSION_SIX => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DATA_VERSION_FIVE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DATA_VERSION_FOUR => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CARD_DATA_CURRENT_VERSION => 7
;@endregion Constants

;@region Methods
    /**
     * Retrieves a specified number of random bytes from the system random number generator.
     * @param {Pointer<Byte>} pbRandomData A pointer to a buffer that receives the retrieved bytes.
     * @param {Pointer} cbRandomData The number of bytes to retrieve.
     * @returns {Integer} Always returns **TRUE**.
     * @see https://learn.microsoft.com/windows/win32/SecCNG/systemprng
     */
    static SystemPrng(pbRandomData, cbRandomData) {
        result := DllCall("BCryptPrimitives.dll\SystemPrng", "ptr", pbRandomData, "ptr", cbRandomData, "int")
        return result
    }

    /**
     * Retrieves a specified number of random bytes from the user-mode per-processor random number generator.
     * @param {Pointer<Byte>} pbData A pointer to a buffer that receives the retrieved bytes.
     * @param {Pointer} cbData The number of bytes to retrieve.
     * @returns {Integer} Always returns **TRUE**.
     * @see https://learn.microsoft.com/windows/win32/SecCNG/processprng
     */
    static ProcessPrng(pbData, cbData) {
        result := DllCall("BCryptPrimitives.dll\ProcessPrng", "ptr", pbData, "ptr", cbData, "int")
        return result
    }

    /**
     * Used to acquire a handle to a particular key container within a particular cryptographic service provider (CSP). This returned handle is used in calls to CryptoAPI functions that use the selected CSP. (ANSI)
     * @remarks
     * The <i>pszContainer</i> parameter specifies the name of the container that is used to hold the key. Each container can contain one key. If  you  specify the name of an existing container when creating keys, the new key will overwrite a previous one.
     * 
     * The combination of the CSP name and the key container name uniquely identifies a single key on the system. If one application tries to modify a key container while another application is using it, unpredictable behavior may result.
     * 
     * If you set the  <i>pszContainer</i> parameter to <b>NULL</b>, the default key container name is used. When the Microsoft software CSPs are called in this manner, a new container is created each time the <b>CryptAcquireContext</b> function is called. However, different CSPs may behave differently in this regard. In particular, a CSP may have a single default container that is shared by all applications accessing the CSP. Therefore, applications must not use the default key container to store private keys. Instead, either prevent key storage by passing the <b>CRYPT_VERIFYCONTEXT</b> flag in the <i>dwFlags</i> parameter, or use an application-specific container that is unlikely to be used by another application.
     * 
     * An application can obtain the name of the key container in use by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetprovparam">CryptGetProvParam</a> function to read the PP_CONTAINER value.
     * 
     * For performance reasons, we recommend that you set the <i>pszContainer</i> parameter to <b>NULL</b> and the <i>dwFlags</i> parameter to <b>CRYPT_VERIFYCONTEXT</b> in all situations where you do not require a persisted key. In particular, consider setting the  <i>pszContainer</i> parameter to <b>NULL</b> and the <i>dwFlags</i> parameter to <b>CRYPT_VERIFYCONTEXT</b> for the following scenarios:
     * 
     * <ul>
     * <li>You are creating a hash.
     * </li>
     * <li>You are generating a symmetric key to encrypt or decrypt data.
     * </li>
     * <li>You are deriving a symmetric key from a hash to encrypt or decrypt data.
     * </li>
     * <li>You are verifying a signature. It is possible to import a public key from a PUBLICKEYBLOB or from a certificate by using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a> or <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportpublickeyinfoex2">CryptImportPublicKeyInfo</a>.
     *  A context can be acquired by using the <b>CRYPT_VERIFYCONTEXT</b> flag if you only plan to import the public key.</li>
     * <li>You plan to export a symmetric key, but not import it within the crypto context's lifetime. A context can be acquired by using the <b>CRYPT_VERIFYCONTEXT</b> flag if you only plan to import the public key for the last two scenarios. 
     * </li>
     * <li>You are performing private key operations, but you are not using a persisted private key that is stored in a key container. </li>
     * </ul>
     * If you plan to perform private key operations, the best way to acquire a context is to try to open the container. If this attempt fails with NTE_BAD_KEYSET, then create the container by using the <b>CRYPT_NEWKEYSET</b> flag.
     * @param {Pointer<UIntPtr>} phProv A pointer to a handle of a CSP. When you have finished using the CSP, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptreleasecontext">CryptReleaseContext</a> function.
     * @param {Pointer<PSTR>} szContainer The key container name. This is a null-terminated string that identifies the key container to the CSP. This name is independent of the method used to store the keys. Some CSPs store their key containers internally (in hardware), some use the system registry, and others use the file system. In most cases, when <i>dwFlags</i> is set to CRYPT_VERIFYCONTEXT, <i>pszContainer</i> must be set to <b>NULL</b>. However, for hardware-based CSPs, such as a smart card CSP, can be access publicly available information in the specfied container.
     * 
     * For more information about the usage of the <i>pszContainer</i> parameter, see Remarks.
     * @param {Pointer<PSTR>} szProvider A null-terminated string that contains the name of the CSP to be used. 
     * 
     * 
     * 
     * 
     * If this parameter is <b>NULL</b>, the user default provider is used. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-service-provider-contexts">Cryptographic Service Provider Contexts</a>. For a list of available cryptographic providers, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-provider-names">Cryptographic Provider Names</a>.
     * 
     * An application can obtain the name of the CSP in use by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetprovparam">CryptGetProvParam</a> function to read the PP_NAME CSP value in the <i>dwParam</i> parameter.
     * 
     * The default CSP can change between operating system releases. To ensure interoperability on different operating system platforms, the CSP should be explicitly set by using this parameter instead of using the default CSP.
     * @param {Integer} dwProvType Specifies the type of provider to acquire. Defined provider types are discussed in 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-provider-types">Cryptographic Provider Types</a>.
     * @param {Integer} dwFlags Flag values. This parameter is usually set to zero, but some applications set one or more of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFYCONTEXT"></a><a id="crypt_verifycontext"></a><dl>
     * <dt><b>CRYPT_VERIFYCONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This option is intended for applications that are using ephemeral keys, or applications that do not require access to persisted private keys, such as applications that perform only <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hashing</a>, <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">encryption</a>, and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">digital signature</a> verification. Only applications that create signatures or decrypt messages need access to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key</a>. In most cases, this flag should be set.
     * 
     * For file-based CSPs, when this flag is set, the <i>pszContainer</i> parameter must be set to <b>NULL</b>. The application has no access to the persisted private keys of public/private key pairs. When this flag is set, temporary <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public/private key pairs</a> can be created, but they are not persisted.
     * 
     * For hardware-based CSPs, such as a smart card CSP, if the <i>pszContainer</i> parameter is <b>NULL</b> or blank, this flag implies that no access to any keys is required, and that no UI should be presented to the user.  This form is used to connect to the CSP to query its capabilities but not to actually use its keys.
     * If the <i>pszContainer</i> parameter is not <b>NULL</b> and not blank, then this flag implies that access to only the publicly available information within the specified container is required.  The CSP should not ask for a PIN.  Attempts to access private information (for example, the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a> function) will fail.
     * 
     * When <b>CryptAcquireContext</b> is called, many CSPs require input from the owning user before granting access to the private keys in the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a>. For example, the private keys can be encrypted, requiring a password from the user before they can be used. However, if the <b>CRYPT_VERIFYCONTEXT</b> flag is specified, access to the private keys is not required and the user interface can be bypassed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NEWKEYSET"></a><a id="crypt_newkeyset"></a><dl>
     * <dt><b>CRYPT_NEWKEYSET</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Creates a new key container with the name specified by <i>pszContainer</i>. If <i>pszContainer</i> is <b>NULL</b>, a key container with the default name is created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_MACHINE_KEYSET"></a><a id="crypt_machine_keyset"></a><dl>
     * <dt><b>CRYPT_MACHINE_KEYSET</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * By default, keys and key containers are stored as user keys. For Base Providers, this means that user key containers are stored in the user's profile. A key container created without this flag by an administrator can be accessed only by the user creating the key container and a user with administration privileges.
     * 
     * 
     * <b>Windows XP:  </b>A key container created without this flag by an administrator can be accessed only by the user creating the key container and the local system account.
     * 
     * 
     * 
     * A key container created without this flag by a user that is not an administrator can be accessed only by the user creating the key container and the local system account.
     * 
     * The CRYPT_MACHINE_KEYSET flag can be combined with all of the other flags to indicate that the key container of interest is a computer key container and the CSP treats it as such. For Base Providers, this means that the keys are stored locally on the computer that created the key container. If a key container is to be a computer container, the CRYPT_MACHINE_KEYSET flag must be used with all calls to <b>CryptAcquireContext</b> that reference the computer container. The key container created with CRYPT_MACHINE_KEYSET by an administrator can be accessed only by its creator and by a user with administrator <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">privileges</a> unless access rights to the container are granted using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>.
     * 
     * 
     * <b>Windows XP:  </b>The key container created with CRYPT_MACHINE_KEYSET by an administrator can be accessed only by its creator and by the local system account unless access rights to the container are granted using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>.
     * 
     * 
     * 
     * The key container created with CRYPT_MACHINE_KEYSET by a user that is not an administrator can be accessed only by its creator and by the local system account unless access rights to the container are granted using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>.
     * 
     * The CRYPT_MACHINE_KEYSET flag is useful when the user is accessing from a service or user account that did not log on interactively. When key containers are created, most CSPs do not automatically create any <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public/private key pairs</a>. These keys must be created as a separate step with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DELETEKEYSET"></a><a id="crypt_deletekeyset"></a><dl>
     * <dt><b>CRYPT_DELETEKEYSET</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Delete the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a> specified by <i>pszContainer</i>. If <i>pszContainer</i> is <b>NULL</b>, the key container with the default name is deleted. All <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key pairs</a> in the key container are also destroyed. 
     * 
     * 
     * 
     * 
     * When this flag is set, the value returned in <i>phProv</i> is undefined, and thus, the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptreleasecontext">CryptReleaseContext</a> function need not be called afterward.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_SILENT"></a><a id="crypt_silent"></a><dl>
     * <dt><b>CRYPT_SILENT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The application requests that the CSP not display any user interface (UI) for this <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a>. If the CSP must display the UI to operate, the call fails and the NTE_SILENT_CONTEXT error code is set as the last error. In addition, if calls are made to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a> with the CRYPT_USER_PROTECTED flag with a context that has been acquired with the CRYPT_SILENT flag, the calls fail and the CSP sets NTE_SILENT_CONTEXT.
     * 
     * CRYPT_SILENT is intended for use with applications for which the UI cannot be displayed by the CSP.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DEFAULT_CONTAINER_OPTIONAL"></a><a id="crypt_default_container_optional"></a><dl>
     * <dt><b>CRYPT_DEFAULT_CONTAINER_OPTIONAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obtains a context for a smart card CSP that can be used for hashing and symmetric key operations but cannot be used for any operation that requires authentication to a smart card using a PIN. This type of context is most often used to perform operations on an empty smart card, such as setting the PIN by using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>. This flag can only be used with smart card CSPs. 
     * 
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>This flag is not supported.
     * 
     * 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes defined in Winerror.h follow.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * <dt>107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Some CSPs set this error if the CRYPT_DELETEKEYSET flag value is set and another thread or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">process</a> is using this <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * <dt>2L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The profile of the user is not loaded and cannot be found. This happens when the application impersonates a user, for example, the IUSR_<i>ComputerName</i> account.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * <dt>87L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * <dt>8L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * <dt>0x80090009L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter has a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY_STATE</b></dt>
     * <dt>0x8009000BL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user password has changed since the private keys were encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEYSET</b></dt>
     * <dt>0x80090016L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key container could not be opened. A common cause of this error is that the key container does not exist. To create a key container, call <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> using the CRYPT_NEWKEYSET flag. This error code can also indicate that access to an existing key container is denied. Access rights to the container can be granted by the key set creator by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEYSET_PARAM</b></dt>
     * <dt>0x8009001FL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszContainer</i> or <i>pszProvider</i> parameter is set to a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_PROV_TYPE</b></dt>
     * <dt>0x80090014L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of the <i>dwProvType</i> parameter is out of range. All provider types must be from 1 through 999, inclusive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * <dt>0x80090006L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider DLL signature could not be verified. Either the DLL or the digital signature has been tampered with.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_EXISTS</b></dt>
     * <dt>0x8009000FL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is CRYPT_NEWKEYSET, but the key container already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_KEYSET_ENTRY_BAD</b></dt>
     * <dt>0x8009001AL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszContainer</i> key container was found but is corrupt.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_KEYSET_NOT_DEF</b></dt>
     * <dt>0x80090019L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested provider does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * <dt>0x8009000EL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROV_DLL_NOT_FOUND</b></dt>
     * <dt>0x8009001EL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider DLL file does not exist or is not on the current path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROV_TYPE_ENTRY_BAD</b></dt>
     * <dt>0x80090018L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider type specified by <i>dwProvType</i> is corrupt. This error can relate to either the user default CSP list or the computer default CSP list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROV_TYPE_NO_MATCH</b></dt>
     * <dt>0x8009001BL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider type specified by <i>dwProvType</i> does not match the provider type found. Note that this error can only occur when <i>pszProvider</i> specifies an actual CSP name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROV_TYPE_NOT_DEF</b></dt>
     * <dt>0x80090017L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No entry exists for the provider type specified by <i>dwProvType</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROVIDER_DLL_FAIL</b></dt>
     * <dt>0x8009001DL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider DLL file could not be loaded or failed to initialize.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_SIGNATURE_FILE_BAD</b></dt>
     * <dt>0x8009001CL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error occurred while loading the DLL file image, prior to verifying its signature.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta
     * @since windows5.1.2600
     */
    static CryptAcquireContextA(phProv, szContainer, szProvider, dwProvType, dwFlags) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptAcquireContextA", "ptr", phProv, "ptr", szContainer, "ptr", szProvider, "uint", dwProvType, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Used to acquire a handle to a particular key container within a particular cryptographic service provider (CSP). This returned handle is used in calls to CryptoAPI functions that use the selected CSP. (Unicode)
     * @remarks
     * The <i>pszContainer</i> parameter specifies the name of the container that is used to hold the key. Each container can contain one key. If  you  specify the name of an existing container when creating keys, the new key will overwrite a previous one.
     * 
     * The combination of the CSP name and the key container name uniquely identifies a single key on the system. If one application tries to modify a key container while another application is using it, unpredictable behavior may result.
     * 
     * If you set the  <i>pszContainer</i> parameter to <b>NULL</b>, the default key container name is used. When the Microsoft software CSPs are called in this manner, a new container is created each time the <b>CryptAcquireContext</b> function is called. However, different CSPs may behave differently in this regard. In particular, a CSP may have a single default container that is shared by all applications accessing the CSP. Therefore, applications must not use the default key container to store private keys. Instead, either prevent key storage by passing the <b>CRYPT_VERIFYCONTEXT</b> flag in the <i>dwFlags</i> parameter, or use an application-specific container that is unlikely to be used by another application.
     * 
     * An application can obtain the name of the key container in use by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetprovparam">CryptGetProvParam</a> function to read the PP_CONTAINER value.
     * 
     * For performance reasons, we recommend that you set the <i>pszContainer</i> parameter to <b>NULL</b> and the <i>dwFlags</i> parameter to <b>CRYPT_VERIFYCONTEXT</b> in all situations where you do not require a persisted key. In particular, consider setting the  <i>pszContainer</i> parameter to <b>NULL</b> and the <i>dwFlags</i> parameter to <b>CRYPT_VERIFYCONTEXT</b> for the following scenarios:
     * 
     * <ul>
     * <li>You are creating a hash.
     * </li>
     * <li>You are generating a symmetric key to encrypt or decrypt data.
     * </li>
     * <li>You are deriving a symmetric key from a hash to encrypt or decrypt data.
     * </li>
     * <li>You are verifying a signature. It is possible to import a public key from a PUBLICKEYBLOB or from a certificate by using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a> or <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportpublickeyinfoex2">CryptImportPublicKeyInfo</a>.
     *  A context can be acquired by using the <b>CRYPT_VERIFYCONTEXT</b> flag if you only plan to import the public key.</li>
     * <li>You plan to export a symmetric key, but not import it within the crypto context's lifetime. A context can be acquired by using the <b>CRYPT_VERIFYCONTEXT</b> flag if you only plan to import the public key for the last two scenarios. 
     * </li>
     * <li>You are performing private key operations, but you are not using a persisted private key that is stored in a key container. </li>
     * </ul>
     * If you plan to perform private key operations, the best way to acquire a context is to try to open the container. If this attempt fails with NTE_BAD_KEYSET, then create the container by using the <b>CRYPT_NEWKEYSET</b> flag.
     * @param {Pointer<UIntPtr>} phProv A pointer to a handle of a CSP. When you have finished using the CSP, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptreleasecontext">CryptReleaseContext</a> function.
     * @param {Pointer<PWSTR>} szContainer The key container name. This is a null-terminated string that identifies the key container to the CSP. This name is independent of the method used to store the keys. Some CSPs store their key containers internally (in hardware), some use the system registry, and others use the file system. In most cases, when <i>dwFlags</i> is set to CRYPT_VERIFYCONTEXT, <i>pszContainer</i> must be set to <b>NULL</b>. However, for hardware-based CSPs, such as a smart card CSP, can be access publicly available information in the specfied container.
     * 
     * For more information about the usage of the <i>pszContainer</i> parameter, see Remarks.
     * @param {Pointer<PWSTR>} szProvider A null-terminated string that contains the name of the CSP to be used. 
     * 
     * 
     * 
     * 
     * If this parameter is <b>NULL</b>, the user default provider is used. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-service-provider-contexts">Cryptographic Service Provider Contexts</a>. For a list of available cryptographic providers, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-provider-names">Cryptographic Provider Names</a>.
     * 
     * An application can obtain the name of the CSP in use by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetprovparam">CryptGetProvParam</a> function to read the PP_NAME CSP value in the <i>dwParam</i> parameter.
     * 
     * The default CSP can change between operating system releases. To ensure interoperability on different operating system platforms, the CSP should be explicitly set by using this parameter instead of using the default CSP.
     * @param {Integer} dwProvType Specifies the type of provider to acquire. Defined provider types are discussed in 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-provider-types">Cryptographic Provider Types</a>.
     * @param {Integer} dwFlags One or more of the following flags. Note, most applications should set the **CRYPT_VERIFYCONTEXT** flag unless they need to create digital signatures or decrypt messages.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFYCONTEXT"></a><a id="crypt_verifycontext"></a><dl>
     * <dt><b>CRYPT_VERIFYCONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not need access to persisted private keys. Apps that use ephemeral keys, or that perform only <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hashing</a>, <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">encryption</a>, and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">digital signature</a> verification should set this flag. Only applications that create signatures or decrypt messages need access to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key</a> (and should not set this flag). 
     * 
     * For file-based CSPs, when this flag is set, the <i>pszContainer</i> parameter must be set to <b>NULL</b>. The application has no access to the persisted private keys of public/private key pairs. When this flag is set, temporary <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public/private key pairs</a> can be created, but they are not persisted.
     * 
     * For hardware-based CSPs, such as a smart card CSP, if the <i>pszContainer</i> parameter is <b>NULL</b> or blank, this flag implies that no access to any keys is required, and that no UI should be presented to the user.  This form is used to connect to the CSP to query its capabilities but not to actually use its keys.
     * If the <i>pszContainer</i> parameter is not <b>NULL</b> and not blank, then this flag implies that access to only the publicly available information within the specified container is required.  The CSP should not ask for a PIN.  Attempts to access private information (for example, the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a> function) will fail.
     * 
     * When <b>CryptAcquireContext</b> is called, many CSPs require input from the owning user before granting access to the private keys in the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a>. For example, the private keys can be encrypted, requiring a password from the user before they can be used. However, if the <b>CRYPT_VERIFYCONTEXT</b> flag is specified, access to the private keys is not required and the user interface can be bypassed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NEWKEYSET"></a><a id="crypt_newkeyset"></a><dl>
     * <dt><b>CRYPT_NEWKEYSET</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Creates a new key container with the name specified by <i>pszContainer</i>. If <i>pszContainer</i> is <b>NULL</b>, a key container with the default name is created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_MACHINE_KEYSET"></a><a id="crypt_machine_keyset"></a><dl>
     * <dt><b>CRYPT_MACHINE_KEYSET</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * By default, keys and key containers are stored as user keys. For Base Providers, this means that user key containers are stored in the user's profile. A key container created without this flag by an administrator can be accessed only by the user creating the key container and a user with administration privileges.
     * 
     * 
     * <b>Windows XP:  </b>A key container created without this flag by an administrator can be accessed only by the user creating the key container and the local system account.
     * 
     * 
     * 
     * A key container created without this flag by a user that is not an administrator can be accessed only by the user creating the key container and the local system account.
     * 
     * The CRYPT_MACHINE_KEYSET flag can be combined with all of the other flags to indicate that the key container of interest is a computer key container and the CSP treats it as such. For Base Providers, this means that the keys are stored locally on the computer that created the key container. If a key container is to be a computer container, the CRYPT_MACHINE_KEYSET flag must be used with all calls to <b>CryptAcquireContext</b> that reference the computer container. The key container created with CRYPT_MACHINE_KEYSET by an administrator can be accessed only by its creator and by a user with administrator <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">privileges</a> unless access rights to the container are granted using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>.
     * 
     * 
     * <b>Windows XP:  </b>The key container created with CRYPT_MACHINE_KEYSET by an administrator can be accessed only by its creator and by the local system account unless access rights to the container are granted using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>.
     * 
     * 
     * 
     * The key container created with CRYPT_MACHINE_KEYSET by a user that is not an administrator can be accessed only by its creator and by the local system account unless access rights to the container are granted using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>.
     * 
     * The CRYPT_MACHINE_KEYSET flag is useful when the user is accessing from a service or user account that did not log on interactively. When key containers are created, most CSPs do not automatically create any <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public/private key pairs</a>. These keys must be created as a separate step with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DELETEKEYSET"></a><a id="crypt_deletekeyset"></a><dl>
     * <dt><b>CRYPT_DELETEKEYSET</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Delete the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a> specified by <i>pszContainer</i>. If <i>pszContainer</i> is <b>NULL</b>, the key container with the default name is deleted. All <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key pairs</a> in the key container are also destroyed. 
     * 
     * 
     * 
     * 
     * When this flag is set, the value returned in <i>phProv</i> is undefined, and thus, the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptreleasecontext">CryptReleaseContext</a> function need not be called afterward.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_SILENT"></a><a id="crypt_silent"></a><dl>
     * <dt><b>CRYPT_SILENT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The application requests that the CSP not display any user interface (UI) for this <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a>. If the CSP must display the UI to operate, the call fails and the NTE_SILENT_CONTEXT error code is set as the last error. In addition, if calls are made to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a> with the CRYPT_USER_PROTECTED flag with a context that has been acquired with the CRYPT_SILENT flag, the calls fail and the CSP sets NTE_SILENT_CONTEXT.
     * 
     * CRYPT_SILENT is intended for use with applications for which the UI cannot be displayed by the CSP.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DEFAULT_CONTAINER_OPTIONAL"></a><a id="crypt_default_container_optional"></a><dl>
     * <dt><b>CRYPT_DEFAULT_CONTAINER_OPTIONAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obtains a context for a smart card CSP that can be used for hashing and symmetric key operations but cannot be used for any operation that requires authentication to a smart card using a PIN. This type of context is most often used to perform operations on an empty smart card, such as setting the PIN by using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>. This flag can only be used with smart card CSPs. 
     * 
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>This flag is not supported.
     * 
     * 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes defined in Winerror.h follow.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * <dt>107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Some CSPs set this error if the CRYPT_DELETEKEYSET flag value is set and another thread or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">process</a> is using this <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * <dt>2L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The profile of the user is not loaded and cannot be found. This happens when the application impersonates a user, for example, the IUSR_<i>ComputerName</i> account.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * <dt>87L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * <dt>8L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * <dt>0x80090009L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter has a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY_STATE</b></dt>
     * <dt>0x8009000BL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user password has changed since the private keys were encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEYSET</b></dt>
     * <dt>0x80090016L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key container could not be opened. A common cause of this error is that the key container does not exist. To create a key container, call <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> using the CRYPT_NEWKEYSET flag. This error code can also indicate that access to an existing key container is denied. Access rights to the container can be granted by the key set creator by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEYSET_PARAM</b></dt>
     * <dt>0x8009001FL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszContainer</i> or <i>pszProvider</i> parameter is set to a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_PROV_TYPE</b></dt>
     * <dt>0x80090014L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value of the <i>dwProvType</i> parameter is out of range. All provider types must be from 1 through 999, inclusive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * <dt>0x80090006L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider DLL signature could not be verified. Either the DLL or the digital signature has been tampered with.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_EXISTS</b></dt>
     * <dt>0x8009000FL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is CRYPT_NEWKEYSET, but the key container already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_KEYSET_ENTRY_BAD</b></dt>
     * <dt>0x8009001AL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszContainer</i> key container was found but is corrupt.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_KEYSET_NOT_DEF</b></dt>
     * <dt>0x80090019L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested provider does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * <dt>0x8009000EL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROV_DLL_NOT_FOUND</b></dt>
     * <dt>0x8009001EL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider DLL file does not exist or is not on the current path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROV_TYPE_ENTRY_BAD</b></dt>
     * <dt>0x80090018L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider type specified by <i>dwProvType</i> is corrupt. This error can relate to either the user default CSP list or the computer default CSP list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROV_TYPE_NO_MATCH</b></dt>
     * <dt>0x8009001BL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider type specified by <i>dwProvType</i> does not match the provider type found. Note that this error can only occur when <i>pszProvider</i> specifies an actual CSP name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROV_TYPE_NOT_DEF</b></dt>
     * <dt>0x80090017L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No entry exists for the provider type specified by <i>dwProvType</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PROVIDER_DLL_FAIL</b></dt>
     * <dt>0x8009001DL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider DLL file could not be loaded or failed to initialize.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_SIGNATURE_FILE_BAD</b></dt>
     * <dt>0x8009001CL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error occurred while loading the DLL file image, prior to verifying its signature.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontextw
     * @since windows5.1.2600
     */
    static CryptAcquireContextW(phProv, szContainer, szProvider, dwProvType, dwFlags) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptAcquireContextW", "ptr", phProv, "ptr", szContainer, "ptr", szProvider, "uint", dwProvType, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Releases the handle of a cryptographic service provider (CSP) and a key container.
     * @remarks
     * After this function has been called, the CSP session is finished and all existing session keys and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash objects</a> created by using the <i>hProv</i> handle are no longer valid. In practice, all of these objects should be destroyed with calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash">CryptDestroyHash</a> before <b>CryptReleaseContext</b> is called.
     * @param {Pointer} hProv Handle of a cryptographic service provider (CSP) created by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} dwFlags Reserved for future use and must be zero. If <i>dwFlags</i> is not set to zero, this function returns <b>FALSE</b> but the CSP is released.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a> specified by <i>hProv</i> is currently being used by another <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">process</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProv</i> parameter does not contain a valid context handle.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptreleasecontext
     * @since windows5.1.2600
     */
    static CryptReleaseContext(hProv, dwFlags) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptReleaseContext", "ptr", hProv, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Generates a random cryptographic session key or a public/private key pair. A handle to the key or key pair is returned in phKey. This handle can then be used as needed with any CryptoAPI function that requires a key handle.
     * @remarks
     * If keys are generated for <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">symmetric</a> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">block ciphers</a>, the key, by default, is set up in <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cipher block chaining</a> (CBC) mode with an initialization vector of zero. This <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cipher mode</a> provides a good default method for bulk encrypting data. To change these parameters, use the 
     * 			<a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetkeyparam">CryptSetKeyParam</a> function.
     * 
     * To choose an appropriate <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key length</a>, the following methods are recommended:
     * 
     * <ul>
     * <li>Enumerate the algorithms that the CSP supports and get maximum and minimum key lengths for each algorithm. To do this, call <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetprovparam">CryptGetProvParam</a> with PP_ENUMALGS_EX.</li>
     * <li>Use the minimum and maximum lengths to choose an appropriate key length. It is not always advisable to choose the maximum length because this can lead to performance issues.</li>
     * <li>After the desired key length has been chosen, use the upper 16 bits of the <i>dwFlags</i> parameter to specify the key length.</li>
     * </ul>
     * @param {Pointer} hProv A handle to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) created by a call to 
     * 					<a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} Algid An 
     * 						<a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> value that identifies the algorithm for which the key is to be generated. Values for this parameter vary depending on the CSP used.
     * 
     * For <b>ALG_ID</b> values to use with the Microsoft Base Cryptographic Provider, see 
     * 			<a href="https://docs.microsoft.com/windows/desktop/SecCrypto/base-provider-algorithms">Base Provider Algorithms</a>.
     * 
     * For <b>ALG_ID</b> values to use with the Microsoft Strong Cryptographic Provider or the Microsoft Enhanced Cryptographic Provider, see 
     * 			<a href="https://docs.microsoft.com/windows/desktop/SecCrypto/enhanced-provider-algorithms">Enhanced Provider Algorithms</a>.
     * @param {Integer} dwFlags Specifies the type of key generated. The sizes of a session key, RSA signature key, and RSA key <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">exchange keys</a> can be set when the key is generated. The key size, representing the length of the key modulus in bits, is set with the upper 16 bits of this parameter. Thus, if a 2,048-bit RSA signature key is to be generated, the value 0x08000000 is combined with any other <i>dwFlags</i> predefined value with a bitwise-<b>OR</b> operation. The upper 16 bits of 0x08000000 is 0x0800, or decimal 2,048. The <b>RSA1024BIT_KEY</b> value can be used to specify a 1024-bit RSA key.
     * 
     * Due to changing export control restrictions, the default CSP and default <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key length</a> may change between operating system versions. It is important that both the encryption and decryption use the same CSP and that the key length be explicitly set using the <i>dwFlags</i> parameter to ensure interoperability on different operating system platforms.
     * 
     * In particular, the default RSA Full Cryptographic Service Provider is the Microsoft RSA Strong Cryptographic Provider. The default DSS Signature Diffie-Hellman Cryptographic Service Provider is the Microsoft Enhanced DSS Diffie-Hellman Cryptographic Provider. Each of these CSPs has a default 128-bit symmetric key length for RC2 and RC4 and a 1,024-bit default key length for public key algorithms. 
     * 
     * If the upper 16 bits is zero, the default key size is generated. If a key larger than the maximum or smaller than the minimum is specified, the call fails with the ERROR_INVALID_PARAMETER code.
     * 
     * The following table lists minimum, default, and maximum signature and exchange key lengths beginning with Windows XP.
     * 
     * <table>
     * <tr>
     * <th>Key type and provider</th>
     * <th>Minimum length</th>
     * <th>Default length</th>
     * <th>Maximum length</th>
     * </tr>
     * <tr>
     * <td>
     * RSA Base Provider
     * 
     * Signature and ExchangeKeys
     * 
     * </td>
     * <td>
     * 384
     * 
     * </td>
     * <td>
     * 512
     * 
     * </td>
     * <td>
     * 16,384
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * RSA Strong and Enhanced Providers
     * 
     * Signature and Exchange Keys
     * 
     * </td>
     * <td>
     * 384
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * <td>
     * 16,384
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DSS Base Providers
     * 
     * Signature Keys
     * 
     * </td>
     * <td>
     * 512
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DSS Base Providers
     * 
     * Exchange Keys
     * 
     * </td>
     * <td>
     * Not applicable
     * 
     * </td>
     * <td>
     * Not applicable
     * 
     * </td>
     * <td>
     * Not applicable
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DSS/DH Base Providers
     * 
     * Signature Keys
     * 
     * </td>
     * <td>
     * 512
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DSS/DH Base Providers
     * 
     * Exchange Keys
     * 
     * </td>
     * <td>
     * 512
     * 
     * </td>
     * <td>
     * 512
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DSS/DH Enhanced Providers
     * 
     * Signature Keys
     * 
     * </td>
     * <td>
     * 512
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DSS/DH Enhanced Providers
     * 
     * Exchange Keys
     * 
     * </td>
     * <td>
     * 512
     * 
     * </td>
     * <td>
     * 1,024
     * 
     * </td>
     * <td>
     * 4,096
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * For session key lengths, see <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptderivekey">CryptDeriveKey</a>.
     * 
     * For more information about keys generated using Microsoft providers, see 
     * 			<a href="https://docs.microsoft.com/windows/desktop/SecCrypto/microsoft-cryptographic-service-providers">Microsoft Cryptographic Service Providers</a>.
     * @param {Pointer<UIntPtr>} phKey Address to which the function copies the handle of the newly generated key. When you have finished  using the key, delete  the handle to the key by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.
     * @returns {Integer} Returns nonzero if successful or zero otherwise.
     * 
     * For extended error information, call 
     * 			<a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Algid</i> parameter specifies an algorithm that this CSP does not support.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProv</i> parameter does not contain a valid context handle.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_SILENT_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider could not perform the action because the context was acquired as silent.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptgenkey
     * @since windows5.1.2600
     */
    static CryptGenKey(hProv, Algid, dwFlags, phKey) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptGenKey", "ptr", hProv, "uint", Algid, "uint", dwFlags, "ptr", phKey, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Generates cryptographic session keys derived from a base data value.
     * @remarks
     * When keys are generated for <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">symmetric</a> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">block ciphers</a>, the key by default is set up in <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cipher block chaining</a> (CBC) mode with an initialization vector of zero. This <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cipher mode</a> provides a good default method for bulk-encrypting data. To change these parameters, use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetkeyparam">CryptSetKeyParam</a> function.
     * 
     * The <b>CryptDeriveKey</b> function completes the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a>. After <b>CryptDeriveKey</b> has been called, no more data can be added to the hash. Additional calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashsessionkey">CryptHashSessionKey</a> fail. After the application is done with the hash, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash">CryptDestroyHash</a> must be called to destroy the hash object.
     * 
     * To choose an appropriate <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key length</a>, the following methods are recommended.
     * 
     * <ul>
     * <li>To enumerate the algorithms that the CSP supports and  to get maximum and minimum key lengths for each algorithm, call <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetprovparam">CryptGetProvParam</a> with  PP_ENUMALGS_EX.</li>
     * <li>Use the minimum and maximum lengths to choose an appropriate key length. It is not always advisable to choose the maximum length because this can lead to performance issues.</li>
     * <li>After the desired key length has been chosen, use the upper 16 bits of the <i>dwFlags</i> parameter to specify the key length.</li>
     * </ul>
     * Let <b>n</b> be the required derived key length, in bytes.  The derived key is the first <b>n</b> bytes of the hash value after the hash computation has been completed by <b>CryptDeriveKey</b>.  If the hash is not a member of the SHA-2 family and the required key is for either 3DES or AES, the key is derived as follows:
     * 
     * <ol>
     * <li>Form a 64-byte buffer by repeating the constant <b>0x36</b> 64 times.  Let <b>k</b> be the length of the hash value that is represented by the input parameter <i>hBaseData</i>.  Set the first <b>k</b> bytes of the buffer to the result of an <b>XOR</b> operation of the first <b>k</b> bytes of the buffer with the hash value that is represented by the input parameter <i>hBaseData</i>.</li>
     * <li>Form a 64-byte buffer by repeating the constant <b>0x5C</b> 64 times.  Set the first <b>k</b> bytes of the buffer to the result of an <b>XOR</b> operation of the first <b>k</b> bytes of the buffer with the hash value that is represented by the input parameter <i>hBaseData</i>.</li>
     * <li>Hash the result of step 1 by using the same hash algorithm as that used to compute the hash value that is represented by the <i>hBaseData</i> parameter.</li>
     * <li>Hash the result of step 2 by using the same hash algorithm as that used to compute the hash value that is represented by the <i>hBaseData</i> parameter.</li>
     * <li>Concatenate the result of step 3 with the result of step 4.</li>
     * <li>Use the first <b>n</b> bytes of the result of step 5 as the derived key.</li>
     * </ol>
     * The default RSA Full Cryptographic Service Provider is the Microsoft RSA Strong Cryptographic Provider. The default DSS Signature Diffie-Hellman Cryptographic Service Provider is the Microsoft Enhanced DSS Diffie-Hellman Cryptographic Provider. Each of these CSPs has a default 128-bit symmetric key length for <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">RC2</a> and RC4.
     * 
     * The following table lists minimum, default, and maximum key lengths for session key by algorithm and provider.
     * 
     * <table>
     * <tr>
     * <th>Provider</th>
     * <th>Algorithms</th>
     * <th>Minimum key length</th>
     * <th>Default key length</th>
     * <th>Maximum key length</th>
     * </tr>
     * <tr>
     * <td>MS Base</td>
     * <td>RC4 and RC2</td>
     * <td>40</td>
     * <td>40</td>
     * <td>56</td>
     * </tr>
     * <tr>
     * <td>MS Base</td>
     * <td>DES</td>
     * <td>56</td>
     * <td>56</td>
     * <td>56</td>
     * </tr>
     * <tr>
     * <td>MS Enhanced</td>
     * <td>RC4 and RC2</td>
     * <td>40</td>
     * <td>128</td>
     * <td>128</td>
     * </tr>
     * <tr>
     * <td>MS Enhanced</td>
     * <td>DES</td>
     * <td>56</td>
     * <td>56</td>
     * <td>56</td>
     * </tr>
     * <tr>
     * <td>MS Enhanced</td>
     * <td>3DES 112</td>
     * <td>112</td>
     * <td>112</td>
     * <td>112</td>
     * </tr>
     * <tr>
     * <td>MS Enhanced</td>
     * <td>3DES</td>
     * <td>168</td>
     * <td>168</td>
     * <td>168</td>
     * </tr>
     * <tr>
     * <td>MS Strong</td>
     * <td>RC4 and RC2</td>
     * <td>40</td>
     * <td>128</td>
     * <td>128</td>
     * </tr>
     * <tr>
     * <td>MS Strong</td>
     * <td>DES</td>
     * <td>56</td>
     * <td>56</td>
     * <td>56</td>
     * </tr>
     * <tr>
     * <td>MS Strong</td>
     * <td>3DES 112</td>
     * <td>112</td>
     * <td>112</td>
     * <td>112</td>
     * </tr>
     * <tr>
     * <td>MS Strong</td>
     * <td>3DES</td>
     * <td>168</td>
     * <td>168</td>
     * <td>168</td>
     * </tr>
     * <tr>
     * <td>DSS/DH Base</td>
     * <td>RC4 and RC2</td>
     * <td>40</td>
     * <td>40</td>
     * <td>56</td>
     * </tr>
     * <tr>
     * <td>DSS/DH Base</td>
     * <td>Cylink MEK</td>
     * <td>40</td>
     * <td>40</td>
     * <td>40</td>
     * </tr>
     * <tr>
     * <td>DSS/DH Base</td>
     * <td>DES</td>
     * <td>56</td>
     * <td>56</td>
     * <td>56</td>
     * </tr>
     * <tr>
     * <td>DSS/DH Enh</td>
     * <td>RC4 and RC2</td>
     * <td>40</td>
     * <td>128</td>
     * <td>128</td>
     * </tr>
     * <tr>
     * <td>DSS/DH Enh</td>
     * <td>Cylink MEK</td>
     * <td>40</td>
     * <td>40</td>
     * <td>40</td>
     * </tr>
     * <tr>
     * <td>DSS/DH Enh</td>
     * <td>DES</td>
     * <td>56</td>
     * <td>56</td>
     * <td>56</td>
     * </tr>
     * <tr>
     * <td>DSS/DH Enh</td>
     * <td>3DES 112</td>
     * <td>112</td>
     * <td>112</td>
     * <td>112</td>
     * </tr>
     * <tr>
     * <td>DSS/DH Enh</td>
     * <td>3DES</td>
     * <td>168</td>
     * <td>168</td>
     * <td>168</td>
     * </tr>
     * </table>
     * @param {Pointer} hProv A <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a> handle of a CSP created by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} Algid An 
     * 						<a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> structure that identifies the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">symmetric encryption</a> algorithm for which the key is to be generated. The algorithms available will most likely be different for each CSP. For more information about which algorithm identifier is used by the different providers for the key specs AT_KEYEXCHANGE and AT_SIGNATURE, see 
     * <b>ALG_ID</b>.
     * 
     * For more information about <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> values to use with the Microsoft Base Cryptographic Provider, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/base-provider-algorithms">Base Provider Algorithms</a>. For more information about <b>ALG_ID</b> values to use with the Microsoft Strong Cryptographic Provider or the Microsoft Enhanced Cryptographic Provider, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/enhanced-provider-algorithms">Enhanced Provider Algorithms</a>.
     * @param {Pointer} hBaseData A handle to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash object</a> that has been fed the exact base data.
     * 
     * To obtain this handle, an application must first create a hash object with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a> and then add the base data to the hash object with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>. This process is described in detail in 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hashes-and-digital-signatures">Hashes and Digital Signatures</a>.
     * @param {Integer} dwFlags Specifies the type of key generated.
     * 
     * The sizes of a session key can be set when the key is generated. The key size, representing the length of the key modulus in bits, is set with the upper 16 bits of this parameter. Thus, if a 128-bit <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">RC4</a> session key is to be generated, the value 0x00800000 is combined with any other <i>dwFlags</i> predefined value with a bitwise-<b>OR</b> operation. Due to changing export control restrictions, the default CSP and default <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key length</a> may change between operating system releases. It is important that both the encryption and decryption use the same CSP and that the key length be explicitly set using the <i>dwFlags</i> parameter to ensure interoperability on different operating system platforms.
     * 
     * The lower 16 bits of this parameter can be zero or you can specify one or more of the following flags by using the bitwise-<b>OR</b> operator to combine them.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_CREATE_SALT"></a><a id="crypt_create_salt"></a><dl>
     * <dt><b>CRYPT_CREATE_SALT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Typically, when a session key is made from a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> value, there are a number of leftover bits. For example, if the hash value is 128 bits and the session key is 40 bits, there will be 88 bits left over.
     * 
     * If this flag is set, then the key is assigned a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">salt value</a> based on the unused hash value bits. You can retrieve this <i>salt value</i> by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetkeyparam">CryptGetKeyParam</a> function with the <i>dwParam</i> parameter set to KP_SALT.
     * 
     * If this flag is not set, then the key is given a salt value of zero.
     * 
     * When keys with nonzero salt values are exported (by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a>), the salt value must also be obtained and kept with the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key BLOB</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_EXPORTABLE"></a><a id="crypt_exportable"></a><dl>
     * <dt><b>CRYPT_EXPORTABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the session key can be transferred out of the CSP into a key BLOB through the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a> function. Because keys generally must be exportable, this flag should usually be set.
     * 
     * If this flag is not set, then the session key is not exportable. This means the key is available only within the current session and only the application that created it is able to use it.
     * 
     * This flag does not apply to <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public/private key pairs</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NO_SALT"></a><a id="crypt_no_salt"></a><dl>
     * <dt><b>CRYPT_NO_SALT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag specifies that a no <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">salt value</a> gets allocated for a 40-bit <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">symmetric key</a>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/salt-value-functionality">Salt Value Functionality</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_UPDATE_KEY"></a><a id="crypt_update_key"></a><dl>
     * <dt><b>CRYPT_UPDATE_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Some CSPs use session keys that are derived from multiple hash values. When this is the case, <b>CryptDeriveKey</b> must be called multiple times.
     * 
     * If this flag is set, a new session key is not generated. Instead, the key specified by <i>phKey</i> is modified. The precise behavior of this flag is dependent on the type of key being generated and on the particular CSP being used.
     * 
     * Microsoft cryptographic service providers ignore this flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_SERVER"></a><a id="crypt_server"></a><dl>
     * <dt><b>CRYPT_SERVER</b></dt>
     * <dt>1024 (0x400)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is used only with <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">Schannel</a> providers. If this flag is set, the key to be generated is a server-write key; otherwise, it is a client-write key.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UIntPtr>} phKey A pointer to  a <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptkey">HCRYPTKEY</a> variable to receive the address of the handle of the newly generated key. When you have finished using the key, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Algid</i> parameter specifies an algorithm that this CSP does not support.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hBaseData</i> parameter does not contain a valid handle to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash object</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH_STATE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt was made to add data to a hash object that is already marked "finished."
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProv</i> parameter does not contain a valid context handle.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_SILENT_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider could not perform the action because the context was acquired as silent.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptderivekey
     * @since windows5.1.2600
     */
    static CryptDeriveKey(hProv, Algid, hBaseData, dwFlags, phKey) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptDeriveKey", "ptr", hProv, "uint", Algid, "ptr", hBaseData, "uint", dwFlags, "ptr", phKey, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Releases the handle referenced by the hKey parameter.
     * @remarks
     * Keys take up both operating system's memory space and the CSP's memory space. Some CSPs are implemented in hardware with limited memory resources. Applications must destroy all keys with the <b>CryptDestroyKey</b> function when they are finished with them.
     * 
     * All key handles that have been created or imported by using a specific CSP must be destroyed before that CSP handle is released with the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptreleasecontext">CryptReleaseContext</a> function.
     * @param {Pointer} hKey The handle of the key to be destroyed.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key object specified by <i>hKey</i> is currently being used and cannot be destroyed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter does not contain a valid handle to a key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the key was created cannot be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptdestroykey
     * @since windows5.1.2600
     */
    static CryptDestroyKey(hKey) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptDestroyKey", "ptr", hKey, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Customizes various aspects of a session key's operations.
     * @remarks
     * If the KP_Q, KP_P, or KP_X parameters are set on a PREGEN Diffie-Hellman or DSS key, the key lengths must be compatible with the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key length</a> set using the upper 16 bits of the <i>dwFlags</i> parameter when the key was created using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a>. If no key length was set in <b>CryptGenKey</b>, the default key length was used. This will create an error if a nondefault key length is used to set P, Q, or X.
     * @param {Pointer} hKey A handle to the key for which values are to be set.
     * @param {Integer} dwParam The following tables contain predefined values that can be used.
     * @param {Pointer<Byte>} pbData A pointer to a buffer initialized with the value to be set before calling <b>CryptSetKeyParam</b>. The form of this data varies depending on the value of <i>dwParam</i>.
     * @param {Integer} dwFlags Used only when <i>dwParam</i> is KP_ALGID. The <i>dwFlags</i> parameter is used to pass in flag values for the enabled key. The <i>dwFlags</i> parameter can hold values such as the key size and the other flag values allowed when generating the same type of key with <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a>. For information about allowable flag values, see 
     * <b>CryptGenKey</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context is currently being used by another <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">process</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero, or the <i>pbData</i> buffer contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwParam</i> parameter specifies an unknown parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the <i>hKey</i> key was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FIXEDPARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Some CSPs have hard-coded P, Q, and G values. If this is the case, then using KP_P, KP_Q, and KP_G for the value of <i>dwParam</i> causes this error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptsetkeyparam
     * @since windows5.1.2600
     */
    static CryptSetKeyParam(hKey, dwParam, pbData, dwFlags) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSetKeyParam", "ptr", hKey, "uint", dwParam, "ptr", pbData, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves data that governs the operations of a key.
     * @param {Pointer} hKey The handle of the key being queried.
     * @param {Integer} dwParam Specifies the type of query being made.
     * @param {Pointer<Byte>} pbData A pointer to a buffer that receives the data. The form of this data depends on the value of <i>dwParam</i>.
     * 
     * If the size of  this buffer is not known, the required size can be retrieved at run time by passing <b>NULL</b> for this parameter and setting the value pointed to by <i>pdwDataLen</i> to zero. This function will place the required size of the buffer, in bytes, in the value pointed to by <i>pdwDataLen</i>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pdwDataLen A pointer to a <b>DWORD</b> value that, on entry, contains the size, in bytes, of the buffer pointed to by the <i>pbData</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size may be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are sometimes specified large enough to ensure that the largest possible output data fits in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @param {Integer} dwFlags This parameter is reserved for future use and must be set to zero.
     * @returns {Integer} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. Some possible error codes include the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbData</i> parameter is not large enough to hold the returned data, the function sets the <b>ERROR_MORE_DATA</b> code and stores the required buffer size, in bytes, in the variable pointed to by <i>pdwDataLen</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY or NTE_NO_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key specified by the <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwParam</i> parameter specifies an unknown value number.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a> that was specified when the key was created cannot be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptgetkeyparam
     * @since windows5.1.2600
     */
    static CryptGetKeyParam(hKey, dwParam, pbData, pdwDataLen, dwFlags) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptGetKeyParam", "ptr", hKey, "uint", dwParam, "ptr", pbData, "ptr", pdwDataLen, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Customizes the operations of a hash object, including setting up initial hash contents and selecting a specific hashing algorithm.
     * @remarks
     * Occasionally, a hash value that has been generated elsewhere must be signed. This can be done by using the following sequence of operations:
     * 
     * <ol>
     * <li>Create a hash object by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>.</li>
     * <li>Set the HP_HASHVAL value.</li>
     * <li>Sign the hash value by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a> and obtain a digital signature block.</li>
     * <li>Destroy the hash object by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash">CryptDestroyHash</a>.</li>
     * </ol>
     * @param {Pointer} hHash A handle to the hash object on which to set parameters.
     * @param {Integer} dwParam 
     * @param {Pointer<Byte>} pbData A value data buffer. Place the value data in this buffer before calling <b>CryptSetHashParam</b>. The form of this data varies, depending on the value number.
     * @param {Integer} dwFlags This parameter is reserved for future use and must be set to zero.
     * @returns {Integer} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context is currently being used by another <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">process</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero or the <i>pbData</i> buffer contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwParam</i> parameter specifies an unknown value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the <i>hKey</i> key was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptsethashparam
     * @since windows5.1.2600
     */
    static CryptSetHashParam(hHash, dwParam, pbData, dwFlags) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSetHashParam", "ptr", hHash, "uint", dwParam, "ptr", pbData, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves data that governs the operations of a hash object.
     * @param {Pointer} hHash Handle of the hash object to be queried.
     * @param {Integer} dwParam Query type. This parameter can be set to one of the following queries. 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="HP_ALGID"></a><a id="hp_algid"></a><dl>
     * <dt><b>HP_ALGID</b></dt>
     * <dt>Hash algorithm</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> that indicates the algorithm specified when the hash object was created. For a list of hash algorithms, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="HP_HASHSIZE"></a><a id="hp_hashsize"></a><dl>
     * <dt><b>HP_HASHSIZE</b></dt>
     * <dt>Hash value size</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>DWORD</b> value indicating the number of bytes in the hash value. This value will vary depending on the hash algorithm. Applications must retrieve this value just before the HP_HASHVAL value so the correct amount of memory can be allocated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="HP_HASHVAL"></a><a id="hp_hashval"></a><dl>
     * <dt><b>HP_HASHVAL</b></dt>
     * <dt>Hash value</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash value or message hash for the hash object specified by <i>hHash</i>. This value is generated based on the data supplied to the hash object earlier through the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashsessionkey">CryptHashSessionKey</a> functions.
     * 
     * The <b>CryptGetHashParam</b> function completes the hash. After <b>CryptGetHashParam</b> has been called, no more data can be added to the hash. Additional calls to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> or <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashsessionkey">CryptHashSessionKey</a> fail. After the application is done with the hash, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash">CryptDestroyHash</a> should be called to destroy the hash object.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  CSPs can add more values that this function can query.</div>
     * <div> </div>
     * @param {Pointer<Byte>} pbData A pointer to a buffer that receives the specified value data. The form of this data varies, depending on the value number. 
     * 
     * 
     * This parameter can be <b>NULL</b> to determine the memory size required.
     * @param {Pointer<UInt32>} pdwDataLen A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the <i>pbData</i> buffer. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer. 
     * 
     * 
     * If <i>pbData</i> is <b>NULL</b>, set the value of <i>pdwDataLen</i> to zero.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbData</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pdwDataLen</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwParam</i> parameter specifies an unknown value number.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the hash was created cannot be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptgethashparam
     * @since windows5.1.2600
     */
    static CryptGetHashParam(hHash, dwParam, pbData, pdwDataLen, dwFlags) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptGetHashParam", "ptr", hHash, "uint", dwParam, "ptr", pbData, "ptr", pdwDataLen, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Customizes the operations of a cryptographic service provider (CSP). This function is commonly used to set a security descriptor on the key container associated with a CSP to control access to the private keys in that key container.
     * @param {Pointer} hProv The handle of a CSP for which to set values. This handle must have already been created by using 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function.
     * @param {Integer} dwParam 
     * @param {Pointer<Byte>} pbData A pointer to a data buffer that contains the value to be set as a provider parameter. The form of this data varies depending on the <i>dwParam</i> value. If <i>dwParam</i> contains <b>PP_USE_HARDWARE_RNG</b>, this parameter must be <b>NULL</b>.
     * @param {Integer} dwFlags If <i>dwParam</i> contains <b>PP_KEYSET_SEC_DESCR</b>, <i>dwFlags</i> contains the <b>SECURITY_INFORMATION</b> applicable bit flags, as defined in the Platform SDK. Key-container security is handled by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setfilesecuritya">SetFileSecurity</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfilesecuritya">GetFileSecurity</a>.
     * 
     * These bit flags can be combined by using a bitwise-<b>OR</b> operation. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetprovparam">CryptGetProvParam</a>.
     * 
     * If <i>dwParam</i> is <b>PP_USE_HARDWARE_RNG</b> or <b>PP_DELETEKEY</b>, <i>dwFlags</i> must be set to zero.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. Error codes include the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context is currently being used by another <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">process</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero or the <i>pbData</i> buffer contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwParam</i> parameter specifies an unknown parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the <i>hKey</i> key was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptsetprovparam
     * @since windows5.1.2600
     */
    static CryptSetProvParam(hProv, dwParam, pbData, dwFlags) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSetProvParam", "ptr", hProv, "uint", dwParam, "ptr", pbData, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves parameters that govern the operations of a cryptographic service provider (CSP).
     * @remarks
     * This function must not be used on a thread of a multithreaded program.
     * 
     * The following values are returned in <i>pbData</i> if <i>dwParam</i> is PP_IMPTYPE.
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>CRYPT_IMPL_HARDWARE<br/>
     * 0x01
     * </td>
     * <td>Implementation is in hardware.</td>
     * </tr>
     * <tr>
     * <td>CRYPT_IMPL_SOFTWARE<br/>
     * 0x02
     * </td>
     * <td>Implementation is in software.</td>
     * </tr>
     * <tr>
     * <td>CRYPT_IMPL_MIXED<br/>
     * 0x03
     * </td>
     * <td>Implementation involves both hardware and software.</td>
     * </tr>
     * <tr>
     * <td>CRYPT_IMPL_UNKNOWN<br/>
     * 0x04
     * </td>
     * <td>Implementation type is unknown.</td>
     * </tr>
     * <tr>
     * <td>CRYPT_IMPL_REMOVABLE<br/>
     * 0x08
     * 	
     * </td>
     * <td>Implementation is in removable media.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * The <i>dwFlags</i> parameter is used to pass in the <b>SECURITY_INFORMATION</b> bit flags that indicate the requested security information. The pointer to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">security descriptor</a> is returned in the <i>pbData</i> parameter and the length of the security descriptor is returned in the <i>pdwDataLen</i> parameter. Key-container security is handled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setfilesecuritya">SetFileSecurity</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfilesecuritya">GetFileSecurity</a>.
     * 
     * 
     * The class of an algorithm enumerated with <i>dwParam</i> set to PP_ENUMALGS or PP_ENUMALGS_EX can be determined. This might be done to display a list of encryption algorithms supported and to disregard the rest. The <b>GET_ALG_CLASS(</b><i>x</i><b>)</b> macro takes an algorithm identifier as an argument and returns a code indicating the general class of that algorithm. Possible return values include:
     * 
     * <ul>
     * <li>ALG_CLASS_DATA_ENCRYPT</li>
     * <li>ALG_CLASS_HASH</li>
     * <li>ALG_CLASS_KEY_EXCHANGE</li>
     * <li>ALG_CLASS_SIGNATURE</li>
     * </ul>
     * 
     * 
     * The following table lists the algorithms supported by the Microsoft Base Cryptographic Provider along with the class of each algorithm.<table>
     * <tr>
     * <th>Name</th>
     * <th>Identifier</th>
     * <th>Class</th>
     * </tr>
     * <tr>
     * <td>"MD2"</td>
     * <td><a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CALG_MD2</a></td>
     * <td>ALG_CLASS_HASH</td>
     * </tr>
     * <tr>
     * <td>"MD5"</td>
     * <td><a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CALG_MD5</a></td>
     * <td>ALG_CLASS_HASH</td>
     * </tr>
     * <tr>
     * <td>"SHA"</td>
     * <td><a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CALG_SHA</a></td>
     * <td>ALG_CLASS_HASH</td>
     * </tr>
     * <tr>
     * <td>"MAC"</td>
     * <td><a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CALG_MAC</a></td>
     * <td>ALG_CLASS_HASH</td>
     * </tr>
     * <tr>
     * <td>"RSA_SIGN"</td>
     * <td><a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CALG_RSA_SIGN</a></td>
     * <td>ALG_CLASS_SIGNATURE</td>
     * </tr>
     * <tr>
     * <td>"RSA_KEYX"</td>
     * <td><a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CALG_RSA_KEYX</a></td>
     * <td>ALG_CLASS_KEY_EXCHANGE</td>
     * </tr>
     * <tr>
     * <td>"RC2"</td>
     * <td><a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CALG_RC2</a></td>
     * <td>ALG_CLASS_DATA_ENCRYPT</td>
     * </tr>
     * <tr>
     * <td>"RC4"</td>
     * <td><a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CALG_RC4</a></td>
     * <td>ALG_CLASS_DATA_ENCRYPT</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * Applications must not use an algorithm with an algorithm identifier that is not recognized. Using an unknown cryptographic algorithm can produce unpredictable results.
     * @param {Pointer} hProv A handle of the CSP target of the query. This handle must have been created by using 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function.
     * @param {Integer} dwParam The nature of the query. The following queries are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_ADMIN_PIN"></a><a id="pp_admin_pin"></a><dl>
     * <dt><b>PP_ADMIN_PIN</b></dt>
     * <dt>31 (0x1F)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns the administrator personal identification number (PIN) in the <i>pbData</i> parameter as a <b>LPSTR</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_APPLI_CERT"></a><a id="pp_appli_cert"></a><dl>
     * <dt><b>PP_APPLI_CERT</b></dt>
     * <dt>18 (0x12)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This constant is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_CHANGE_PASSWORD"></a><a id="pp_change_password"></a><dl>
     * <dt><b>PP_CHANGE_PASSWORD</b></dt>
     * <dt>7 (0x7)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This constant is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_CERTCHAIN"></a><a id="pp_certchain"></a><dl>
     * <dt><b>PP_CERTCHAIN</b></dt>
     * <dt>9 (0x9)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns the certificate chain associated with the <i>hProv</i> handle. The returned certificate chain is <b>X509_ASN_ENCODING</b> encoded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_CONTAINER"></a><a id="pp_container"></a><dl>
     * <dt><b>PP_CONTAINER</b></dt>
     * <dt>6 (0x6)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name of the current <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a> as a <b>null</b>-terminated <b>CHAR</b> string. This string is exactly the same as the one passed in the <i>pszContainer</i> parameter of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function to specify the key container to use. The <i>pszContainer</i> parameter can be read to determine the name of the default key container.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_CRYPT_COUNT_KEY_USE"></a><a id="pp_crypt_count_key_use"></a><dl>
     * <dt><b>PP_CRYPT_COUNT_KEY_USE</b></dt>
     * <dt>41 (0x29)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not implemented by Microsoft CSPs. This behavior may be implemented by other CSPs.
     * 
     * <b>Windows XP:  </b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_ENUMALGS"></a><a id="pp_enumalgs"></a><dl>
     * <dt><b>PP_ENUMALGS</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-prov_enumalgs">PROV_ENUMALGS</a> structure that contains information about one algorithm supported by the CSP being queried.
     * 
     * The first time this value is read, the <i>dwFlags</i> parameter must contain the <b>CRYPT_FIRST</b> flag. Doing so causes this function to retrieve the first element in the enumeration. The subsequent elements can then be retrieved by setting the <b>CRYPT_NEXT</b> flag in the <i>dwFlags</i> parameter. When this function fails with the <b>ERROR_NO_MORE_ITEMS</b> error code, the end of the enumeration has been reached.
     * 
     * This function is not thread safe, and all of the available algorithms might not be enumerated if this function is used in a multithreaded context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_ENUMALGS_EX"></a><a id="pp_enumalgs_ex"></a><dl>
     * <dt><b>PP_ENUMALGS_EX</b></dt>
     * <dt>22 (0x16)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 
     * 								<a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-prov_enumalgs_ex">PROV_ENUMALGS_EX</a> structure that contains information about one algorithm supported by the CSP being queried. The structure returned contains more information about the algorithm than the structure returned for PP_ENUMALGS.
     * 
     * The first time this value is read, the <i>dwFlags</i> parameter must contain the <b>CRYPT_FIRST</b> flag. Doing so causes this function to retrieve the first element in the enumeration. The subsequent elements can then be retrieved by setting the <b>CRYPT_NEXT</b> flag in the <i>dwFlags</i> parameter. When this function fails with the <b>ERROR_NO_MORE_ITEMS</b> error code, the end of the enumeration has been reached.
     * 
     * This function is not thread safe and all of the available algorithms might not be enumerated if this function is used in a multithreaded context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_ENUMCONTAINERS"></a><a id="pp_enumcontainers"></a><dl>
     * <dt><b>PP_ENUMCONTAINERS</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name of one of the key containers maintained by the CSP in the form of a <b>null</b>-terminated <b>CHAR</b> string. 
     * 
     * The first time this value is read, the <i>dwFlags</i> parameter must contain the <b>CRYPT_FIRST</b> flag. Doing so causes this function to retrieve the first element in the enumeration. The subsequent elements can then be retrieved by setting the <b>CRYPT_NEXT</b> flag in the <i>dwFlags</i> parameter. When this function fails with the <b>ERROR_NO_MORE_ITEMS</b> error code, the end of the enumeration has been reached.
     * 
     * To enumerate key containers associated with a computer, first call <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> using the <b>CRYPT_MACHINE_KEYSET</b> flag, and then use the handle returned from <b>CryptAcquireContext</b> as the <i>hProv</i> parameter in the call to <b>CryptGetProvParam</b>.
     * 
     * This function is not thread safe and all of the available algorithms might not be enumerated if this function is used in a multithreaded context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_ENUMELECTROOTS"></a><a id="pp_enumelectroots"></a><dl>
     * <dt><b>PP_ENUMELECTROOTS</b></dt>
     * <dt>26 (0x1A)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This constant is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_ENUMEX_SIGNING_PROT"></a><a id="pp_enumex_signing_prot"></a><dl>
     * <dt><b>PP_ENUMEX_SIGNING_PROT</b></dt>
     * <dt>40 (0x28)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the current CSP supports the <b>dwProtocols</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-prov_enumalgs_ex">PROV_ENUMALGS_EX</a> structure. If this function succeeds, the CSP supports the <b>dwProtocols</b> member of the <b>PROV_ENUMALGS_EX</b> structure. If this function fails with an <b>NTE_BAD_TYPE</b> error code, the CSP does not support the <b>dwProtocols</b> member.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_ENUMMANDROOTS"></a><a id="pp_enummandroots"></a><dl>
     * <dt><b>PP_ENUMMANDROOTS</b></dt>
     * <dt>25 (0x19)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This constant is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_IMPTYPE"></a><a id="pp_imptype"></a><dl>
     * <dt><b>PP_IMPTYPE</b></dt>
     * <dt>3 (0x3)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <b>DWORD</b> value that indicates how the CSP is implemented. For a table of possible values, see Remarks.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_KEY_TYPE_SUBTYPE"></a><a id="pp_key_type_subtype"></a><dl>
     * <dt><b>PP_KEY_TYPE_SUBTYPE</b></dt>
     * <dt>10 (0xA)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This query is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_KEYEXCHANGE_PIN"></a><a id="pp_keyexchange_pin"></a><dl>
     * <dt><b>PP_KEYEXCHANGE_PIN</b></dt>
     * <dt>32 (0x20)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies that the key exchange PIN is contained in <i>pbData</i>. The PIN is represented as a <b>null</b>-terminated ASCII string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_KEYSET_SEC_DESCR"></a><a id="pp_keyset_sec_descr"></a><dl>
     * <dt><b>PP_KEYSET_SEC_DESCR</b></dt>
     * <dt>8 (0x8)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">security descriptor</a> for the key storage container. The <i>pbData</i> parameter is the address of a <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> structure that receives the security descriptor for the key storage container. The security descriptor is returned in self-relative format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_KEYSET_TYPE"></a><a id="pp_keyset_type"></a><dl>
     * <dt><b>PP_KEYSET_TYPE</b></dt>
     * <dt>27 (0x1B)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the <i>hProv</i> parameter is a computer key set. The <i>pbData</i> parameter must be a <b>DWORD</b>; the <b>DWORD</b> will be set to the CRYPT_MACHINE_KEYSET flag if that flag was passed to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_KEYSPEC"></a><a id="pp_keyspec"></a><dl>
     * <dt><b>PP_KEYSPEC</b></dt>
     * <dt>39 (0x27)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns information about the key specifier values that the CSP supports. Key specifier values are joined in a logical <b>OR</b> and returned in the <i>pbData</i> parameter of the call as a <b>DWORD</b>. For example, the Microsoft Base Cryptographic Provider version 1.0 returns a <b>DWORD</b> value of AT_SIGNATURE | AT_KEYEXCHANGE.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_KEYSTORAGE"></a><a id="pp_keystorage"></a><dl>
     * <dt><b>PP_KEYSTORAGE</b></dt>
     * <dt>17 (0x11)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns a <b>DWORD</b> value of CRYPT_SEC_DESCR.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_KEYX_KEYSIZE_INC"></a><a id="pp_keyx_keysize_inc"></a><dl>
     * <dt><b>PP_KEYX_KEYSIZE_INC</b></dt>
     * <dt>35 (0x23)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The number of bits for the increment length of AT_KEYEXCHANGE. This information is used with information returned in the PP_ENUMALGS_EX value. With the information returned when using PP_ENUMALGS_EX and PP_KEYX_KEYSIZE_INC, the valid key lengths for AT_KEYEXCHANGE can be determined. These key lengths can then be used with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a>. For example if a CSP enumerates <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CALG_RSA_KEYX</a> (AT_KEYEXCHANGE) with a minimum key length of 512 bits and a maximum of 1024 bits, and returns the increment length as 64 bits, then valid key lengths are 512, 576, 640,… 1024.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_NAME"></a><a id="pp_name"></a><dl>
     * <dt><b>PP_NAME</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name of the CSP in the form of a <b>null</b>-terminated <b>CHAR</b> string. This string is identical to the one passed in the <i>pszProvider</i> parameter of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function to specify that the current CSP be used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_PROVTYPE"></a><a id="pp_provtype"></a><dl>
     * <dt><b>PP_PROVTYPE</b></dt>
     * <dt>16 (0x10)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <b>DWORD</b> value that indicates the provider type of the CSP.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_ROOT_CERTSTORE"></a><a id="pp_root_certstore"></a><dl>
     * <dt><b>PP_ROOT_CERTSTORE</b></dt>
     * <dt>46 (0x2E)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obtains the root certificate store for the smart card. This certificate store contains all of the root certificates that are stored on the smart card.
     * 
     * The <i>pbData</i> parameter is the address of an <b>HCERTSTORE</b> variable that receives the handle of the certificate store. When this handle is no longer needed, the caller must close it by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a> function.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_SESSION_KEYSIZE"></a><a id="pp_session_keysize"></a><dl>
     * <dt><b>PP_SESSION_KEYSIZE</b></dt>
     * <dt>20 (0x14)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size, in bits, of the session key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_SGC_INFO"></a><a id="pp_sgc_info"></a><dl>
     * <dt><b>PP_SGC_INFO</b></dt>
     * <dt>37 (0x25)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used with <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">server gated cryptography</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_SIG_KEYSIZE_INC"></a><a id="pp_sig_keysize_inc"></a><dl>
     * <dt><b>PP_SIG_KEYSIZE_INC</b></dt>
     * <dt>34 (0x22)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The number of bits for the increment length of AT_SIGNATURE. This information is used with information returned in the PP_ENUMALGS_EX value. With the information returned when using PP_ENUMALGS_EX and PP_SIG_KEYSIZE_INC, the valid <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key lengths</a> for AT_SIGNATURE can be determined. These key lengths can then be used with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a>.
     * 
     * For example, if a CSP enumerates <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CALG_RSA_SIGN</a> (AT_SIGNATURE) with a minimum <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key length</a> of 512 bits and a maximum of 1024 bits, and returns the increment length as 64 bits, then valid key lengths are 512, 576, 640,… 1024.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_SIGNATURE_PIN"></a><a id="pp_signature_pin"></a><dl>
     * <dt><b>PP_SIGNATURE_PIN</b></dt>
     * <dt>33 (0x21)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies that the key signature PIN is contained in <i>pbData</i>. The PIN is represented as a <b>null</b>-terminated ASCII string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_SMARTCARD_GUID"></a><a id="pp_smartcard_guid"></a><dl>
     * <dt><b>PP_SMARTCARD_GUID</b></dt>
     * <dt>45 (0x2D)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obtains the identifier of the smart card. The <i>pbData</i> parameter is the address of a <b>GUID</b> structure that receives the identifier of the smart card.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_SMARTCARD_READER"></a><a id="pp_smartcard_reader"></a><dl>
     * <dt><b>PP_SMARTCARD_READER</b></dt>
     * <dt>43 (0x2B)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obtains the name of the smart card reader. The <i>pbData</i> parameter is the address of an ANSI character array that receives a <b>null</b>-terminated ANSI string that contains the name of the smart card reader. The size of this buffer, contained in the variable pointed to by the <i>pdwDataLen</i> parameter, must include the <b>NULL</b> terminator.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_SYM_KEYSIZE"></a><a id="pp_sym_keysize"></a><dl>
     * <dt><b>PP_SYM_KEYSIZE</b></dt>
     * <dt>19 (0x13)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of the symmetric key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_UI_PROMPT"></a><a id="pp_ui_prompt"></a><dl>
     * <dt><b>PP_UI_PROMPT</b></dt>
     * <dt>21 (0x15)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This query  is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_UNIQUE_CONTAINER"></a><a id="pp_unique_container"></a><dl>
     * <dt><b>PP_UNIQUE_CONTAINER</b></dt>
     * <dt>36 (0x24)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The unique container name of the current key container in the form of a <b>null</b>-terminated <b>CHAR</b> string. For many CSPs, this name is the same name returned when the PP_CONTAINER value is used. The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function must work with this container name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_USE_HARDWARE_RNG"></a><a id="pp_use_hardware_rng"></a><dl>
     * <dt><b>PP_USE_HARDWARE_RNG</b></dt>
     * <dt>38 (0x26)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates whether a hardware random number generator (RNG) is supported. When <b>PP_USE_HARDWARE_RNG</b> is specified, the function succeeds and returns <b>TRUE</b> if a hardware RNG is supported. The function fails and returns <b>FALSE</b> if a hardware RNG is not supported. If a RNG is supported, <b>PP_USE_HARDWARE_RNG</b> can be set in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a> to indicate that the CSP must exclusively use the hardware RNG for this provider context. When <b>PP_USE_HARDWARE_RNG</b> is used, the <i>pbData</i> parameter must be <b>NULL</b> and <i>dwFlags</i> must be zero.
     * 
     * None of the Microsoft CSPs currently support using a hardware RNG.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_USER_CERTSTORE"></a><a id="pp_user_certstore"></a><dl>
     * <dt><b>PP_USER_CERTSTORE</b></dt>
     * <dt>42 (0x2A)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obtains the user certificate store for the smart card. This certificate store contains all of the user certificates that are stored on the smart card. The certificates in this store are encoded by using PKCS_7_ASN_ENCODING or X509_ASN_ENCODING encoding and should contain the <b>CERT_KEY_PROV_INFO_PROP_ID</b> property. 
     * 
     * The <i>pbData</i> parameter is the address of an <b>HCERTSTORE</b> variable that receives the handle of an in-memory certificate store. When this handle is no longer needed, the caller must close it by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a> function.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PP_VERSION"></a><a id="pp_version"></a><dl>
     * <dt><b>PP_VERSION</b></dt>
     * <dt>5 (0x5)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The version number of the CSP. The least significant byte contains the minor version number and the next most significant byte the major version number. Version 2.0 is represented as 0x00000200. To maintain backward compatibility with earlier versions of the 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/microsoft-base-cryptographic-provider">Microsoft Base Cryptographic Provider</a> and the 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/microsoft-enhanced-cryptographic-provider">Microsoft Enhanced Cryptographic Provider</a>, the provider names retain the "v1.0" designation in later versions.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} pbData A pointer to a buffer to receive the data. The form of this data varies depending on the value of <i>dwParam</i>. When <i>dwParam</i> is set to PP_USE_HARDWARE_RNG, <i>pbData</i> must be set to <b>NULL</b>.
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pdwDataLen A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the buffer pointed to by the <i>pbData</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored or to be stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.
     * 
     * <p class="note">If PP_ENUMALGS, or PP_ENUMALGS_EX is set, the <i>pdwDataLen</i> parameter works somewhat differently. If <i>pbData</i> is <b>NULL</b> or the value pointed to by <i>pdwDataLen</i> is too small, the value returned in this parameter is the size of the largest item in the enumeration list instead of the size of the item currently being read.
     * 
     * <p class="note">If PP_ENUMCONTAINERS is set, the first call to the function returns the size of the maximum key-container allowed by the current provider. This is in contrast to other possible behaviors, like returning the length of the longest existing container, or the length of the current container. Subsequent enumerating calls will not change the <i>dwLen</i> parameter. For each enumerated container, the caller can determine the length of the <b>null</b>-terminated string programmatically, if desired. If one of the enumeration values is read and the <i>pbData</i> parameter is <b>NULL</b>, the CRYPT_FIRST flag must be specified for the size information to be correctly retrieved.
     * 
     * </div>
     * <div> </div>
     * @param {Integer} dwFlags If <i>dwParam</i> is <b>PP_KEYSET_SEC_DESCR</b>, the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">security descriptor</a> on the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a> where the keys are stored is retrieved. For this case, <i>dwFlags</i> is used to pass in the <b>SECURITY_INFORMATION</b> bit flags that indicate the requested security information, as defined in the Platform SDK. <b>SECURITY_INFORMATION</b> bit flags can be combined with a bitwise-<b>OR</b> operation.
     * 						
     * 					
     * 
     * 
     * The following values are defined for use with <b>PP_KEYSET_SEC_DESCR</b>.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="OWNER_SECURITY_INFORMATION"></a><a id="owner_security_information"></a><dl>
     * <dt><b>OWNER_SECURITY_INFORMATION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Owner identifier of the object is being referenced.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GROUP_SECURITY_INFORMATION"></a><a id="group_security_information"></a><dl>
     * <dt><b>GROUP_SECURITY_INFORMATION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Primary group identifier of the object is being referenced.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="DACL_SECURITY_INFORMATION"></a><a id="dacl_security_information"></a><dl>
     * <dt><b>DACL_SECURITY_INFORMATION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Discretionary ACL of the object is being referenced.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SACL_SECURITY_INFORMATION"></a><a id="sacl_security_information"></a><dl>
     * <dt><b>SACL_SECURITY_INFORMATION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * System ACL of the object is being referenced.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * The following values are defined for use with <b>PP_ENUMALGS</b>, <b>PP_ENUMALGS_EX</b>, and <b>PP_ENUMCONTAINERS</b>.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_FIRST"></a><a id="crypt_first"></a><dl>
     * <dt><b>CRYPT_FIRST</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the first element in the enumeration. This has the same effect as resetting the enumerator.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NEXT"></a><a id="crypt_next"></a><dl>
     * <dt><b>CRYPT_NEXT</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the next element in the enumeration. When there are no more elements to retrieve, this function will fail and set the last error to <b>ERROR_NO_MORE_ITEMS</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_SGC_ENUM"></a><a id="crypt_sgc_enum"></a><dl>
     * <dt><b>CRYPT_SGC_ENUM</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">server-gated cryptography</a> (SGC) enabled certificates. SGC enabled certificates are no longer supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_SGC"></a><a id="crypt_sgc"></a><dl>
     * <dt><b>CRYPT_SGC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_FASTSGC"></a><a id="crypt_fastsgc"></a><dl>
     * <dt><b>CRYPT_FASTSGC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not used.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbData</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pdwDataLen</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end of the enumeration list has been reached. No valid data has been placed in the <i>pbData</i> buffer. This error code is returned only when <i>dwParam</i> equals PP_ENUMALGS or PP_ENUMCONTAINERS.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter specifies a flag that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwParam</i> parameter specifies an unknown value number.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a> specified by <i>hProv</i> is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptgetprovparam
     * @since windows5.1.2600
     */
    static CryptGetProvParam(hProv, dwParam, pbData, pdwDataLen, dwFlags) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptGetProvParam", "ptr", hProv, "uint", dwParam, "ptr", pbData, "ptr", pdwDataLen, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Fills a buffer with cryptographically random bytes.
     * @remarks
     * The data produced by this function is cryptographically random. It is far more random than the data generated by the typical random number generator such as the one shipped with your C compiler.
     * 
     * This function is often used to generate random <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">initialization vectors</a> and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">salt values</a>.
     * 
     * Software random number generators work in fundamentally the same way. They start with a random number, known as the seed, and then use an algorithm to generate a pseudo-random sequence of bits based on it. The most difficult part of this process is to get a seed that is truly random. This is usually based on user input latency, or the jitter from one or more hardware components.
     * 
     * With Microsoft CSPs, <b>CryptGenRandom</b> uses the same random number generator used by other security components. This allows numerous processes to contribute to a system-wide seed. CryptoAPI stores an intermediate random seed with every user. To form the seed for the random number generator, a calling application supplies bits it might have—for instance, mouse or keyboard timing input—that are then combined with both the stored seed and various system data and user data such as the process ID and thread ID, the system clock, the system time, the system counter, memory status, free disk clusters, the hashed user environment block. This result is used to seed the pseudorandom number generator (PRNG). In Windows Vista with Service Pack 1 (SP1) and later, an implementation of the AES counter-mode based PRNG specified in NIST Special Publication 800-90 is used. In Windows Vista, Windows Storage Server 2003, and Windows XP, the PRNG specified in Federal Information Processing Standard (FIPS) 186-2 is used. If an application has access to a good random source, it can fill the <i>pbBuffer</i> buffer with some random data before calling <b>CryptGenRandom</b>. The CSP then uses this data to further randomize its internal seed. It is acceptable to omit the step of initializing the <i>pbBuffer</i> buffer before calling <b>CryptGenRandom</b>.
     * @param {Pointer} hProv Handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) created by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} dwLen Number of bytes of random data to be generated.
     * @param {Pointer<Byte>} pbBuffer Buffer to receive the returned data. This buffer must be at least <i>dwLen</i> bytes in length. 
     * 
     * 
     * 
     * 
     * Optionally, the application can fill this buffer with data to use as an auxiliary random seed.
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProv</i> parameter does not contain a valid context handle.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptgenrandom
     * @since windows5.1.2600
     */
    static CryptGenRandom(hProv, dwLen, pbBuffer) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptGenRandom", "ptr", hProv, "uint", dwLen, "ptr", pbBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a handle of one of a user's two public/private key pairs.
     * @param {Pointer} hProv <b>HCRYPTPROV</b> handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) created by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} dwKeySpec Identifies the private key to use from the key container. It can be AT_KEYEXCHANGE or AT_SIGNATURE. 
     * 
     * 
     * 
     * 
     * Additionally, some providers allow access to other user-specific keys through this function. For details, see the documentation on the specific provider.
     * @param {Pointer<UIntPtr>} phUserKey A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptkey">HCRYPTKEY</a> handle of the retrieved keys. When you have finished using the key, delete the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwKeySpec</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProv</i> parameter does not contain a valid context handle.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key requested by the <i>dwKeySpec</i> parameter does not exist.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptgetuserkey
     * @since windows5.1.2600
     */
    static CryptGetUserKey(hProv, dwKeySpec, phUserKey) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptGetUserKey", "ptr", hProv, "uint", dwKeySpec, "ptr", phUserKey, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Exports a cryptographic key or a key pair from a cryptographic service provider (CSP) in a secure manner.
     * @remarks
     * For any of the DES key permutations that use a PLAINTEXTKEYBLOB, only the full key size, including parity bit, may be exported. The following key sizes are supported.
     * 
     * <table>
     * <tr>
     * <th>Algorithm</th>
     * <th>Supported key size</th>
     * </tr>
     * <tr>
     * <td>CALG_DES</td>
     * <td>64 bits</td>
     * </tr>
     * <tr>
     * <td>CALG_3DES_112</td>
     * <td>128 bits</td>
     * </tr>
     * <tr>
     * <td>CALG_3DES</td>
     * <td>192 bits</td>
     * </tr>
     * </table>
     * @param {Pointer} hKey A handle to the key to be exported.
     * @param {Pointer} hExpKey A handle to a cryptographic key of the destination user. The key data within the exported <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key BLOB</a> is encrypted using this key. This ensures that only the destination user is able to make use of the key BLOB.  Both <i>hExpKey</i> and <i>hKey</i> must come from the same CSP.
     * 
     * 
     * Most often, this is the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key exchange public key</a> of the destination user. However, certain protocols in some CSPs require that a session key belonging to the destination user be used for this purpose.
     * 
     * If the key BLOB type specified by <i>dwBlobType</i> is <b>PUBLICKEYBLOB</b>, this parameter is unused and must be set to zero.
     * 
     * If the key BLOB type specified by <i>dwBlobType</i> is <b>PRIVATEKEYBLOB</b>, this is typically a handle to a session key that is to be used to encrypt the key BLOB. Some CSPs allow this parameter to be zero, in which case the application must encrypt the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key BLOB</a> manually so as to protect it.
     * 
     * To determine how Microsoft <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service providers</a> respond to this parameter, see the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key BLOB</a> sections of 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/microsoft-cryptographic-service-providers">Microsoft Cryptographic Service Providers</a>.
     * 
     * <div class="alert"><b>Note</b>  Some CSPs may modify this parameter as a result of the operation. Applications that subsequently use this key for other purposes should call the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptduplicatekey">CryptDuplicateKey</a> function to create a duplicate key handle. When the application has finished using the handle, release it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.</div>
     * <div> </div>
     * @param {Integer} dwBlobType Specifies the type of <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key BLOB</a> to be exported in <i>pbData</i>. This must be one of the following constants as discussed in 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-key-storage-and-exchange">Cryptographic Key Storage and Exchange</a>.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="OPAQUEKEYBLOB"></a><a id="opaquekeyblob"></a><dl>
     * <dt><b>OPAQUEKEYBLOB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used to store session keys in an Schannel CSP or any other vendor-specific format. OPAQUEKEYBLOBs are nontransferable and must be used within the CSP that generated the BLOB.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PRIVATEKEYBLOB"></a><a id="privatekeyblob"></a><dl>
     * <dt><b>PRIVATEKEYBLOB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used to transport <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public/private key pairs</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PUBLICKEYBLOB"></a><a id="publickeyblob"></a><dl>
     * <dt><b>PUBLICKEYBLOB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used to transport public keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SIMPLEBLOB"></a><a id="simpleblob"></a><dl>
     * <dt><b>SIMPLEBLOB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used to transport session keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PLAINTEXTKEYBLOB"></a><a id="plaintextkeyblob"></a><dl>
     * <dt><b>PLAINTEXTKEYBLOB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/jj650836(v=vs.85)">PLAINTEXTKEYBLOB</a> used to export any key supported by the CSP in use. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SYMMETRICWRAPKEYBLOB"></a><a id="symmetricwrapkeyblob"></a><dl>
     * <dt><b>SYMMETRICWRAPKEYBLOB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used to export and import a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">symmetric key</a> wrapped with another symmetric key. The actual wrapped key is in the format specified in the IETF <a href="https://www.ietf.org/rfc/rfc3217.txt">RFC 3217</a> standard.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags 
     * @param {Pointer<Byte>} pbData A pointer to a buffer that receives the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key BLOB</a> data. The format of this BLOB varies depending on the BLOB type requested in the <i>dwBlobType</i> parameter. For the format for PRIVATEKEYBLOBs, PUBLICKEYBLOBs, and SIMPLEBLOBs, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/base-provider-key-blobs">Base Provider Key BLOBs</a>.
     * 
     * If this parameter is <b>NULL</b>, the required buffer size is placed in the value pointed to by the <i>pdwDataLen</i> parameter. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pdwDataLen A pointer to a <b>DWORD</b> value that, on entry, contains the size, in bytes, of the buffer pointed to by the <i>pbData</i> parameter. When the function returns, this value contains the number of bytes stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * To retrieve the required size of the <i>pbData</i> buffer, pass <b>NULL</b> for <i>pbData</i>. The required buffer size will be placed in the value pointed to by this parameter.
     * @returns {Integer} If the function succeeds, the function returns  nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP being used. The following table shows some of the possible error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbData</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pdwDataLen</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either the algorithm that works with the public key to be exported is not supported by this CSP, or an attempt was made to export a session key that was encrypted with something other than one of your public keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or both of the keys specified by <i>hKey</i> and <i>hExpKey</i> are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY_STATE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * You do not have permission to export the key. That is, when the <i>hKey</i> key was created, the CRYPT_EXPORTABLE flag was not specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_PUBLIC_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key BLOB</a> type specified by <i>dwBlobType</i> is PUBLICKEYBLOB, but <i>hExpKey</i> does not contain a public key handle.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwBlobType</i> parameter specifies an unknown BLOB type.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the <i>hKey</i> key was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A session key is being exported, and the <i>hExpKey</i> parameter does not specify a public key.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptexportkey
     * @since windows5.1.2600
     */
    static CryptExportKey(hKey, hExpKey, dwBlobType, dwFlags, pbData, pdwDataLen) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptExportKey", "ptr", hKey, "ptr", hExpKey, "uint", dwBlobType, "uint", dwFlags, "ptr", pbData, "ptr", pdwDataLen, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Transfers a cryptographic key from a key BLOB into a cryptographic service provider (CSP).
     * @remarks
     * When importing a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">Hash-Based Message Authentication Code</a> (HMAC) key, the caller must identify the imported key as a <b>PLAINTEXTKEYBLOB</b> type and set the appropriate algorithm identifier in the <b>aiKeyAlg</b> field of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-publickeystruc">PUBLICKEYSTRUC</a> BLOB header.
     * 
     * The <b>CryptImportKey</b> function can be used to import a plaintext key for symmetric algorithms; however, we recommend that, for ease of use, you use the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a> function instead. When you import a plaintext key, the structure of the key BLOB that is passed in the <i>pbData</i> parameter is a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/jj650836(v=vs.85)">PLAINTEXTKEYBLOB</a>.
     * 
     * You can use the <b>PLAINTEXTKEYBLOB</b> type with any algorithm or type of key combination supported by the CSP in use. 
     * 
     * For an example of importing a plaintext key, see <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/example-c-program--importing-a-plaintext-key">Example C Program: Importing a Plaintext Key</a>.
     * 
     * The following example shows how you can set the header fields.
     * 
     * 
     * ```cpp
     * keyBlob.header.bType = PLAINTEXTKEYBLOB;
     * keyBlob.header.bVersion = CUR_BLOB_VERSION;
     * keyBlob.header.reserved = 0;
     * // CALG_AES_128 is used as an example. You would set this to the 
     * // algorithm id that corresponds to the one used by the key.
     * keyBlob.header.aiKeyAlg = CALG_AES_128;
     * ```
     * 
     * 
     * The length of the key is specified in keyBlob.keyLength, which is followed by the actual key data.
     * 
     * <div class="alert"><b>Note</b>  The HMAC algorithms do not have their own algorithm identifiers; use CALG_RC2 instead. <b>CRYPT_IPSEC_HMAC_KEY</b> allows the import of RC2 keys longer than 16 bytes.</div>
     * <div> </div>
     * For any of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">Data Encryption Standard</a> (DES) key permutations that use <b>PLAINTEXTKEYBLOB</b>, only the full key size, including parity bit, can be imported.
     * 
     * The following key sizes are supported.
     * 
     * <table>
     * <tr>
     * <th>Algorithm</th>
     * <th>Supported key size</th>
     * </tr>
     * <tr>
     * <td>CALG_DES</td>
     * <td>64 bits</td>
     * </tr>
     * <tr>
     * <td>CALG_3DES_112</td>
     * <td>128 bits</td>
     * </tr>
     * <tr>
     * <td>CALG_3DES</td>
     * <td>192 bits</td>
     * </tr>
     * </table>
     * @param {Pointer} hProv The handle of a CSP obtained with the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function.
     * @param {Pointer<Byte>} pbData A <b>BYTE</b> array that contains a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-publickeystruc">PUBLICKEYSTRUC</a> BLOB header followed by the encrypted key. This key BLOB is created by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a> function, either in this application or by another application possibly running on a different computer.
     * @param {Integer} dwDataLen Contains the length, in bytes, of the key BLOB.
     * @param {Pointer} hPubKey A handle to the cryptographic key that decrypts the key stored in <i>pbData</i>.  This key must come from the same CSP to which <i>hProv</i> refers. The meaning of this parameter differs depending on the CSP type and the type of key BLOB being imported:
     * 
     * <ul>
     * <li>If the key BLOB is encrypted with the key <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">exchange key pair</a>, for example, a <b>SIMPLEBLOB</b>, this parameter can be the handle to the key exchange key.</li>
     * <li>If the key BLOB is encrypted with a session key, for example, an encrypted <b>PRIVATEKEYBLOB</b>, this parameter contains the handle of this session key.</li>
     * <li>If the key BLOB is not encrypted, for example, a <b>PUBLICKEYBLOB</b>, this parameter is not used and must be zero.</li>
     * <li>If the key BLOB is encrypted with a session key in an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">Schannel</a> CSP, for example, an encrypted <b>OPAQUEKEYBLOB</b> or any other vendor-specific <b>OPAQUEKEYBLOB</b>, this parameter is not used and must be set to zero.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  Some CSPs may modify this parameter as a result of the operation. Applications that subsequently use this key for other purposes should call the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptduplicatekey">CryptDuplicateKey</a> function to create a duplicate key handle.  When the application has finished using the handle, release it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.</div>
     * <div> </div>
     * @param {Integer} dwFlags Currently used only when a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public/private key pair</a> in the form of a <b>PRIVATEKEYBLOB</b> is imported into the CSP.
     * @param {Pointer<UIntPtr>} phKey A pointer to a <b>HCRYPTKEY</b> value that receives the handle of the imported key. When you have finished using the key, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.
     * @returns {Integer} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * Error codes prefaced by "NTE" are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Some CSPs set this error if a private key is imported into a container while another thread or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">process</a> is using this key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">simple key BLOB</a> to be imported is not encrypted with the expected <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key exchange algorithm</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either the algorithm that works with the public key to be imported is not supported by this CSP, or an attempt was made to import a session key that was encrypted with something other than one of your public keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter specified is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key BLOB type is not supported by this CSP and is possibly not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProv</i> parameter does not contain a valid context handle.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_VER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The version number of the key BLOB does not match the CSP version. This usually indicates that the CSP needs to be upgraded.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptimportkey
     * @since windows5.1.2600
     */
    static CryptImportKey(hProv, pbData, dwDataLen, hPubKey, dwFlags, phKey) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptImportKey", "ptr", hProv, "ptr", pbData, "uint", dwDataLen, "ptr", hPubKey, "uint", dwFlags, "ptr", phKey, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Encrypts data. The algorithm used to encrypt the data is designated by the key held by the CSP module and is referenced by the hKey parameter.
     * @remarks
     * If a large amount of data is to be encrypted, it can be done in sections by calling <b>CryptEncrypt</b> repeatedly. The <i>Final</i> parameter must be set to <b>TRUE</b> on the last call to <b>CryptEncrypt</b>, so that the encryption engine can properly finish the encryption process. The following extra actions are performed when <i>Final</i> is <b>TRUE</b>:
     * 
     * <ul>
     * <li>If the key is a block cipher key, the data is padded to a multiple of the block size of the cipher. If the data length equals the block size of the cipher, one additional block of padding is appended to the data. To find the block size of a cipher, use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetkeyparam">CryptGetKeyParam</a> to get the KP_BLOCKLEN value of the key.</li>
     * <li>If the cipher is operating in a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">chaining mode</a>, the next <b>CryptEncrypt</b> operation resets the cipher's feedback register to the KP_IV value of the key.</li>
     * <li>If the cipher is a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">stream cipher</a>, the next <b>CryptEncrypt</b> resets the cipher to its initial <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">state</a>.</li>
     * </ul>
     * 
     * 
     * There is no way to set the cipher's feedback register to the KP_IV value of the key without setting the <i>Final</i> parameter to <b>TRUE</b>. If this is necessary, as in the case where you do not want to add an additional padding block or change the size of each block, you can simulate this by creating a duplicate of the original key by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptduplicatekey">CryptDuplicateKey</a> function, and passing the duplicate key to the <b>CryptEncrypt</b> function. This causes the KP_IV of the original key to be placed in the duplicate key. After you create or import the original key, you cannot use the original key for encryption because the feedback register of the key will be changed. The following pseudocode shows how this can be done.
     * 
     * 
     * ``` syntax
     * // Set the IV for the original key. Do not use the original key for 
     * // encryption or decryption after doing this because the key's 
     * // feedback register will get modified and you cannot change it.
     * CryptSetKeyParam(hOriginalKey, KP_IV, newIV)
     * 
     * while(block = NextBlock())
     * {
     *     // Create a duplicate of the original key. This causes the 
     *     // original key's IV to be copied into the duplicate key's 
     *     // feedback register.
     *     hDuplicateKey = CryptDuplicateKey(hOriginalKey)
     * 
     *     // Encrypt the block with the duplicate key.
     *     CryptEncrypt(hDuplicateKey, block)
     * 
     *     // Destroy the duplicate key. Its feedback register has been 
     *     // modified by the CryptEncrypt function, so it cannot be used
     *     // again. It will be re-duplicated in the next iteration of the 
     *     // loop.
     *     CryptDestroyKey(hDuplicateKey)
     * }
     * ```
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/microsoft-enhanced-cryptographic-provider">Microsoft Enhanced Cryptographic Provider</a> supports direct encryption with <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">RSA</a> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public keys</a> and decryption with RSA <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private keys</a>. The encryption uses PKCS #1 <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">padding</a>. On decryption, this padding is verified. The length of plaintext data that can be encrypted with a call to <b>CryptEncrypt</b> with an RSA key is the length of the key modulus minus eleven bytes. The eleven bytes is the chosen minimum for PKCS #1 padding. The ciphertext is returned in <a href="https://docs.microsoft.com/windows/desktop/SecGloss/l-gly">little-endian</a> format.
     * @param {Pointer} hKey A handle to the encryption key. An application obtains this handle by using either the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a> or the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a> function.
     * 
     * The key specifies the encryption algorithm used.
     * @param {Pointer} hHash A handle to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash object</a>. If data is to be hashed and encrypted simultaneously, a handle to a hash object can be passed in the <i>hHash</i> parameter. The hash value is updated with the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">plaintext</a> passed in. This option is useful when generating signed and encrypted text.
     * 
     * Before calling <b>CryptEncrypt</b>, the application must obtain a handle to the hash object by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a> function. After the encryption is complete, the hash value can be obtained by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a> function, or the hash can be signed by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a> function.
     * 
     * If no hash is to be done, this parameter must be <b>NULL</b>.
     * @param {Integer} Final A Boolean value that specifies whether this is the last section in a series being encrypted. <i>Final</i> is set to <b>TRUE</b> for the last or only block and to <b>FALSE</b> if there are more blocks to be encrypted. For more information, see  Remarks.
     * @param {Integer} dwFlags The following <i>dwFlags</i> value is defined but reserved for future use.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_OAEP"></a><a id="crypt_oaep"></a><dl>
     * <dt><b>CRYPT_OAEP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use Optimal Asymmetric Encryption Padding (OAEP)  (PKCS #1 version 2). This flag is only supported by the <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/microsoft-enhanced-cryptographic-provider">Microsoft Enhanced Cryptographic Provider</a> with RSA encryption/decryption.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} pbData A pointer to a buffer that contains the plaintext to be encrypted.  The plaintext in this buffer is overwritten with the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">ciphertext</a> created by this function.
     * 
     * The <i>pdwDataLen</i> parameter points to a variable that contains the length, in bytes, of the plaintext. The <i>dwBufLen</i> parameter contains the total size, in bytes, of this buffer.
     * 
     * If this parameter contains <b>NULL</b>, this function will calculate the required size for the ciphertext and place that in the value pointed to by the <i>pdwDataLen</i> parameter.
     * @param {Pointer<UInt32>} pdwDataLen A pointer to a <b>DWORD</b> value that , on entry, contains the length, in bytes, of the plaintext in the <i>pbData</i> buffer. On exit, this <b>DWORD</b> contains the length, in bytes, of the ciphertext written to the <i>pbData</i> buffer.
     * 
     * If the buffer allocated for <i>pbData</i> is not large enough to hold the encrypted data, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_MORE_DATA</b> and stores the required buffer size, in bytes, in the <b>DWORD</b> value pointed to by <i>pdwDataLen</i>.
     * 
     * If <i>pbData</i> is <b>NULL</b>, no error is returned, and the function stores the size of the encrypted data, in bytes, in the <b>DWORD</b> value pointed to by <i>pdwDataLen</i>. This allows an application to determine the correct buffer size.
     * 
     * When a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">block cipher</a> is used, this data length must be a multiple of the block size unless this is the final section of data to be encrypted and the <i>Final</i> parameter is <b>TRUE</b>.
     * @param {Integer} dwBufLen Specifies the total size, in bytes, of the input <i>pbData</i> buffer.
     * 
     * Note that, depending on the algorithm used, the encrypted text can be larger than the original plaintext. In this case, the <i>pbData</i> buffer needs to be large enough to contain the encrypted text and any padding.
     * 
     * As a rule, if a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">stream cipher</a> is used, the ciphertext is the same size as the plaintext. If a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">block cipher</a> is used, the ciphertext is up to a block length larger than the plaintext.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 						
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">session key</a> specifies an algorithm that this CSP does not support.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data to be encrypted is not valid. For example, when a block cipher is used and the <i>Final</i> flag is <b>FALSE</b>, the value specified by <i>pdwDataLen</i> must be a multiple of the block size.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> parameter contains a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH_STATE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt was made to add data to a hash object that is already marked "finished."
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter does not contain a valid handle to a key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_LEN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of the output buffer is too small to hold the generated ciphertext.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the key was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_DOUBLE_ENCRYPT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The application attempted to encrypt the same data twice.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptencrypt
     * @since windows5.1.2600
     */
    static CryptEncrypt(hKey, hHash, Final, dwFlags, pbData, pdwDataLen, dwBufLen) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptEncrypt", "ptr", hKey, "ptr", hHash, "int", Final, "uint", dwFlags, "ptr", pbData, "ptr", pdwDataLen, "uint", dwBufLen, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Decrypts data previously encrypted by using the CryptEncrypt function.
     * @remarks
     * If a large amount of data is to be decrypted, it can be done in sections by calling <b>CryptDecrypt</b> repeatedly. The <i>Final</i> parameter must be set to <b>TRUE</b> only on the last call to <b>CryptDecrypt</b>, so that the decryption engine can properly finish the decryption process. The following extra actions are performed when <i>Final</i> is <b>TRUE</b>:
     * 
     * <ul>
     * <li>If the key is a block cipher key, the data is padded to a multiple of the block size of the cipher. To find the block size of a cipher, use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetkeyparam">CryptGetKeyParam</a> to get the KP_BLOCKLEN value of the key.</li>
     * <li>If the cipher is operating in a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">chaining mode</a>, the next <b>CryptDecrypt</b> operation resets the cipher's feedback register to the KP_IV value of the key.</li>
     * <li>If the cipher is a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">stream cipher</a>, the next <b>CryptDecrypt</b> call resets the cipher to its initial <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">state</a>.</li>
     * </ul>
     * 
     * 
     * There is no way to set the cipher's feedback register to the KP_IV value of the key without setting the <i>Final</i> parameter to <b>TRUE</b>. If this is necessary, as in the case where you do not want to add an additional padding block or change the size of each block, you can simulate this by creating a duplicate of the original key by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptduplicatekey">CryptDuplicateKey</a> function, and passing the duplicate key to the <b>CryptDecrypt</b> function. This causes the KP_IV of the original key to be placed in the duplicate key. After you create or import the original key, you cannot use the original key for encryption because the feedback register of the key will be changed. The following pseudocode shows how this can be done.
     * 
     * 
     * ``` syntax
     * // Set the IV for the original key. Do not use the original key for 
     * // encryption or decryption after doing this because the key's 
     * // feedback register will get modified and you cannot change it.
     * CryptSetKeyParam(hOriginalKey, KP_IV, newIV)
     * 
     * while(block = NextBlock())
     * {
     *     // Create a duplicate of the original key. This causes the 
     *     // original key's IV to be copied into the duplicate key's 
     *     // feedback register.
     *     hDuplicateKey = CryptDuplicateKey(hOriginalKey)
     * 
     *     // Decrypt the block with the duplicate key.
     *     CryptDecrypt(hDuplicateKey, block)
     * 
     *     // Destroy the duplicate key. Its feedback register has been 
     *     // modified by the CryptEncrypt function, so it cannot be used
     *     // again. It will be re-duplicated in the next iteration of the 
     *     // loop.
     *     CryptDestroyKey(hDuplicateKey)
     * }
     * ```
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/microsoft-enhanced-cryptographic-provider">Microsoft Enhanced Cryptographic Provider</a> supports direct encryption with <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">RSA</a> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public keys</a> and decryption with RSA <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private keys</a>. The encryption uses PKCS #1 <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">padding</a>. On decryption, this padding is verified. The length of <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">ciphertext</a> data to be decrypted must be the same length as the modulus of the RSA key used to decrypt the data. If the ciphertext has zeros in the most significant bytes, these bytes must be included in the input data buffer and in the input buffer length. The ciphertext must be in <a href="https://docs.microsoft.com/windows/desktop/SecGloss/l-gly">little-endian</a> format.
     * @param {Pointer} hKey A handle to the key to use for the decryption. An application obtains this handle by using either the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a> function. 
     * 
     * 
     * 
     * 
     * This key specifies the decryption algorithm to be used.
     * @param {Pointer} hHash A handle to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash object</a>. If data is to be decrypted and hashed simultaneously, a handle to a hash object is passed in this parameter. The hash value is updated with the decrypted <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">plaintext</a>. This option is useful when simultaneously decrypting and verifying a signature. 
     * 
     * 
     * 
     * 
     * Before calling <b>CryptDecrypt</b>, the application must obtain a handle to the hash object by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a> function. After the decryption is complete, the hash value can be obtained by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a> function, it can also be signed by using 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a> function, or it can be used to verify a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">digital signature</a> by using 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea">CryptVerifySignature</a> function.
     * 
     * If no hash is to be done, this parameter must be zero.
     * @param {Integer} Final A Boolean value that specifies whether this is the last section in a series being decrypted. This value is <b>TRUE</b> if this is the last or only block. If this is not the last block, this value is <b>FALSE</b>. For more information, see  Remarks.
     * @param {Integer} dwFlags The following flag values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_OAEP"></a><a id="crypt_oaep"></a><dl>
     * <dt><b>CRYPT_OAEP</b></dt>
     * <dt>0x00000040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use Optimal Asymmetric Encryption Padding (OAEP)  (PKCS #1 version 2). This flag is only supported by the <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/microsoft-enhanced-cryptographic-provider">Microsoft Enhanced Cryptographic Provider</a> with RSA encryption/decryption. This flag cannot be combined with the <b>CRYPT_DECRYPT_RSA_NO_PADDING_CHECK</b> flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECRYPT_RSA_NO_PADDING_CHECK"></a><a id="crypt_decrypt_rsa_no_padding_check"></a><dl>
     * <dt><b>CRYPT_DECRYPT_RSA_NO_PADDING_CHECK</b></dt>
     * <dt>0x00000020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Perform the decryption on the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a> without checking the padding. This flag is only supported by the <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/microsoft-enhanced-cryptographic-provider">Microsoft Enhanced Cryptographic Provider</a> with RSA encryption/decryption. This flag cannot be combined with the <b>CRYPT_OAEP</b> flag.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} pbData A pointer to a buffer that contains the data to be decrypted. After the decryption has been performed, the plaintext is placed back into this same buffer. 
     * 
     * 
     * 
     * 
     * The number of encrypted bytes in this buffer is specified by <i>pdwDataLen</i>.
     * @param {Pointer<UInt32>} pdwDataLen A pointer to a <b>DWORD</b> value that indicates the length of the <i>pbData</i> buffer. Before calling this function, the calling application sets the <b>DWORD</b> value to the number of bytes to be decrypted. Upon return, the <b>DWORD</b> value contains the number of bytes of the decrypted plaintext. 
     * 
     * 
     * 
     * 
     * When a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">block cipher</a> is used, this data length must be a multiple of the block size unless this is the final section of data to be decrypted and the <i>Final</i> parameter is <b>TRUE</b>.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 						
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">session key</a> specifies an algorithm that this CSP does not support.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data to be decrypted is not valid. For example, when a block cipher is used and the <i>Final</i> flag is <b>FALSE</b>, the value specified by <i>pdwDataLen</i> must be a multiple of the block size. This error can also be returned when the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">padding</a> is found to be not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> parameter contains a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter does not contain a valid handle to a key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_LEN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of the output buffer is too small to hold the generated plaintext.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the key was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_DOUBLE_ENCRYPT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The application attempted to decrypt the same data twice.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptdecrypt
     * @since windows5.1.2600
     */
    static CryptDecrypt(hKey, hHash, Final, dwFlags, pbData, pdwDataLen) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptDecrypt", "ptr", hKey, "ptr", hHash, "int", Final, "uint", dwFlags, "ptr", pbData, "ptr", pdwDataLen, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Initiates the hashing of a stream of data. It creates and returns to the calling application a handle to a cryptographic service provider (CSP) hash object.
     * @remarks
     * For a list of Microsoft service providers and the algorithms they implement, see <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/microsoft-cryptographic-service-providers">Microsoft Cryptographic Service Providers</a>.
     * 
     * The computation of the actual hash is done with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashsessionkey">CryptHashSessionKey</a> functions. These require a handle to the hash object. After all the data has been added to the hash object, any of the following operations can be performed:
     * 
     * <ul>
     * <li>The hash value can be retrieved by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a>.</li>
     * <li>A session key can be derived by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptderivekey">CryptDeriveKey</a>.</li>
     * <li>The hash can be signed by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a>.</li>
     * <li>A signature can be verified by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea">CryptVerifySignature</a>.</li>
     * </ul>
     * After one of the functions from this list has been called, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashsessionkey">CryptHashSessionKey</a> cannot be called.
     * @param {Pointer} hProv A handle to a CSP created by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} Algid An <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> value that identifies  the hash algorithm to use.
     * 
     * Valid values for this parameter vary, depending on the CSP that is used. For a list of default algorithms, see  Remarks.
     * @param {Pointer} hKey If the type of hash algorithm is a keyed hash, such as the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">Hash-Based Message Authentication Code</a> (HMAC) or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">Message Authentication Code</a> (MAC) algorithm, the key for the hash is passed in this parameter. For nonkeyed algorithms, this parameter must be set to zero.
     * 
     * For keyed algorithms, the key must be to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">block cipher</a> key, such as RC2, that has a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cipher mode</a> of <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">Cipher Block Chaining</a> (CBC).
     * @param {Integer} dwFlags The following flag value is defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_SECRETDIGEST"></a><a id="crypt_secretdigest"></a><dl>
     * <dt><b>CRYPT_SECRETDIGEST</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not used.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UIntPtr>} phHash The address to which the function copies a handle to the new hash object. When you have finished using the hash object, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash">CryptDestroyHash</a> function.
     * @returns {Integer} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP you are using. The following table shows some of the possible error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Algid</i> parameter specifies an algorithm that this CSP does not support.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A keyed <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> algorithm, such as <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CALG_MAC</a>, is specified by <i>Algid</i>, and the <i>hKey</i> parameter is either zero or it specifies a key handle that is not valid. This error code is also returned if the key is to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">stream cipher</a> or if the cipher mode is anything other than CBC.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptcreatehash
     * @since windows5.1.2600
     */
    static CryptCreateHash(hProv, Algid, hKey, dwFlags, phHash) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptCreateHash", "ptr", hProv, "uint", Algid, "ptr", hKey, "uint", dwFlags, "ptr", phHash, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds data to a specified hash object.
     * @param {Pointer} hHash Handle of the hash object.
     * @param {Pointer<Byte>} pbData A pointer to a buffer that contains the data to be added to the hash object.
     * @param {Integer} dwDataLen Number of bytes of data to be added. This must be zero if the CRYPT_USERDATA flag is set.
     * @param {Integer} dwFlags The following flag values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_OWF_REPL_LM_HASH"></a><a id="crypt_owf_repl_lm_hash"></a><dl>
     * <dt><b>CRYPT_OWF_REPL_LM_HASH</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_USERDATA"></a><a id="crypt_userdata"></a><dl>
     * <dt><b>CRYPT_USERDATA</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * All Microsoft Cryptographic Providers ignore this parameter. For any CSP that does not ignore this parameter, if this flag is set, the CSP prompts the user to input data directly. This data is added to the hash. The application is not allowed access to the data. This flag can be used to allow the user to enter a PIN into the system.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> handle specifies an algorithm that this CSP does not support.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH_STATE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt was made to add data to a hash object that is already marked "finished."
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A keyed hash algorithm is being used, but the session key is no longer valid. This error is generated if the session key is destroyed before the hashing operation is complete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_LEN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP does not ignore the CRYPT_USERDATA flag, the flag is set, and the <i>dwDataLen</i> parameter has a nonzero value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the hash object was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-crypthashdata
     * @since windows5.1.2600
     */
    static CryptHashData(hHash, pbData, dwDataLen, dwFlags) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptHashData", "ptr", hHash, "ptr", pbData, "uint", dwDataLen, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Computes the cryptographic hash of a session key object.
     * @param {Pointer} hHash A handle to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash object</a>.
     * @param {Pointer} hKey A handle to the key object to be hashed.
     * @param {Integer} dwFlags The following flag value is defined. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LITTLE_ENDIAN"></a><a id="crypt_little_endian"></a><dl>
     * <dt><b>CRYPT_LITTLE_ENDIAN</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When this flag is set, the bytes of the key are hashed in <a href="https://docs.microsoft.com/windows/desktop/SecGloss/l-gly">little-endian</a> form. Note that by default (when <i>dwFlags</i> is zero), the bytes of the key are hashed in <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">big-endian</a> form.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> handle specifies an algorithm that this CSP does not support.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH_STATE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt was made to add data to a hash object that is already marked "finished."
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A keyed hash algorithm is being used, but the session key is no longer valid. This error is generated if the session key is destroyed before the hashing operation is complete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the hash object was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function failed in some unexpected way.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-crypthashsessionkey
     * @since windows5.1.2600
     */
    static CryptHashSessionKey(hHash, hKey, dwFlags) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptHashSessionKey", "ptr", hHash, "ptr", hKey, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Destroys the hash object referenced by the hHash parameter.
     * @remarks
     * When a hash object is destroyed, many CSPs overwrite the memory in the CSP where the hash object was held. The CSP memory is then freed.
     * 
     * There should be a one-to-one correspondence between calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a> and <b>CryptDestroyHash</b>.
     * 
     * All hash objects that have been created by using a specific CSP must be destroyed before that CSP handle is released with the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptreleasecontext">CryptReleaseContext</a> function.
     * @param {Pointer} hHash The handle of the hash object to be destroyed.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by <i>hHash</i> is currently being used and cannot be destroyed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> parameter specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> handle specifies an algorithm that this CSP does not support.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the hash object was created cannot be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptdestroyhash
     * @since windows5.1.2600
     */
    static CryptDestroyHash(hHash) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptDestroyHash", "ptr", hHash, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Signs data. (CryptSignHashA)
     * @remarks
     * Before calling this function, the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a> function must be called to get a handle to a hash object. The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashsessionkey">CryptHashSessionKey</a> function is then used to add the data or session keys to the hash object. The <b>CryptSignHash</b> function completes the hash.
     * 
     * While the DSS CSP supports hashing with both the MD5 and the SHA hash algorithms, the DSS CSP only supports signing SHA hashes.
     * 
     * After this function is called, no more data can be added to the hash. Additional calls to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> or <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashsessionkey">CryptHashSessionKey</a> fail.
     * 
     * After the application finishes using the hash, 
     * destroy the hash object by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash">CryptDestroyHash</a> function.
     * 
     * By default, the Microsoft RSA providers use the PKCS #1 padding method for the signature. The hash OID in the <b>DigestInfo</b> element of the signature is automatically set to the algorithm OID associated with the hash object. Using the <b>CRYPT_NOHASHOID</b> flag will cause this OID to be omitted from the signature.
     * 
     * Occasionally, a hash value that has been generated elsewhere must be signed. This can be done by using the following sequence of operations:
     * 
     * <ol>
     * <li>Create a hash object by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>.</li>
     * <li>Set the hash value in the hash object by using the <b>HP_HASHVAL</b> value of the <i>dwParam</i> parameter in <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsethashparam">CryptSetHashParam</a>.</li>
     * <li>Sign the hash value by using 
     * <b>CryptSignHash</b> and obtain a digital signature block.</li>
     * <li>Destroy the hash object by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash">CryptDestroyHash</a>.</li>
     * </ol>
     * @param {Pointer} hHash Handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash object</a> to be signed.
     * @param {Integer} dwKeySpec Identifies the private key to use from the provider's container. It can be AT_KEYEXCHANGE or AT_SIGNATURE. 
     * 
     * 
     * 
     * 
     * The signature algorithm used is specified when the key pair is originally created.
     * 
     * The only signature algorithm that the Microsoft Base Cryptographic Provider supports is the RSA Public Key algorithm.
     * @param {Pointer<PSTR>} szDescription This parameter is no longer used and must be set to <b>NULL</b> to prevent security vulnerabilities. However, it is still supported for backward compatibility in the Microsoft Base Cryptographic Provider.
     * @param {Integer} dwFlags The following flag values are defined. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NOHASHOID"></a><a id="crypt_nohashoid"></a><dl>
     * <dt><b>CRYPT_NOHASHOID</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used with RSA providers. The hash <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) is not placed in the RSA public key encryption. If this flag is not set, the hash OID in the default signature is as specified in the definition of DigestInfo in PKCS #1. 
     * 
     * 
     * 
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_TYPE2_FORMAT"></a><a id="crypt_type2_format"></a><dl>
     * <dt><b>CRYPT_TYPE2_FORMAT</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_X931_FORMAT"></a><a id="crypt_x931_format"></a><dl>
     * <dt><b>CRYPT_X931_FORMAT</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the RSA signature padding method specified in the ANSI X9.31 standard.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} pbSignature A pointer to a buffer receiving the signature data. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the buffer size for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pdwSigLen A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the <i>pbSignature</i> buffer. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer specified by the <i>pbSignature</i> parameter is not large enough to hold the returned data. The required buffer size, in bytes, is in the <i>pdwSigLen</i><b>DWORD</b> value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> handle specifies an algorithm that this CSP does not support, or the <i>dwKeySpec</i> parameter has an incorrect value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the hash object was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The private key specified by <i>dwKeySpec</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptsignhasha
     * @since windows5.1.2600
     */
    static CryptSignHashA(hHash, dwKeySpec, szDescription, dwFlags, pbSignature, pdwSigLen) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSignHashA", "ptr", hHash, "uint", dwKeySpec, "ptr", szDescription, "uint", dwFlags, "ptr", pbSignature, "ptr", pdwSigLen, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Signs data. (CryptSignHashW)
     * @remarks
     * Before calling this function, the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a> function must be called to get a handle to a hash object. The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashsessionkey">CryptHashSessionKey</a> function is then used to add the data or session keys to the hash object. The <b>CryptSignHash</b> function completes the hash.
     * 
     * While the DSS CSP supports hashing with both the MD5 and the SHA hash algorithms, the DSS CSP only supports signing SHA hashes.
     * 
     * After this function is called, no more data can be added to the hash. Additional calls to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> or <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashsessionkey">CryptHashSessionKey</a> fail.
     * 
     * After the application finishes using the hash, 
     * destroy the hash object by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash">CryptDestroyHash</a> function.
     * 
     * By default, the Microsoft RSA providers use the PKCS #1 padding method for the signature. The hash OID in the <b>DigestInfo</b> element of the signature is automatically set to the algorithm OID associated with the hash object. Using the <b>CRYPT_NOHASHOID</b> flag will cause this OID to be omitted from the signature.
     * 
     * Occasionally, a hash value that has been generated elsewhere must be signed. This can be done by using the following sequence of operations:
     * 
     * <ol>
     * <li>Create a hash object by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>.</li>
     * <li>Set the hash value in the hash object by using the <b>HP_HASHVAL</b> value of the <i>dwParam</i> parameter in <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsethashparam">CryptSetHashParam</a>.</li>
     * <li>Sign the hash value by using 
     * <b>CryptSignHash</b> and obtain a digital signature block.</li>
     * <li>Destroy the hash object by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash">CryptDestroyHash</a>.</li>
     * </ol>
     * @param {Pointer} hHash Handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash object</a> to be signed.
     * @param {Integer} dwKeySpec Identifies the private key to use from the provider's container. It can be AT_KEYEXCHANGE or AT_SIGNATURE. 
     * 
     * 
     * 
     * 
     * The signature algorithm used is specified when the key pair is originally created.
     * 
     * The only signature algorithm that the Microsoft Base Cryptographic Provider supports is the RSA Public Key algorithm.
     * @param {Pointer<PWSTR>} szDescription This parameter is no longer used and must be set to <b>NULL</b> to prevent security vulnerabilities. However, it is still supported for backward compatibility in the Microsoft Base Cryptographic Provider.
     * @param {Integer} dwFlags The following flag values are defined. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NOHASHOID"></a><a id="crypt_nohashoid"></a><dl>
     * <dt><b>CRYPT_NOHASHOID</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used with RSA providers. The hash <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) is not placed in the RSA public key encryption. If this flag is not set, the hash OID in the default signature is as specified in the definition of DigestInfo in PKCS #1. 
     * 
     * 
     * 
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_TYPE2_FORMAT"></a><a id="crypt_type2_format"></a><dl>
     * <dt><b>CRYPT_TYPE2_FORMAT</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_X931_FORMAT"></a><a id="crypt_x931_format"></a><dl>
     * <dt><b>CRYPT_X931_FORMAT</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the RSA signature padding method specified in the ANSI X9.31 standard.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} pbSignature A pointer to a buffer receiving the signature data. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the buffer size for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pdwSigLen A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the <i>pbSignature</i> buffer. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer specified by the <i>pbSignature</i> parameter is not large enough to hold the returned data. The required buffer size, in bytes, is in the <i>pdwSigLen</i><b>DWORD</b> value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hHash</i> handle specifies an algorithm that this CSP does not support, or the <i>dwKeySpec</i> parameter has an incorrect value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP context that was specified when the hash object was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The private key specified by <i>dwKeySpec</i> does not exist.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptsignhashw
     * @since windows5.1.2600
     */
    static CryptSignHashW(hHash, dwKeySpec, szDescription, dwFlags, pbSignature, pdwSigLen) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSignHashW", "ptr", hHash, "uint", dwKeySpec, "ptr", szDescription, "uint", dwFlags, "ptr", pbSignature, "ptr", pdwSigLen, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Verifies the signature of a hash object. (ANSI)
     * @remarks
     * The <b>CryptVerifySignature</b> function completes the hash. After this call, no more data can be added to the hash. Additional calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashsessionkey">CryptHashSessionKey</a> fail. After the application is done with the hash, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash">CryptDestroyHash</a> should be called to destroy the hash object.
     * 
     * If you generate a signature by using the .NET Framework APIs and try to verify it by using the <b>CryptVerifySignature</b> function, the function will fail and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return  <b>NTE_BAD_SIGNATURE</b>. This is due to the different byte orders between the native Win32 API  and the .NET Framework API.
     * 
     * The native cryptography API uses little-endian byte order while the .NET Framework API uses big-endian byte order. If you are verifying a  signature generated by using a .NET Framework API, you must swap the order of signature bytes before calling the <b>CryptVerifySignature</b> function to verify the signature.
     * @param {Pointer} hHash A handle to the hash object to verify.
     * @param {Pointer<Byte>} pbSignature The address of the signature data to be verified.
     * @param {Integer} dwSigLen The number of bytes in the <i>pbSignature</i> signature data.
     * @param {Pointer} hPubKey A handle to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key</a> to use to authenticate the signature. This public key must belong to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key pair</a> that was originally used to create the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">digital signature</a>.
     * @param {Pointer<PSTR>} szDescription This parameter should no longer be used and must be set to <b>NULL</b> to prevent security vulnerabilities. However, it is still supported for backward compatibility in the Microsoft Base Cryptographic Provider.
     * @param {Integer} dwFlags The following flag values are defined. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NOHASHOID"></a><a id="crypt_nohashoid"></a><dl>
     * <dt><b>CRYPT_NOHASHOID</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is used with RSA providers. When verifying the signature, the hash <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) is not expected to be present or checked. If this flag is not set, the hash OID in the default signature is verified as specified in the definition of DigestInfo in PKCS #7. 
     * 
     * 
     * 
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_TYPE2_FORMAT"></a><a id="crypt_type2_format"></a><dl>
     * <dt><b>CRYPT_TYPE2_FORMAT</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_X931_FORMAT"></a><a id="crypt_x931_format"></a><dl>
     * <dt><b>CRYPT_X931_FORMAT</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use X.931 support for the FIPS 186-2–compliant version of RSA (rDSA).
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hPubKey</i> parameter does not contain a handle to a valid <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature was not valid. This might be because the data itself has changed, the description string did not match, or the wrong public key was specified by <i>hPubKey</i>.
     * 
     * This error can also be returned if the hashing or signature algorithms do not match the ones used to create the signature.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) context that was specified when the hash object was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptverifysignaturea
     * @since windows5.1.2600
     */
    static CryptVerifySignatureA(hHash, pbSignature, dwSigLen, hPubKey, szDescription, dwFlags) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptVerifySignatureA", "ptr", hHash, "ptr", pbSignature, "uint", dwSigLen, "ptr", hPubKey, "ptr", szDescription, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Verifies the signature of a hash object. (Unicode)
     * @remarks
     * The <b>CryptVerifySignature</b> function completes the hash. After this call, no more data can be added to the hash. Additional calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashsessionkey">CryptHashSessionKey</a> fail. After the application is done with the hash, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash">CryptDestroyHash</a> should be called to destroy the hash object.
     * 
     * If you generate a signature by using the .NET Framework APIs and try to verify it by using the <b>CryptVerifySignature</b> function, the function will fail and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return  <b>NTE_BAD_SIGNATURE</b>. This is due to the different byte orders between the native Win32 API  and the .NET Framework API.
     * 
     * The native cryptography API uses little-endian byte order while the .NET Framework API uses big-endian byte order. If you are verifying a  signature generated by using a .NET Framework API, you must swap the order of signature bytes before calling the <b>CryptVerifySignature</b> function to verify the signature.
     * @param {Pointer} hHash A handle to the hash object to verify.
     * @param {Pointer<Byte>} pbSignature The address of the signature data to be verified.
     * @param {Integer} dwSigLen The number of bytes in the <i>pbSignature</i> signature data.
     * @param {Pointer} hPubKey A handle to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key</a> to use to authenticate the signature. This public key must belong to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key pair</a> that was originally used to create the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">digital signature</a>.
     * @param {Pointer<PWSTR>} szDescription This parameter should no longer be used and must be set to <b>NULL</b> to prevent security vulnerabilities. However, it is still supported for backward compatibility in the Microsoft Base Cryptographic Provider.
     * @param {Integer} dwFlags The following flag values are defined. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NOHASHOID"></a><a id="crypt_nohashoid"></a><dl>
     * <dt><b>CRYPT_NOHASHOID</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is used with RSA providers. When verifying the signature, the hash <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) is not expected to be present or checked. If this flag is not set, the hash OID in the default signature is verified as specified in the definition of DigestInfo in PKCS #7. 
     * 
     * 
     * 
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_TYPE2_FORMAT"></a><a id="crypt_type2_format"></a><dl>
     * <dt><b>CRYPT_TYPE2_FORMAT</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_X931_FORMAT"></a><a id="crypt_x931_format"></a><dl>
     * <dt><b>CRYPT_X931_FORMAT</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use X.931 support for the FIPS 186-2–compliant version of RSA (rDSA).
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by "NTE" are generated by the particular CSP you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter is nonzero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash object specified by the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hPubKey</i> parameter does not contain a handle to a valid <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature was not valid. This might be because the data itself has changed, the description string did not match, or the wrong public key was specified by <i>hPubKey</i>.
     * 
     * This error can also be returned if the hashing or signature algorithms do not match the ones used to create the signature.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_UID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) context that was specified when the hash object was created cannot be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CSP ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptverifysignaturew
     * @since windows5.1.2600
     */
    static CryptVerifySignatureW(hHash, pbSignature, dwSigLen, hPubKey, szDescription, dwFlags) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptVerifySignatureW", "ptr", hHash, "ptr", pbSignature, "uint", dwSigLen, "ptr", hPubKey, "ptr", szDescription, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Specifies the current user's default cryptographic service provider (CSP). (ANSI)
     * @remarks
     * Typical applications do not specify a CSP name when calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>; however, an application does have the option of selecting a specific CSP. This gives a user the freedom to select a CSP with an appropriate level of security.
     * 
     * Since calling <b>CryptSetProvider</b> determines the CSP of a specified type used by all applications that run from that point on, this function must not be called without users' consent.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The wincrypt.h header defines CryptSetProvider as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} pszProvName Name of the new default CSP. The named CSP must be installed on the computer. For a list of available cryptographic providers, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-provider-names">Cryptographic Provider Names</a>.
     * @param {Integer} dwProvType Provider type of the CSP specified by <i>pszProvName</i>.
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Errors can also be propagated from internal calls to <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regcreatekeyexa">RegCreateKeyEx</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regsetvalueexa">RegSetValueEx</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptsetprovidera
     * @since windows5.1.2600
     */
    static CryptSetProviderA(pszProvName, dwProvType) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSetProviderA", "ptr", pszProvName, "uint", dwProvType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Specifies the current user's default cryptographic service provider (CSP). (Unicode)
     * @remarks
     * Typical applications do not specify a CSP name when calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>; however, an application does have the option of selecting a specific CSP. This gives a user the freedom to select a CSP with an appropriate level of security.
     * 
     * Since calling <b>CryptSetProvider</b> determines the CSP of a specified type used by all applications that run from that point on, this function must not be called without users' consent.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The wincrypt.h header defines CryptSetProvider as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} pszProvName Name of the new default CSP. The named CSP must be installed on the computer. For a list of available cryptographic providers, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-provider-names">Cryptographic Provider Names</a>.
     * @param {Integer} dwProvType Provider type of the CSP specified by <i>pszProvName</i>.
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters specifies a handle that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory during the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Errors can also be propagated from internal calls to <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regcreatekeyexa">RegCreateKeyEx</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regsetvalueexa">RegSetValueEx</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptsetproviderw
     * @since windows5.1.2600
     */
    static CryptSetProviderW(pszProvName, dwProvType) {
        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSetProviderW", "ptr", pszProvName, "uint", dwProvType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Specifies the default cryptographic service provider (CSP) of a specified provider type for the local computer or current user. (ANSI)
     * @remarks
     * Most applications do not specify a CSP name when calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function; however, an application can specify a CSP name and thereby select a CSP with an appropriate level of security. Because calls to <b>CryptSetProviderEx</b> determine the CSP of a specified type used by all applications from that point on, <b>CryptSetProviderEx</b> must never be called without a user's consent.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The wincrypt.h header defines CryptSetProviderEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} pszProvName The name of the new default CSP. This must be a CSP installed on the computer. For a list of available cryptographic providers, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-provider-names">Cryptographic Provider Names</a>.
     * @param {Integer} dwProvType The provider type of the CSP specified by <i>pszProvName</i>.
     * @param {Integer} dwFlags The following flag values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DELETE_DEFAULT"></a><a id="crypt_delete_default"></a><dl>
     * <dt><b>CRYPT_DELETE_DEFAULT</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Can be used in conjunction with CRYPT_MACHINE_DEFAULT or CRYPT_USER_DEFAULT to delete the default.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_USER_DEFAULT"></a><a id="crypt_user_default"></a><dl>
     * <dt><b>CRYPT_USER_DEFAULT</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Causes the user-context default CSP of the specified type to be set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_MACHINE_DEFAULT"></a><a id="crypt_machine_default"></a><dl>
     * <dt><b>CRYPT_MACHINE_DEFAULT</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Causes the computer default CSP of the specified type to be set.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes include those shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptsetproviderexa
     * @since windows5.1.2600
     */
    static CryptSetProviderExA(pszProvName, dwProvType, dwFlags) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSetProviderExA", "ptr", pszProvName, "uint", dwProvType, "ptr", pdwReserved, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Specifies the default cryptographic service provider (CSP) of a specified provider type for the local computer or current user. (Unicode)
     * @remarks
     * Most applications do not specify a CSP name when calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function; however, an application can specify a CSP name and thereby select a CSP with an appropriate level of security. Because calls to <b>CryptSetProviderEx</b> determine the CSP of a specified type used by all applications from that point on, <b>CryptSetProviderEx</b> must never be called without a user's consent.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The wincrypt.h header defines CryptSetProviderEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} pszProvName The name of the new default CSP. This must be a CSP installed on the computer. For a list of available cryptographic providers, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/cryptographic-provider-names">Cryptographic Provider Names</a>.
     * @param {Integer} dwProvType The provider type of the CSP specified by <i>pszProvName</i>.
     * @param {Integer} dwFlags The following flag values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DELETE_DEFAULT"></a><a id="crypt_delete_default"></a><dl>
     * <dt><b>CRYPT_DELETE_DEFAULT</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Can be used in conjunction with CRYPT_MACHINE_DEFAULT or CRYPT_USER_DEFAULT to delete the default.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_USER_DEFAULT"></a><a id="crypt_user_default"></a><dl>
     * <dt><b>CRYPT_USER_DEFAULT</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Causes the user-context default CSP of the specified type to be set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_MACHINE_DEFAULT"></a><a id="crypt_machine_default"></a><dl>
     * <dt><b>CRYPT_MACHINE_DEFAULT</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Causes the computer default CSP of the specified type to be set.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes include those shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptsetproviderexw
     * @since windows5.1.2600
     */
    static CryptSetProviderExW(pszProvName, dwProvType, dwFlags) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptSetProviderExW", "ptr", pszProvName, "uint", dwProvType, "ptr", pdwReserved, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Finds the default cryptographic service provider (CSP) of a specified provider type for the local computer or current user. (ANSI)
     * @remarks
     * This function determines which installed CSP is currently set as the default for the local computer or current user. This information is often displayed to the user.
     * @param {Integer} dwProvType The provider type for which the default CSP name is to be found. 
     * 
     * Defined provider types are  as follows:
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-rsa-full">PROV_RSA_FULL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-rsa-sig">PROV_RSA_SIG</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-dss">PROV_DSS</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-dss-dh">PROV_DSS_DH</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-dh-schannel">PROV_DH_SCHANNEL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-fortezza">PROV_FORTEZZA</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-ms-exchange">PROV_MS_EXCHANGE</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-rsa-schannel">PROV_RSA_SCHANNEL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-ssl">PROV_SSL</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags The following flag values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_USER_DEFAULT"></a><a id="crypt_user_default"></a><dl>
     * <dt><b>CRYPT_USER_DEFAULT</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns the user-context default CSP of the specified type.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_MACHINE_DEFAULT"></a><a id="crypt_machine_default"></a><dl>
     * <dt><b>CRYPT_MACHINE_DEFAULT</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns the computer default CSP of the specified type.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PSTR>} pszProvName A pointer to a null-terminated character string buffer to receive the name of the default CSP.
     * 
     * To find the size of the buffer for memory allocation purposes, this parameter can be <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbProvName A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the buffer pointed to by the <i>pszProvName</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored or to be stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 						
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error code prefaced by NTE is generated by the particular CSP being used. Possible error codes include the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer for the name is not large enough.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter has an unrecognized value.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptgetdefaultprovidera
     * @since windows5.1.2600
     */
    static CryptGetDefaultProviderA(dwProvType, dwFlags, pszProvName, pcbProvName) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptGetDefaultProviderA", "uint", dwProvType, "ptr", pdwReserved, "uint", dwFlags, "ptr", pszProvName, "ptr", pcbProvName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Finds the default cryptographic service provider (CSP) of a specified provider type for the local computer or current user. (Unicode)
     * @remarks
     * This function determines which installed CSP is currently set as the default for the local computer or current user. This information is often displayed to the user.
     * @param {Integer} dwProvType The provider type for which the default CSP name is to be found. 
     * 
     * Defined provider types are  as follows:
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-rsa-full">PROV_RSA_FULL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-rsa-sig">PROV_RSA_SIG</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-dss">PROV_DSS</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-dss-dh">PROV_DSS_DH</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-dh-schannel">PROV_DH_SCHANNEL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-fortezza">PROV_FORTEZZA</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-ms-exchange">PROV_MS_EXCHANGE</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-rsa-schannel">PROV_RSA_SCHANNEL</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/prov-ssl">PROV_SSL</a>
     * </li>
     * </ul>
     * @param {Integer} dwFlags The following flag values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_USER_DEFAULT"></a><a id="crypt_user_default"></a><dl>
     * <dt><b>CRYPT_USER_DEFAULT</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns the user-context default CSP of the specified type.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_MACHINE_DEFAULT"></a><a id="crypt_machine_default"></a><dl>
     * <dt><b>CRYPT_MACHINE_DEFAULT</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns the computer default CSP of the specified type.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} pszProvName A pointer to a null-terminated character string buffer to receive the name of the default CSP.
     * 
     * To find the size of the buffer for memory allocation purposes, this parameter can be <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbProvName A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the buffer pointed to by the <i>pszProvName</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored or to be stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 						
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error code prefaced by NTE is generated by the particular CSP being used. Possible error codes include the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer for the name is not large enough.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter has an unrecognized value.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptgetdefaultproviderw
     * @since windows5.1.2600
     */
    static CryptGetDefaultProviderW(dwProvType, dwFlags, pszProvName, pcbProvName) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptGetDefaultProviderW", "uint", dwProvType, "ptr", pdwReserved, "uint", dwFlags, "ptr", pszProvName, "ptr", pcbProvName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the first or next types of cryptographic service provider (CSP) supported on the computer. (ANSI)
     * @remarks
     * This function enumerates the provider types available on a computer. Providers for any specific provider type can be enumerated using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptenumprovidersa">CryptEnumProviders</a>.
     * @param {Integer} dwIndex Index of the next provider type to be enumerated.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<UInt32>} pdwProvType Address of the <b>DWORD</b> value designating the enumerated provider type.
     * @param {Pointer<PSTR>} szTypeName A pointer to a buffer that receives the data from the enumerated provider type. This is a string including the terminating <b>NULL</b> character. Some provider types do not have display names, and in this case no name is returned and the returned value pointed to by <i>pcbTypeName</i> is zero. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to get the size of the name for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbTypeName A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pszTypeName</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored or to be stored in the buffer. Some provider types do not have display names, and in this case no name is returned and the returned value pointed to by <i>pcbTypeName</i> is zero. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There are no more items to enumerate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter has an unrecognized value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Something was wrong with the type registration.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptenumprovidertypesa
     * @since windows5.1.2600
     */
    static CryptEnumProviderTypesA(dwIndex, dwFlags, pdwProvType, szTypeName, pcbTypeName) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptEnumProviderTypesA", "uint", dwIndex, "ptr", pdwReserved, "uint", dwFlags, "ptr", pdwProvType, "ptr", szTypeName, "ptr", pcbTypeName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the first or next types of cryptographic service provider (CSP) supported on the computer. (Unicode)
     * @remarks
     * This function enumerates the provider types available on a computer. Providers for any specific provider type can be enumerated using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptenumprovidersa">CryptEnumProviders</a>.
     * @param {Integer} dwIndex Index of the next provider type to be enumerated.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<UInt32>} pdwProvType Address of the <b>DWORD</b> value designating the enumerated provider type.
     * @param {Pointer<PWSTR>} szTypeName A pointer to a buffer that receives the data from the enumerated provider type. This is a string including the terminating <b>NULL</b> character. Some provider types do not have display names, and in this case no name is returned and the returned value pointed to by <i>pcbTypeName</i> is zero. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to get the size of the name for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbTypeName A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pszTypeName</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored or to be stored in the buffer. Some provider types do not have display names, and in this case no name is returned and the returned value pointed to by <i>pcbTypeName</i> is zero. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There are no more items to enumerate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter has an unrecognized value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Something was wrong with the type registration.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptenumprovidertypesw
     * @since windows5.1.2600
     */
    static CryptEnumProviderTypesW(dwIndex, dwFlags, pdwProvType, szTypeName, pcbTypeName) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptEnumProviderTypesW", "uint", dwIndex, "ptr", pdwReserved, "uint", dwFlags, "ptr", pdwProvType, "ptr", szTypeName, "ptr", pcbTypeName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Important  This API is deprecated. (CryptEnumProvidersA)
     * @remarks
     * This function  enumerates the providers available on a computer. The provider types can be enumerated by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptenumprovidertypesa">CryptEnumProviderTypes</a>.
     * @param {Integer} dwIndex Index of the next provider to be enumerated.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<UInt32>} pdwProvType Address of the <b>DWORD</b> value designating the type of the enumerated provider.
     * @param {Pointer<PSTR>} szProvName A pointer to a buffer that receives the data from the enumerated provider. This is a string including the terminating null character.
     * 
     * This parameter can be <b>NULL</b> to set the size of the name for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbProvName A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pszProvName</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszProvName</i> buffer was not large enough to hold the provider name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There are no more items to enumerate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter has an unrecognized value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Something was wrong with the type registration.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptenumprovidersa
     * @since windows5.1.2600
     */
    static CryptEnumProvidersA(dwIndex, dwFlags, pdwProvType, szProvName, pcbProvName) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptEnumProvidersA", "uint", dwIndex, "ptr", pdwReserved, "uint", dwFlags, "ptr", pdwProvType, "ptr", szProvName, "ptr", pcbProvName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Important  This API is deprecated. (CryptEnumProvidersW)
     * @remarks
     * This function  enumerates the providers available on a computer. The provider types can be enumerated by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptenumprovidertypesa">CryptEnumProviderTypes</a>.
     * @param {Integer} dwIndex Index of the next provider to be enumerated.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<UInt32>} pdwProvType Address of the <b>DWORD</b> value designating the type of the enumerated provider.
     * @param {Pointer<PWSTR>} szProvName A pointer to a buffer that receives the data from the enumerated provider. This is a string including the terminating null character.
     * 
     * This parameter can be <b>NULL</b> to set the size of the name for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbProvName A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pszProvName</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error codes prefaced by NTE are generated by the particular CSP being used. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszProvName</i> buffer was not large enough to hold the provider name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_ITEMS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There are no more items to enumerate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operating system ran out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter has an unrecognized value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_FAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Something was wrong with the type registration.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptenumprovidersw
     * @since windows5.1.2600
     */
    static CryptEnumProvidersW(dwIndex, dwFlags, pdwProvType, szProvName, pcbProvName) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptEnumProvidersW", "uint", dwIndex, "ptr", pdwReserved, "uint", dwFlags, "ptr", pdwProvType, "ptr", szProvName, "ptr", pcbProvName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds one to the reference count of an HCRYPTPROV cryptographic service provider (CSP) handle.
     * @remarks
     * This function increases the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> on a 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a> handle so that multiple calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptreleasecontext">CryptReleaseContext</a> are required to actually release the handle.
     * @param {Pointer} hProv <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a> handle for which the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> is being incremented. This handle must have already been created using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptcontextaddref
     * @since windows5.1.2600
     */
    static CryptContextAddRef(hProv, dwFlags) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptContextAddRef", "ptr", hProv, "ptr", pdwReserved, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Makes an exact copy of a key and the state of the key.
     * @remarks
     * <b>CryptDuplicateKey</b> makes a copy of a key and the exact <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">state</a> of the key. One scenario when this function can be used is when an application needs to encrypt two separate messages with the same key but with different <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">salt values</a>. The original key is generated and then a duplicate key is made by using the <b>CryptDuplicateKey</b> function. The different salt values are then set on the original and duplicate keys with separate calls to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetkeyparam">CryptSetKeyParam</a> function.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> must be called to destroy any keys that are created by using <b>CryptDuplicateKey</b>. Destroying the original key does not cause the duplicate key to be destroyed. After a duplicate key is made, it is separate from the original key. There is no shared state between the two keys.
     * @param {Pointer} hKey A handle to the key to be duplicated.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<UIntPtr>} phKey Address of the handle to the duplicated key. When you have finished using the key, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error code prefaced by "NTE" is generated by the particular CSP being used. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Because this is a new function, existing CSPs might not implement it. This error is returned if the CSP does not support this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A handle to the original key is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptduplicatekey
     * @since windows5.1.2600
     */
    static CryptDuplicateKey(hKey, dwFlags, phKey) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptDuplicateKey", "ptr", hKey, "ptr", pdwReserved, "uint", dwFlags, "ptr", phKey, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Makes an exact copy of a hash to the point when the duplication is done.
     * @remarks
     * <b>CryptDuplicateHash</b> makes a copy of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> and the exact <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">state</a> of the hash. This function might be used if a calling application needed to generate two hashes but both hashes had to start with some common data hashed. For example, a hash might be created, the common data hashed, a duplicate made with the <b>CryptDuplicateHash</b> function, and then the data unique to each hash would be added.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash">CryptDestroyHash</a> function must be called to destroy any hashes that are created with <b>CryptDuplicateHash</b>. Destroying the original hash does not cause the duplicate hash to be destroyed. After a duplicate hash is made, it is separate from the original hash. There is no shared <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">state</a> between the two hashes.
     * @param {Pointer} hHash Handle of the hash to be duplicated.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<UIntPtr>} phHash Address of the handle of the duplicated hash. When you have finished using the hash, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash">CryptDestroyHash</a> function.
     * @returns {Integer} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The error code prefaced by "NTE" is generated by the particular <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) that you are using. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Because this is a new function, existing CSPs cannot implement it. This error is returned if the CSP does not support this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid. This is most often a pointer that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A handle to the original hash is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptduplicatehash
     * @since windows5.1.2600
     */
    static CryptDuplicateHash(hHash, dwFlags, phHash) {
        static pdwReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\CryptDuplicateHash", "ptr", hHash, "ptr", pdwReserved, "uint", dwFlags, "ptr", phHash, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Loads and initializes a CNG provider.
     * @remarks
     * Because of the number and type of operations that are required to find, load, and initialize an algorithm provider, the <b>BCryptOpenAlgorithmProvider</b> function is a relatively time intensive function. Because of this, we recommend that you cache any algorithm provider handles that you will use more than once, rather than opening and closing the algorithm providers over and over.
     * 
     * <b>BCryptOpenAlgorithmProvider</b> can be called either from user mode or kernel mode. Kernel mode callers must be executing at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a>.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * 
     * 
     * 
     * Starting in Windows 10, CNG no longer follows every update to the cryptography configuration. Certain changes, like adding a new default provider or changing the preference order of algorithm providers, may require a reboot. Because of this, you should reboot before calling <b>BCryptOpenAlgorithmProvider</b>    with any newly configured provider.
     * @param {Pointer<BCRYPT_ALG_HANDLE>} phAlgorithm A pointer to a <b>BCRYPT_ALG_HANDLE</b> variable that receives the CNG provider handle. When you have finished using this handle, release it by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptclosealgorithmprovider">BCryptCloseAlgorithmProvider</a> function.
     * @param {Pointer<PWSTR>} pszAlgId A pointer to a null-terminated Unicode string that identifies the requested cryptographic algorithm. This can be one of the standard <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-algorithm-identifiers">CNG Algorithm Identifiers</a> or the identifier for another registered algorithm.
     * @param {Pointer<PWSTR>} pszImplementation A pointer to a null-terminated Unicode string that identifies the specific provider to load. This is the registered alias of the cryptographic primitive provider. This parameter is optional and can be <b>NULL</b> if it is not needed. If this parameter is <b>NULL</b>, the default provider for the specified algorithm will be loaded.
     * 
     * 
     * <div class="alert"><b>Note</b>  If the <i>pszImplementation</i> parameter value  is <b>NULL</b>, CNG attempts to open each registered provider, in order of priority, for the algorithm specified by the <i>pszAlgId</i> parameter and returns the handle of the first  provider that is successfully opened. For the lifetime of the handle, any BCrypt*** cryptographic APIs will use the provider that was successfully opened.</div>
     * <div> </div>
     * <b>Windows Server 2008 and Windows Vista:  </b>CNG attempts to fall back to the Microsoft CNG provider.
     * 
     * 
     * 
     * 
     * The following are the predefined provider names.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MS_PRIMITIVE_PROVIDER"></a><a id="ms_primitive_provider"></a><dl>
     * <dt><b>MS_PRIMITIVE_PROVIDER</b></dt>
     * <dt>"Microsoft Primitive Provider"</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Identifies the basic Microsoft CNG provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MS_PLATFORM_CRYPTO_PROVIDER"></a><a id="ms_platform_crypto_provider"></a><dl>
     * <dt><b>MS_PLATFORM_CRYPTO_PROVIDER</b></dt>
     * <dt>L"Microsoft Platform Crypto Provider"</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Identifies the TPM key storage provider that is provided by Microsoft.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No provider was found for the specified algorithm ID.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider
     * @since windows6.0.6000
     */
    static BCryptOpenAlgorithmProvider(phAlgorithm, pszAlgId, pszImplementation, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptOpenAlgorithmProvider", "ptr", phAlgorithm, "ptr", pszAlgId, "ptr", pszImplementation, "uint", dwFlags, "int")
        return result
    }

    /**
     * Gets a list of the registered algorithm identifiers.
     * @remarks
     * <b>BCryptEnumAlgorithms</b> can be called either from user mode or kernel mode. Kernel mode callers must be executing at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a>.
     * @param {Integer} dwAlgOperations 
     * @param {Pointer<UInt32>} pAlgCount A pointer to a <b>ULONG</b> variable to receive the number of elements in the <i>ppAlgList</i> array.
     * @param {Pointer<BCRYPT_ALGORITHM_IDENTIFIER>} ppAlgList The address of a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-bcrypt_algorithm_identifier">BCRYPT_ALGORITHM_IDENTIFIER</a> structure pointer to receive the array of registered algorithm identifiers. This pointer must be passed to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function when it is no longer needed.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are defined for this function.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptenumalgorithms
     * @since windows6.0.6000
     */
    static BCryptEnumAlgorithms(dwAlgOperations, pAlgCount, ppAlgList, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptEnumAlgorithms", "uint", dwAlgOperations, "ptr", pAlgCount, "ptr", ppAlgList, "uint", dwFlags, "int")
        return result
    }

    /**
     * Obtains all of the CNG providers that support a specified algorithm.
     * @remarks
     * <b>BCryptEnumProviders</b> can be called either from user mode or kernel mode. Kernel mode callers must be executing at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a>.
     * @param {Pointer<PWSTR>} pszAlgId A pointer to a null-terminated Unicode string that identifies the algorithm to obtain the providers for. This can be one of the predefined <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-algorithm-identifiers">CNG Algorithm Identifiers</a> or another algorithm identifier.
     * @param {Pointer<UInt32>} pImplCount A pointer to a <b>ULONG</b> variable to receive the number of elements in the <i>ppImplList</i> array.
     * @param {Pointer<PWSTR>} ppImplList The address of an array of <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-bcrypt_provider_name">BCRYPT_PROVIDER_NAME</a> structures to receive the collection of providers that support the specified algorithm. The <i>pImplCount</i> parameter receives the number of elements in this array. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * @param {Integer} dwFlags A set of flags that modifies the behavior of this function. There are currently no flags defined, so this parameter must be zero.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptenumproviders
     * @since windows6.0.6000
     */
    static BCryptEnumProviders(pszAlgId, pImplCount, ppImplList, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptEnumProviders", "ptr", pszAlgId, "ptr", pImplCount, "ptr", ppImplList, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves the value of a named property for a CNG object.
     * @remarks
     * To obtain the required size for a property, pass <b>NULL</b> for the <i>pbOutput</i> parameter. This function will place the required size, in bytes, in the value pointed to by the <i>pcbResult</i> parameter.
     * 
     * Depending on what processor modes a provider supports, <b>BCryptGetProperty</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, any pointers passed to the <b>BCryptGetProperty</b> function must refer to nonpaged (or locked) memory. If the object specified in the <i>hObject</i> parameter is a handle, it must have been opened by using the <b>BCRYPT_PROV_DISPATCH</b> flag.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_HANDLE>} hObject A handle that represents the CNG object to obtain the property value for.
     * @param {Pointer<PWSTR>} pszProperty A pointer to a null-terminated Unicode string that contains the name of the property to retrieve. This can be one of the predefined <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-property-identifiers">Cryptography Primitive Property Identifiers</a> or a custom property identifier.
     * @param {Pointer<Byte>} pbOutput The address of a buffer that receives the property value. The <i>cbOutput</i> parameter contains the size of this buffer.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer.
     * @param {Pointer<UInt32>} pcbResult A pointer to a <b>ULONG</b> variable that receives the number of bytes that were copied to the <i>pbOutput</i> buffer. If the <i>pbOutput</i> parameter is <b>NULL</b>, this function will place the required size, in bytes, in the location pointed to by this parameter.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are defined for this function.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer size specified by the <i>cbOutput</i> parameter is not large enough to hold the property value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hObject</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The named property specified by the <i>pszProperty</i> parameter is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptgetproperty
     * @since windows6.0.6000
     */
    static BCryptGetProperty(hObject, pszProperty, pbOutput, cbOutput, pcbResult, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptGetProperty", "ptr", hObject, "ptr", pszProperty, "ptr", pbOutput, "uint", cbOutput, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Sets the value of a named property for a CNG object.
     * @remarks
     * Depending on what processor modes a provider supports, <b>BCryptSetProperty</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, any pointers passed to <b>BCryptSetProperty</b> must refer to nonpaged (or locked) memory. If the object specified in the <i>hObject</i> parameter is a handle, it must have been opened by using the <b>BCRYPT_PROV_DISPATCH</b> flag.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_HANDLE>} hObject A handle that represents the CNG object to set the property value for.
     * @param {Pointer<PWSTR>} pszProperty A pointer to a null-terminated Unicode string that contains the name of the property to set. This can be one of the predefined <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-property-identifiers">Cryptography Primitive Property Identifiers</a> or a custom property identifier.
     * @param {Pointer<Byte>} pbInput The address of a buffer that contains the new property value. The <i>cbInput</i> parameter contains the size of this buffer.
     * @param {Integer} cbInput The size, in bytes, of the <i>pbInput</i> buffer.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are defined for this function.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hObject</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The named property specified by the <i>pszProperty</i> parameter is not supported or is read-only.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptsetproperty
     * @since windows6.0.6000
     */
    static BCryptSetProperty(hObject, pszProperty, pbInput, cbInput, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptSetProperty", "ptr", hObject, "ptr", pszProperty, "ptr", pbInput, "uint", cbInput, "uint", dwFlags, "int")
        return result
    }

    /**
     * Closes an algorithm provider.
     * @remarks
     * <b>BCryptCloseAlgorithmProvider</b> can be called either from user mode or kernel mode. Kernel mode callers must be executing at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a>.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). For more information, see <a href="https://www.microsoft.com/?ref=go">WDK and Developer Tools</a>.<b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_ALG_HANDLE>} hAlgorithm A handle that represents the algorithm provider to close. This handle is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are defined for this function.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm handle in the <i>hAlgorithm</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptclosealgorithmprovider
     * @since windows6.0.6000
     */
    static BCryptCloseAlgorithmProvider(hAlgorithm, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptCloseAlgorithmProvider", "ptr", hAlgorithm, "uint", dwFlags, "int")
        return result
    }

    /**
     * Used to free memory that was allocated by one of the CNG functions.
     * @remarks
     * <b>BCryptFreeBuffer</b> must be called in the same processor mode as the BCrypt API function that allocated the buffer. In addition, if the buffer was allocated at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a>, it must be freed at that <i>IRQL</i>. If the buffer was allocated at <b>DISPATCH_LEVEL</b> <i>IRQL</i>, it can be freed at either <b>DISPATCH_LEVEL</b> <i>IRQL</i> or <b>PASSIVE_LEVEL</b> <i>IRQL</i>.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<Void>} pvBuffer A pointer to the memory buffer to be freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptfreebuffer
     * @since windows6.0.6000
     */
    static BCryptFreeBuffer(pvBuffer) {
        DllCall("bcrypt.dll\BCryptFreeBuffer", "ptr", pvBuffer)
    }

    /**
     * Creates a key object for use with a symmetrical key encryption algorithm from a supplied key.
     * @remarks
     * Depending on what processor modes a provider supports, <b>BCryptGenerateSymmetricKey</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hAlgorithm</i> parameter must have been opened by using the <b>BCRYPT_PROV_DISPATCH</b> flag, and any pointers passed to the <b>BCryptGenerateSymmetricKey</b> function must refer to nonpaged (or locked) memory.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_ALG_HANDLE>} hAlgorithm The handle of an algorithm provider created with the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function. The algorithm specified when the provider was created must support symmetric key encryption.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} phKey A pointer to a <b>BCRYPT_KEY_HANDLE</b> that receives the handle of the key. This handle is used in subsequent functions that require a key, such as <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptencrypt">BCryptEncrypt</a>. This handle must be released when it is no longer needed by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroykey">BCryptDestroyKey</a> function.
     * @param {Pointer<Byte>} pbKeyObject A pointer to a buffer that receives the key object. The <i>cbKeyObject</i> parameter contains the size of this buffer. The required size of this buffer can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_OBJECT_LENGTH</b> property. This will provide the size of the key object for the specified algorithm.
     * 
     * This memory can only be freed after the <i>phKey</i> key handle is destroyed.
     * 
     * If the value of this parameter is <b>NULL</b> and the value of the <i>cbKeyObject</i> parameter is zero, the memory for the key object is allocated and freed by this function.<b>Windows 7:  </b>This memory management functionality is available beginning with Windows 7.
     * @param {Integer} cbKeyObject The size, in bytes, of the <i>pbKeyObject</i> buffer.
     * 
     * If the value of this parameter is zero and the value of the <i>pbKeyObject</i> parameter is <b>NULL</b>, the memory for the key object is allocated and freed by this function.<b>Windows 7:  </b>This memory management functionality is available beginning with Windows 7.
     * @param {Pointer<Byte>} pbSecret Pointer to a buffer that contains the key from which to create the key object. The <i>cbSecret</i> parameter contains the size of this buffer. This is normally a hash of a password or some other reproducible data. If the data passed in exceeds the target key size, the data will be truncated and the excess will be ignored.
     * 
     * <div class="alert"><b>Note</b>  We strongly recommended that applications pass in the exact number of bytes required by the target key.</div>
     * <div> </div>
     * @param {Integer} cbSecret The size, in bytes, of the <i>pbSecret</i> buffer.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are currently defined, so this parameter should be zero.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of the key object specified by the <i>cbKeyObject</i> parameter is not large enough to hold the key object.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm handle in the <i>hAlgorithm</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptgeneratesymmetrickey
     * @since windows6.0.6000
     */
    static BCryptGenerateSymmetricKey(hAlgorithm, phKey, pbKeyObject, cbKeyObject, pbSecret, cbSecret, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptGenerateSymmetricKey", "ptr", hAlgorithm, "ptr", phKey, "ptr", pbKeyObject, "uint", cbKeyObject, "ptr", pbSecret, "uint", cbSecret, "uint", dwFlags, "int")
        return result
    }

    /**
     * Creates an empty public/private key pair.
     * @remarks
     * Depending on what processor modes a provider supports, <b>BCryptGenerateKeyPair</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hAlgorithm</i> parameter must have been opened by using the <b>BCRYPT_PROV_DISPATCH</b> flag, and any pointers passed to the <b>BCryptGenerateKeyPair</b> function must refer to nonpaged (or locked) memory.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_ALG_HANDLE>} hAlgorithm Handle of an algorithm provider that supports signing, asymmetric encryption, or key agreement. This handle must have been created by using the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} phKey A pointer to a <b>BCRYPT_KEY_HANDLE</b> that receives the handle of the key. This handle is used in subsequent functions that require a key, such as <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptencrypt">BCryptEncrypt</a>. This handle must be released when it is no longer needed by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroykey">BCryptDestroyKey</a> function.
     * @param {Integer} dwLength The length, in bits, of the key. Algorithm providers have different key size restrictions for each standard asymmetric algorithm.
     * 
     * <table>
     * <tr>
     * <th>Algorithm identifier</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_DH_ALGORITHM"></a><a id="bcrypt_dh_algorithm"></a><dl>
     * <dt><b>BCRYPT_DH_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key size must be greater than or equal to 512 bits, less than or equal to 4096 bits, and must be a multiple of 64.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_DSA_ALGORITHM"></a><a id="bcrypt_dsa_algorithm"></a><dl>
     * <dt><b>BCRYPT_DSA_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Prior to Windows 8, the key size must be greater than or equal to 512 bits, less than or equal to 1024 bits, and must be a multiple of 64.
     * 
     * Beginning with Windows 8, the key size must be greater than or equal to 512 bits, less than or equal to 3072 bits, and must be a multiple of 64. Processing for key sizes less than or equal to 1024 bits adheres to FIPS 186-2. Processing for key sizes greater than 1024 and less than or equal to 3072 adheres to FIPS 186-3.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_ECDH_P256_ALGORITHM"></a><a id="bcrypt_ecdh_p256_algorithm"></a><dl>
     * <dt><b>BCRYPT_ECDH_P256_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key size must be 256 bits.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_ECDH_P384_ALGORITHM"></a><a id="bcrypt_ecdh_p384_algorithm"></a><dl>
     * <dt><b>BCRYPT_ECDH_P384_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key size must be 384 bits.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_ECDH_P521_ALGORITHM"></a><a id="bcrypt_ecdh_p521_algorithm"></a><dl>
     * <dt><b>BCRYPT_ECDH_P521_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key size must be 521 bits.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_ECDSA_P256_ALGORITHM"></a><a id="bcrypt_ecdsa_p256_algorithm"></a><dl>
     * <dt><b>BCRYPT_ECDSA_P256_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key size must be 256 bits.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_ECDSA_P384_ALGORITHM"></a><a id="bcrypt_ecdsa_p384_algorithm"></a><dl>
     * <dt><b>BCRYPT_ECDSA_P384_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key size must be 384 bits.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_ECDSA_P521_ALGORITHM"></a><a id="bcrypt_ecdsa_p521_algorithm"></a><dl>
     * <dt><b>BCRYPT_ECDSA_P521_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key size must be 521 bits.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_RSA_ALGORITHM"></a><a id="bcrypt_rsa_algorithm"></a><dl>
     * <dt><b>BCRYPT_RSA_ALGORITHM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key size must be greater than or equal to 512 bits, less than or equal to 16384 bits, and must be a multiple of 64.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are currently defined, so this parameter should be zero.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm handle in the <i>hAlgorithm</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified provider does not support asymmetric key encryption.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptgeneratekeypair
     * @since windows6.0.6000
     */
    static BCryptGenerateKeyPair(hAlgorithm, phKey, dwLength, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptGenerateKeyPair", "ptr", hAlgorithm, "ptr", phKey, "uint", dwLength, "uint", dwFlags, "int")
        return result
    }

    /**
     * Encrypts a block of data. (BCryptEncrypt)
     * @remarks
     * The <i>pbInput</i> and <i>pbOutput</i> parameters can be equal. In this case, this function will perform the encryption in place. It is possible that the encrypted data size will be larger than the unencrypted data size, so the buffer must be large enough to hold the encrypted data. If <i>pbInput</i> and <i>pbOutput</i> are not equal then the two buffers may not overlap.
     * 
     * Depending on what processor modes a provider supports, <b>BCryptEncrypt</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hKey</i> parameter must be derived from an algorithm handle returned by a provider that was opened with the <b>BCRYPT_PROV_DISPATCH</b> flag, and any pointers passed to the <b>BCryptEncrypt</b> function must refer to nonpaged (or locked) memory.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} hKey The handle of the key to use to encrypt the data. This handle is obtained from one of the key creation functions, such as <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgeneratesymmetrickey">BCryptGenerateSymmetricKey</a>, <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgeneratekeypair">BCryptGenerateKeyPair</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptimportkey">BCryptImportKey</a>.
     * @param {Pointer<Byte>} pbInput The address of a buffer that contains the plaintext to be encrypted. The <i>cbInput</i> parameter contains the size of the plaintext to encrypt. For more information, see Remarks.
     * @param {Integer} cbInput The number of bytes in the <i>pbInput</i> buffer to encrypt.
     * @param {Pointer<Void>} pPaddingInfo A pointer to a structure that contains padding information. This parameter is only used with asymmetric keys and authenticated encryption modes. If an  authenticated encryption mode is used, this parameter must point to a <a href="https://docs.microsoft.com/windows/win32/api/bcrypt/ns-bcrypt-bcrypt_authenticated_cipher_mode_info">BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO</a> structure. If asymmetric keys are used, the type of structure this parameter points to is determined by the value of the <i>dwFlags</i> parameter. Otherwise, the parameter  must be set to <b>NULL</b>.
     * @param {Pointer<Byte>} pbIV The address of a buffer that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">initialization vector</a> (IV) to use during encryption. The <i>cbIV</i> parameter contains the size of this buffer. This function will modify the contents of this buffer. If you need to reuse the IV later, make sure you make a copy of this buffer before calling this function.
     * 
     * This parameter is optional and can be <b>NULL</b> if no IV is used.
     * 
     *  The required size of the IV can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_BLOCK_LENGTH</b> property. This will provide the size of a block for the algorithm, which is also the size of the IV.
     * @param {Integer} cbIV The size, in bytes, of the <i>pbIV</i> buffer.
     * @param {Pointer<Byte>} pbOutput The address of the buffer that receives the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">ciphertext</a> produced by this function. The <i>cbOutput</i> parameter contains the size of this buffer. For more information, see Remarks.
     * 
     * If this parameter is <b>NULL</b>, the <b>BCryptEncrypt</b> function calculates the size needed for the ciphertext of the data passed in the <i>pbInput</i> parameter. In this case, the location pointed to by the <i>pcbResult</i> parameter contains this size, and the  function returns <b>STATUS_SUCCESS</b>. The <i>pPaddingInfo</i> parameter is not modified.
     * 
     * If the values of both the <i>pbOutput</i> and <i>pbInput</i> parameters are <b>NULL</b>, an error is returned unless  an authenticated encryption algorithm is in use. In the latter case, the call is treated as an authenticated encryption call with zero length data, and the authentication tag is returned in the <i>pPaddingInfo</i> parameter.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer. This parameter is ignored if the <i>pbOutput</i> parameter is <b>NULL</b>.
     * @param {Pointer<UInt32>} pcbResult A pointer to a <b>ULONG</b> variable that receives the number of bytes copied to the <i>pbOutput</i> buffer. If <i>pbOutput</i> is <b>NULL</b>, this receives the size, in bytes, required for the ciphertext.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. The allowed set of flags depends on the type of key specified by the <i>hKey</i> parameter.
     * 
     * 
     * If the key is a symmetric key, this can be zero or the following value. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_BLOCK_PADDING"></a><a id="bcrypt_block_padding"></a><dl>
     * <dt><b>BCRYPT_BLOCK_PADDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Allows the encryption algorithm to pad the data to the next block size. If this flag is not specified, the size of the plaintext specified in the <i>cbInput</i> parameter must be a multiple of the algorithm's block size.
     * 
     *  The block size can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_BLOCK_LENGTH</b> property for the key. This will provide the size of a block for the algorithm.
     * 
     * This flag must not be used with the authenticated encryption modes (AES-CCM and AES-GCM).
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size specified by the <i>cbOutput</i> parameter is not large enough to hold the ciphertext.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_BUFFER_SIZE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>cbInput</i> parameter is not a multiple of the algorithm's block size and the <b>BCRYPT_BLOCK_PADDING</b> or the <b>BCRYPT_PAD_NONE</b> flag was not specified in the <i>dwFlags</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle in the <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm does not support encryption.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptencrypt
     * @since windows6.0.6000
     */
    static BCryptEncrypt(hKey, pbInput, cbInput, pPaddingInfo, pbIV, cbIV, pbOutput, cbOutput, pcbResult, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptEncrypt", "ptr", hKey, "ptr", pbInput, "uint", cbInput, "ptr", pPaddingInfo, "ptr", pbIV, "uint", cbIV, "ptr", pbOutput, "uint", cbOutput, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Decrypts a block of data.
     * @remarks
     * The <i>pbInput</i> and <i>pbOutput</i> parameters can be equal. In this case, this function will perform the decryption in place. If <i>pbInput</i> and <i>pbOutput</i> are not equal, the two buffers may not overlap.
     * 
     * Depending on what processor modes a provider supports, <b>BCryptDecrypt</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hKey</i> parameter must be derived from an algorithm handle returned by a provider that was opened with the <b>BCRYPT_PROV_DISPATCH</b> flag, and any pointers passed to the <b>BCryptDecrypt</b> function must refer to nonpaged (or locked) memory.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} hKey The handle of the key to use to decrypt the data. This handle is obtained from one of the key creation functions, such as <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgeneratesymmetrickey">BCryptGenerateSymmetricKey</a>, <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgeneratekeypair">BCryptGenerateKeyPair</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptimportkey">BCryptImportKey</a>.
     * @param {Pointer<Byte>} pbInput The address of a buffer that contains the ciphertext to be decrypted. The <i>cbInput</i> parameter contains the size of the ciphertext to decrypt. For more information, see Remarks.
     * @param {Integer} cbInput The number of bytes in the <i>pbInput</i> buffer to decrypt.
     * @param {Pointer<Void>} pPaddingInfo A pointer to a structure that contains padding information. This parameter is only used with asymmetric keys and authenticated encryption modes. If an  authenticated encryption mode is used, this parameter must point to a <a href="https://docs.microsoft.com/windows/win32/api/bcrypt/ns-bcrypt-bcrypt_authenticated_cipher_mode_info">BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO</a> structure. If asymmetric keys are used, the type of structure this parameter points to is determined by the value of the <i>dwFlags</i> parameter. Otherwise, the parameter  must be set to <b>NULL</b>.
     * @param {Pointer<Byte>} pbIV The address of a buffer that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">initialization vector</a> (IV) to use during decryption. The <i>cbIV</i> parameter contains the size of this buffer. This function will modify the contents of this buffer. If you need to reuse the IV later, make sure you make a copy of this buffer before calling this function.
     * 
     * This parameter is optional and can be <b>NULL</b> if no IV is used.
     * 
     *  The required size of the IV can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_BLOCK_LENGTH</b> property. This will provide the size of a block for the algorithm, which is also the size of the IV.
     * @param {Integer} cbIV The size, in bytes, of the <i>pbIV</i> buffer.
     * @param {Pointer<Byte>} pbOutput The address of a buffer to receive the plaintext produced by this function. The <i>cbOutput</i> parameter contains the size of this buffer. For more information, see Remarks.
     * 
     * If this parameter is <b>NULL</b>, the <b>BCryptDecrypt</b>  function calculates the size required for the plaintext of the encrypted data passed in the <i>pbInput</i> parameter. In this case, the location pointed to by the <i>pcbResult</i> parameter contains this size, and the function returns <b>STATUS_SUCCESS</b>.
     * 
     * If the values of both the <i>pbOutput</i> and <i>pbInput</i> parameters are <b>NULL</b>, an error is returned unless  an authenticated encryption algorithm is in use. In the latter case, the call is treated as an authenticated encryption call with zero length data, and the authentication tag, passed in the <i>pPaddingInfo</i> parameter, is verified.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer. This parameter is ignored if the <i>pbOutput</i> parameter is <b>NULL</b>.
     * @param {Pointer<UInt32>} pcbResult A pointer to a <b>ULONG</b> variable to receive the number of bytes copied to the <i>pbOutput</i> buffer. If <i>pbOutput</i> is <b>NULL</b>, this receives the size, in bytes, required for the plaintext.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. The allowed set of flags depends on the type of key specified by the <i>hKey</i> parameter.
     * 
     * 
     * If the key is a symmetric key, this can be zero or the following value. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_BLOCK_PADDING"></a><a id="bcrypt_block_padding"></a><dl>
     * <dt><b>BCRYPT_BLOCK_PADDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data was padded to the next block size when it was encrypted. If this flag was used with the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptencrypt">BCryptEncrypt</a> function, it must also be specified in this function. This flag must not be used with the authenticated encryption modes (AES-CCM and AES-GCM).
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_AUTH_TAG_MISMATCH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The computed authentication tag did not match the value supplied in the <i>pPaddingInfo</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size specified by the <i>cbOutput</i> parameter is not large enough to hold the ciphertext.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_BUFFER_SIZE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>cbInput</i> parameter is not a multiple of the algorithm's block size, and the <b>BCRYPT_BLOCK_PADDING</b> flag was not specified in the <i>dwFlags</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle in the <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm does not support decryption.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptdecrypt
     * @since windows6.0.6000
     */
    static BCryptDecrypt(hKey, pbInput, cbInput, pPaddingInfo, pbIV, cbIV, pbOutput, cbOutput, pcbResult, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptDecrypt", "ptr", hKey, "ptr", pbInput, "uint", cbInput, "ptr", pPaddingInfo, "ptr", pbIV, "uint", cbIV, "ptr", pbOutput, "uint", cbOutput, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Exports a key to a memory BLOB that can be persisted for later use.
     * @remarks
     * Depending on what processor modes a provider supports, <b>BCryptExportKey</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hKey</i> parameter must be derived from an algorithm handle returned by a provider that was opened with the <b>BCRYPT_PROV_DISPATCH</b> flag, and any pointers passed to the <b>BCryptExportKey</b> function must refer to nonpaged (or locked) memory.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} hKey The handle of the key to export.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} hExportKey The handle of the key with which to wrap the exported key. Use this parameter when exporting BLOBs of type <b>BCRYPT_AES_WRAP_KEY_BLOB</b>; otherwise, set it to <b>NULL</b>.<div class="alert"><b>Note</b>  The <i>hExportKey</i> handle must be supplied by the same provider that supplied the <i>hKey</i> handle, and <i>hExportKey</i> must be a handle to a symmetric key that can be used in the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Advanced Encryption Standard</a> (AES) key wrap algorithm. When the <i>hKey</i> handle is from the Microsoft provider, <i>hExportKey</i> must be an AES key handle.</div>
     * <div> </div>
     * 
     * 
     * <b>Windows Server 2008 and Windows Vista:  </b>This parameter is not used and should be set to <b>NULL</b>.
     * @param {Pointer<PWSTR>} pszBlobType 
     * @param {Pointer<Byte>} pbOutput The address of a buffer that receives the key BLOB. The <i>cbOutput</i> parameter contains the size of this buffer. If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the <b>ULONG</b> pointed to by the <i>pcbResult</i> parameter.
     * @param {Integer} cbOutput Contains the size, in bytes, of the <i>pbOutput</i> buffer.
     * @param {Pointer<UInt32>} pcbResult A pointer to a <b>ULONG</b> that receives the number of bytes that were copied to the <i>pbOutput</i> buffer. If the <i>pbOutput</i> parameter is <b>NULL</b>, this function will place the required size, in bytes, in the <b>ULONG</b> pointed to by this parameter.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are defined for this function.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size specified by the <i>cbOutput</i> parameter is not large enough to hold the ciphertext.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle in the <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified BLOB type is not supported by the provider.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptexportkey
     * @since windows6.0.6000
     */
    static BCryptExportKey(hKey, hExportKey, pszBlobType, pbOutput, cbOutput, pcbResult, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptExportKey", "ptr", hKey, "ptr", hExportKey, "ptr", pszBlobType, "ptr", pbOutput, "uint", cbOutput, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Imports a symmetric key from a key BLOB.
     * @remarks
     * Depending on what processor modes a provider supports, <b>BCryptImportKey</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hAlgorithm</i> parameter must have been opened by using the <b>BCRYPT_PROV_DISPATCH</b> flag, and any pointers passed to the <b>BCryptImportKey</b> function must refer to nonpaged (or locked) memory.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_ALG_HANDLE>} hAlgorithm The handle of the algorithm provider to import the key. This handle is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} hImportKey The handle of the key encryption key needed to unwrap the key BLOB in the <i>pbInput</i> parameter.<div class="alert"><b>Note</b>  The handle must be supplied by the same provider that supplied the key that is being imported.</div>
     * <div> </div>
     * 
     * 
     * <b>Windows Server 2008 and Windows Vista:  </b>This parameter is not used and should be set to <b>NULL</b>.
     * @param {Pointer<PWSTR>} pszBlobType 
     * @param {Pointer<BCRYPT_KEY_HANDLE>} phKey A pointer to a <b>BCRYPT_KEY_HANDLE</b> that receives the handle of the imported key. This handle is used in subsequent functions that require a key, such as <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptencrypt">BCryptEncrypt</a>. This handle must be released when it is no longer needed by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroykey">BCryptDestroyKey</a> function.
     * @param {Pointer<Byte>} pbKeyObject A pointer to a buffer that receives the imported key object. The <i>cbKeyObject</i> parameter contains the size of this buffer. The required size of this buffer can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_OBJECT_LENGTH</b> property. This will provide the size of the key object for the specified algorithm.
     * 
     * This memory can only be freed after the <i>phKey</i> key handle is destroyed.
     * @param {Integer} cbKeyObject The size, in bytes, of the <i>pbKeyObject</i> buffer.
     * @param {Pointer<Byte>} pbInput The address of a buffer that contains the key BLOB to import. The <i>cbInput</i> parameter contains the size of this buffer. The <i>pszBlobType</i> parameter specifies the type of key BLOB this buffer contains.
     * @param {Integer} cbInput The size, in bytes, of the <i>pbInput</i> buffer.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are currently defined, so this parameter should be zero.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of the key object specified by the <i>cbKeyObject</i> parameter is not large enough to hold the key object.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm handle in the <i>hAlgorithm</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm provider specified by the <i>hAlgorithm</i> parameter does not support the BLOB type specified by the <i>pszBlobType</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptimportkey
     * @since windows6.0.6000
     */
    static BCryptImportKey(hAlgorithm, hImportKey, pszBlobType, phKey, pbKeyObject, cbKeyObject, pbInput, cbInput, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptImportKey", "ptr", hAlgorithm, "ptr", hImportKey, "ptr", pszBlobType, "ptr", phKey, "ptr", pbKeyObject, "uint", cbKeyObject, "ptr", pbInput, "uint", cbInput, "uint", dwFlags, "int")
        return result
    }

    /**
     * Imports a public/private key pair from a key BLOB.
     * @remarks
     * Depending on what processor modes a provider supports, <b>BCryptImportKeyPair</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hAlgorithm</i> parameter must have been opened by using the <b>BCRYPT_PROV_DISPATCH</b> flag, and any pointers passed to the <b>BCryptImportKeyPair</b> function must refer to nonpaged (or locked) memory.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_ALG_HANDLE>} hAlgorithm The handle of the algorithm provider to import the key. This handle is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} hImportKey This parameter is not currently used and should be <b>NULL</b>.
     * @param {Pointer<PWSTR>} pszBlobType 
     * @param {Pointer<BCRYPT_KEY_HANDLE>} phKey A pointer to a <b>BCRYPT_KEY_HANDLE</b> that receives the handle of the imported key. This handle is used in subsequent functions that require a key, such as <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptsignhash">BCryptSignHash</a>. This handle must be released when it is no longer needed by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroykey">BCryptDestroyKey</a> function.
     * @param {Pointer<Byte>} pbInput The address of a buffer that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key BLOB</a> to import. The <i>cbInput</i> parameter contains the size of this buffer. The <i>pszBlobType</i> parameter specifies the type of key BLOB this buffer contains.
     * @param {Integer} cbInput The size, in bytes, of the <i>pbInput</i> buffer.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. This can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_NO_KEY_VALIDATION"></a><a id="bcrypt_no_key_validation"></a><dl>
     * <dt><b>BCRYPT_NO_KEY_VALIDATION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not validate the public portion of the key pair.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm handle in the <i>hAlgorithm</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm provider specified by the <i>hAlgorithm</i> parameter does not support the BLOB type specified by the <i>pszBlobType</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptimportkeypair
     * @since windows6.0.6000
     */
    static BCryptImportKeyPair(hAlgorithm, hImportKey, pszBlobType, phKey, pbInput, cbInput, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptImportKeyPair", "ptr", hAlgorithm, "ptr", hImportKey, "ptr", pszBlobType, "ptr", phKey, "ptr", pbInput, "uint", cbInput, "uint", dwFlags, "int")
        return result
    }

    /**
     * Creates a duplicate of a symmetric key.
     * @remarks
     * Depending on what processor modes a provider supports, <b>BCryptDuplicateKey</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hKey</i> parameter must be derived from an algorithm handle returned by a provider that was opened with the <b>BCRYPT_PROV_DISPATCH</b> flag, and any pointers passed to the <b>BCryptDuplicateKey</b> function must refer to nonpaged (or locked) memory.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} hKey The handle of the key to duplicate. This must be a handle to a symmetric key.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} phNewKey A pointer to a <b>BCRYPT_KEY_HANDLE</b> variable that receives the handle of the duplicate key. This handle is used in subsequent functions that require a key, such as <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptencrypt">BCryptEncrypt</a>. This handle must be released when it is no longer needed by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroykey">BCryptDestroyKey</a> function.
     * @param {Pointer<Byte>} pbKeyObject A pointer to a buffer that receives the duplicate key object. The <i>cbKeyObject</i> parameter contains the size of this buffer. The required size of this buffer can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_OBJECT_LENGTH</b> property. This will provide the size of the key object for the specified algorithm.
     * 
     * This memory can only be freed after the <i>phNewKey</i> key handle is destroyed.
     * @param {Integer} cbKeyObject The size, in bytes, of the <i>pbKeyObject</i> buffer.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are currently defined, so this parameter should be zero.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of the key object specified by the <i>cbKeyObject</i> parameter is not large enough to hold the key object.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle in the <i>hKey</i> parameter is not valid. This value is also returned if the key to duplicate is not a symmetric key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptduplicatekey
     * @since windows6.0.6000
     */
    static BCryptDuplicateKey(hKey, phNewKey, pbKeyObject, cbKeyObject, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptDuplicateKey", "ptr", hKey, "ptr", phNewKey, "ptr", pbKeyObject, "uint", cbKeyObject, "uint", dwFlags, "int")
        return result
    }

    /**
     * Completes a public/private key pair.
     * @remarks
     * Depending on what processor modes a provider supports, <b>BCryptFinalizeKeyPair</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hKey</i> parameter must be derived from an algorithm handle returned by a provider that was opened with the <b>BCRYPT_PROV_DISPATCH</b> flag.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} hKey The handle of the key to complete. This handle is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgeneratekeypair">BCryptGenerateKeyPair</a> function.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are currently defined, so this parameter should be zero.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle in the <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified provider does not support asymmetric key encryption.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptfinalizekeypair
     * @since windows6.0.6000
     */
    static BCryptFinalizeKeyPair(hKey, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptFinalizeKeyPair", "ptr", hKey, "uint", dwFlags, "int")
        return result
    }

    /**
     * Destroys a key.
     * @remarks
     * Depending on what processor modes a provider supports, <b>BCryptDestroyKey</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hKey</i> parameter must be derived from an algorithm handle returned by a provider that was opened with the <b>BCRYPT_PROV_DISPATCH</b> flag.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} hKey The handle of the key to destroy.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle in the <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptdestroykey
     * @since windows6.0.6000
     */
    static BCryptDestroyKey(hKey) {
        result := DllCall("bcrypt.dll\BCryptDestroyKey", "ptr", hKey, "int")
        return result
    }

    /**
     * Destroys a secret agreement handle that was created by using the BCryptSecretAgreement function.
     * @remarks
     * Depending on what processor modes a provider supports, <b>BCryptDestroySecret</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hSecret</i> parameter must be derived from an algorithm handle returned by a provider that was opened by using the <b>BCRYPT_PROV_DISPATCH</b> flag.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_SECRET_HANDLE>} hSecret The <b>BCRYPT_SECRET_HANDLE</b> to be destroyed.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hSecret</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptdestroysecret
     * @since windows6.0.6000
     */
    static BCryptDestroySecret(hSecret) {
        result := DllCall("bcrypt.dll\BCryptDestroySecret", "ptr", hSecret, "int")
        return result
    }

    /**
     * Creates a signature of a hash value. (BCryptSignHash)
     * @remarks
     * This function will encrypt the hash value with the specified key to create the signature.
     * 
     * To later verify that the signature is valid, call the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptverifysignature">BCryptVerifySignature</a> function with an identical key and an identical hash of the original data.
     * 
     * Depending on what processor modes a provider supports, <b>BCryptSignHash</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hKey</i> parameter must be derived from an algorithm handle returned by a provider that was opened with the <b>BCRYPT_PROV_DISPATCH</b> flag, and any pointers passed to the <b>BCryptSignHash</b> function must refer to nonpaged (or locked) memory.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} hKey The handle of the key to use to sign the hash.
     * @param {Pointer<Void>} pPaddingInfo A pointer to a structure that contains padding information. The actual type of structure this parameter points to depends on the value of the <i>dwFlags</i> parameter. This parameter is only used with asymmetric keys and must be <b>NULL</b> otherwise.
     * @param {Pointer<Byte>} pbInput A pointer to a buffer that contains the hash value to sign. The <i>cbInput</i> parameter contains the size of this buffer.
     * @param {Integer} cbInput The number of bytes in the <i>pbInput</i> buffer to sign.
     * @param {Pointer<Byte>} pbOutput The address of a buffer to receive the signature produced by this function. The <i>cbOutput</i> parameter contains the size of this buffer.
     * 
     * If this parameter is <b>NULL</b>, this function will calculate the size required for the signature and return the size in the location pointed to by the <i>pcbResult</i> parameter.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer. This parameter is ignored if the <i>pbOutput</i> parameter is <b>NULL</b>.
     * @param {Pointer<UInt32>} pcbResult A pointer to a <b>ULONG</b> variable that receives the number of bytes copied to the <i>pbOutput</i> buffer. 
     * 
     * If <i>pbOutput</i> is <b>NULL</b>, this receives the size, in bytes, required for the signature.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. The allowed set of flags depends on the type of key specified by the <i>hKey</i> parameter.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle specified by the <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm provider used to create the key handle specified by the <i>hKey</i> parameter is not a signing algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The memory size specified by the <i>cbOutput</i> parameter is not large enough to hold the signature.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptsignhash
     * @since windows6.0.6000
     */
    static BCryptSignHash(hKey, pPaddingInfo, pbInput, cbInput, pbOutput, cbOutput, pcbResult, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptSignHash", "ptr", hKey, "ptr", pPaddingInfo, "ptr", pbInput, "uint", cbInput, "ptr", pbOutput, "uint", cbOutput, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Verifies that the specified signature matches the specified hash. (BCryptVerifySignature)
     * @remarks
     * This function calculates the signature with provided key and then compares calculated signature value to the specified signature value.
     * 
     * To use this function, you must hash the data by using the same hashing algorithm that was used to create the hash value that was signed. If applicable, you must also specify the same padding scheme that was specified when the signature was created.
     * 
     * Depending on what processor modes a provider supports, <b>BCryptVerifySignature</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hKey</i> parameter must be derived from an algorithm handle returned by a provider that was opened by using the <b>BCRYPT_PROV_DISPATCH</b> flag, and any pointers passed to the <b>BCryptVerifySignature</b> function must refer to nonpaged (or locked) memory.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} hKey The handle of the key to use to decrypt the signature. This must be an identical key or the public key portion of the key pair used to sign the data with the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptsignhash">BCryptSignHash</a> function.
     * @param {Pointer<Void>} pPaddingInfo A pointer to a structure that contains padding information. The actual type of structure this parameter points to depends on the value of the <i>dwFlags</i> parameter. This parameter is only used with asymmetric keys and must be <b>NULL</b> otherwise.
     * @param {Pointer<Byte>} pbHash The address of a buffer that contains the hash of the data. The <i>cbHash</i> parameter contains the size of this buffer.
     * @param {Integer} cbHash The size, in bytes, of the <i>pbHash</i> buffer.
     * @param {Pointer<Byte>} pbSignature The address of a buffer that contains the signed hash of the data. The <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptsignhash">BCryptSignHash</a> function is used to create the signature. The <i>cbSignature</i> parameter contains the size of this buffer.
     * @param {Integer} cbSignature The size, in bytes, of the <i>pbSignature</i> buffer. The <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptsignhash">BCryptSignHash</a> function is used to create the signature.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. The allowed set of flags depends on the type of key specified by the <i>hKey</i> parameter.
     * 
     * If the key is a symmetric key, this parameter is not used and should be zero.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature was not verified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of supplied parameters is invalid.
     *  
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle specified by the <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm provider used to create the key handle specified by the <i>hKey</i> parameter is not a signing algorithm.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptverifysignature
     * @since windows6.0.6000
     */
    static BCryptVerifySignature(hKey, pPaddingInfo, pbHash, cbHash, pbSignature, cbSignature, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptVerifySignature", "ptr", hKey, "ptr", pPaddingInfo, "ptr", pbHash, "uint", cbHash, "ptr", pbSignature, "uint", cbSignature, "uint", dwFlags, "int")
        return result
    }

    /**
     * Creates a secret agreement value from a private and a public key. (BCryptSecretAgreement)
     * @remarks
     * Depending on what processor modes a provider supports, <b>BCryptSecretAgreement</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handles provided in the <i>hPrivKey</i> and <i>hPubKey</i>  parameters must be derived from an algorithm handle returned by a provider that was opened by using the <b>BCRYPT_PROV_DISPATCH</b> flag, and any pointers passed to the <b>BCryptSecretAgreement</b> function must refer to nonpaged (or locked) memory.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} hPrivKey The handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key</a> to use to create the secret agreement value. This key and the <i>hPubKey</i> key must come from the same CNG cryptographic algorithm provider.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} hPubKey The handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key</a> to use to create the secret agreement value. This key and the <i>hPrivKey</i> key must come from the same CNG cryptographic algorithm provider.
     * @param {Pointer<BCRYPT_SECRET_HANDLE>} phAgreedSecret A pointer to a <b>BCRYPT_SECRET_HANDLE</b> that receives a handle that represents the secret agreement value. This handle must be released by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroysecret">BCryptDestroySecret</a> function when it is no longer needed.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are defined for this function.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle in the <i>hPrivKey</i> or <i>hPubKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key handle in the <i>hPrivKey</i> parameter is not a Diffie-Hellman key.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptsecretagreement
     * @since windows6.0.6000
     */
    static BCryptSecretAgreement(hPrivKey, hPubKey, phAgreedSecret, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptSecretAgreement", "ptr", hPrivKey, "ptr", hPubKey, "ptr", phAgreedSecret, "uint", dwFlags, "int")
        return result
    }

    /**
     * Derives a key from a secret agreement value. (BCryptDeriveKey)
     * @remarks
     * The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa375370(v=vs.85)">BCryptBufferDesc</a> structure in the <i>pParameterList</i> parameter can contain more than one of the <b>KDF_SECRET_PREPEND</b> and <b>KDF_SECRET_APPEND</b> parameters. If more than one of these parameters is specified, the parameter values are concatenated in the order in which they are contained in the array before the KDF is called. For example, assume the following parameter values are specified.
     * 
     * 
     * ```cpp
     * BYTE pbValue0[1] = {0x01};
     * BYTE pbValue1[2] = {0x04, 0x05};
     * BYTE pbValue2[3] = {0x10, 0x11, 0x12};
     * BYTE pbValue3[4] = {0x20, 0x21, 0x22, 0x23};
     * 
     * Parameter[0].type = KDF_SECRET_APPEND
     * Parameter[0].value = pbValue0;
     * Parameter[0].length = sizeof  (pbValue0);
     * Parameter[1].type = KDF_SECRET_PREPEND
     * Parameter[1].value = pbValue1;
     * Parameter[1].length = sizeof (pbValue1);
     * Parameter[2].type = KDF_SECRET_APPEND
     * Parameter[2].value = pbValue2;
     * Parameter[2].length = sizeof (pbValue2);
     * Parameter[3].type = KDF_SECRET_PREPEND
     * Parameter[3].value = pbValue3;
     * Parameter[3].length = sizeof (pbValue3);
     * 
     * ```
     * 
     * 
     * If the above parameter values are specified, the concatenated values to the actual KDF are as follows.
     * 
     * 
     * ``` syntax
     * Type: KDF_SECRET_PREPEND
     * Value: {0x04, 0x05, 0x20, 0x21, 0x22, 0x23}, length 6
     * 
     * Type: KDF_SECRET_APPEND
     * Value: {0x01, 0x10, 0x11, 0x12}, length 4
     * 
     * ```
     * 
     * 
     * If the <i>pwszKDF</i> parameter is set to <b>BCRYPT_KDF_RAW_SECRET</b>, The returned secret (unlike the other <i>pwszKDF</i> values) will be encoded in little-endian format. It is important to take note of this when using the raw secret in any other CNG functions, as most of them take in big-endian encoded inputs.
     * 
     * 
     * Depending on what processor modes a provider supports, <b>BCryptDeriveKey</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hSharedSecret</i> parameter must be located in nonpaged (or locked) memory and must be derived from an algorithm handle returned by a provider that was opened by using the <b>BCRYPT_PROV_DISPATCH</b> flag.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_SECRET_HANDLE>} hSharedSecret The secret agreement handle to create the key from. This handle is obtained from the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptsecretagreement">BCryptSecretAgreement</a> function.
     * @param {Pointer<PWSTR>} pwszKDF A pointer to a null-terminated Unicode string that identifies the <i>key derivation function</i> (KDF) to use to derive the key. This can be one of the following strings.
     * @param {Pointer<BCryptBufferDesc>} pParameterList The address of a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa375370(v=vs.85)">BCryptBufferDesc</a> structure that contains the KDF parameters. This parameter is optional and can be <b>NULL</b> if it is not needed.
     * @param {Pointer<Byte>} pbDerivedKey The address of a buffer that receives the key. The <i>cbDerivedKey</i> parameter contains the size of this buffer. If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the <b>ULONG</b> pointed to by the <i>pcbResult</i> parameter.
     * @param {Integer} cbDerivedKey The size, in bytes, of the <i>pbDerivedKey</i> buffer.
     * @param {Pointer<UInt32>} pcbResult A pointer to a <b>ULONG</b> that receives the number of bytes that were copied to the <i>pbDerivedKey</i> buffer. If the <i>pbDerivedKey</i> parameter is <b>NULL</b>, this function will place the required size, in bytes, in the <b>ULONG</b> pointed to by this parameter.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. This can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="KDF_USE_SECRET_AS_HMAC_KEY_FLAG"></a><a id="kdf_use_secret_as_hmac_key_flag"></a><dl>
     * <dt><b>KDF_USE_SECRET_AS_HMAC_KEY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The secret agreement value will also serve as the HMAC key. If this flag is specified, the <b>KDF_HMAC_KEY</b> parameter should not be included in the set of parameters in the <i>pParameterList</i> parameter. This flag is only used by the <b>BCRYPT_KDF_HMAC</b> key derivation function.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INTERNAL_ERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal error occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hSharedSecret</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptderivekey
     * @since windows6.0.6000
     */
    static BCryptDeriveKey(hSharedSecret, pwszKDF, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptDeriveKey", "ptr", hSharedSecret, "ptr", pwszKDF, "ptr", pParameterList, "ptr", pbDerivedKey, "uint", cbDerivedKey, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Derives a key without requiring a secret agreement.
     * @remarks
     * You can use the following algorithm identifiers in the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function before calling <b>BCryptKeyDerivation</b>:
     * 
     * <ul>
     * <li><b>BCRYPT_CAPI_KDF_ALGORITHM</b></li>
     * <li><b>BCRYPT_SP800108_CTR_HMAC_ALGORITHM</b></li>
     * <li><b>BCRYPT_SP80056A_CONCAT_ALGORITHM</b></li>
     * <li><b>BCRYPT_PBKDF2_ALGORITHM</b></li>
     * </ul>
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} hKey Handle of the input key.
     * @param {Pointer<BCryptBufferDesc>} pParameterList Pointer to a  <b>BCryptBufferDesc</b> structure that contains the KDF parameters. This parameter is optional and can be <b>NULL</b> if it is not needed. 
     * The parameters can be specific to a key derivation function (KDF) or generic. The following table shows the required and optional parameters for specific KDFs implemented by the Microsoft Primitive provider.
     * 
     * <table>
     * <tr>
     * <th>KDF</th>
     * <th>Parameter</th>
     * <th>Required</th>
     * </tr>
     * <tr>
     * <td>SP800-108 HMAC in counter mode</td>
     * <td>KDF_LABEL</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_CONTEXT</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_HASH_ALGORITHM</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td>SP800-56A</td>
     * <td>KDF_ALGORITHMID</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_PARTYUINFO</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_PARTYVINFO</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_HASH_ALGORITHM</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_SUPPPUBINFO</td>
     * <td>no</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_SUPPPRIVINFO</td>
     * <td>no</td>
     * </tr>
     * <tr>
     * <td>PBKDF2</td>
     * <td>KDF_HASH_ALGORITHM</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_SALT</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_ITERATION_COUNT</td>
     * <td>no</td>
     * </tr>
     * <tr>
     * <td>CAPI_KDF</td>
     * <td>KDF_HASH_ALGORITHM</td>
     * <td>yes</td>
     * </tr>
     * </table>
     *  
     * 
     * The following generic parameter can be used:<ul>
     * <li>KDF_GENERIC_PARAMETER</li>
     * </ul>Generic parameters map to KDF specific parameters in the following manner:
     * 
     * SP800-108 HMAC in counter mode:<ul>
     * <li>KDF_GENERIC_PARAMETER = KDF_LABEL||0x00||KDF_CONTEXT</li>
     * </ul>
     * 
     * 
     * SP800-56A<ul>
     * <li>KDF_GENERIC_PARAMETER = KDF_ALGORITHMID || KDF_PARTYUINFO || KDF_PARTYVINFO {|| KDF_SUPPPUBINFO } {|| KDF_SUPPPRIVINFO }</li>
     * </ul>
     * 
     * 
     * PBKDF2<ul>
     * <li>KDF_GENERIC_PARAMETER = KDF_SALT </li>
     * <li>KDF_ITERATION_COUNT – defaults to 10000</li>
     * </ul>
     * 
     * 
     * CAPI_KDF<ul>
     * <li>KDF_GENERIC_PARAMETER = Not Used </li>
     * </ul>
     * @param {Pointer<Byte>} pbDerivedKey Address of a buffer that receives the key. The <i>cbDerivedKey</i> parameter contains the size of this buffer.
     * @param {Integer} cbDerivedKey Size, in bytes, of the buffer pointed to by the <i>pbDerivedKey</i> parameter.
     * @param {Pointer<UInt32>} pcbResult Pointer to a variable that receives the number of bytes that were copied to the buffer pointed to by the <i>pbDerivedKey</i> parameter.
     * @param {Integer} dwFlags Flags that modify the behavior of this function. The following value can be used with the Microsoft Primitive provider.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>BCRYPT_CAPI_AES_FLAG</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies that the target algorithm is AES and that the key therefore must be double expanded.
     * This flag is only valid with the CAPI_KDF algorithm.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptkeyderivation
     * @since windows8.0
     */
    static BCryptKeyDerivation(hKey, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptKeyDerivation", "ptr", hKey, "ptr", pParameterList, "ptr", pbDerivedKey, "uint", cbDerivedKey, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Called to create a hash or Message Authentication Code (MAC) object.
     * @remarks
     * Depending on what processor modes a provider supports, <b>BCryptCreateHash</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hAlgorithm</i> parameter must have been opened by using the <b>BCRYPT_PROV_DISPATCH</b> flag, and any pointers passed to the <b>BCryptCreateHash</b> function must refer to nonpaged (or locked) memory.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). For more information, see <a href="https://www.microsoft.com/?ref=go">WDK and Developer Tools</a>.<b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_ALG_HANDLE>} hAlgorithm The handle of an algorithm provider created by using the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function. The algorithm that was specified when the provider was created must support the hash interface.
     * @param {Pointer<BCRYPT_HASH_HANDLE>} phHash A pointer to a <b>BCRYPT_HASH_HANDLE</b> value that receives a handle that represents the hash or MAC object. This handle is used in subsequent hashing or MAC functions, such as the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcrypthashdata">BCryptHashData</a> function. When you have finished using this handle, release it by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroyhash">BCryptDestroyHash</a> function.
     * @param {Pointer<Byte>} pbHashObject A pointer to a buffer that receives the hash or MAC object. The <i>cbHashObject</i> parameter contains the size of this buffer. The required size of this buffer can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_OBJECT_LENGTH</b> property. This will provide the size of the hash or MAC object for the specified algorithm.
     * 
     * This memory can only be freed after the handle pointed to by the <i>phHash</i> parameter is destroyed.
     * 
     * If the value of this parameter is <b>NULL</b> and the value of the <i>cbHashObject</i> parameter is zero, the memory for the hash object is allocated and freed by this function. <b>Windows 7:</b> This memory management functionality is available beginning with Windows 7.
     * @param {Integer} cbHashObject The size, in bytes, of the <i>pbHashObject</i> buffer.
     * 
     * If the value of this parameter is zero and the value of the <i>pbHashObject</i> parameter is <b>NULL</b>, the memory for the key object is allocated and freed by this function. <b>Windows 7:</b> This memory management functionality is available beginning with Windows 7.</p>
     * @param {Pointer<Byte>} pbSecret A pointer to a buffer that contains the key to use for the hash or MAC. The <i>cbSecret</i> parameter contains the size of this buffer. This key only applies to hash algorithms opened by the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function by using the <b>BCRYPT_ALG_HANDLE_HMAC</b> flag.  Otherwise, set this parameter to <b>NULL</b>.
     * @param {Integer} cbSecret The size, in bytes, of the <i>pbSecret</i> buffer. If no key is used, set this parameter to zero.
     * @param {Integer} dwFlags Flags that modify the behavior of the function. This can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_HASH_REUSABLE_FLAG"></a><a id="bcrypt_hash_reusable_flag"></a><dl>
     * <dt><b>BCRYPT_HASH_REUSABLE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Creates a reusable hashing object. The object can be used for a new hashing operation immediately after calling <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfinishhash">BCryptFinishHash</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecCNG/creating-a-hash-with-cng">Creating a Hash with CNG</a>.
     * 
     * <b>Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  </b>This flag is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of the hash object specified by the <i>cbHashObject</i> parameter is not large enough to hold the hash object.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm handle in the <i>hAlgorithm</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm provider specified by the <i>hAlgorithm</i> parameter does not support the hash interface.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptcreatehash
     * @since windows6.0.6000
     */
    static BCryptCreateHash(hAlgorithm, phHash, pbHashObject, cbHashObject, pbSecret, cbSecret, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptCreateHash", "ptr", hAlgorithm, "ptr", phHash, "ptr", pbHashObject, "uint", cbHashObject, "ptr", pbSecret, "uint", cbSecret, "uint", dwFlags, "int")
        return result
    }

    /**
     * Performs a one way hash or Message Authentication Code (MAC) on a data buffer.
     * @remarks
     * To combine more than one buffer into the hash or MAC, you can call this function multiple times, passing a different buffer each time. To obtain the hash or MAC value, call the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfinishhash">BCryptFinishHash</a> function. After the <b>BCryptFinishHash</b> function has been called for a specified  handle, that handle cannot be reused.
     * 
     * Depending on what processor modes a provider supports, <b>BCryptHashData</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hHash</i> parameter must be derived from an algorithm handle returned by a provider that was opened by using the <b>BCRYPT_PROV_DISPATCH</b> flag, and any pointers passed to the <b>BCryptHashData</b> function must refer to nonpaged (or locked) memory.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_HASH_HANDLE>} hHash The handle of the hash or MAC object to use to perform the operation. This handle is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptcreatehash">BCryptCreateHash</a> function.
     * @param {Pointer<Byte>} pbInput A pointer to a buffer that contains the data to process. The <i>cbInput</i> parameter contains the number of bytes in this buffer. This function does not modify the contents of this buffer.
     * @param {Integer} cbInput The number of bytes in the <i>pbInput</i> buffer.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are currently defined, so this parameter should be zero.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash handle in the <i>hHash</i> parameter is not valid. After the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfinishhash">BCryptFinishHash</a> function has been called for a hash  handle, that handle cannot be reused.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcrypthashdata
     * @since windows6.0.6000
     */
    static BCryptHashData(hHash, pbInput, cbInput, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptHashData", "ptr", hHash, "ptr", pbInput, "uint", cbInput, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves the hash or Message Authentication Code (MAC) value for the data accumulated from prior calls to BCryptHashData.
     * @remarks
     * Depending on what processor modes a provider supports, <b>BCryptFinishHash</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hHash</i> parameter must be derived from an algorithm handle returned by a provider that was opened by using the <b>BCRYPT_PROV_DISPATCH</b> flag, and any pointers passed to the <b>BCryptFinishHash</b> function must refer to nonpaged (or locked) memory.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_HASH_HANDLE>} hHash The handle of the hash or MAC object to use to compute the hash or MAC. This handle is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptcreatehash">BCryptCreateHash</a> function. After this function has been called, the hash handle passed to this function cannot be used again except in a call to <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroyhash">BCryptDestroyHash</a>.
     * @param {Pointer<Byte>} pbOutput A pointer to a buffer that receives the hash or MAC value. The <i>cbOutput</i> parameter contains the size of this buffer.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer. This size must exactly match the size of the hash or MAC value.
     * 
     * The size can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_HASH_LENGTH</b> property. This will provide the size of the hash or MAC value for the specified algorithm.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are currently defined, so this parameter should be zero.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash handle in the <i>hHash</i> parameter is not valid. After the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfinishhash">BCryptFinishHash</a> function has been called for a hash  handle, that handle cannot be reused.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid. This includes the case where <i>cbOutput</i> is not the same size as the hash.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptfinishhash
     * @since windows6.0.6000
     */
    static BCryptFinishHash(hHash, pbOutput, cbOutput, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptFinishHash", "ptr", hHash, "ptr", pbOutput, "uint", cbOutput, "uint", dwFlags, "int")
        return result
    }

    /**
     * The BCryptCreateMultiHash function creates a multi-hash state that allows for the parallel computation of multiple hash operations.
     * @remarks
     * Internally, parallel hash computations are done using single-instruction multiple-data (SIMD) instructions with up to 8 parallel computations at a time, depending on the hash algorithm and the CPU features available. To maximize performance, we recommend that the caller provide at least eight computations that can be processed in parallel.
     * 
     * For computations of unequal length, providing more computations in parallel allows the implementation to schedule the computations better across the CPU registers. This can provide a throughput benefit. For optimal throughput, we recommend that the caller provide between eight and 100 computations. Select a lower value in that range only if all the hash computations are the same length.
     * 
     * Multi-hashing is not supported for HMAC-MD2, HMAC-MD4, and GMAC.
     * @param {Pointer<BCRYPT_ALG_HANDLE>} hAlgorithm *BCRYPT_ALG_HANDLE* `[in, out]`
     * 
     * The algorithm handle used for all of the hash states in the multi-hash array. The algorithm handle must have been opened with the **BCYRPT_MULTI_FLAG** passed to the [BCryptOpenAlgorithmProvider](nf-bcrypt-bcryptopenalgorithmprovider.md) function. Alternatively, the caller can use the pseudo-handles.
     * @param {Pointer<BCRYPT_HASH_HANDLE>} phHash *BCRYPT_HASH_HANDLE** `[out]`
     * 
     * A pointer to a **BCRYPT_HASH_HANDLE** value that receives a handle that represents the multi-hash state. This handle is used in subsequent operations such as [BCryptProcessMultiOperations](nf-bcrypt-bcryptprocessmultioperations.md). When you have finished using this handle, release it by passing it to the [BCryptDestroyHash](nf-bcrypt-bcryptdestroyhash.md) function.
     * @param {Integer} nHashes *ULONG* `[in]`
     * 
     * The number of elements in the array. The multi-hash state that this function creates is able to perform parallel computations on *nHashes* different hash states.
     * @param {Pointer<Byte>} pbHashObject *PUCHAR* `[out]`
     * 
     * A pointer to a buffer that receives the multi-hash state.
     * 
     * The size can be calculated from the **cbPerObject** and **cbPerElement** members of the [BCRYPT_MULTI_OBJECT_LENGTH_STRUCT](ns-bcrypt-bcrypt_multi_object_length_struct.md) structure. The value is the following: `cbPerObject + (number of hash states) * cbPerElement`.
     * 
     * If *pbHashObject* is `NULL` and *cbHashObject* has a value of zero (`0`), the object buffer is automatically allocated.
     * @param {Integer} cbHashObject *ULONG* `[in]`
     * 
     * The size of the *pbHashObject* buffer, or zero (`0`) if *pbHashObject* is `NULL`.
     * @param {Pointer<Byte>} pbSecret *PUCHAR* `[in]`
     * 
     * A pointer to a buffer that contains the key to use for the hash or MAC. The *cbSecret* parameter contains the size of this buffer. This key only applies to hash algorithms opened by the [BCryptOpenAlgorithmProvider](nf-bcrypt-bcryptopenalgorithmprovider.md) function by using the **BCRYPT_ALG_HANDLE_HMAC** flag. Otherwise, set this parameter to `NULL`.
     * 
     * The same key is used for all elements of the array.
     * @param {Integer} cbSecret *ULONG* `[in]`
     * 
     * The size, in bytes, of the *pbSecret* buffer. If no key is used, set this parameter to zero (`0`).
     * @param {Integer} dwFlags *ULONG* `[in]`
     * 
     * Flags that modify the behavior of the function. This can be zero or the values below. Multi-hash objects are always reusable and always behave as if the **BCRYPT_HASH_REUSABLE_FLAG** was passed. This flag is supported here for consistency.
     * 
     * | Value | Meaning |
     * |--------|--------|
     * | **BCRYPT_HASH_REUSABLE_FLAG** | Creates a reusable hashing object. The object can be used for a new hashing operation immediately after calling [BCryptFinishHash](nf-bcrypt-bcryptfinishhash.md). For more information, see [Creating a Hash with CNG](/windows/win32/SecCNG/creating-a-hash-with-cng). |
     * @returns {Integer} Returns a status code that indicates the success or failure of the function. If the method succeeds, it will return `STATUS_SUCCESS`. For other **NTSTATUS** values, see [NTSTATUS Values](/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55).
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptcreatemultihash
     * @since windows8.1
     */
    static BCryptCreateMultiHash(hAlgorithm, phHash, nHashes, pbHashObject, cbHashObject, pbSecret, cbSecret, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptCreateMultiHash", "ptr", hAlgorithm, "ptr", phHash, "uint", nHashes, "ptr", pbHashObject, "uint", cbHashObject, "ptr", pbSecret, "uint", cbSecret, "uint", dwFlags, "int")
        return result
    }

    /**
     * The BCryptProcessMultiOperations function processes a sequence of operations on a multi-object state.
     * @remarks
     * Each element of the *pOperations* array contains instructions for a particular computation to be performed on a single element of the multi-object state. The functional behavior of **BCryptProcessMultiOperations** is equivalent to performing, for each element in the multi-object state, the computations specified in the operations array for that element, one at a time, in order.
     * 
     * The relative order of two operations that operate on different elements of the array is not guaranteed. If an output buffer overlaps an input or output buffer the result is not deterministic.
     * @param {Pointer<BCRYPT_HANDLE>} hObject *BCRYPT_HANDLE* `[in, out]`
     * 
     * A handle to a multi-object state, such as one created by the [BCryptCreateMultiHash](nf-bcrypt-bcryptcreatemultihash.md) function.
     * @param {Integer} operationType *BCRYPT_MULTI_OPERATION_TYPE* `[in]`
     * 
     * One of the **BCRYPT_OPERATION_TYPE_**\* values. Currently the only defined value is **BCRYPT_OPERATION_TYPE_HASH**. This value identifies the *hObject* parameter as a multi-hash object and the *pOperations* pointer as pointing to an array of [BCRYPT_MULTI_HASH_OPERATION](ns-bcrypt-bcrypt_multi_hash_operation.md) elements.
     * @param {Pointer<Void>} pOperations *PVOID* `[in]`
     * 
     * A pointer to an array of operation command structures. For hashing, it is a pointer to an array of [BCRYPT_MULTI_HASH_OPERATION](ns-bcrypt-bcrypt_multi_hash_operation.md) structures.
     * @param {Integer} cbOperations *ULONG* `[in]`
     * 
     * The size, in bytes, of the *pOperations* array.
     * @param {Integer} dwFlags *ULONG* `[in]`
     * 
     * Specify a value of zero (`0`).
     * @returns {Integer} Returns a status code that indicates the success or failure of the function. If the method succeeds, it will return `STATUS_SUCCESS`. For other **NTSTATUS** values, see [NTSTATUS Values](/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55).
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptprocessmultioperations
     * @since windows8.1
     */
    static BCryptProcessMultiOperations(hObject, operationType, pOperations, cbOperations, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptProcessMultiOperations", "ptr", hObject, "int", operationType, "ptr", pOperations, "uint", cbOperations, "uint", dwFlags, "int")
        return result
    }

    /**
     * Duplicates an existing hash or Message Authentication Code (MAC) object.
     * @remarks
     * This function is useful when computing a hash or MAC over a block of common data. After the common data has been processed, the hash or MAC object can be duplicated, and then the unique data can be added to the individual objects.
     * 
     * Depending on what processor modes a provider supports, <b>BCryptDuplicateHash</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hHash</i> parameter must be derived from an algorithm handle returned by a provider that was opened by using the <b>BCRYPT_PROV_DISPATCH</b> flag, and any pointers passed to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroykey">BCryptDestroyKey</a> function must refer to nonpaged (or locked) memory.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_HASH_HANDLE>} hHash The handle of the hash or MAC object to duplicate.
     * @param {Pointer<BCRYPT_HASH_HANDLE>} phNewHash A pointer to a <b>BCRYPT_HASH_HANDLE</b> value that receives the handle that represents the duplicate hash or MAC object.
     * @param {Pointer<Byte>} pbHashObject A pointer to a buffer that receives the duplicate hash or MAC object. The <i>cbHashObject</i> parameter contains the size of this buffer. The required size of this buffer can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_OBJECT_LENGTH</b> property. This will provide the size of the hash object for the specified algorithm.
     * 
     * When the duplicate hash handle is released, free this memory.
     * @param {Integer} cbHashObject The size, in bytes, of the <i>pbHashObject</i> buffer.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are currently defined, so this parameter should be zero.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size of the hash object specified by the <i>cbHashObject</i> parameter is not large enough to hold the hash object.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash handle in the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptduplicatehash
     * @since windows6.0.6000
     */
    static BCryptDuplicateHash(hHash, phNewHash, pbHashObject, cbHashObject, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptDuplicateHash", "ptr", hHash, "ptr", phNewHash, "ptr", pbHashObject, "uint", cbHashObject, "uint", dwFlags, "int")
        return result
    }

    /**
     * Destroys a hash or Message Authentication Code (MAC) object.
     * @remarks
     * Depending on what processor modes a provider supports, <b>BCryptDestroyHash</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hHash</i> parameter must be derived from an algorithm handle returned by a provider that was opened by using the <b>BCRYPT_PROV_DISPATCH</b> flag.
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_HASH_HANDLE>} hHash The handle of the hash or MAC object to destroy. This handle is obtained by using the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptcreatehash">BCryptCreateHash</a> function.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm handle in the <i>hHash</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptdestroyhash
     * @since windows6.0.6000
     */
    static BCryptDestroyHash(hHash) {
        result := DllCall("bcrypt.dll\BCryptDestroyHash", "ptr", hHash, "int")
        return result
    }

    /**
     * Performs a single hash computation. This is a convenience function that wraps calls to BCryptCreateHash, BCryptHashData, BCryptFinishHash, and BCryptDestroyHash.
     * @param {Pointer<BCRYPT_ALG_HANDLE>} hAlgorithm The handle of an algorithm provider created by using the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function. The algorithm that was specified when the provider was created must support the hash interface.
     * @param {Pointer<Byte>} pbSecret A pointer to a buffer that contains the key to use for the hash or MAC. The <i>cbSecret</i> parameter contains the size of this buffer. This key only applies to hash algorithms opened by the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function by using the <b>BCRYPT_ALG_HANDLE_HMAC</b> flag.  Otherwise, set this parameter to <b>NULL</b>
     * @param {Integer} cbSecret The size, in bytes, of the <i>pbSecret</i> buffer. If no key is used, set this parameter to zero.
     * @param {Pointer<Byte>} pbInput A pointer to a buffer that contains the data to process. The <i>cbInput</i> parameter contains the number of bytes in this buffer. This function does not modify the contents of this buffer.
     * @param {Integer} cbInput The number of bytes in the <i>pbInput</i> buffer.
     * @param {Pointer<Byte>} pbOutput A pointer to a buffer that receives the hash or MAC value. The <i>cbOutput</i> parameter contains the size of this buffer.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer. This size must exactly match the size of the hash or MAC value.
     * 
     * The size can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a> function to get the <b>BCRYPT_HASH_LENGTH</b> property. This will provide the size of the hash or MAC value for the specified algorithm.
     * @returns {Integer} A status code indicating success or failure.
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcrypthash
     * @since windows10.0.10240
     */
    static BCryptHash(hAlgorithm, pbSecret, cbSecret, pbInput, cbInput, pbOutput, cbOutput) {
        result := DllCall("bcrypt.dll\BCryptHash", "ptr", hAlgorithm, "ptr", pbSecret, "uint", cbSecret, "ptr", pbInput, "uint", cbInput, "ptr", pbOutput, "uint", cbOutput, "int")
        return result
    }

    /**
     * Generates a random number.
     * @remarks
     * The default random number provider implements an algorithm for generating random numbers that complies with the NIST SP800-90 standard, specifically the  CTR_DRBG portion of that standard.
     * 
     * <b>Windows Vista:  </b>Prior to Windows Vista with Service Pack 1 (SP1) the default random number provider implements an algorithm for generating random numbers that complies with the FIPS 186-2 standard. 
     * 
     * Depending on what processor modes a provider supports, <b>BCryptGenRandom</b> can be called either from user mode or kernel mode. Kernel mode callers can execute either at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a> or <b>DISPATCH_LEVEL</b> IRQL. If the current IRQL level is <b>DISPATCH_LEVEL</b>, the handle provided in the <i>hAlgorithm</i> parameter must have been opened by using the <b>BCRYPT_PROV_DISPATCH</b> flag, and any pointers passed to the <b>BCryptGenRandom</b> function must refer to nonpaged (or locked) memory.<b>Windows Vista:  </b>The Microsoft provider does not support calling at <b>DISPATCH_LEVEL</b>.
     * 
     * 
     * 
     * To call this function in kernel mode, use Cng.lib, which is part of the Driver Development Kit (DDK). <b>Windows Server 2008 and Windows Vista:  </b>To call this function in kernel mode, use Ksecdd.lib.
     * @param {Pointer<BCRYPT_ALG_HANDLE>} hAlgorithm The handle of an algorithm provider created by using the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a> function. The algorithm that was specified when the provider was created must support the random number generator interface.
     * @param {Pointer<Byte>} pbBuffer The address of a buffer that receives the random number. The size of this buffer is specified by the <i>cbBuffer</i> parameter.
     * @param {Integer} cbBuffer The size, in bytes, of the <i>pbBuffer</i> buffer.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. This parameter can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_RNG_USE_ENTROPY_IN_BUFFER"></a><a id="bcrypt_rng_use_entropy_in_buffer"></a><dl>
     * <dt><b>BCRYPT_RNG_USE_ENTROPY_IN_BUFFER</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This function will use the number in the <i>pbBuffer</i> buffer as additional entropy for the random number. If this flag is not specified, this function will use a random number for the entropy.
     * 
     * <b>Windows 8 and later:  </b>This flag is ignored in  Windows 8 and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_USE_SYSTEM_PREFERRED_RNG"></a><a id="bcrypt_use_system_preferred_rng"></a><dl>
     * <dt><b>BCRYPT_USE_SYSTEM_PREFERRED_RNG</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the system-preferred random number generator algorithm. The <i>hAlgorithm</i> parameter must be <b>NULL</b>.
     * 
     * BCRYPT_USE_SYSTEM_PREFERRED_RNG is only supported at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a>. For more information, see Remarks.
     * 
     * <b>Windows Vista:  </b>This flag is not supported without SP2.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hAlgorithm</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom
     * @since windows6.0.6000
     */
    static BCryptGenRandom(hAlgorithm, pbBuffer, cbBuffer, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptGenRandom", "ptr", hAlgorithm, "ptr", pbBuffer, "uint", cbBuffer, "uint", dwFlags, "int")
        return result
    }

    /**
     * Derives a key from a hash value.
     * @remarks
     * This function does not support the PK salt functionality of the CAPI <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptderivekey">CryptDeriveKey</a> function.
     * @param {Pointer<BCRYPT_HASH_HANDLE>} hHash The handle of the hash object. The handle is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptcreatehash">BCryptCreateHash</a> function. When you have finished using the handle, you must free it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroyhash">BCryptDestroyHash</a> function.
     * @param {Pointer<BCRYPT_ALG_HANDLE>} hTargetAlg The handle of the algorithm object.  This can be an <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> value that is compatible with the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptderivekey">CryptDeriveKey</a> function.
     * 
     * <div class="alert"><b>Note</b>  Limitations in CAPI and key expansion prevent the use of any hash algorithm that generates an output that is larger than 512 bits.</div>
     * <div> </div>
     * @param {Pointer<Byte>} pbDerivedKey A pointer to the buffer that receives the derived key.
     * @param {Integer} cbDerivedKey The size, in characters, of the derived key pointed to by the <i>pbDerivedKey</i> parameter.
     * @param {Integer} dwFlags This parameter is reserved and must be set to zero.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hHash</i> or  <i>hTargetAlg</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value in  the <i>cbDerivedKey</i> parameter is larger than twice the output size of the hash function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     *  
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptderivekeycapi
     * @since windows6.1
     */
    static BCryptDeriveKeyCapi(hHash, hTargetAlg, pbDerivedKey, cbDerivedKey, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptDeriveKeyCapi", "ptr", hHash, "ptr", hTargetAlg, "ptr", pbDerivedKey, "uint", cbDerivedKey, "uint", dwFlags, "int")
        return result
    }

    /**
     * Derives a key from a hash value by using the PBKDF2 key derivation algorithm as defined by RFC 2898.
     * @param {Pointer<BCRYPT_ALG_HANDLE>} hPrf The handle of an algorithm provider that provides the pseudo-random function. This should be an algorithm provider that performs a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">Message Authentication Code</a> computation. When you use the default Microsoft algorithm provider, any <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hashing algorithm</a> opened by using the  <b>BCRYPT_ALG_HANDLE_HMAC_FLAG</b> flag can be used.
     * 
     * <div class="alert"><b>Note</b>  Only algorithms that implement the BCRYPT_IS_KEYED_HASH  property can be used to populate this parameter.</div>
     * <div> </div>
     * @param {Pointer<Byte>} pbPassword A pointer to a buffer that contains the password parameter for the PBKDF2 key derivation algorithm. <div class="alert"><b>Note</b>  Any secret information used in the key derivation should be passed in this buffer.</div>
     * <div> </div>
     * @param {Integer} cbPassword The length, in bytes, of the data in the buffer pointed to by the <i>pbPassword</i> parameter.
     * @param {Pointer<Byte>} pbSalt A pointer to a buffer that contains the salt argument  for the PBKDF2 key derivation algorithm.
     * 
     * <div class="alert"><b>Note</b>  Any information that is not secret and that is used in the key derivation should be passed in this buffer.</div>
     * <div> </div>
     * @param {Integer} cbSalt The length, in bytes, of the salt argument pointed to by the <i>pbSalt</i> parameter.
     * @param {Integer} cIterations The iteration count for the PBKDF2 key derivation algorithm.
     * @param {Pointer<Byte>} pbDerivedKey A pointer to a buffer that receives the derived key.
     * @param {Integer} cbDerivedKey The length, in bytes, of the derived key returned in the buffer pointed to by the <i>pbDerivedKey</i> parameter.
     * @param {Integer} dwFlags This parameter is reserved and must be set to zero.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hPrf</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     *  
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptderivekeypbkdf2
     * @since windows6.1
     */
    static BCryptDeriveKeyPBKDF2(hPrf, pbPassword, cbPassword, pbSalt, cbSalt, cIterations, pbDerivedKey, cbDerivedKey, dwFlags) {
        result := DllCall("bcrypt.dll\BCryptDeriveKeyPBKDF2", "ptr", hPrf, "ptr", pbPassword, "uint", cbPassword, "ptr", pbSalt, "uint", cbSalt, "uint", cIterations, "ptr", pbDerivedKey, "uint", cbDerivedKey, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves information about a CNG provider.
     * @remarks
     * <b>BCryptQueryProviderRegistration</b> can be called only in user mode.
     * @param {Pointer<PWSTR>} pszProvider A pointer to a null-terminated Unicode string that contains the name of the provider to obtain information about.
     * @param {Integer} dwMode 
     * @param {Integer} dwInterface 
     * @param {Pointer<UInt32>} pcbBuffer A pointer to a <b>ULONG</b> value that, on entry, contains the size, in bytes, of the buffer pointed to by the <i>ppBuffer</i> parameter. On exit, this value receives either the number of bytes copied to the buffer or the required size, in bytes, of the buffer.
     * 
     * 
     * <div class="alert"><b>Note</b>  This is the total size, in bytes, of the entire buffer, not just the size of the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_provider_reg">CRYPT_PROVIDER_REG</a> structure. The buffer must be able to hold other data for the providers in addition to the <b>CRYPT_PROVIDER_REG</b> structure.</div>
     * <div> </div>
     * @param {Pointer<CRYPT_PROVIDER_REG>} ppBuffer A pointer to a buffer pointer that receives a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_provider_reg">CRYPT_PROVIDER_REG</a> structure and other data that describes the provider.
     * 
     * If this parameter is <b>NULL</b>, this function will return <b>STATUS_BUFFER_TOO_SMALL</b> and place in the value pointed to by the <i>pcbBuffer</i> parameter, the required size, in bytes, of all data.
     * 
     * If this parameter is the address of a <b>NULL</b> pointer, this function will allocate the required memory, fill it in with the provider information, and place a pointer to this memory in this parameter. When you have finished using this memory, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is the address of a non-<b>NULL</b> pointer, this function will copy the provider information into this buffer. The <i>pcbBuffer</i> parameter must contain the size, in bytes, of the entire buffer. If the buffer is not large enough to hold all of the provider information, this function will return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size specified by the <i>pcbBuffer</i> parameter is not large enough to hold all of the data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No provider could be found that matches the specified criteria.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptqueryproviderregistration
     * @since windows6.0.6000
     */
    static BCryptQueryProviderRegistration(pszProvider, dwMode, dwInterface, pcbBuffer, ppBuffer) {
        result := DllCall("bcrypt.dll\BCryptQueryProviderRegistration", "ptr", pszProvider, "uint", dwMode, "uint", dwInterface, "ptr", pcbBuffer, "ptr", ppBuffer, "int")
        return result
    }

    /**
     * Retrieves information about the registered providers.
     * @remarks
     * The <b>BCryptEnumRegisteredProviders</b> function can be called in one of two ways:
     * 
     * <ul>
     * <li>
     * The first is to have the <b>BCryptEnumRegisteredProviders</b> function allocate the memory. This is accomplished by passing the address of a <b>NULL</b> pointer for the <i>ppBuffer</i> parameter.
     * 
     * The following example shows how to use the <b>BCryptEnumRegisteredProviders</b> function to allocate memory by passing the address of a <b>NULL</b> pointer for the <i>ppBuffer</i> parameter.
     * 
     * 
     * ```cpp
     * PCRYPT_PROVIDERS pBuffer = NULL;
     * BCryptEnumRegisteredProviders(//..., &pBuffer);
     * 
     * 
     * ```
     * 
     * 
     * This code will allocate the memory required for the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_providers">CRYPT_PROVIDERS</a> structure and the associated strings. When the <b>BCryptEnumRegisteredProviders</b> function is used in this manner, you must free the memory when it is no longer needed by passing <i>ppBuffer</i> to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * </li>
     * <li>The second method is to allocate the required memory yourself. This is accomplished by calling the <b>BCryptEnumRegisteredProviders</b> function with <b>NULL</b> for the <i>ppBuffer</i> parameter. The <b>BCryptEnumRegisteredProviders</b> function will place in the value pointed to by the <i>pcbBuffer</i> parameter, the required size, in bytes, of the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_providers">CRYPT_PROVIDERS</a> structure and all strings. You then allocate the required memory and pass the address of this buffer pointer for the <i>ppBuffer</i> parameter in a second call to the <b>BCryptEnumRegisteredProviders</b> function.</li>
     * </ul>
     * 
     * 
     * <b>BCryptEnumRegisteredProviders</b> can be called only in user mode.
     * @param {Pointer<UInt32>} pcbBuffer A pointer to a <b>ULONG</b> value that, on entry, contains the size, in bytes, of the buffer pointed to by the <i>ppBuffer</i> parameter. On exit, this value receives either the number of bytes copied to the buffer or the required size, in bytes, of the buffer.
     * 
     * <div class="alert"><b>Note</b>  This is the total size, in bytes, of the entire buffer, not just the size of the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_providers">CRYPT_PROVIDERS</a> structure. The buffer must be able to hold other data for the providers in addition to the <b>CRYPT_PROVIDERS</b> structure.</div>
     * <div> </div>
     * @param {Pointer<CRYPT_PROVIDERS>} ppBuffer A pointer to a buffer pointer that receives a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_providers">CRYPT_PROVIDERS</a> structure and other data that describes the collection of registered providers.
     * 
     * If this parameter is <b>NULL</b>, this function will return <b>STATUS_BUFFER_TOO_SMALL</b> and place in the value pointed to by the <i>pcbBuffer</i> parameter, the required size, in bytes, of all the data.
     * 
     * If this parameter is the address of a <b>NULL</b> pointer, this function will allocate the required memory, fill the memory with the information about the providers, and place the pointer to this memory in this parameter. When you have finished using this memory,  free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is the address of a non-<b>NULL</b> pointer, this function will copy the provider information into this buffer. The <i>pcbBuffer</i> parameter must contain the size, in bytes, of the entire buffer. If the buffer is not large enough to hold all of the provider information, this function will return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size specified by the <i>pcbBuffer</i> parameter is not large enough to hold all of the data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptenumregisteredproviders
     * @since windows6.0.6000
     */
    static BCryptEnumRegisteredProviders(pcbBuffer, ppBuffer) {
        result := DllCall("bcrypt.dll\BCryptEnumRegisteredProviders", "ptr", pcbBuffer, "ptr", ppBuffer, "int")
        return result
    }

    /**
     * Creates a new CNG configuration context.
     * @remarks
     * <b>BCryptCreateContext</b> can be called only in user mode.
     * @param {Integer} dwTable 
     * @param {Pointer<PWSTR>} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to create.
     * @param {Pointer<CRYPT_CONTEXT_CONFIG>} pConfig A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_context_config">CRYPT_CONTEXT_CONFIG</a> structure that contains additional configuration data for the new context. This parameter can be <b>NULL</b> if it is not needed.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptcreatecontext
     * @since windows6.0.6000
     */
    static BCryptCreateContext(dwTable, pszContext, pConfig) {
        result := DllCall("bcrypt.dll\BCryptCreateContext", "uint", dwTable, "ptr", pszContext, "ptr", pConfig, "int")
        return result
    }

    /**
     * Deletes an existing CNG configuration context.
     * @remarks
     * <b>BCryptDeleteContext</b> can be called only in user mode.
     * @param {Integer} dwTable 
     * @param {Pointer<PWSTR>} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to delete.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptdeletecontext
     * @since windows6.0.6000
     */
    static BCryptDeleteContext(dwTable, pszContext) {
        result := DllCall("bcrypt.dll\BCryptDeleteContext", "uint", dwTable, "ptr", pszContext, "int")
        return result
    }

    /**
     * Obtains the identifiers of the contexts in the specified configuration table.
     * @remarks
     * <b>BCryptEnumContexts</b> can be called only in user mode.
     * @param {Integer} dwTable 
     * @param {Pointer<UInt32>} pcbBuffer The address of a <b>ULONG</b> variable that, on entry, contains the size, in bytes, of the buffer pointed to by <i>ppBuffer</i>. If this size is not large enough to hold the set of context identifiers, this function will fail with <b>STATUS_BUFFER_TOO_SMALL</b>.
     * 
     * After this function returns, this value contains the number of bytes that were copied to the <i>ppBuffer</i> buffer.
     * @param {Pointer<CRYPT_CONTEXTS>} ppBuffer The address of a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_contexts">CRYPT_CONTEXTS</a> structure that receives the set of contexts retrieved by this function. The value pointed to by the <i>pcbBuffer</i> parameter contains the size of this buffer.
     * 
     * If the value pointed to by this parameter is <b>NULL</b>, this function will allocate the required memory. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the variable pointed to by the <i>pcbBuffer</i> parameter and return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>ppBuffer</i> parameter is not <b>NULL</b>, and the value pointed to by the <i>pcbBuffer</i> parameter is not large enough to hold the set of contexts.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptenumcontexts
     * @since windows6.0.6000
     */
    static BCryptEnumContexts(dwTable, pcbBuffer, ppBuffer) {
        result := DllCall("bcrypt.dll\BCryptEnumContexts", "uint", dwTable, "ptr", pcbBuffer, "ptr", ppBuffer, "int")
        return result
    }

    /**
     * Sets the configuration information for an existing CNG context.
     * @remarks
     * <b>BCryptConfigureContext</b> can be called only in user mode.
     * @param {Integer} dwTable 
     * @param {Pointer<PWSTR>} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to set the configuration information for.
     * @param {Pointer<CRYPT_CONTEXT_CONFIG>} pConfig The address of a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_context_config">CRYPT_CONTEXT_CONFIG</a> structure that contains the new context configuration information.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptconfigurecontext
     * @since windows6.0.6000
     */
    static BCryptConfigureContext(dwTable, pszContext, pConfig) {
        result := DllCall("bcrypt.dll\BCryptConfigureContext", "uint", dwTable, "ptr", pszContext, "ptr", pConfig, "int")
        return result
    }

    /**
     * Retrieves the current configuration for the specified CNG context.
     * @remarks
     * Each context has only one set of configuration information, so although the <i>ppBuffer</i> parameter appears to be a used as an array, this function treats this as an array with only one element. The following example helps clarify how this parameter is used.
     * 
     * 
     * ```cpp
     * // Get the configuration information for the context.
     * CRYPT_CONTEXT_CONFIG config;
     * ULONG uSize = sizeof(config);
     * PCRYPT_CONTEXT_CONFIG pConfig = &config;
     * status = BCryptQueryContextConfiguration(
     *     CRYPT_LOCAL, 
     *     pszContextID, 
     *     &uSize, 
     *     &pConfig);
     * 
     * ```
     * 
     * 
     * <b>BCryptQueryContextConfiguration</b> can be called only in user mode.
     * @param {Integer} dwTable 
     * @param {Pointer<PWSTR>} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to obtain the configuration information for.
     * @param {Pointer<UInt32>} pcbBuffer The address of a <b>ULONG</b> variable that, on entry, contains the size, in bytes, of the buffer pointed to by <i>ppBuffer</i>. If this size is not large enough to hold the context information, this function will fail with <b>STATUS_BUFFER_TOO_SMALL</b>.
     * 
     * After this function returns, this variable contains the number of bytes that were copied to the <i>ppBuffer</i> buffer.
     * @param {Pointer<CRYPT_CONTEXT_CONFIG>} ppBuffer The address of a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_context_config">CRYPT_CONTEXT_CONFIG</a> structure that receives the context configuration information retrieved by this function. The value pointed to by the <i>pcbBuffer</i> parameter contains the size of this buffer.
     * 
     * If the value pointed to by this parameter is <b>NULL</b>, this function will allocate the required memory. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the variable pointed to by the <i>pcbBuffer</i> parameter and return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * 
     * For more information on the usage of this parameter, see Remarks.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>ppBuffer</i> parameter is not <b>NULL</b>, and the value pointed to by the <i>pcbBuffer</i> parameter is not large enough to hold the set of contexts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified context could not be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptquerycontextconfiguration
     * @since windows6.0.6000
     */
    static BCryptQueryContextConfiguration(dwTable, pszContext, pcbBuffer, ppBuffer) {
        result := DllCall("bcrypt.dll\BCryptQueryContextConfiguration", "uint", dwTable, "ptr", pszContext, "ptr", pcbBuffer, "ptr", ppBuffer, "int")
        return result
    }

    /**
     * Adds a cryptographic function to the list of functions that are supported by an existing CNG context.
     * @remarks
     * If the function added is already in the list, it will be removed and inserted at the new position.
     * 
     * <b>BCryptAddContextFunction</b> can be called only in user mode.
     * @param {Integer} dwTable 
     * @param {Pointer<PWSTR>} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to add the function to.
     * @param {Integer} dwInterface 
     * @param {Pointer<PWSTR>} pszFunction A pointer to a null-terminated Unicode string that contains the identifier of the cryptographic function to add.
     * @param {Integer} dwPosition Specifies the position in the list at which to insert this function. The function is inserted at this position ahead of any existing functions. The <b>CRYPT_PRIORITY_TOP</b> value is used to insert the function at the top of the list. The <b>CRYPT_PRIORITY_BOTTOM</b> value is used to insert the function at the end of the list.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The context could not be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptaddcontextfunction
     * @since windows6.0.6000
     */
    static BCryptAddContextFunction(dwTable, pszContext, dwInterface, pszFunction, dwPosition) {
        result := DllCall("bcrypt.dll\BCryptAddContextFunction", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "uint", dwPosition, "int")
        return result
    }

    /**
     * Removes a cryptographic function from the list of functions that are supported by an existing CNG context.
     * @remarks
     * <b>BCryptRemoveContextFunction</b> can be called only in user mode.
     * @param {Integer} dwTable 
     * @param {Pointer<PWSTR>} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to remove the function from.
     * @param {Integer} dwInterface 
     * @param {Pointer<PWSTR>} pszFunction A pointer to a null-terminated Unicode string that contains the identifier of the cryptographic function to remove.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified context or function could not be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptremovecontextfunction
     * @since windows6.0.6000
     */
    static BCryptRemoveContextFunction(dwTable, pszContext, dwInterface, pszFunction) {
        result := DllCall("bcrypt.dll\BCryptRemoveContextFunction", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "int")
        return result
    }

    /**
     * Obtains the cryptographic functions for a context in the specified configuration table.
     * @remarks
     * <b>BCryptEnumContextFunctions</b> can be called only in user mode.
     * @param {Integer} dwTable 
     * @param {Pointer<PWSTR>} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to enumerate the functions for.
     * @param {Integer} dwInterface 
     * @param {Pointer<UInt32>} pcbBuffer The address of a <b>ULONG</b> variable that, on entry, contains the size, in bytes, of the buffer pointed to by <i>ppBuffer</i>. If this size is not large enough to hold the set of context identifiers, this function will fail with <b>STATUS_BUFFER_TOO_SMALL</b>.
     * 
     * After this function returns, this value contains the number of bytes that were copied to the <i>ppBuffer</i> buffer.
     * @param {Pointer<CRYPT_CONTEXT_FUNCTIONS>} ppBuffer The address of a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_context_functions">CRYPT_CONTEXT_FUNCTIONS</a> structure that receives the set of context functions retrieved by this function. The value pointed to by the <i>pcbBuffer</i> parameter contains the size of this buffer.
     * 
     * If the value pointed to by this parameter is <b>NULL</b>, this function will allocate the required memory. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the variable pointed to by the <i>pcbBuffer</i> parameter and return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>ppBuffer</i> parameter is not <b>NULL</b>, and the value pointed to by the <i>pcbBuffer</i> parameter is not large enough to hold the set of contexts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No context functions that match the specified criteria were found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptenumcontextfunctions
     * @since windows6.0.6000
     */
    static BCryptEnumContextFunctions(dwTable, pszContext, dwInterface, pcbBuffer, ppBuffer) {
        result := DllCall("bcrypt.dll\BCryptEnumContextFunctions", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pcbBuffer, "ptr", ppBuffer, "int")
        return result
    }

    /**
     * Sets the configuration information for the cryptographic function of an existing CNG context.
     * @remarks
     * <b>BCryptConfigureContextFunction</b> can be called only in user mode.
     * @param {Integer} dwTable 
     * @param {Pointer<PWSTR>} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to set the cryptographic function configuration information for.
     * @param {Integer} dwInterface 
     * @param {Pointer<PWSTR>} pszFunction A pointer to a null-terminated Unicode string that contains the identifier of the cryptographic function to set the configuration information for.
     * @param {Pointer<CRYPT_CONTEXT_FUNCTION_CONFIG>} pConfig The address of a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_context_function_config">CRYPT_CONTEXT_FUNCTION_CONFIG</a> structure that contains the new function configuration information.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptconfigurecontextfunction
     * @since windows6.0.6000
     */
    static BCryptConfigureContextFunction(dwTable, pszContext, dwInterface, pszFunction, pConfig) {
        result := DllCall("bcrypt.dll\BCryptConfigureContextFunction", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "ptr", pConfig, "int")
        return result
    }

    /**
     * Obtains the cryptographic function configuration information for an existing CNG context.
     * @remarks
     * Each cryptographic function has only one set of configuration information, so although the <i>ppBuffer</i> parameter appears to be a used as an array, this function treats this as an array with only one element. The following example helps clarify how this parameter is used.
     * 
     * 
     * ```cpp
     * // Get the function configuration information.
     * CRYPT_CONTEXT_FUNCTION_CONFIG FuncConfig;
     * ULONG uSize = sizeof(FuncConfig);
     * PCRYPT_CONTEXT_FUNCTION_CONFIG pFuncConfig = &FuncConfig;
     * status = BCryptQueryContextFunctionConfiguration(
     *     CRYPT_LOCAL, 
     *     pszContext, 
     *     NCRYPT_SCHANNEL_INTERFACE,
     *     pszFunction,
     *     &uSize, 
     *     &pFuncConfig);
     * 
     * ```
     * 
     * 
     * <b>BCryptQueryContextFunctionConfiguration</b> can be called only in user mode.
     * @param {Integer} dwTable 
     * @param {Pointer<PWSTR>} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to obtain the function configuration information for.
     * @param {Integer} dwInterface 
     * @param {Pointer<PWSTR>} pszFunction A pointer to a null-terminated Unicode string that contains the identifier of the cryptographic function to obtain the configuration information for.
     * @param {Pointer<UInt32>} pcbBuffer The address of a <b>ULONG</b> variable that, on entry, contains the size, in bytes, of the buffer pointed to by <i>ppBuffer</i>. If this size is not large enough to hold the context information, this function will fail with <b>STATUS_BUFFER_TOO_SMALL</b>.
     * 
     * After this function returns, this variable contains the number of bytes that were copied to the <i>ppBuffer</i> buffer.
     * @param {Pointer<CRYPT_CONTEXT_FUNCTION_CONFIG>} ppBuffer The address of a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_context_function_config">CRYPT_CONTEXT_FUNCTION_CONFIG</a> structure that receives the function configuration information retrieved by this function. The value pointed to by the <i>pcbBuffer</i> parameter contains the size of this buffer.
     * 
     * If the value pointed to by this parameter is <b>NULL</b>, this function will allocate the required memory. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the variable pointed to by the <i>pcbBuffer</i> parameter and return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * 
     * For more information about the usage of this parameter, see Remarks.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>ppBuffer</i> parameter is not <b>NULL</b>, and the value pointed to by the <i>pcbBuffer</i> parameter is not large enough to hold the set of contexts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified context or function could not be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptquerycontextfunctionconfiguration
     * @since windows6.0.6000
     */
    static BCryptQueryContextFunctionConfiguration(dwTable, pszContext, dwInterface, pszFunction, pcbBuffer, ppBuffer) {
        result := DllCall("bcrypt.dll\BCryptQueryContextFunctionConfiguration", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "ptr", pcbBuffer, "ptr", ppBuffer, "int")
        return result
    }

    /**
     * Obtains the providers for the cryptographic functions for a context in the specified configuration table.
     * @remarks
     * <b>BCryptEnumContextFunctionProviders</b> can be called only in user mode.
     * @param {Integer} dwTable 
     * @param {Pointer<PWSTR>} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to enumerate the function providers for.
     * @param {Integer} dwInterface 
     * @param {Pointer<PWSTR>} pszFunction A pointer to a null-terminated Unicode string that contains the identifier of the function to enumerate the providers for.
     * @param {Pointer<UInt32>} pcbBuffer The address of a <b>ULONG</b> variable that, on entry, contains the size, in bytes, of the buffer pointed to by <i>ppBuffer</i>. If this size is not large enough to hold the set of context identifiers, this function will fail with <b>STATUS_BUFFER_TOO_SMALL</b>.
     * 
     * After this function returns, this value contains the number of bytes that were copied to the <i>ppBuffer</i> buffer.
     * @param {Pointer<CRYPT_CONTEXT_FUNCTION_PROVIDERS>} ppBuffer The address of a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_context_function_providers">CRYPT_CONTEXT_FUNCTION_PROVIDERS</a> structure that receives the set of context function providers retrieved by this function. The value pointed to by the <i>pcbBuffer</i> parameter contains the size of this buffer.
     * 
     * If the value pointed to by this parameter is <b>NULL</b>, this function will allocate the required memory. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the variable pointed to by the <i>pcbBuffer</i> parameter and return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>ppBuffer</i> parameter is not <b>NULL</b>, and the value pointed to by the <i>pcbBuffer</i> parameter is not large enough to hold the set of contexts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No context function providers that match the specified criteria were found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptenumcontextfunctionproviders
     * @since windows6.0.6000
     */
    static BCryptEnumContextFunctionProviders(dwTable, pszContext, dwInterface, pszFunction, pcbBuffer, ppBuffer) {
        result := DllCall("bcrypt.dll\BCryptEnumContextFunctionProviders", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "ptr", pcbBuffer, "ptr", ppBuffer, "int")
        return result
    }

    /**
     * Sets the value of a named property for a cryptographic function in an existing CNG context.
     * @remarks
     * <b>BCryptSetContextFunctionProperty</b> can be called only in user mode.
     * @param {Integer} dwTable 
     * @param {Pointer<PWSTR>} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to set the function property in.
     * @param {Integer} dwInterface 
     * @param {Pointer<PWSTR>} pszFunction A pointer to a null-terminated Unicode string that contains the identifier of the cryptographic function to set the property for.
     * @param {Pointer<PWSTR>} pszProperty A pointer to a null-terminated Unicode string that contains the identifier of the property to set.
     * @param {Integer} cbValue Contains the size, in bytes, of the <i>pbValue</i> buffer. This is the exact number of bytes that will be stored. If the property value is a string, you should add the size of one character to also store the terminating null character, if needed.
     * @param {Pointer<Byte>} pbValue The address of a buffer that contains the new property value.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The caller does not have write access to the properties for the function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified context or function could not be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptsetcontextfunctionproperty
     * @since windows6.0.6000
     */
    static BCryptSetContextFunctionProperty(dwTable, pszContext, dwInterface, pszFunction, pszProperty, cbValue, pbValue) {
        result := DllCall("bcrypt.dll\BCryptSetContextFunctionProperty", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "ptr", pszProperty, "uint", cbValue, "ptr", pbValue, "int")
        return result
    }

    /**
     * Obtains the value of a named property for a cryptographic function in an existing CNG context.
     * @remarks
     * <b>BCryptQueryContextFunctionProperty</b> can be called only in user mode.
     * @param {Integer} dwTable 
     * @param {Pointer<PWSTR>} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context to obtain the function property from.
     * @param {Integer} dwInterface 
     * @param {Pointer<PWSTR>} pszFunction A pointer to a null-terminated Unicode string that contains the identifier of the cryptographic function to obtain the property for.
     * @param {Pointer<PWSTR>} pszProperty A pointer to a null-terminated Unicode string that contains the identifier of the property to obtain.
     * @param {Pointer<UInt32>} pcbValue The address of a <b>ULONG</b> variable that, on entry, contains the size, in bytes, of the buffer pointed to by <i>ppbValue</i>. If this size is not large enough to hold the property value, this function will fail with <b>STATUS_BUFFER_TOO_SMALL</b>.
     * 
     * After this function returns, this variable contains the number of bytes that were copied to the <i>ppbValue</i> buffer.
     * @param {Pointer<Byte>} ppbValue The address of a pointer to a buffer that receives the property data. The size and format of this buffer depends on the format of the property being retrieved. The value pointed to by the <i>pcbValue</i> parameter contains the size of this buffer.
     * 
     * If the value pointed to by this parameter is <b>NULL</b>, this function will allocate the required memory. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the variable pointed to by the <i>pcbValue</i> parameter and return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>ppbValue</i> parameter is not <b>NULL</b>, and the value pointed to by the <i>pcbValue</i> parameter is not large enough to hold the set of contexts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified context, function, or property could not be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptquerycontextfunctionproperty
     * @since windows6.0.6000
     */
    static BCryptQueryContextFunctionProperty(dwTable, pszContext, dwInterface, pszFunction, pszProperty, pcbValue, ppbValue) {
        result := DllCall("bcrypt.dll\BCryptQueryContextFunctionProperty", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "ptr", pszProperty, "ptr", pcbValue, "ptr", ppbValue, "int")
        return result
    }

    /**
     * Creates a user mode CNG configuration change event handler.
     * @remarks
     * The handle returned in the variable pointed to by the <i>phEvent</i> parameter will be signaled when a change to the CNG configuration occurs.
     * 
     * <b>BCryptRegisterConfigChangeNotify(HANDLE*)</b> can be called only in user mode. Code executing in kernel mode must call <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptregisterconfigchangenotify">BCryptRegisterConfigChangeNotify(PRKEVENT)</a>.
     * @param {Pointer<HANDLE>} phEvent 
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>phEvent</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptregisterconfigchangenotify
     * @since windows6.0.6000
     */
    static BCryptRegisterConfigChangeNotify(phEvent) {
        result := DllCall("bcrypt.dll\BCryptRegisterConfigChangeNotify", "ptr", phEvent, "int")
        return result
    }

    /**
     * Removes a user mode CNG configuration change event handler that was created by using the BCryptRegisterConfigChangeNotify(HANDLE*) function.
     * @remarks
     * <b>BCryptUnregisterConfigChangeNotify(HANDLE)</b> can be called only in user mode. Code executing in kernel mode must call <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptunregisterconfigchangenotify">BCryptUnregisterConfigChangeNotify(PRKEVENT)</a>.
     * @param {Pointer<HANDLE>} hEvent 
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hEvent</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptunregisterconfigchangenotify
     * @since windows6.0.6000
     */
    static BCryptUnregisterConfigChangeNotify(hEvent) {
        result := DllCall("bcrypt.dll\BCryptUnregisterConfigChangeNotify", "ptr", hEvent, "int")
        return result
    }

    /**
     * Obtains a collection of all of the providers that meet the specified criteria.
     * @remarks
     * <b>BCryptResolveProviders</b> can be called either from user mode or kernel mode. Kernel mode callers must be executing at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a>.
     * @param {Pointer<PWSTR>} pszContext A pointer to a null-terminated Unicode string that contains the identifier of the context for which to obtain the providers.  If this is set to <b>NULL</b> or to an empty string, the default context is assumed.
     * @param {Integer} dwInterface The identifier of an interface that the provider must support. This must be one of the <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-interface-identifiers">CNG Interface Identifiers</a>. If the <i>pszFunction</i> parameter is not <b>NULL</b> or an empty string, you can set <i>dwInterface</i> to zero to force the function to infer the interface.
     * @param {Pointer<PWSTR>} pszFunction A pointer to a null-terminated Unicode string that contains the algorithm or function identifier that the provider must support. This can be one of the standard <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-algorithm-identifiers">CNG Algorithm Identifiers</a> or the identifier for another registered algorithm.  If <i>dwInterface</i> is set to a nonzero value, then <i>pszFunction</i> can be <b>NULL</b> to include all algorithms and functions.
     * @param {Pointer<PWSTR>} pszProvider A pointer to a null-terminated Unicode string that contains the name of the provider to retrieve. If this parameter is <b>NULL</b>, then all providers will be included.
     * 
     * This parameter allows you to specify a specific provider to retrieve in the event that more than one provider meets the other criteria.
     * @param {Integer} dwMode 
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function.
     * @param {Pointer<UInt32>} pcbBuffer A pointer to a <b>DWORD</b> value that, on entry, contains the size, in bytes, of the buffer pointed to by the <i>ppBuffer</i> parameter. On exit, this value receives either the number of bytes copied to the buffer or the required size, in bytes, of the buffer.
     * @param {Pointer<CRYPT_PROVIDER_REFS>} ppBuffer The address of a <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/ns-bcrypt-crypt_provider_refs">CRYPT_PROVIDER_REFS</a> pointer that receives the collection of providers that meet the specified criteria.
     * 
     * If this parameter is <b>NULL</b>, this function will return <b>STATUS_SUCCESS</b> and place in the value pointed to by the <i>pcbBuffer</i> parameter, the required size, in bytes, of all the data.
     * 
     * If this parameter is the address of a <b>NULL</b> pointer, this function will allocate the required memory, fill the memory with the information about the providers, and place the pointer to this memory in this parameter. When you have finished using this memory,  free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfreebuffer">BCryptFreeBuffer</a> function.
     * 
     * If this parameter is the address of a non-<b>NULL</b> pointer, this function will copy the provider information into this buffer. The <i>pcbBuffer</i> parameter must contain the size, in bytes, of the entire buffer. If the buffer is not large enough to hold all of the provider information, this function will return <b>STATUS_BUFFER_TOO_SMALL</b>.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size specified by the <i>pcbBuffer</i> parameter is not large enough to hold all of the data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No provider could be found that meets all of the specified criteria.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptresolveproviders
     * @since windows6.0.6000
     */
    static BCryptResolveProviders(pszContext, dwInterface, pszFunction, pszProvider, dwMode, dwFlags, pcbBuffer, ppBuffer) {
        result := DllCall("bcrypt.dll\BCryptResolveProviders", "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "ptr", pszProvider, "uint", dwMode, "uint", dwFlags, "ptr", pcbBuffer, "ptr", ppBuffer, "int")
        return result
    }

    /**
     * Determines whether Federal Information Processing Standard (FIPS) compliance is enabled.
     * @remarks
     * <b>BCryptGetFipsAlgorithmMode</b> can be called either from user mode or kernel mode. Kernel mode callers must be executing at <b>PASSIVE_LEVEL</b> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">IRQL</a>.
     * @param {Pointer<Byte>} pfEnabled The address of a <b>BOOLEAN</b> variable that receives zero if FIPS compliance is not enabled, or a nonzero value if FIPS compliance is enabled.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pfEnabled</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/bcrypt/nf-bcrypt-bcryptgetfipsalgorithmmode
     * @since windows6.0.6000
     */
    static BCryptGetFipsAlgorithmMode(pfEnabled) {
        result := DllCall("bcrypt.dll\BCryptGetFipsAlgorithmMode", "ptr", pfEnabled, "int")
        return result
    }

    /**
     * Loads and initializes a CNG key storage provider.
     * @remarks
     * In the case that an error condition is returned, the provider will have been unloaded from memory. Functions within the provider must not be called after a failure error is returned.
     * 
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer<UIntPtr>} phProvider A pointer to a <b>NCRYPT_PROV_HANDLE</b> variable that receives the provider handle. When you have finished using this handle, release it by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreeobject">NCryptFreeObject</a> function.
     * @param {Pointer<PWSTR>} pszProviderName A pointer to a null-terminated Unicode string that identifies the key storage provider to load. This is the registered alias of the key storage provider. This parameter is optional and can be <b>NULL</b>. If this parameter is <b>NULL</b>, the default key storage provider is loaded. The following values identify the built-in key storage providers.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MS_KEY_STORAGE_PROVIDER"></a><a id="ms_key_storage_provider"></a><dl>
     * <dt><b>MS_KEY_STORAGE_PROVIDER</b></dt>
     * <dt>L"Microsoft Software Key Storage Provider"</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Identifies the software key storage provider that is provided by Microsoft.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MS_SMART_CARD_KEY_STORAGE_PROVIDER"></a><a id="ms_smart_card_key_storage_provider"></a><dl>
     * <dt><b>MS_SMART_CARD_KEY_STORAGE_PROVIDER</b></dt>
     * <dt>L"Microsoft Smart Card Key Storage Provider"</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Identifies the smart card key storage provider that is provided by Microsoft.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MS_PLATFORM_CRYPTO_PROVIDER"></a><a id="ms_platform_crypto_provider"></a><dl>
     * <dt><b>MS_PLATFORM_CRYPTO_PROVIDER</b></dt>
     * <dt>L"Microsoft Platform Crypto Provider"</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Identifies the TPM key storage provider that is provided by Microsoft.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags Flags that modify the behavior of the function. No flags are defined for this function.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains one or more flags that are not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptopenstorageprovider
     * @since windows6.0.6000
     */
    static NCryptOpenStorageProvider(phProvider, pszProviderName, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptOpenStorageProvider", "ptr", phProvider, "ptr", pszProviderName, "uint", dwFlags, "int")
        return result
    }

    /**
     * Obtains the names of the algorithms that are supported by the specified key storage provider.
     * @remarks
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hProvider The handle of the key storage provider to enumerate the algorithms for. This handle is obtained with the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenstorageprovider">NCryptOpenStorageProvider</a> function.
     * @param {Integer} dwAlgOperations 
     * @param {Pointer<UInt32>} pdwAlgCount The address of a <b>DWORD</b> that receives the number of elements in the <i>ppAlgList</i> array.
     * @param {Pointer<NCryptAlgorithmName>} ppAlgList The address of an <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/ns-ncrypt-ncryptalgorithmname">NCryptAlgorithmName</a> structure pointer that receives an array of the registered algorithm names. The variable pointed to by the <i>pdwAlgCount</i> parameter receives the number of elements in this array.
     * 
     * When this memory is no longer needed, it must be freed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreebuffer">NCryptFreeBuffer</a> function.
     * @param {Integer} dwFlags Flags that modify function behavior. This can be zero (0) or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider (KSP) not display any user interface. If the provider must display the UI to operate, the call fails and the KSP should set the <b>NTE_SILENT_CONTEXT</b> error code as the last error.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProvider</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptenumalgorithms
     * @since windows6.0.6000
     */
    static NCryptEnumAlgorithms(hProvider, dwAlgOperations, pdwAlgCount, ppAlgList, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptEnumAlgorithms", "ptr", hProvider, "uint", dwAlgOperations, "ptr", pdwAlgCount, "ptr", ppAlgList, "uint", dwFlags, "int")
        return result
    }

    /**
     * Determines if a CNG key storage provider supports a specific cryptographic algorithm.
     * @remarks
     * If the provider supports the algorithm, this function returns <b>ERROR_SUCCESS</b>. If the provider does not support the algorithm, and no other errors occurred, this function returns <b>NTE_NOT_SUPPORTED</b>.
     * 
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hProvider The handle of the key storage provider. This handle is obtained with the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenstorageprovider">NCryptOpenStorageProvider</a> function.
     * @param {Pointer<PWSTR>} pszAlgId A pointer to a null-terminated Unicode string that identifies the cryptographic algorithm in question. This can be one of the standard <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-algorithm-identifiers">CNG Algorithm Identifiers</a> or the identifier for another registered algorithm.
     * @param {Integer} dwFlags Flags that modify function behavior. This can be zero (0) or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider (KSP) not display any user interface. If the provider must display the UI to operate, the call fails and the KSP should set the <b>NTE_SILENT_CONTEXT</b> error code as the last error.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider supports the specified algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains one or more flags that are not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle specified by the <i>hProvider</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider does not support the specified algorithm.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptisalgsupported
     * @since windows6.0.6000
     */
    static NCryptIsAlgSupported(hProvider, pszAlgId, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptIsAlgSupported", "ptr", hProvider, "ptr", pszAlgId, "uint", dwFlags, "int")
        return result
    }

    /**
     * Obtains the names of the keys that are stored by the provider.
     * @remarks
     * This function retrieves only one item each time it is called. The state of the enumeration is stored in the variable pointed to by the <i>ppEnumState</i> parameter, so this must be preserved between calls to this function. When the last key stored by the provider has been retrieved, this function will return <b>NTE_NO_MORE_ITEMS</b> the next time it is called. To start the enumeration over, set the variable pointed to by the <i>ppEnumState</i> parameter to <b>NULL</b>, free the memory pointed to by the <i>ppKeyName</i> parameter, if it is not <b>NULL</b>, and call this function again.
     * 
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hProvider The handle of the key storage provider to enumerate the keys for. This handle is obtained with the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenstorageprovider">NCryptOpenStorageProvider</a> function.
     * @param {Pointer<PWSTR>} pszScope This parameter is not currently used and must be <b>NULL</b>.
     * @param {Pointer<NCryptKeyName>} ppKeyName The address of a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/ns-ncrypt-ncryptkeyname">NCryptKeyName</a> structure that receives the name of the retrieved key. When the application has finished using this memory, free it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreebuffer">NCryptFreeBuffer</a> function.
     * @param {Pointer<Void>} ppEnumState The address of a <b>VOID</b> pointer that receives enumeration state information that is used in subsequent calls to this function. This information only has meaning to the key storage provider and is opaque to the caller. The key storage provider uses this information to determine which item is next in the enumeration. If the variable pointed to by this parameter contains <b>NULL</b>, the enumeration is started from the beginning.
     * 
     * When this memory is no longer needed, it must be freed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreebuffer">NCryptFreeBuffer</a> function.
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProvider</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MORE_ITEMS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end of the enumeration has been reached.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_SILENT_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains the <b>NCRYPT_SILENT_FLAG</b> flag, but the key being enumerated requires user interaction.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptenumkeys
     * @since windows6.0.6000
     */
    static NCryptEnumKeys(hProvider, pszScope, ppKeyName, ppEnumState, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptEnumKeys", "ptr", hProvider, "ptr", pszScope, "ptr", ppKeyName, "ptr", ppEnumState, "uint", dwFlags, "int")
        return result
    }

    /**
     * Obtains the names of the registered key storage providers.
     * @remarks
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer<UInt32>} pdwProviderCount The address of a <b>DWORD</b> to receive the number of elements in the <i>ppProviderList</i> array.
     * @param {Pointer<NCryptProviderName>} ppProviderList The address of an <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/ns-ncrypt-ncryptprovidername">NCryptProviderName</a> structure pointer to receive an array of the registered key storage provider names. The variable pointed to by the <i>pdwProviderCount</i> parameter receives the number of elements in this array.
     * 
     * When this memory is no longer needed, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreebuffer">NCryptFreeBuffer</a> function.
     * @param {Integer} dwFlags Flags that modify function behavior. This can be zero (0) or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider (KSP) not display any user interface. If the provider must display the UI to operate, the call fails and the KSP should set the <b>NTE_SILENT_CONTEXT</b> error code as the last error.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptenumstorageproviders
     * @since windows6.0.6000
     */
    static NCryptEnumStorageProviders(pdwProviderCount, ppProviderList, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptEnumStorageProviders", "ptr", pdwProviderCount, "ptr", ppProviderList, "uint", dwFlags, "int")
        return result
    }

    /**
     * Releases a block of memory allocated by a CNG key storage provider.
     * @remarks
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer<Void>} pvInput The address of the memory to be released.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pvInput</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptfreebuffer
     * @since windows6.0.6000
     */
    static NCryptFreeBuffer(pvInput) {
        result := DllCall("ncrypt.dll\NCryptFreeBuffer", "ptr", pvInput, "int")
        return result
    }

    /**
     * Opens a key that exists in the specified CNG key storage provider.
     * @remarks
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * 
     * For performance reasons, Microsoft software-based KSPs cache private key material in the Local Security Authority (LSA) for as long as a handle to the key is open. The LSA is a privileged system process. Therefore, other users cannot access this cached copy of the key unless the user possesses administrator privileges on the system. This behavior cannot be altered through configuration.
     * @param {Pointer} hProvider The handle of the key storage provider to open the key from.
     * @param {Pointer<UIntPtr>} phKey A pointer to a <b>NCRYPT_KEY_HANDLE</b> variable that receives the key handle. When you have finished using this handle, release it by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreeobject">NCryptFreeObject</a> function.
     * @param {Pointer<PWSTR>} pszKeyName A pointer to a null-terminated Unicode string that contains the name of the key to retrieve.
     * @param {Integer} dwLegacyKeySpec 
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEYSET</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified key was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProvider</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptopenkey
     * @since windows6.0.6000
     */
    static NCryptOpenKey(hProvider, phKey, pszKeyName, dwLegacyKeySpec, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptOpenKey", "ptr", hProvider, "ptr", phKey, "ptr", pszKeyName, "uint", dwLegacyKeySpec, "uint", dwFlags, "int")
        return result
    }

    /**
     * Creates a new key and stores it in the specified key storage provider.
     * @remarks
     * If you are creating an RSA key pair, you can also have the key stored in legacy storage so that it can be used with the CryptoAPI by passing the <b>NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG</b> flag to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfinalizekey">NCryptFinalizeKey</a> function when the key is finalized.
     * 
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hProvider The handle of the key storage provider to create the key in. This handle is obtained by using the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenstorageprovider">NCryptOpenStorageProvider</a> function.
     * @param {Pointer<UIntPtr>} phKey The address of an <b>NCRYPT_KEY_HANDLE</b> variable that receives the handle of the key. When you have finished using this handle, release it by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreeobject">NCryptFreeObject</a> function. To delete the key file on disk, pass the handle to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptdeletekey">NCryptDeleteKey</a> function. This will also release the handle. So applications may pass the handle to either <b>NCryptFreeObject</b> or <b>NCryptDeleteKey</b>, but not both.
     * @param {Pointer<PWSTR>} pszAlgId A pointer to a null-terminated Unicode string that contains the identifier of the cryptographic algorithm to create the key. This can be one of the standard <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-algorithm-identifiers">CNG Algorithm Identifiers</a> or the identifier for another registered algorithm.
     * @param {Pointer<PWSTR>} pszKeyName A pointer to a null-terminated Unicode string that contains the name of the key. If this parameter is <b>NULL</b>, this function will create an ephemeral key that is not persisted.
     * @param {Integer} dwLegacyKeySpec 
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A key with the specified name already exists and the <b>NCRYPT_OVERWRITE_KEY_FLAG</b> was not specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProvider</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptcreatepersistedkey
     * @since windows6.0.6000
     */
    static NCryptCreatePersistedKey(hProvider, phKey, pszAlgId, pszKeyName, dwLegacyKeySpec, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptCreatePersistedKey", "ptr", hProvider, "ptr", phKey, "ptr", pszAlgId, "ptr", pszKeyName, "uint", dwLegacyKeySpec, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves the value of a named property for a key storage object.
     * @remarks
     * A service must not call this function from its [StartService](/windows/win32/api/winsvc/nf-winsvc-startservicea) function. If a service calls this function from its `StartService` function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hObject The handle of the object to get the property for. This can be a provider handle (**NCRYPT_PROV_HANDLE**) or a key handle (**NCRYPT_KEY_HANDLE**).
     * @param {Pointer<PWSTR>} pszProperty A pointer to a null-terminated Unicode string that contains the name of the property to retrieve. This can be one of the predefined [Key Storage Property Identifiers](/windows/win32/SecCNG/key-storage-property-identifiers) or a custom property identifier.
     * @param {Pointer<Byte>} pbOutput The address of a buffer that receives the property value. The _cbOutput_ parameter contains the size of this buffer.
     * 
     *  To calculate the size required for the buffer, set this parameter to **NULL**. The size, in bytes, required is returned in the location pointed to by the _pcbResult_ parameter.
     * @param {Integer} cbOutput The size, in bytes, of the _pbOutput_ buffer.
     * @param {Pointer<UInt32>} pcbResult A pointer to a **DWORD** variable that receives the number of bytes that were copied to the _pbOutput_ buffer.
     * 
     * If the _pbOutput_ parameter is **NULL**, the size, in bytes, required for the buffer is placed in the location pointed to by this parameter.
     * @param {Integer} dwFlags Flags that modify function behavior. This can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_PERSIST_ONLY_FLAG"></a><a id="ncrypt_persist_only_flag"></a><dl>
     * <dt><b>NCRYPT_PERSIST_ONLY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ignore any built in values for this property and only retrieve the user-persisted properties of the key.  The maximum size of the data for any persisted property is <b>NCRYPT_MAX_PROPERTY_DATA</b> bytes.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider (KSP) not display any user interface. If the provider must display the UI to operate, the call fails and the KSP should set the <b>NTE_SILENT_CONTEXT</b> error code as the last error.
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * | Return code | Description |
     * |-------|--------|
     * | `ERROR_SUCCESS` | The function was successful. |
     * | `NTE_BAD_FLAGS` | The `dwFlags` parameter contains a value that is not valid. |
     * | `NTE_INVALID_HANDLE` | The `hObject` parameter is not valid. |
     * | `NTE_INVALID_PARAMETER` | One or more parameters are not valid. |
     * | `NTE_NO_MEMORY` | A memory allocation failure occurred. |
     * | `NTE_NOT_SUPPORTED` | The specified property is not supported for the object. |
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptgetproperty
     * @since windows6.0.6000
     */
    static NCryptGetProperty(hObject, pszProperty, pbOutput, cbOutput, pcbResult, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptGetProperty", "ptr", hObject, "ptr", pszProperty, "ptr", pbOutput, "uint", cbOutput, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Sets the value for a named property for a CNG key storage object.
     * @remarks
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hObject The handle of the key storage object to set the property for.
     * @param {Pointer<PWSTR>} pszProperty A pointer to a null-terminated Unicode string that contains the name of the property to set. This can be one of the predefined <a href="https://docs.microsoft.com/windows/desktop/SecCNG/key-storage-property-identifiers">Key Storage Property Identifiers</a> or a custom property identifier.
     * @param {Pointer<Byte>} pbInput The address of a buffer that contains the new property value. The <i>cbInput</i> parameter contains the size of this buffer.
     * @param {Integer} cbInput The size, in bytes, of the <i>pbInput</i> buffer.
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hObject</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified property is not supported for the object.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptsetproperty
     * @since windows6.0.6000
     */
    static NCryptSetProperty(hObject, pszProperty, pbInput, cbInput, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptSetProperty", "ptr", hObject, "ptr", pszProperty, "ptr", pbInput, "uint", cbInput, "uint", dwFlags, "int")
        return result
    }

    /**
     * Completes a CNG key storage key.
     * @remarks
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hKey The handle of the key to complete. This handle is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptcreatepersistedkey">NCryptCreatePersistedKey</a> function.
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptfinalizekey
     * @since windows6.0.6000
     */
    static NCryptFinalizeKey(hKey, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptFinalizeKey", "ptr", hKey, "uint", dwFlags, "int")
        return result
    }

    /**
     * Encrypts a block of data. (NCryptEncrypt)
     * @remarks
     * The <i>pbInput</i> and <i>pbOutput</i> parameters can point to the same buffer. In this case, this function will perform the encryption in place. It is possible that the encrypted data size will be larger than the unencrypted data size, so the buffer must be large enough to hold the encrypted data.
     * 
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hKey The handle of the key to use to encrypt the data.
     * @param {Pointer<Byte>} pbInput The address of a buffer that contains the data to be encrypted. The <i>cbInput</i> parameter contains the size of the data to encrypt. For more information, see Remarks.
     * @param {Integer} cbInput The number of bytes in the <i>pbInput</i> buffer to encrypt.
     * @param {Pointer<Void>} pPaddingInfo A pointer to a structure that contains padding information. The actual type of structure this parameter points to depends on the value of the <i>dwFlags</i> parameter. This parameter is only used with asymmetric keys and must be <b>NULL</b> otherwise.
     * @param {Pointer<Byte>} pbOutput The address of a buffer that will receive the encrypted data produced by this function. The <i>cbOutput</i> parameter contains the size of this buffer. For more information, see Remarks.
     * 
     * If this parameter is <b>NULL</b>, this function will calculate the size needed for the encrypted data and return the size in the location pointed to by the <i>pcbResult</i> parameter.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer. This parameter is ignored if the <i>pbOutput</i> parameter is <b>NULL</b>.
     * @param {Pointer<UInt32>} pcbResult A pointer to a <b>DWORD</b> variable that receives the number of bytes copied to the <i>pbOutput</i> buffer. If <i>pbOutput</i> is <b>NULL</b>, this receives the size, in bytes, required for the ciphertext.
     * @param {Integer} dwFlags Flags that modify function behavior. The allowed set of flags depends on the type of key specified by the <i>hKey</i> parameter.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_KEY_STATE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key identified by the <i>hKey</i> parameter has not been finalized or is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size specified by the <i>cbOutput</i> parameter is not large enough to hold the encrypted data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptencrypt
     * @since windows6.0.6000
     */
    static NCryptEncrypt(hKey, pbInput, cbInput, pPaddingInfo, pbOutput, cbOutput, pcbResult, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptEncrypt", "ptr", hKey, "ptr", pbInput, "uint", cbInput, "ptr", pPaddingInfo, "ptr", pbOutput, "uint", cbOutput, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Decrypts a block of encrypted data.
     * @remarks
     * The <i>pbInput</i> and <i>pbOutput</i> parameters can point to the same buffer. In this case, this function will perform the decryption in place.
     * 
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hKey The handle of the key to use to decrypt the data.
     * @param {Pointer<Byte>} pbInput The address of a buffer that contains the data to be decrypted. The <i>cbInput</i> parameter contains the size of the data to decrypt. For more information, see Remarks.
     * @param {Integer} cbInput The number of bytes in the <i>pbInput</i> buffer to decrypt.
     * @param {Pointer<Void>} pPaddingInfo A pointer to a structure that contains padding information. The actual type of structure this parameter points to depends on the value of the <i>dwFlags</i> parameter. This parameter is only used with asymmetric keys and must be <b>NULL</b> otherwise.
     * @param {Pointer<Byte>} pbOutput The address of a buffer that will receive the decrypted data produced by this function. The <i>cbOutput</i> parameter contains the size of this buffer. For more information, see Remarks.
     * 
     * If this parameter is <b>NULL</b>, this function will calculate the size needed for the decrypted data and return the size in the location pointed to by the <i>pcbResult</i> parameter.
     * @param {Integer} cbOutput The size, in bytes, of the <i>pbOutput</i> buffer. This parameter is ignored if the <i>pbOutput</i> parameter is <b>NULL</b>.
     * @param {Pointer<UInt32>} pcbResult A pointer to a <b>DWORD</b> variable that receives the number of bytes copied to the <i>pbOutput</i> buffer. If <i>pbOutput</i> is <b>NULL</b>, this receives the size, in bytes, required for the decrypted data.
     * @param {Integer} dwFlags Flags that modify function behavior. The allowed set of flags depends on the type of key specified by the <i>hKey</i> parameter.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BUFFER_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size specified by the <i>cbOutput</i> parameter is not large enough to hold the decrypted data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_PERM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key identified by the <i>hKey</i> parameter cannot be used for decryption.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptdecrypt
     * @since windows6.0.6000
     */
    static NCryptDecrypt(hKey, pbInput, cbInput, pPaddingInfo, pbOutput, cbOutput, pcbResult, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptDecrypt", "ptr", hKey, "ptr", pbInput, "uint", cbInput, "ptr", pPaddingInfo, "ptr", pbOutput, "uint", cbOutput, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Imports a Cryptography API:\_Next Generation (CNG) key from a memory BLOB.
     * @remarks
     * A service must not call this function from its [StartService Function](/windows/win32/api/winsvc/nf-winsvc-startservicea). If a service calls this function from its **StartService** function, a deadlock can occur, and the service may stop responding.
     * 
     * The following sections describe behaviors specific to the Microsoft key storage providers:
     * 
     * - **Microsoft Software KSP**
     * - **Microsoft Smart Card KSP**
     * @param {Pointer} hProvider The handle of the key storage provider.
     * @param {Pointer} hImportKey The handle of the [cryptographic key](/windows/win32/SecGloss/c-gly) with which the key data within the imported [key BLOB](/windows/win32/SecGloss/k-gly) was encrypted. This must be a handle to the same key that was passed in the _hExportKey_ parameter of the [NCryptExportKey](/windows/win32/api/ncrypt/nf-ncrypt-ncryptexportkey) function. If this parameter is **NULL**, the key BLOB is assumed to not be encrypted.
     * @param {Pointer<PWSTR>} pszBlobType A null-terminated Unicode string that contains an identifier that specifies the format of the key BLOB. These formats are specific to a particular key storage provider. For the BLOB formats supported by Microsoft providers, see Remarks.
     * @param {Pointer<BCryptBufferDesc>} pParameterList The address of an [NCryptBufferDesc](/windows/win32/api/bcrypt/ns-bcrypt-bcryptbufferdesc) structure that points to an array of buffers that contain parameter information for the key.
     * @param {Pointer<UIntPtr>} phKey The address of an **NCRYPT_KEY_HANDLE** variable that receives the handle of the key. When you have finished using this handle, release it by passing it to the [NCryptFreeObject](/windows/win32/api/ncrypt/nf-ncrypt-ncryptfreeobject) function.
     * @param {Pointer<Byte>} pbData The address of a buffer that contains the key BLOB to be imported. The _cbData_ parameter contains the size of this buffer.
     * @param {Integer} cbData The size, in bytes, of the _pbData_ buffer.
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * | Return code | Description |
     * |--------|--------|
     * | **ERROR_SUCCESS** | The function was successful. |
     * | **NTE_BAD_FLAGS** | The _dwFlags_ parameter contains a value that is not valid. |
     * | **NTE_EXISTS** | A key with the specified name already exists and the **NCRYPT_OVERWRITE_KEY_FLAG** was not specified. |
     * | **NTE_INVALID_HANDLE** | The _hProvider_ parameter is not valid. |
     * | **NTE_INVALID_PARAMETER** | One or more parameters are not valid. |
     * | **NTE_NO_MEMORY** | A memory allocation failure occurred. |
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptimportkey
     * @since windows6.0.6000
     */
    static NCryptImportKey(hProvider, hImportKey, pszBlobType, pParameterList, phKey, pbData, cbData, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptImportKey", "ptr", hProvider, "ptr", hImportKey, "ptr", pszBlobType, "ptr", pParameterList, "ptr", phKey, "ptr", pbData, "uint", cbData, "uint", dwFlags, "int")
        return result
    }

    /**
     * Exports a CNG key to a memory BLOB.
     * @remarks
     * A service must not call this function from its [StartService Function](/windows/win32/api/winsvc/nf-winsvc-startservicea). If a service calls this function from its **StartService** function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hKey A handle of the key to export.
     * @param {Pointer} hExportKey A handle to a cryptographic key of the destination user. The key data within the exported key BLOB is encrypted by using this key. This ensures that only the destination user is able to make use of the key BLOB.
     * @param {Pointer<PWSTR>} pszBlobType 
     * @param {Pointer<BCryptBufferDesc>} pParameterList The address of an [NCryptBufferDesc](/windows/win32/api/bcrypt/ns-bcrypt-bcryptbufferdesc) structure that receives parameter information for the key. This parameter can be **NULL** if this information is not needed.
     * @param {Pointer<Byte>} pbOutput The address of a buffer that receives the key BLOB. The _cbOutput_ parameter contains the size of this buffer. If this parameter is **NULL**, this function will place the required size, in bytes, in the **DWORD** pointed to by the _pcbResult_ parameter.
     * @param {Integer} cbOutput The size, in bytes, of the _pbOutput_ buffer.
     * @param {Pointer<UInt32>} pcbResult The address of a **DWORD** variable that receives the number of bytes copied to the _pbOutput_ buffer. If the _pbOutput_ parameter is **NULL**, this function will place the required size, in bytes, in the **DWORD** pointed to by this parameter.
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * | Return code | Description |
     * |--------|--------|
     * | ERROR_SUCCESS | The function was successful. |
     * | NTE_BAD_FLAGS | The _dwFlags_ parameter contains a value that is not valid. |
     * | NTE_BAD_KEY_STATE | The key specified by the _hKey_ parameter is not valid. The most common cause of this error is that the key was not completed by using the [NCryptFinalizeKey](/windows/win32/api/ncrypt/nf-ncrypt-ncryptfinalizekey) function. |
     * | NTE_BAD_TYPE | The key specified by the _hKey_ parameter cannot be exported into the BLOB type specified by the _pszBlobType_ parameter. |
     * | NTE_INVALID_HANDLE | The _hKey_ or the _hExportKey_ parameter is not valid. |
     * | NTE_INVALID_PARAMETER | One or more parameters are not valid. |
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptexportkey
     * @since windows6.0.6000
     */
    static NCryptExportKey(hKey, hExportKey, pszBlobType, pParameterList, pbOutput, cbOutput, pcbResult, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptExportKey", "ptr", hKey, "ptr", hExportKey, "ptr", pszBlobType, "ptr", pParameterList, "ptr", pbOutput, "uint", cbOutput, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Creates a signature of a hash value. (NCryptSignHash)
     * @remarks
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hKey The handle of the key to use to sign the hash.
     * @param {Pointer<Void>} pPaddingInfo A pointer to a structure that contains padding information. The actual type of structure this parameter points to depends on the value of the <i>dwFlags</i> parameter. This parameter is only used with asymmetric keys and must be <b>NULL</b> otherwise.
     * @param {Pointer<Byte>} pbHashValue A pointer to a buffer that contains the hash value to sign. The <i>cbInput</i> parameter contains the size of this buffer.
     * @param {Integer} cbHashValue The number of bytes in the <i>pbHashValue</i> buffer to sign.
     * @param {Pointer<Byte>} pbSignature The address of a buffer to receive the signature produced by this function. The <i>cbSignature</i> parameter contains the size of this buffer.
     * 
     * If this parameter is <b>NULL</b>, this function will calculate the size required for the signature and return the size in the location pointed to by the <i>pcbResult</i> parameter.
     * @param {Integer} cbSignature The size, in bytes, of the <i>pbSignature</i> buffer. This parameter is ignored if the <i>pbSignature</i> parameter is <b>NULL</b>.
     * @param {Pointer<UInt32>} pcbResult A pointer to a <b>DWORD</b> variable that receives the number of bytes copied to the <i>pbSignature</i> buffer. 
     * 
     * If <i>pbSignature</i> is <b>NULL</b>, this receives the size, in bytes, required for the signature.
     * @param {Integer} dwFlags Flags that modify function behavior. The allowed set of flags depends on the type of key specified by the <i>hKey</i> parameter.
     * 
     * If the key is a symmetric key, this parameter is not used and should be set to zero.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key represented by the <i>hKey</i> parameter does not support signing.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptsignhash
     * @since windows6.0.6000
     */
    static NCryptSignHash(hKey, pPaddingInfo, pbHashValue, cbHashValue, pbSignature, cbSignature, pcbResult, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptSignHash", "ptr", hKey, "ptr", pPaddingInfo, "ptr", pbHashValue, "uint", cbHashValue, "ptr", pbSignature, "uint", cbSignature, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Verifies that the specified signature matches the specified hash. (NCryptVerifySignature)
     * @remarks
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hKey The handle of the key to use to decrypt the signature. This must be an identical key or the public key portion of the key pair used to sign the data with the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptsignhash">NCryptSignHash</a> function.
     * @param {Pointer<Void>} pPaddingInfo A pointer to a structure that contains padding information. The actual type of structure this parameter points to depends on the value of the <i>dwFlags</i> parameter. This parameter is only used with asymmetric keys and must be <b>NULL</b> otherwise.
     * @param {Pointer<Byte>} pbHashValue The address of a buffer that contains the hash of the data. The <i>cbHash</i> parameter contains the size of this buffer.
     * @param {Integer} cbHashValue The size, in bytes, of the <i>pbHash</i> buffer.
     * @param {Pointer<Byte>} pbSignature The address of a buffer that contains the signed hash of the data. The <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptsignhash">NCryptSignHash</a> function is used to create the signature. The <i>cbSignature</i> parameter contains the size of this buffer.
     * @param {Integer} cbSignature The size, in bytes, of the <i>pbSignature</i> buffer. The <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptsignhash">NCryptSignHash</a> function is used to create the signature.
     * @param {Integer} dwFlags Flags that modify function behavior. The allowed set of flags depends on the type of key specified by the <i>hKey</i> parameter.
     * 
     * If the key is a symmetric key, this parameter is not used and should be zero.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature was not verified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm provider used to create the key handle specified by the <i>hKey</i> parameter is not a signing algorithm.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptverifysignature
     * @since windows6.0.6000
     */
    static NCryptVerifySignature(hKey, pPaddingInfo, pbHashValue, cbHashValue, pbSignature, cbSignature, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptVerifySignature", "ptr", hKey, "ptr", pPaddingInfo, "ptr", pbHashValue, "uint", cbHashValue, "ptr", pbSignature, "uint", cbSignature, "uint", dwFlags, "int")
        return result
    }

    /**
     * Deletes a CNG key.
     * @remarks
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hKey The handle of the key to delete. This handle is obtained by using the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenkey">NCryptOpenKey</a> function.
     * 
     * <div class="alert"><b>Note</b>  The <b>NCryptDeleteKey</b> function frees the handle. Applications must not use the handle or attempt to call the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreeobject">NCryptFreeObject</a> function on it after calling the <b>NCryptDeleteKey</b> function.</div>
     * <div> </div>
     * @param {Integer} dwFlags Flags that modify function behavior. This can be zero or a combination of values that is specific to each key storage provider.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider (KSP) not display any user interface. If the provider must display the UI to operate, the call fails and the KSP should set the <b>NTE_SILENT_CONTEXT</b> error code as the last error.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptdeletekey
     * @since windows6.0.6000
     */
    static NCryptDeleteKey(hKey, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptDeleteKey", "ptr", hKey, "uint", dwFlags, "int")
        return result
    }

    /**
     * Frees a CNG key storage object.
     * @remarks
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hObject The handle of the object to free. This can be either a provider handle (<b>NCRYPT_PROV_HANDLE</b>) or a key handle (<b>NCRYPT_KEY_HANDLE</b>).
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hObject</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptfreeobject
     * @since windows6.0.6000
     */
    static NCryptFreeObject(hObject) {
        result := DllCall("ncrypt.dll\NCryptFreeObject", "ptr", hObject, "int")
        return result
    }

    /**
     * Determines if the specified handle is a CNG key handle.
     * @remarks
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hKey The handle of the key to test.
     * @returns {Integer} Returns a nonzero value if the handle is a key handle or zero otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptiskeyhandle
     * @since windows6.0.6000
     */
    static NCryptIsKeyHandle(hKey) {
        result := DllCall("ncrypt.dll\NCryptIsKeyHandle", "ptr", hKey, "int")
        return result
    }

    /**
     * Translates a CryptoAPI handle into a CNG key handle.
     * @remarks
     * This is a helper function intended to help applications and system components that currently use the CryptoAPI to make a graceful transition to using CNG.
     * 
     * This function will only be successful if a CNG key storage provider is registered with a name or alias that is identical to the name of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) referred to by the <i>hLegacyProv</i> parameter.
     * 
     * This function will perform the following steps to translate the CSP handle into a CNG key handle:
     * 
     * <ol>
     * <li>Obtain the name of the CSP from the <i>hLegacyProv</i> handle.</li>
     * <li>Open the CNG provider whose name or alias is identical to the CSP name.</li>
     * <li>Obtain the name of the current key container in the CSP.</li>
     * <li>Obtain the CryptoAPI key, translate it into a CNG key, and return it in the <i>phKey</i> parameter.</li>
     * </ol>
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer<UIntPtr>} phProvider A pointer to an <b>NCRYPT_PROV_HANDLE</b> variable that receives the handle of the CNG key storage provider that owns the CNG key placed in the <i>phKey</i> parameter. This parameter can be <b>NULL</b> if this handle is not needed.
     * @param {Pointer<UIntPtr>} phKey A pointer to a <b>NCRYPT_KEY_HANDLE</b> variable that receives the CNG key handle.
     * @param {Pointer} hLegacyProv The handle of the CryptoAPI provider that contains the key to translate. This function will translate the CryptoAPI key that is in the container in this provider.
     * @param {Pointer} hLegacyKey The handle of a CryptoAPI key to use to help determine the key specification for the returned key. This parameter is ignored if the <i>dwLegacyKeySpec</i> parameter contains a value other than zero.
     * 
     * If <i>hLegacyKey</i> is <b>NULL</b> and <i>dwLegacyKeySpec</i> is zero, this function will attempt to determine the key specification from the <i>hLegacyProv</i> handle.
     * @param {Integer} dwLegacyKeySpec 
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are defined for this function.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncrypttranslatehandle
     * @since windows6.0.6000
     */
    static NCryptTranslateHandle(phProvider, phKey, hLegacyProv, hLegacyKey, dwLegacyKeySpec, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptTranslateHandle", "ptr", phProvider, "ptr", phKey, "ptr", hLegacyProv, "ptr", hLegacyKey, "uint", dwLegacyKeySpec, "uint", dwFlags, "int")
        return result
    }

    /**
     * Creates or removes a key change notification.
     * @remarks
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hProvider The handle of the key storage provider. This handle is obtained by using the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenstorageprovider">NCryptOpenStorageProvider</a> function.
     * @param {Pointer<HANDLE>} phEvent The address of a <b>HANDLE</b> variable that either receives or contains the key change notification event handle. This is the same handle that is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstchangenotificationa">FindFirstChangeNotification</a> function. For more information, see the <i>dwFlags</i> parameter description.
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProvider</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptnotifychangekey
     * @since windows6.0.6000
     */
    static NCryptNotifyChangeKey(hProvider, phEvent, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptNotifyChangeKey", "ptr", hProvider, "ptr", phEvent, "uint", dwFlags, "int")
        return result
    }

    /**
     * Creates a secret agreement value from a private and a public key. (NCryptSecretAgreement)
     * @remarks
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hPrivKey The handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key</a> to use to create the secret agreement value. This key and the <i>hPubKey</i> key must come from the same key storage provider.
     * @param {Pointer} hPubKey The handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key</a> to use to create the secret agreement value. This key and the <i>hPrivKey</i> key must come from the same key storage provider.
     * @param {Pointer<UIntPtr>} phAgreedSecret A pointer to an <b>NCRYPT_SECRET_HANDLE</b> variable that receives a handle that represents the secret agreement value. When this handle is no longer needed, release it by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreeobject">NCryptFreeObject</a> function.
     * @param {Integer} dwFlags 
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hPrivKey</i> or the <i>hPubKey</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptsecretagreement
     * @since windows6.0.6000
     */
    static NCryptSecretAgreement(hPrivKey, hPubKey, phAgreedSecret, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptSecretAgreement", "ptr", hPrivKey, "ptr", hPubKey, "ptr", phAgreedSecret, "uint", dwFlags, "int")
        return result
    }

    /**
     * Derives a key from a secret agreement value. (NCryptDeriveKey)
     * @remarks
     * The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa375370(v=vs.85)">BCryptBufferDesc</a> structure in the <i>pParameterList</i> parameter can contain more than one of the <b>KDF_SECRET_PREPEND</b> and <b>KDF_SECRET_APPEND</b> parameters. If more than one of these parameters is specified, the parameter values are concatenated in the order in which they are contained in the array before the KDF is called. For example, assume the following parameter values are specified.
     * 
     * 
     * ```cpp
     * BYTE pbValue0[1] = {0x01};
     * BYTE pbValue1[2] = {0x04, 0x05};
     * BYTE pbValue2[3] = {0x10, 0x11, 0x12};
     * BYTE pbValue3[4] = {0x20, 0x21, 0x22, 0x23};
     * 
     * Parameter[0].type = KDF_SECRET_APPEND
     * Parameter[0].value = pbValue0;
     * Parameter[0].length = sizeof  (pbValue0);
     * Parameter[1].type = KDF_SECRET_PREPEND
     * Parameter[1].value = pbValue1;
     * Parameter[1].length = sizeof (pbValue1);
     * Parameter[2].type = KDF_SECRET_APPEND
     * Parameter[2].value = pbValue2;
     * Parameter[2].length = sizeof (pbValue2);
     * Parameter[3].type = KDF_SECRET_PREPEND
     * Parameter[3].value = pbValue3;
     * Parameter[3].length = sizeof (pbValue3);
     * 
     * ```
     * 
     * 
     * If the above parameter values are specified, the concatenated values to the actual KDF are as follows.
     * 
     * 
     * ``` syntax
     * Type: KDF_SECRET_PREPEND
     * Value: {0x04, 0x05, 0x20, 0x21, 0x22, 0x23}, length 6
     * 
     * Type: KDF_SECRET_APPEND
     * Value: {0x01, 0x10, 0x11, 0x12}, length 4
     * 
     * ```
     * 
     * A service must not call this function from its <a href="https://docs.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicea">StartService Function</a>. If a service calls this function from its StartService function, a deadlock can occur, and the service may stop responding.
     * @param {Pointer} hSharedSecret The secret agreement handle to create the key from. This handle is obtained from the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptsecretagreement">NCryptSecretAgreement</a> function.
     * @param {Pointer<PWSTR>} pwszKDF A pointer to a null-terminated Unicode string that identifies the <i>key derivation function</i> (KDF) to use to derive the key. This can be one of the following strings.
     * @param {Pointer<BCryptBufferDesc>} pParameterList The address of a <a href="https://docs.microsoft.com/windows/win32/api/bcrypt/ns-bcrypt-bcryptbufferdesc">NCryptBufferDesc</a> structure that contains the KDF parameters. This parameter is optional and can be <b>NULL</b> if it is not needed.
     * @param {Pointer<Byte>} pbDerivedKey The address of a buffer that receives the key. The <i>cbDerivedKey</i> parameter contains the size of this buffer. If this parameter is <b>NULL</b>, this function will place the required size, in bytes, in the <b>DWORD</b> pointed to by the <i>pcbResult</i> parameter.
     * @param {Integer} cbDerivedKey The size, in bytes, of the <i>pbDerivedKey</i> buffer.
     * @param {Pointer<UInt32>} pcbResult A pointer to a <b>DWORD</b> that receives the number of bytes that were copied to the <i>pbDerivedKey</i> buffer. If the <i>pbDerivedKey</i> parameter is <b>NULL</b>, this function will place the required size, in bytes, in the <b>DWORD</b> pointed to by this parameter.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. This can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="KDF_USE_SECRET_AS_HMAC_KEY_FLAG"></a><a id="kdf_use_secret_as_hmac_key_flag"></a><dl>
     * <dt><b>KDF_USE_SECRET_AS_HMAC_KEY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The secret agreement value will also serve as the HMAC key. If this flag is specified, the <b>KDF_HMAC_KEY</b> parameter should not be included in the set of parameters in the <i>pParameterList</i> parameter. This flag is only used by the <b>BCRYPT_KDF_HMAC</b> key derivation function.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hSharedSecret</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptderivekey
     * @since windows6.0.6000
     */
    static NCryptDeriveKey(hSharedSecret, pwszKDF, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptDeriveKey", "ptr", hSharedSecret, "ptr", pwszKDF, "ptr", pParameterList, "ptr", pbDerivedKey, "uint", cbDerivedKey, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Creates a key from another key by using the specified key derivation function.
     * @remarks
     * You can use the following algorithm identifiers in the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptcreatepersistedkey">NCryptCreatePersistedKey</a> function before calling <b>NCryptKeyDerivation</b>:
     * 
     * <ul>
     * <li><b>BCRYPT_CAPI_KDF_ALGORITHM</b></li>
     * <li><b>BCRYPT_SP800108_CTR_HMAC_ALGORITHM</b></li>
     * <li><b>BCRYPT_SP80056A_CONCAT_ALGORITHM</b></li>
     * <li><b>BCRYPT_PBKDF2_ALGORITHM</b></li>
     * </ul>
     * @param {Pointer} hKey Handle of the key derivation function (KDF) key.
     * @param {Pointer<BCryptBufferDesc>} pParameterList The address of a <a href="https://docs.microsoft.com/windows/win32/api/bcrypt/ns-bcrypt-bcryptbufferdesc">NCryptBufferDesc</a> structure that contains the KDF parameters. The parameters can be specific to a KDF or generic. The following table shows the required and optional parameters for specific KDFs implemented by the Microsoft software key storage provider.
     * 
     * <table>
     * <tr>
     * <th>KDF</th>
     * <th>Parameter</th>
     * <th>Required</th>
     * </tr>
     * <tr>
     * <td>SP800-108 HMAC in counter mode</td>
     * <td>KDF_LABEL</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_CONTEXT</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_HASH_ALGORITHM</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td>SP800-56A</td>
     * <td>KDF_ALGORITHMID</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_PARTYUINFO</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_PARTYVINFO</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_HASH_ALGORITHM</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_SUPPPUBINFO</td>
     * <td>no</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_SUPPPRIVINFO</td>
     * <td>no</td>
     * </tr>
     * <tr>
     * <td>PBKDF2</td>
     * <td>KDF_HASH_ALGORITHM</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_SALT</td>
     * <td>yes</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>KDF_ITERATION_COUNT</td>
     * <td>no</td>
     * </tr>
     * <tr>
     * <td>CAPI_KDF</td>
     * <td>KDF_HASH_ALGORITHM</td>
     * <td>yes</td>
     * </tr>
     * </table>
     *  
     * 
     * The following generic parameter can be used:<ul>
     * <li>KDF_GENERIC_PARAMETER</li>
     * </ul>Generic parameters map to KDF specific parameters in the following manner:
     * 
     * SP800-108 HMAC in counter mode:<ul>
     * <li>KDF_GENERIC_PARAMETER = KDF_LABEL||0x00||KDF_CONTEXT</li>
     * </ul>
     * 
     * 
     * SP800-56A<ul>
     * <li>KDF_GENERIC_PARAMETER = KDF_ALGORITHMID || KDF_PARTYUINFO || KDF_PARTYVINFO {|| KDF_SUPPPUBINFO } {|| KDF_SUPPPRIVINFO }</li>
     * </ul>
     * 
     * 
     * PBKDF2<ul>
     * <li>KDF_GENERIC_PARAMETER = KDF_SALT </li>
     * <li>KDF_ITERATION_COUNT – defaults to 10000</li>
     * </ul>
     * 
     * 
     * CAPI_KDF<ul>
     * <li>KDF_GENERIC_PARAMETER = Not Used </li>
     * </ul>
     * @param {Pointer<Byte>} pbDerivedKey Address of a buffer that receives the key. The <i>cbDerivedKey</i> parameter contains the size, in bytes, of the key buffer.
     * @param {Integer} cbDerivedKey Size, in bytes, of the buffer pointed to by the <i>pbDerivedKey</i> parameter.
     * @param {Pointer<UInt32>} pcbResult Pointer to a <b>DWORD</b> that receives the number of bytes copied to the buffer pointed to by the <i>pbDerivedKey</i> parameter.
     * @param {Integer} dwFlags Flags that modify function behavior. The following value can be used with the Microsoft software key storage provider.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BCRYPT_CAPI_AES_FLAG"></a><a id="bcrypt_capi_aes_flag"></a><dl>
     * <dt><b>BCRYPT_CAPI_AES_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies that the target algorithm is AES and that the key therefore must be double expanded.
     * This flag is only valid with the CAPI_KDF algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider (KSP) not display any user interface. If the provider must display the UI to operate, the call fails and the KSP should set the <b>NTE_SILENT_CONTEXT</b> error code as the last error.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * 
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hProvider</i> or <i>hKey</i> handles are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The  <i>pwszDerivedKeyAlg</i> and <i>pParameterList</i> parameters cannot be <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was not enough memory to create the key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This function is not supported by the key storage provider.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptkeyderivation
     * @since windows8.0
     */
    static NCryptKeyDerivation(hKey, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptKeyDerivation", "ptr", hKey, "ptr", pParameterList, "ptr", pbDerivedKey, "uint", cbDerivedKey, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Creates a key attestation claim.
     * @param {Pointer} hSubjectKey The subject key handle that the claim is created for.
     * @param {Pointer} hAuthorityKey The authority key handle that the claim is based on.
     * @param {Integer} dwClaimType The type of claim.
     * @param {Pointer<BCryptBufferDesc>} pParameterList An optional parameter list.
     * @param {Pointer<Byte>} pbClaimBlob Output of the created claim blob.
     * @param {Integer} cbClaimBlob 
     * @param {Pointer<UInt32>} pcbResult The output of the created claim blob.
     * @param {Integer} dwFlags As of Windows 10, no  flags are defined. This parameter should be set to 0.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptcreateclaim
     * @since windows10.0.10240
     */
    static NCryptCreateClaim(hSubjectKey, hAuthorityKey, dwClaimType, pParameterList, pbClaimBlob, cbClaimBlob, pcbResult, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptCreateClaim", "ptr", hSubjectKey, "ptr", hAuthorityKey, "uint", dwClaimType, "ptr", pParameterList, "ptr", pbClaimBlob, "uint", cbClaimBlob, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Verifies a key attestation claim.
     * @param {Pointer} hSubjectKey The subject key handle for the claim.
     * @param {Pointer} hAuthorityKey The authority key handle to use when verifying the claim. This parameter is optional because the authority key is self-contained for certain claim types.
     * @param {Integer} dwClaimType The type of claim.
     * @param {Pointer<BCryptBufferDesc>} pParameterList An optional parameter list.
     * @param {Pointer<Byte>} pbClaimBlob The input claim blob.
     * @param {Integer} cbClaimBlob 
     * @param {Pointer<BCryptBufferDesc>} pOutput The output blob.
     * @param {Integer} dwFlags As of Windows 10, no  flags are defined. This parameter should be set to 0.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     * @see https://learn.microsoft.com/windows/win32/api/ncrypt/nf-ncrypt-ncryptverifyclaim
     * @since windows10.0.10240
     */
    static NCryptVerifyClaim(hSubjectKey, hAuthorityKey, dwClaimType, pParameterList, pbClaimBlob, cbClaimBlob, pOutput, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptVerifyClaim", "ptr", hSubjectKey, "ptr", hAuthorityKey, "uint", dwClaimType, "ptr", pParameterList, "ptr", pbClaimBlob, "uint", cbClaimBlob, "ptr", pOutput, "uint", dwFlags, "int")
        return result
    }

    /**
     * The CryptFormatObject function formats the encoded data and returns a Unicode string in the allocated buffer according to the certificate encoding type.
     * @remarks
     * The default behavior of this function is to return a single-line display of the encoded data, that is, each subfield is concatenated with a comma (,) on one line. If you prefer to display the data in multiple lines, set the CRYPT_FORMAT_STR_MULTI_LINE flag. Each subfield will then be displayed on a separate line.
     * 
     * If there is no formatting routine installed or registered for the <i>lpszStructType</i> parameter, the hexadecimal dump of the encoded 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_INTEGER_BLOB</a> will be returned. A user can set the CRYPT_FORMAT_STR_NO_HEX flag to disable the hexadecimal dump.
     * @param {Integer} dwCertEncodingType Type of encoding used on the certificate. The currently defined certificate encoding type used is X509_ASN_ENCODING.
     * @param {Integer} dwFormatType Format type values. Not used. Set to zero.
     * @param {Integer} dwFormatStrType Structure format type values. This parameter can be zero, or you can specify one or more of the following flags by using the bitwise-<b>OR</b> operator to combine them.
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="0"></a><dl>
     * <dt><b>0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Display the data in a single line. Each subfield is concatenated with a comma (,). For more information, see Remarks.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_FORMAT_STR_MULTI_LINE"></a><a id="crypt_format_str_multi_line"></a><dl>
     * <dt><b>CRYPT_FORMAT_STR_MULTI_LINE</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Display the data in multiple lines rather than single line (the default). For more information, see Remarks.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_FORMAT_STR_NO_HEX"></a><a id="crypt_format_str_no_hex"></a><dl>
     * <dt><b>CRYPT_FORMAT_STR_NO_HEX</b></dt>
     * <dt>0x0010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Disables the hexadecimal dump. For more information, see Remarks.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pFormatStruct A pointer to the format of the structure. Not used. Set to <b>NULL</b>.
     * @param {Pointer<PSTR>} lpszStructType A pointer to an OID that defines the encoded data. If the high-order word of the <i>lpszStructType</i> parameter is zero, the low-order word specifies the integer identifier for the type of the given structure. Otherwise, this parameter is a long pointer to a <b>null</b>-terminated string. 
     * 
     * 
     * 
     * 
     * The following table lists supported OIDs with their associated OID extension.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPC_FINANCIAL_CRITERIA_OBJID"></a><a id="spc_financial_criteria_objid"></a><dl>
     * <dt><b>SPC_FINANCIAL_CRITERIA_OBJID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 1.3.6.1.4.1.311.2.1.27
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPC_SP_AGENCY_INFO_OBJID"></a><a id="spc_sp_agency_info_objid"></a><dl>
     * <dt><b>SPC_SP_AGENCY_INFO_OBJID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 1.3.6.1.4.1.311.2.1.10
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_AUTHORITY_INFO_ACCESS"></a><a id="szoid_authority_info_access"></a><a id="SZOID_AUTHORITY_INFO_ACCESS"></a><dl>
     * <dt><b>szOID_AUTHORITY_INFO_ACCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 1.3.6.1.5.5.7.1.1
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_AUTHORITY_KEY_IDENTIFIER2"></a><a id="szoid_authority_key_identifier2"></a><a id="SZOID_AUTHORITY_KEY_IDENTIFIER2"></a><dl>
     * <dt><b>szOID_AUTHORITY_KEY_IDENTIFIER2</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.35
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_BASIC_CONSTRAINTS2"></a><a id="szoid_basic_constraints2"></a><a id="SZOID_BASIC_CONSTRAINTS2"></a><dl>
     * <dt><b>szOID_BASIC_CONSTRAINTS2</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.19
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_CERT_POLICIES"></a><a id="szoid_cert_policies"></a><a id="SZOID_CERT_POLICIES"></a><dl>
     * <dt><b>szOID_CERT_POLICIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.32
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_CRL_DIST_POINTS"></a><a id="szoid_crl_dist_points"></a><a id="SZOID_CRL_DIST_POINTS"></a><dl>
     * <dt><b>szOID_CRL_DIST_POINTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.31
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_CRL_REASON_CODE"></a><a id="szoid_crl_reason_code"></a><a id="SZOID_CRL_REASON_CODE"></a><dl>
     * <dt><b>szOID_CRL_REASON_CODE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.21
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_ENHANCED_KEY_USAGE"></a><a id="szoid_enhanced_key_usage"></a><a id="SZOID_ENHANCED_KEY_USAGE"></a><dl>
     * <dt><b>szOID_ENHANCED_KEY_USAGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.37
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_ISSUER_ALT_NAME2"></a><a id="szoid_issuer_alt_name2"></a><a id="SZOID_ISSUER_ALT_NAME2"></a><dl>
     * <dt><b>szOID_ISSUER_ALT_NAME2</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.18
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_KEY_ATTRIBUTES"></a><a id="szoid_key_attributes"></a><a id="SZOID_KEY_ATTRIBUTES"></a><dl>
     * <dt><b>szOID_KEY_ATTRIBUTES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.2
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_KEY_USAGE"></a><a id="szoid_key_usage"></a><a id="SZOID_KEY_USAGE"></a><dl>
     * <dt><b>szOID_KEY_USAGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.15
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_KEY_USAGE_RESTRICTION"></a><a id="szoid_key_usage_restriction"></a><a id="SZOID_KEY_USAGE_RESTRICTION"></a><dl>
     * <dt><b>szOID_KEY_USAGE_RESTRICTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.4
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_NEXT_UPDATE_LOCATION"></a><a id="szoid_next_update_location"></a><a id="SZOID_NEXT_UPDATE_LOCATION"></a><dl>
     * <dt><b>szOID_NEXT_UPDATE_LOCATION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 1.3.6.1.4.1.311.10.2
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_RSA_SMIMECapabilities"></a><a id="szoid_rsa_smimecapabilities"></a><a id="SZOID_RSA_SMIMECAPABILITIES"></a><dl>
     * <dt><b>szOID_RSA_SMIMECapabilities</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 1.2.840.113549.1.9.15
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_SUBJECT_ALT_NAME2"></a><a id="szoid_subject_alt_name2"></a><a id="SZOID_SUBJECT_ALT_NAME2"></a><dl>
     * <dt><b>szOID_SUBJECT_ALT_NAME2</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.17
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="szOID_SUBJECT_KEY_IDENTIFIER"></a><a id="szoid_subject_key_identifier"></a><a id="SZOID_SUBJECT_KEY_IDENTIFIER"></a><dl>
     * <dt><b>szOID_SUBJECT_KEY_IDENTIFIER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 2.5.29.14
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} pbEncoded A pointer to the encoded data to be formatted. If <i>lpszStructType</i> is one of the OIDs listed above, the <i>pbEncoded</i> is the encoded extension.
     * @param {Integer} cbEncoded The size, in bytes, of the <i>pbEncoded</i> structure.
     * @param {Pointer<Void>} pbFormat A pointer to a buffer that receives the formatted string. When the buffer that is specified is not large enough to receive the decoded structure, the function sets ERROR_MORE_DATA and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbFormat</i>. This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbFormat A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pbFormat</i> parameter. When the function returns, the variable pointed to by the <i>pcbFormat</i> parameter contains the number of bytes stored in the buffer. This parameter can be <b>NULL</b>, only if <i>pbFormat</i> is <b>NULL</b>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size may be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit into the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>. If it does not succeed, the return value is <b>FALSE</b>. To retrieve extended error information, use the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptformatobject
     * @since windows5.1.2600
     */
    static CryptFormatObject(dwCertEncodingType, dwFormatType, dwFormatStrType, pFormatStruct, lpszStructType, pbEncoded, cbEncoded, pbFormat, pcbFormat) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptFormatObject", "uint", dwCertEncodingType, "uint", dwFormatType, "uint", dwFormatStrType, "ptr", pFormatStruct, "ptr", lpszStructType, "ptr", pbEncoded, "uint", cbEncoded, "ptr", pbFormat, "ptr", pcbFormat, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Encodes a structure of the type indicated by the value of the lpszStructType parameter.
     * @remarks
     * When encoding a cryptographic object using the preferred <b>CryptEncodeObjectEx</b> function, the terminating <b>NULL</b> character is included. When decoding, using the preferred <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdecodeobjectex">CryptDecodeObjectEx</a> function, the terminating <b>NULL</b> character is not retained.
     * 
     * <b>CryptEncodeObjectEx</b> first looks for an installable extended encoding function. If no extended encoding function is found, the old, nonextended, installable function is located.
     * 
     *  When direct <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> encoding of the object is not possible, you can specify Punycode encoding by setting the <i>dwFlag</i> parameter to the <b>CRYPT_ENCODE_ENABLE_PUNYCODE_FLAG</b> value. Setting the <b>CRYPT_ENCODE_ENABLE_PUNYCODE_FLAG</b> flag has different effects based on the structure type being encoded as specified by the value of the <i>lpszStructType</i> parameter.
     * 
     * Each constant in the list below has an associated structure type that is pointed to by the <i>pvStructInfo</i> parameter. The structure  pointed to, directly or indirectly, has a reference to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_alt_name_entry">CERT_ALT_NAME_ENTRY</a> structure.  
     * 
     * <ul>
     * <li>X509_ALTERNATE_NAME
     * 	</li>
     * <li>szOID_AUTHORITY_INFO_ACCESS
     * 			</li>
     * <li>X509_AUTHORITY_INFO_ACCESS
     * 			</li>
     * <li>X509_AUTHORITY_KEY_ID2
     * 			</li>
     * <li>szOID_AUTHORITY_KEY_IDENTIFIER2
     * 			</li>
     * <li>szOID_CRL_DIST_POINTS
     * 			</li>
     * <li>X509_CRL_DIST_POINTS
     * 			</li>
     * <li>szOID_CROSS_CERT_DIST_POINTS
     * 			</li>
     * <li>X509_CROSS_CERT_DIST_POINTS
     * 			</li>
     * <li>szOID_ISSUER_ALT_NAME
     * 			</li>
     * <li>szOID_ISSUER_ALT_NAME2
     * 			</li>
     * <li>szOID_ISSUING_DIST_POINT
     * 	</li>
     * <li>X509_ISSUING_DIST_POINT
     * 			</li>
     * <li>szOID_NAME_CONSTRAINTS
     * 			</li>
     * <li>X509_NAME_CONSTRAINTS
     * 			</li>
     * <li>szOID_NEXT_UPDATE_LOCATION
     * 			</li>
     * <li>OCSP_REQUEST
     * 			</li>
     * <li>zOID_SUBJECT_ALT_NAME
     * 			</li>
     * <li>szOID_SUBJECT_ALT_NAME2
     * 			</li>
     * </ul>
     * The <b>CRYPT_ENCODE_ENABLE_PUNYCODE_FLAG</b> flag, in conjunction with the value of the <b>dwAltNameChoice</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_alt_name_entry">CERT_ALT_NAME_ENTRY</a> structure, determines the manner in which strings are encoded.
     * 
     * <table>
     * <tr>
     * <th><b>dwAltNameChoice</b></th>
     * <th>Effect</th>
     * </tr>
     * <tr>
     * <td><b>CERT_ALT_NAME_DNS_NAME</b></td>
     * <td>If the host name contains Unicode characters outside of the ASCII character set, the host name is first encoded in Punycode and then encoded as an <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> string. </td>
     * </tr>
     * <tr>
     * <td><b>CERT_ALT_NAME_RFC822_NAME</b></td>
     * <td>If the host name portion of the email address contains Unicode characters outside of the ASCII character set, the host name portion of the email address is encoded in Punycode. The resultant email address is then encoded as an <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> string. </td>
     * </tr>
     * <tr>
     * <td><b>CERT_ALT_NAME_URL</b></td>
     * <td>If the server host name of the URI contains Unicode characters outside of the ASCII character set,  then the host name portion of URI is encoded in Punycode. Then the resultant URI is escaped, and the URL is then  encoded as an <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> string. </td>
     * </tr>
     * </table>
     *  
     * 
     * Each constant in the list below has an associated structure type that is pointed to by the <i>pvStructInfo</i> parameter. The structure  pointed to, directly or indirectly, has a reference to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_hashed_url">CERT_HASHED_URL</a> structure. 
     * 
     * <ul>
     * <li>szOID_BIOMETRIC_EXT</li>
     * <li>X509_BIOMETRIC_EXT</li>
     * <li>szOID_LOGOTYPE_EXT</li>
     * <li>X509_LOGOTYPE_EXT</li>
     * </ul>
     * When encoding the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_hashed_url">CERT_HASHED_URL</a> structure value, if the server host name of the URI contains Unicode characters outside of the ASCII character set, and the <b>CRYPT_ENCODE_ENABLE_PUNYCODE_FLAG</b> is set, the host name portion of URI is encoded in Punycode.  Then the resultant URI is escaped, and the URL is then  encoded as an <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> string.
     * 
     * Each <b>X509_UNICODE_NAME</b> constant in the list below has an associated structure type that is pointed to by the <i>pvStructInfo</i> parameter.
     * 
     * <ul>
     * <li>X509_UNICODE_NAME</li>
     * </ul>
     * If the <i>pszObjId</i> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_rdn_attr">CERT_RDN_ATTR</a> structure is set to <b>szOID_RSA_emailAddr</b> and the email address in the <b>Value</b> member contains Unicode characters outside of the ASCII character set, the host name portion of the email address is encoded in Punycode. Then the resultant email address is then  encoded as an <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> string.
     * 
     * In all cases, the Punycode encoding of the host name is performed on a label-by-label basis.
     * @param {Integer} dwCertEncodingType 
     * @param {Pointer<PSTR>} lpszStructType A pointer to an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) that defines the structure type. If the high-order word of the <i>lpszStructType</i> parameter is zero, the low-order word specifies an integer identifier for the type of the specified structure. Otherwise, this parameter is a pointer to a null-terminated string that contains the string representation of the OID.
     * 
     * For more information about object identifier strings, their predefined constants and corresponding structures, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/constants-for-cryptencodeobject-and-cryptdecodeobject">Constants for CryptEncodeObject and CryptDecodeObject</a>.
     * @param {Pointer<Void>} pvStructInfo A pointer to the structure to be encoded. The structure must be of the type specified by <i>lpszStructType</i>.
     * @param {Integer} dwFlags 
     * @param {Pointer<CRYPT_ENCODE_PARA>} pEncodePara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_encode_para">CRYPT_ENCODE_PARA</a> structure that contains encoding information. This parameter can be <b>NULL</b>.
     * 
     * If either <i>pEncodePara</i> or the <b>pfnAlloc</b> member of <i>pEncodePara</i> is <b>NULL</b>, then <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> is used for the allocation and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> must be called to free the memory.
     * 
     * If both <i>pEncodePara</i> and the <b>pfnAlloc</b> member of <i>pEncodePara</i> are not <b>NULL</b>, then the function pointed to by the <b>pfnAlloc</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_encode_para">CRYPT_ENCODE_PARA</a> structure pointed to by <i>pEncodePara</i> is called for the allocation. The function pointed to by the <b>pfnFree</b> member of <i>pEncodePara</i> must be called to free the memory.
     * @param {Pointer<Void>} pvEncoded A pointer to a buffer to receive the encoded structure. The size of this buffer is specified in the <i>pcbEncoded</i> parameter. When the buffer that is specified is not large enough to receive the decoded structure, the function sets the <b>ERROR_MORE_DATA</b> code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbEncoded</i>.
     * 
     * This parameter can be <b>NULL</b> to retrieve the size of the buffer for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * 
     * If <i>dwFlags</i> contains the <b>CRYPT_ENCODE_ALLOC_FLAG</b> flag, <i>pvEncoded</i> is not a pointer to a buffer but is the address of a pointer to the buffer. Because memory is allocated inside the function and the pointer is stored in <i>pvEncoded</i>, <i>pvEncoded</i> cannot be <b>NULL</b>.
     * @param {Pointer<UInt32>} pcbEncoded A pointer to a <b>DWORD</b> variable that contains the size, in bytes, of the buffer pointed to by the <i>pvEncoded</i> parameter. When the function returns, the variable pointed to by the <i>pcbEncoded</i> parameter contains the number of allocated, encoded bytes stored in the buffer.
     * 
     * When <i>dwFlags</i> contains the <b>CRYPT_ENCODE_ALLOC_FLAG</b> flag, <i>pcbEncoded</i> is the address of a pointer to the <b>DWORD</b> value that is updated.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} Returns nonzero if successful or zero otherwise.
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following table shows some possible error codes that can be returned from <b>GetLastError</b> when <b>CryptEncodeObjectEx</b> fails.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_BAD_ENCODE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error was encountered while encoding.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An encoding function could not be found for the specified <i>dwCertEncodingType</i> and <i>lpszStructType</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pvEncoded</i> parameter is not large enough to hold the returned data, the function sets the <b>ERROR_MORE_DATA</b> code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbEncoded</i>.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptencodeobjectex
     * @since windows5.1.2600
     */
    static CryptEncodeObjectEx(dwCertEncodingType, lpszStructType, pvStructInfo, dwFlags, pEncodePara, pvEncoded, pcbEncoded) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptEncodeObjectEx", "uint", dwCertEncodingType, "ptr", lpszStructType, "ptr", pvStructInfo, "uint", dwFlags, "ptr", pEncodePara, "ptr", pvEncoded, "ptr", pcbEncoded, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptEncodeObject function encodes a structure of the type indicated by the value of the lpszStructType parameter. The use of CryptEncodeObjectEx is recommended as an API that performs the same function with significant performance improvements.
     * @remarks
     * When encoding a cryptographic object using the preferred <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencodeobjectex">CryptEncodeObjectEx</a> function, the terminating <b>NULL</b> character is included. When decoding, using the preferred <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdecodeobjectex">CryptDecodeObjectEx</a> function, the terminating <b>NULL</b> character is not retained.
     * @param {Integer} dwCertEncodingType Type of encoding used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * <div class="alert"><b>Note</b>  Either a certificate or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> is required. X509_ASN_ENCODING is the default. If that type is indicated, it is used. Otherwise, if the PKCS7_ASN_ENCODING type is indicated, it is used.</div>
     * <div> </div>
     * @param {Pointer<PSTR>} lpszStructType A pointer to an OID defining the structure type. If the high-order word of the <i>lpszStructType</i> parameter is zero, the low-order word specifies the integer identifier for the type of the specified structure. Otherwise, this parameter is a long pointer to a null-terminated string.
     * 
     * For more information about object identifier strings, their predefined constants and corresponding structures, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/constants-for-cryptencodeobject-and-cryptdecodeobject">Constants for CryptEncodeObject and CryptDecodeObject</a>.
     * @param {Pointer<Void>} pvStructInfo A pointer to the structure to be encoded. The structure must be of a type specified by <i>lpszStructType</i>.
     * @param {Pointer<Byte>} pbEncoded A pointer to a buffer to receive the encoded structure. When the buffer that is specified is not large enough to receive the decoded structure, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbEncoded</i>.
     * 
     * This parameter can be <b>NULL</b> to retrieve the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbEncoded A pointer to a <b>DWORD</b> variable that contains the size, in bytes, of the buffer pointed to by the <i>pbEncoded</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of allocated encoded bytes stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_BAD_ENCODE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error was encountered while encoding.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An encoding function could not be found for the specified <i>dwCertEncodingType</i> and <i>lpszStructType</i>.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbEncoded</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbEncoded</i>.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptencodeobject
     * @since windows5.1.2600
     */
    static CryptEncodeObject(dwCertEncodingType, lpszStructType, pvStructInfo, pbEncoded, pcbEncoded) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptEncodeObject", "uint", dwCertEncodingType, "ptr", lpszStructType, "ptr", pvStructInfo, "ptr", pbEncoded, "ptr", pcbEncoded, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Decodes a structure of the type indicated by the lpszStructType parameter.
     * @remarks
     * When encoding a cryptographic object using the preferred <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencodeobjectex">CryptEncodeObjectEx</a> function, the terminating <b>NULL</b> character is included. When decoding, using the preferred <b>CryptDecodeObjectEx</b> function, the terminating <b>NULL</b> character is not retained.
     * 
     * Each constant in the list below has an associated structure type that is pointed to by the <i>pvStructInfo</i> parameter. The structure  pointed to, directly or indirectly, has a reference to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_alt_name_entry">CERT_ALT_NAME_ENTRY</a> structure.  
     * 
     * <ul>
     * <li>X509_ALTERNATE_NAME
     * 	</li>
     * <li>szOID_AUTHORITY_INFO_ACCESS
     * 			</li>
     * <li>X509_AUTHORITY_INFO_ACCESS
     * 			</li>
     * <li>X509_AUTHORITY_KEY_ID2
     * 			</li>
     * <li>szOID_AUTHORITY_KEY_IDENTIFIER2
     * 			</li>
     * <li>szOID_CRL_DIST_POINTS
     * 			</li>
     * <li>X509_CRL_DIST_POINTS
     * 			</li>
     * <li>szOID_CROSS_CERT_DIST_POINTS
     * 			</li>
     * <li>X509_CROSS_CERT_DIST_POINTS
     * 			</li>
     * <li>szOID_ISSUER_ALT_NAME
     * 			</li>
     * <li>szOID_ISSUER_ALT_NAME2
     * 			</li>
     * <li>szOID_ISSUING_DIST_POINT
     * 	</li>
     * <li>X509_ISSUING_DIST_POINT
     * 			</li>
     * <li>X509_NAME_CONSTRAINTS
     * 			</li>
     * <li>szOID_NAME_CONSTRAINTS
     * 			</li>
     * <li>szOID_NEXT_UPDATE_LOCATION
     * 			</li>
     * <li>OCSP_REQUEST
     * 			</li>
     * <li>zOID_SUBJECT_ALT_NAME
     * 			</li>
     * <li>szOID_SUBJECT_ALT_NAME2
     * 			</li>
     * </ul>
     * The <b>CRYPT_DECODE_ENABLE_PUNYCODE_FLAG</b> flag, in conjunction with the value of the <b>dwAltNameChoice</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_alt_name_entry">CERT_ALT_NAME_ENTRY</a> structure, determines the manner in which strings are encoded.
     * 
     * <table>
     * <tr>
     * <th><b>dwAltNameChoice</b></th>
     * <th>Effect</th>
     * </tr>
     * <tr>
     * <td><b>CERT_ALT_NAME_DNS_NAME</b></td>
     * <td>If the host name contains a Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> string, it is converted  to the  Unicode equivalent.</td>
     * </tr>
     * <tr>
     * <td><b>CERT_ALT_NAME_RFC822_NAME</b></td>
     * <td>If the host name portion of the email address contains a Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> string, it is converted to its Unicode equivalent.</td>
     * </tr>
     * <tr>
     * <td><b>CERT_ALT_NAME_URL</b></td>
     * <td>The URI is decoded. If the server host name of the URI contains a Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> string, the host name string  is decoded to the Unicode equivalent.</td>
     * </tr>
     * </table>
     *  
     * 
     * Each constant in the list below has an associated structure type that is pointed to by the <i>pvStructInfo</i> parameter. The structure  pointed to, directly or indirectly, has a reference to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_hashed_url">CERT_HASHED_URL</a> structure. 
     * 
     * <ul>
     * <li>szOID_LOGOTYPE_EXT</li>
     * <li>X509_LOGOTYPE_EXT</li>
     * <li>szOID_BIOMETRIC_EXT</li>
     * <li>X509_BIOMETRIC_EXT</li>
     * </ul>
     * When decoding the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_hashed_url">CERT_HASHED_URL</a>  structure value, the URI is decoded.  If the host name contains a Punycode encoded host name, it is converted to the Unicode equivalent.
     * 
     * Each <b>X509_UNICODE_NAME</b> constant in the list below has an associated structure type that is pointed to by the <i>pvStructInfo</i> parameter.
     * 
     * <ul>
     * <li>X509_UNICODE_NAME</li>
     * </ul>
     * If the <i>pszObjId</i> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_rdn_attr">CERT_RDN_ATTR</a> structure is set to <b>szOID_RSA_emailAddr</b> and the email address in the <b>Value</b> member contains Punycode encoded string, it is converted to the Unicode equivalent.
     * @param {Integer} dwCertEncodingType The type of encoding used. It is always acceptable to specify both the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a> and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * <div class="alert"><b>Note</b>  Either a certificate or message encoding type is required. X509_ASN_ENCODING is the default. If that type is indicated, it is used. Otherwise, if the PKCS7_ASN_ENCODING type is indicated, it is used.</div>
     * <div> </div>
     * @param {Pointer<PSTR>} lpszStructType A pointer to an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) that defines the structure type. If the high-order word of the <i>lpszStructType</i> parameter is zero, the low-order word specifies the integer identifier for the type of the specified structure. Otherwise, this parameter is a long pointer to a null-terminated string.
     * 
     * For more information about object identifier strings, their predefined constants, and corresponding structures, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/constants-for-cryptencodeobject-and-cryptdecodeobject">Constants for CryptEncodeObject and CryptDecodeObject</a>.
     * @param {Pointer<Byte>} pbEncoded A pointer to the data to be decoded. The structure must be of the type specified by <i>lpszStructType</i>.
     * @param {Integer} cbEncoded The number of bytes pointed to by <i>pbEncoded</i>. This is the number of bytes to be decoded.
     * @param {Integer} dwFlags This parameter can be one or more of the following flags. The flags can be combined by using a bitwise-<b>OR</b> operation.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_ALLOC_FLAG"></a><a id="crypt_decode_alloc_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_ALLOC_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The called decoding function allocates memory for the decoded structure. A pointer to the allocated structure is returned in <i>pvStructInfo</i>.
     * 
     * If <i>pDecodePara</i> or the <b>pfnAlloc</b>  member of <i>pDecodePara</i> is <b>NULL</b>, then <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> is called for the allocation and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> must be called to free the memory.
     * 
     * If <i>pDecodePara</i> and the <b>pfnAlloc</b>  member of <i>pDecodePara</i> are not <b>NULL</b>, then the function pointed to by <b>pfnAlloc</b> is called for the allocation and the function pointed to by the <b>pfnFree</b>  member of <i>pDecodePara</i> must be called to free the memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_ENABLE_PUNYCODE_FLAG"></a><a id="crypt_decode_enable_punycode_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_ENABLE_PUNYCODE_FLAG</b></dt>
     * <dt>33554432 (0x2000000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is applicable for enabling Punycode decoding of Unicode string values. For more information, see Remarks.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This flag is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_NOCOPY_FLAG"></a><a id="crypt_decode_nocopy_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_NOCOPY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag can be set to enable a "no copy" optimization. This optimization updates the <i>pvStructInfo</i> members to point to content that resides within <i>pbEncoded</i> instead of making a copy of the content and appending it to <i>pvStructInfo</i>. The calling application needs to allocate less memory and execution is faster because a copy is not made. Note that when performing "no copy" decoding, <i>pbEncoded</i> cannot be freed until <i>pvStructInfo</i> is freed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG"></a><a id="crypt_unicode_name_decode_disable_ie4_utf8_flag"></a><dl>
     * <dt><b>CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is applicable when decoding X509_UNICODE_NAME, X509_UNICODE_NAME_VALUE, or X509_UNICODE_ANY_STRING. By default, CERT_RDN_T61_STRING encoded values are initially decoded as UTF8. If the UTF8 decoding fails, then the value is decoded as eight-bit characters. If this flag is set, it skips the initial attempt to decode the value as UTF8 and decodes the value as eight-bit characters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_TO_BE_SIGNED_FLAG"></a><a id="crypt_decode_to_be_signed_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_TO_BE_SIGNED_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * By default, the contents of the buffer pointed to by <i>pbEncoded</i> included the signed content and the signature. If this flag is set, the buffer includes only the "to be signed" content. This flag is applicable to X509_CERT_TO_BE_SIGNED, X509_CERT_CRL_TO_BE_SIGNED, X509_CRT_REQUEST_TO_BE_SIGNED, and X509_KEYGEN_REQUEST_TO_BE_SIGNED objects.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_SHARE_OID_STRING_FLAG"></a><a id="crypt_decode_share_oid_string_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_SHARE_OID_STRING_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When this flag is set, the OID strings are allocated in Crypt32.dll and shared instead of being copied into the returned data structure. This flag can be set if Crypt32.dll is not unloaded before the caller is unloaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG"></a><a id="crypt_decode_no_signature_byte_reversal_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * By default, the signature bytes are reversed. If this flag is set, this byte reversal is inhibited.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CRYPT_DECODE_PARA>} pDecodePara A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_decode_para">CRYPT_DECODE_PARA</a> structure that contains decoding paragraph information. If <i>pDecodePara</i> is set to <b>NULL</b>, then <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> are used to allocate and free memory. If <i>pDecodePara</i> points to a <b>CRYPT_DECODE_PARA</b> structure, that structure passes in callback functions to allocate and free memory. These callback functions override the default memory allocation of <b>LocalAlloc</b> and <b>LocalFree</b>.
     * @param {Pointer<Void>} pvStructInfo If the <i>dwFlags</i> CRYPT_ENCODE_ALLOC_FLAG is set, <i>pvStructInfo</i> is not a pointer to a buffer but is the address of a pointer to the buffer. Because memory is allocated inside the function and the pointer is stored at *<i>pvStructInfo</i>, <i>pvStructInfo</i> must never be <b>NULL</b>.
     * 
     * If CRYPT_ENCODE_ALLOC_FLAG is not set, <i>pvStructInfo</i> is a pointer to a buffer that receives the decoded structure. When the buffer that is specified is not large enough to receive the decoded structure, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbStructInfo</i>.
     * 
     * This parameter can be <b>NULL</b> to retrieve the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbStructInfo A pointer to a <b>DWORD</b> variable that contains the size, in bytes, of the buffer pointed to by the <i>pvStructInfo</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer. The size contained in the variable pointed to by <i>pcbStructInfo</i> can indicate a size larger than the decoded structure because the decoded structure can include pointers to auxiliary data. This size is the sum of the size needed by the decoded structure and the auxiliary data.
     * 
     * When CRYPT_DECODE_ALLOC_FLAG is set, the initial value of *<i>pcbStructInfo</i> is not used by the function, and on return, *<i>pcbStructInfo</i> contains the number of bytes allocated for <i>pvStructInfo</i>.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following table shows some possible error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_BAD_ENCODE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error was encountered while decoding.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A decoding function could not be found for the specified <i>dwCertEncodingType</i> and <i>lpszStructType</i>.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pvStructInfo</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbStructInfo</i>.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptdecodeobjectex
     * @since windows5.1.2600
     */
    static CryptDecodeObjectEx(dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pDecodePara, pvStructInfo, pcbStructInfo) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptDecodeObjectEx", "uint", dwCertEncodingType, "ptr", lpszStructType, "ptr", pbEncoded, "uint", cbEncoded, "uint", dwFlags, "ptr", pDecodePara, "ptr", pvStructInfo, "ptr", pcbStructInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptDecodeObject function decodes a structure of the type indicated by the lpszStructType parameter. The use of CryptDecodeObjectEx is recommended as an API that performs the same function with significant performance improvements.
     * @remarks
     * When encoding a cryptographic object using the preferred <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencodeobjectex">CryptEncodeObjectEx</a> function, the terminating <b>NULL</b> character is included. When decoding, using the preferred <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdecodeobjectex">CryptDecodeObjectEx</a> function, the terminating <b>NULL</b> character is not retained.
     * @param {Integer} dwCertEncodingType Type of encoding used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * <div class="alert"><b>Note</b>  Either a certificate or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> is required. X509_ASN_ENCODING is the default. If that type is indicated, it is used. Otherwise, if the PKCS7_ASN_ENCODING type is indicated, it is used.</div>
     * <div> </div>
     * @param {Pointer<PSTR>} lpszStructType A pointer to an OID defining the structure type. If the high-order word of the <i>lpszStructType</i> parameter is zero, the low-order word specifies the integer identifier for the type of the specified structure. Otherwise, this parameter is a long pointer to a null-terminated string.
     * 
     * For more information about object identifier strings, their predefined constants and corresponding structures, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/constants-for-cryptencodeobject-and-cryptdecodeobject">Constants for CryptEncodeObject and CryptDecodeObject</a>.
     * @param {Pointer<Byte>} pbEncoded A pointer to the encoded structure to be decoded.
     * @param {Integer} cbEncoded Number of bytes pointed to by <i>pbEncoded</i>.
     * @param {Integer} dwFlags The following flags are defined. They can be combined with a bitwise-<b>OR</b> operation.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_NOCOPY_FLAG"></a><a id="crypt_decode_nocopy_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_NOCOPY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag can be set to indicate that "no copy" optimization is enabled. This optimization, where applicable, updates the <i>pvStructInfo</i> parameter to point to content residing within <i>pbEncoded</i> instead of making a copy of the content and appending it to <i>pvStructInfo</i>. For applicable cases, less memory needs to be allocated by the calling application and execution is faster because a copy is not being made. Note that the trade-off when performing a "no copy" decoding is that <i>pbEncoded</i> cannot be freed until <i>pvStructInfo</i> is freed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG"></a><a id="crypt_unicode_name_decode_disable_ie4_utf8_flag"></a><dl>
     * <dt><b>CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is applicable when decoding X509_UNICODE_NAME, X509_UNICODE_NAME_VALUE, or X509_UNICODE_ANY_STRING. By default, CERT_RDN_T61_STRING encoded values are initially decoded as UTF8. If the UTF8 decoding fails, then the value is decoded as eight-bit characters. If this flag is set, it skips the initial attempt to decode the value as UTF8 and decodes the value as eight-bit characters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_TO_BE_SIGNED_FLAG"></a><a id="crypt_decode_to_be_signed_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_TO_BE_SIGNED_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * By default, the contents of the buffer pointed to by <i>pbEncoded</i> included the signed content and the signature. If this flag is set, the buffer includes only the "to be signed" content. This flag is applicable to X509_CERT_TO_BE_SIGNED, X509_CERT_CRL_TO_BE_SIGNED, X509_CRT_REQUEST_TO_BE_SIGNED, and X509_KEYGEN_REQUEST_TO_BE_SIGNED objects.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_SHARE_OID_STRING_FLAG"></a><a id="crypt_decode_share_oid_string_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_SHARE_OID_STRING_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When this flag is set, the OID strings are allocated in Crypt32.dll and shared instead of being copied into the returned data structure. This flag can be set if Crypt32.dll is not unloaded before the caller is unloaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG"></a><a id="crypt_decode_no_signature_byte_reversal_flag"></a><dl>
     * <dt><b>CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * By default, the signature bytes are reversed. If this flag is set, this byte reversal is inhibited.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvStructInfo A pointer to a buffer to receive the decoded structure. When the buffer that is specified is not large enough to receive the decoded structure, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbStructInfo</i>.
     * 
     * This parameter can be <b>NULL</b> to retrieve the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbStructInfo A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pvStructInfo</i> parameter. When the function returns, this <b>DWORD</b> value contains the size of the decoded data copied to <i>pvStructInfo</i>. The size contained in the variable pointed to by <i>pcbStructInfo</i> can indicate a size larger than the decoded structure, as the decoded structure can include pointers to other structures. This size is the sum of the size needed by the decoded structure and other structures pointed to. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_BAD_ENCODE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error was encountered while decoding.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A decoding function could not be found for the specified <i>dwCertEncodingType</i> and <i>lpszStructType</i>
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pvStructInfo</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbStructInfo</i>.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptdecodeobject
     * @since windows5.1.2600
     */
    static CryptDecodeObject(dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pvStructInfo, pcbStructInfo) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptDecodeObject", "uint", dwCertEncodingType, "ptr", lpszStructType, "ptr", pbEncoded, "uint", cbEncoded, "uint", dwFlags, "ptr", pvStructInfo, "ptr", pcbStructInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptInstallOIDFunctionAddress function installs a set of callable object identifier (OID) function addresses.
     * @param {Pointer<HMODULE>} hModule This parameter is updated with the <i>hModule</i> parameter passed to <b>DllMain</b> to prevent the DLL that contains the function addresses from being unloaded by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetoidfunctionaddress">CryptGetOIDFunctionAddress</a> or
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptfreeoidfunctionaddress">CryptFreeOIDFunctionAddress</a>. This would be the case when the DLL has also registered OID functions through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptregisteroidfunction">CryptRegisterOIDFunction</a>.
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. To match both current encoding types, use:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * @param {Pointer<PSTR>} pszFuncName Name of the function set being installed.
     * @param {Integer} cFuncEntry Number of array elements in <i>rgFuncEntry</i>[].
     * @param {Pointer<CRYPT_OID_FUNC_ENTRY>} rgFuncEntry Array of <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_oid_func_entry">CRYPT_OID_FUNC_ENTRY</a> structures, each containing an OID and the starting address of its correlated routine. 
     * 					
     * 
     * Default functions are installed by setting the <b>pszOID</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_oid_func_entry">CRYPT_OID_FUNC_ENTRY</a> structure for their array element to CRYPT_DEFAULT_OID.
     * @param {Integer} dwFlags By default, a new function set is installed at the end of the list of function sets. Setting the CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG flag installs the function set at the beginning of the list.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptinstalloidfunctionaddress
     * @since windows5.1.2600
     */
    static CryptInstallOIDFunctionAddress(hModule, dwEncodingType, pszFuncName, cFuncEntry, rgFuncEntry, dwFlags) {
        result := DllCall("CRYPT32.dll\CryptInstallOIDFunctionAddress", "ptr", hModule, "uint", dwEncodingType, "ptr", pszFuncName, "uint", cFuncEntry, "ptr", rgFuncEntry, "uint", dwFlags, "int")
        return result
    }

    /**
     * The CryptInitOIDFunctionSet initializes and returns the handle of the OID function set identified by a supplied function set name.
     * @param {Pointer<PSTR>} pszFuncName Name of the OID function set.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptinitoidfunctionset
     * @since windows5.1.2600
     */
    static CryptInitOIDFunctionSet(pszFuncName, dwFlags) {
        DllCall("CRYPT32.dll\CryptInitOIDFunctionSet", "ptr", pszFuncName, "uint", dwFlags)
    }

    /**
     * Searches the list of registered and installed functions for an encoding type and object identifier (OID) match.
     * @remarks
     * You can call <b>CryptGetOIDFunctionAddress</b> with the <i>pszOID</i> argument set to <b>CMSG_DEFAULT_INSTALLABLE_FUNC_OID</b> to get the default installable function for the following callback functions.
     * 
     * For retrieval of the default functions, set <i>dwEncodingType</i> to a bitwise <b>OR</b> combination of the following encoding types.
     * 
     * <b>CRYPT_ASN_ENCODING</b>
     * <b>X509_ASN_ENCODING</b>
     * @param {Pointer<Void>} hFuncSet The function set handle previously obtained from a call to 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptinitoidfunctionset">CryptInitOIDFunctionSet</a> function.
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are used; however, additional encoding types can be added in the future. To match both current encoding types, use:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * For functions that do not use an encoding type, set this parameter to zero.
     * @param {Pointer<PSTR>} pszOID If the high-order word of the OID is nonzero, <i>pszOID</i> is a pointer to either an OID string such as "2.5.29.1" or an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">ASCII</a> string such as "file". If the high-order word of the OID is zero, the low-order word specifies the numeric identifier to be used as the object identifier. This resulting OID maps to the function that was either installed or registered with the same OID.
     * @param {Integer} dwFlags This parameter can be the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_GET_INSTALLED_OID_FUNC_FLAG"></a><a id="crypt_get_installed_oid_func_flag"></a><dl>
     * <dt><b>CRYPT_GET_INSTALLED_OID_FUNC_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches only the installed list of functions.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} ppvFuncAddr A pointer to a pointer to a function address. If a match is found, <i>ppvFuncAddr</i> points to the function address.
     * @param {Pointer<Void>} phFuncAddr If a match is found, <i>phFuncAddr</i> points to the function handle. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> for the handle is incremented. 
     * When you have finished using the handle, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptfreeoidfunctionaddress">CryptFreeOIDFunctionAddress</a> function. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  By default, both the registered and installed function lists are searched. To search only the installed list of functions, set CRYPT_GET_INSTALLED_OID_FUNC_FLAG. This flag would be set by a registered function to get the address of a preinstalled function it was replacing. For example, the registered function might handle a new special case and call the preinstalled function to handle the remaining cases.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds and a match is found, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails or no match is found, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptgetoidfunctionaddress
     * @since windows5.1.2600
     */
    static CryptGetOIDFunctionAddress(hFuncSet, dwEncodingType, pszOID, dwFlags, ppvFuncAddr, phFuncAddr) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptGetOIDFunctionAddress", "ptr", hFuncSet, "uint", dwEncodingType, "ptr", pszOID, "uint", dwFlags, "ptr", ppvFuncAddr, "ptr", phFuncAddr, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptGetDefaultOIDDllList function acquires the list of the names of DLL files that contain registered default object identifier (OID) functions for a specified function set and encoding type.
     * @param {Pointer<Void>} hFuncSet Function set handle previously obtained by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptinitoidfunctionset">CryptInitOIDFunctionSet</a>.
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. To match both current encoding types, use:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * <div class="alert"><b>Note</b>  Either a certificate or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> is required. X509_ASN_ENCODING is the default. If that type is indicated, it is used; otherwise, if the PKCS7_ASN_ENCODING type is indicated, it is used.</div>
     * <div> </div>
     * @param {Pointer<PWSTR>} pwszDllList A pointer to a buffer to receive the list of zero or more null-terminated file names. The returned list is terminated with a terminating <b>NULL</b> character. For example, a list of two names could be: 
     * 
     * 
     * 
     * 
     * L"<i>first</i>.dll\0" L"<i>second</i>.dll\0" L"\0"
     * 
     * To retrieve the number of wide characters the buffer must hold, this parameter can be <b>NULL</b>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcchDllList A pointer to a <b>DWORD</b> that specifies the size, in wide characters, of the returned list pointed to by the <i>pwszDllList</i> parameter. When the function returns, the variable pointed to by the <i>pcchDllList</i> parameter contains the number of wide characters stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * This function has the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pwszDllList</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in wide characters, in the variable pointed to by <i>pcchDllList</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptgetdefaultoiddlllist
     * @since windows5.1.2600
     */
    static CryptGetDefaultOIDDllList(hFuncSet, dwEncodingType, pwszDllList, pcchDllList) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptGetDefaultOIDDllList", "ptr", hFuncSet, "uint", dwEncodingType, "ptr", pwszDllList, "ptr", pcchDllList, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptGetDefaultOIDFunctionAddress function loads the DLL that contains a default function address.
     * @param {Pointer<Void>} hFuncSet Function set handle previously obtained from a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptinitoidfunctionset">CryptInitOIDFunctionSet</a>.
     * @param {Integer} dwEncodingType Encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. To match both current encoding types, use:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * @param {Pointer<PWSTR>} pwszDll Name of the DLL to load. Normally, the DLL name is obtained from the list returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetdefaultoiddlllist">CryptGetDefaultOIDDllList</a>. If <i>pwszDll</i> is <b>NULL</b>, a search is performed on the list of installed default functions.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Void>} ppvFuncAddr A pointer to the address of the return function. If the function fails, a <b>NULL</b> is returned in <i>ppvFuncAddr</i>.
     * @param {Pointer<Void>} phFuncAddr Used only if <i>pwszDll</i> is <b>NULL</b>. On the first call to the function, *<i>phFuncAddr</i> must be <b>NULL</b> to acquire the first installed function. 
     * 
     * 
     * 
     * 
     * When this function is successful, *<i>phFuncAddr</i> is set to a function handle. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> for the function handle is incremented.
     * 
     * After the first call to the function, <i>phFuncAddr</i> is set to the pointer returned by the previous call. This input pointer is always freed within the function through a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptfreeoidfunctionaddress">CryptFreeOIDFunctionAddress</a> by this function. The call to free the pointer is always made even when the main function returns an error.
     * 
     * A non-<b>NULL</b><i>phFuncAddr</i> must be released either through a call to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptfreeoidfunctionaddress">CryptFreeOIDFunctionAddress</a> or by being passed back as input to this function or as input to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetoidfunctionaddress">CryptGetOIDFunctionAddress</a>.
     * 
     * If <i>pwszDll</i> is not <b>NULL</b>, the value of this parameter is ignored and a non-<b>NULL</b> pointer is not freed.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptgetdefaultoidfunctionaddress
     * @since windows5.1.2600
     */
    static CryptGetDefaultOIDFunctionAddress(hFuncSet, dwEncodingType, pwszDll, dwFlags, ppvFuncAddr, phFuncAddr) {
        result := DllCall("CRYPT32.dll\CryptGetDefaultOIDFunctionAddress", "ptr", hFuncSet, "uint", dwEncodingType, "ptr", pwszDll, "uint", dwFlags, "ptr", ppvFuncAddr, "ptr", phFuncAddr, "int")
        return result
    }

    /**
     * The CryptFreeOIDFunctionAddress function releases a handle returned by CryptGetOIDFunctionAddress or CryptGetDefaultOIDFunctionAddress by decrementing the reference count on the function handle.
     * @remarks
     * If the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> becomes zero and a DLL is loaded for the function being freed, the DLL might be unloaded. If the DLL exports the <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-dllcanunloadnow">DLLCanUnloadNow</a> function, that function is called and its return is checked. An S_FALSE return from this function cancels the unloading of the DLL at this time. If the function returns S_TRUE or if the DLL does not export the <b>DLLCanUnloadNow</b> function, an unloading process is started. In this case, actual unloading is deferred for 15 seconds. If another <b>CryptFreeOIDFunctionAddress</b> or <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetdefaultoidfunctionaddress">CryptGetDefaultOIDFunctionAddress</a> that requires the DLL occurs before the 15 seconds elapse, the deferred unload process is canceled.
     * @param {Pointer<Void>} hFuncAddr Handle of the function previously obtained from a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetoidfunctionaddress">CryptGetOIDFunctionAddress</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetdefaultoidfunctionaddress">CryptGetDefaultOIDFunctionAddress</a>.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptfreeoidfunctionaddress
     * @since windows5.1.2600
     */
    static CryptFreeOIDFunctionAddress(hFuncAddr, dwFlags) {
        result := DllCall("CRYPT32.dll\CryptFreeOIDFunctionAddress", "ptr", hFuncAddr, "uint", dwFlags, "int")
        return result
    }

    /**
     * Registers a DLL that contains the function to be called for the specified encoding type, function name, and object identifier (OID).
     * @remarks
     * When you have finished using an OID function, unregister it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptunregisteroidfunction">CryptUnregisterOIDFunction</a>  function.
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. To match both current encoding types, use: 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Pointer<PSTR>} pszFuncName Name of the function being registered.
     * @param {Pointer<PSTR>} pszOID OID of the function to be registered. If the high-order word of the OID is nonzero, <i>pszOID</i> is a pointer to either an OID string such as "2.5.29.1" or an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">ASCII</a> string such as "file." If the high-order word of the OID is zero, the low-order word specifies the numeric identifier to be used as the object identifier.
     * @param {Pointer<PWSTR>} pwszDll Name of the DLL file to be registered. It can contain environment-variable strings to be expanded by using the <a href="https://docs.microsoft.com/windows/desktop/api/rrascfg/nn-rrascfg-ieapproviderconfig">ExpandEnvironmentStrings</a> function before loading the DLL.
     * @param {Pointer<PSTR>} pszOverrideFuncName String that specifies a name for the function exported in the DLL. If <i>pszOverrideFuncName</i> is <b>NULL</b>, the function name specified by <i>pszFuncName</i> is used.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptregisteroidfunction
     * @since windows5.1.2600
     */
    static CryptRegisterOIDFunction(dwEncodingType, pszFuncName, pszOID, pwszDll, pszOverrideFuncName) {
        result := DllCall("CRYPT32.dll\CryptRegisterOIDFunction", "uint", dwEncodingType, "ptr", pszFuncName, "ptr", pszOID, "ptr", pwszDll, "ptr", pszOverrideFuncName, "int")
        return result
    }

    /**
     * Removes the registration of a DLL that contains the function to be called for the specified encoding type, function name, and OID.
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are used; however, additional encoding types may be added in the future. To match both current encoding types, use: 
     * 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * For functions that do not use an encoding type, set this parameter to zero.
     * @param {Pointer<PSTR>} pszFuncName Name of the function being unregistered.
     * @param {Pointer<PSTR>} pszOID A pointer to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) that corresponds to the name of the function being unregistered. If the high order word of the OID is nonzero, <i>pszOID</i> is a pointer to either an OID string such as "2.5.29.1" or an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">ASCII</a> string such as "file." If the high order word of the OID is zero, the low order word specifies the integer identifier to be used as the object identifier.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptunregisteroidfunction
     * @since windows5.1.2600
     */
    static CryptUnregisterOIDFunction(dwEncodingType, pszFuncName, pszOID) {
        result := DllCall("CRYPT32.dll\CryptUnregisterOIDFunction", "uint", dwEncodingType, "ptr", pszFuncName, "ptr", pszOID, "int")
        return result
    }

    /**
     * The CryptRegisterDefaultOIDFunction registers a DLL containing the default function to be called for the specified encoding type and function name. Unlike CryptRegisterOIDFunction, the function name to be exported by the DLL cannot be overridden.
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. To match both current encoding types, use: 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Pointer<PSTR>} pszFuncName Name of the function being registered.
     * @param {Integer} dwIndex Index location for the insertion of the DLL in the list of DLLs. If <i>dwIndex</i> is zero, the DLL is inserted at the beginning of the list. If it is CRYPT_REGISTER_LAST_INDEX, the DLL is appended at the end of the list.
     * @param {Pointer<PWSTR>} pwszDll Optional environment-variable string to be expanded using <a href="https://docs.microsoft.com/windows/desktop/api/rrascfg/nn-rrascfg-ieapproviderconfig">ExpandEnvironmentStrings</a> function before loading the DLL.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptregisterdefaultoidfunction
     * @since windows5.1.2600
     */
    static CryptRegisterDefaultOIDFunction(dwEncodingType, pszFuncName, dwIndex, pwszDll) {
        result := DllCall("CRYPT32.dll\CryptRegisterDefaultOIDFunction", "uint", dwEncodingType, "ptr", pszFuncName, "uint", dwIndex, "ptr", pwszDll, "int")
        return result
    }

    /**
     * The CryptUnregisterDefaultOIDFunction removes the registration of a DLL containing the default function to be called for the specified encoding type and function name.
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. To match both current encoding types, use: 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Pointer<PSTR>} pszFuncName Name of the function being unregistered.
     * @param {Pointer<PWSTR>} pwszDll Name of the DLL where the function is located.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptunregisterdefaultoidfunction
     * @since windows5.1.2600
     */
    static CryptUnregisterDefaultOIDFunction(dwEncodingType, pszFuncName, pwszDll) {
        result := DllCall("CRYPT32.dll\CryptUnregisterDefaultOIDFunction", "uint", dwEncodingType, "ptr", pszFuncName, "ptr", pwszDll, "int")
        return result
    }

    /**
     * The CryptSetOIDFunctionValue function sets a value for the specified encoding type, function name, OID, and value name.
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. To match both current encoding types, use: 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Pointer<PSTR>} pszFuncName Name of the function for which the encoding type, OID, and value name is being updated.
     * @param {Pointer<PSTR>} pszOID If the high-order word of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) is nonzero, <i>pszOID</i> is a pointer to either an OID string such as "2.5.29.1" or an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">ASCII</a> string such as "file". If the high-order word of the OID is zero, the low-order word specifies the integer identifier to be used as the object identifier.
     * @param {Pointer<PWSTR>} pwszValueName A pointer to a Unicode string containing the name of the value to set. If a value with this name is not already present, the function creates it.
     * @param {Integer} dwValueType 
     * @param {Pointer<Byte>} pbValueData Points to a buffer containing the data to be stored for the specified value name.
     * @param {Integer} cbValueData Specifies the size, in bytes, of the information pointed to by the <i>pbValueData</i> parameter. If the data is of type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, the size must include the terminating <b>NULL</b> wide character.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptsetoidfunctionvalue
     * @since windows5.1.2600
     */
    static CryptSetOIDFunctionValue(dwEncodingType, pszFuncName, pszOID, pwszValueName, dwValueType, pbValueData, cbValueData) {
        result := DllCall("CRYPT32.dll\CryptSetOIDFunctionValue", "uint", dwEncodingType, "ptr", pszFuncName, "ptr", pszOID, "ptr", pwszValueName, "uint", dwValueType, "ptr", pbValueData, "uint", cbValueData, "int")
        return result
    }

    /**
     * The CryptGetOIDFunctionValue function queries a value associated with an OID.
     * @param {Integer} dwEncodingType Specifies the encoding type to be matched. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. To match both current encoding types, use    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Pointer<PSTR>} pszFuncName A pointer to the null-terminated string that contains the name of the OID function set.
     * @param {Pointer<PSTR>} pszOID If the high-order word of the OID is nonzero, <i>pszOID</i> is a pointer to either a  null-terminated OID string such as "2.5.29.1" or a null-terminated <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">ASCII</a> string such as "file." If the high-order word of the OID is zero, the low-order word specifies the numeric identifier to be used as the object identifier.
     * @param {Pointer<PWSTR>} pwszValueName A pointer to a null-terminated Unicode string that contains the name of the value to be queried.
     * @param {Pointer<UInt32>} pdwValueType A pointer to a variable to receive the value's type. The type returned through this parameter will be one of the following.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="REG_DWORD"></a><a id="reg_dword"></a><dl>
     * <dt><b>REG_DWORD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 32-bit number.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="REG_EXPAND_SZ"></a><a id="reg_expand_sz"></a><dl>
     * <dt><b>REG_EXPAND_SZ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A Unicode string that contains unexpanded references to environment variables such as "%PATH%". Applications should ensure that the string has a terminating null character before using it. For details about when the string does not have a terminating null character, see <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regqueryvalueexa">RegQueryValueEx</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="REG_MULTI_SZ"></a><a id="reg_multi_sz"></a><dl>
     * <dt><b>REG_MULTI_SZ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An array of null-terminated Unicode strings. Applications should ensure that the array is properly terminated by two null characters before using it. For details about when the array is not  terminated by two null characters, see <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regqueryvalueexa">RegQueryValueEx</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="REG_SZ"></a><a id="reg_sz"></a><dl>
     * <dt><b>REG_SZ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A Unicode string. Applications should ensure that the string has a terminating null character before using it. For details about when the string does not have a terminating null character, see <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regqueryvalueexa">RegQueryValueEx</a>.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The <i>pdwValueType</i> parameter can be <b>NULL</b> if a returned type is not required.
     * @param {Pointer<Byte>} pbValueData A pointer to a buffer to receive the value associated with the <i>pwszValueName</i> parameter. The buffer must be big enough to contain the terminating <b>NULL</b> character. This parameter can be <b>NULL</b> if returned data is not required.
     * 
     * This parameter can also be <b>NULL</b> to find the size of the buffer for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbValueData A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pbValueData</i>.
     * 
     * In most cases the value returned in *<i>pcbValueData</i> includes the size of the terminating <b>NULL</b> character in the string.  For information about situations where the <b>NULL</b> character is not included, see the Remarks section of <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regqueryvalueexa">RegQueryValueEx</a>.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * This function has the following error code.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbValueData</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbValueData</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptgetoidfunctionvalue
     * @since windows5.1.2600
     */
    static CryptGetOIDFunctionValue(dwEncodingType, pszFuncName, pszOID, pwszValueName, pdwValueType, pbValueData, pcbValueData) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptGetOIDFunctionValue", "uint", dwEncodingType, "ptr", pszFuncName, "ptr", pszOID, "ptr", pwszValueName, "ptr", pdwValueType, "ptr", pbValueData, "ptr", pcbValueData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptEnumOIDFunction function enumerates the registered object identifier (OID) functions.
     * @param {Integer} dwEncodingType Specifies the encoding type to match. Setting this parameter to CRYPT_MATCH_ANY_ENCODING_TYPE matches any encoding type. Note that if CRYPT_MATCH_ANY_ENCODING_TYPE is not specified, either a certificate or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> is required. If the low-order word that contains the certificate encoding type is nonzero, it is used; otherwise, the high-order word that contains the message encoding type is used. If both are specified, the certificate encoding type in the low-order word is used. 
     * 
     * 
     * 
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>CRYPT_ASN_ENCODING</li>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * <li>CRYPT_MATCH_ANY_ENCODING_TYPE</li>
     * </ul>
     * @param {Pointer<PSTR>} pszFuncName Name of a function for which a case insensitive match search is performed. Setting this parameter to <b>NULL</b> results in a match being found for any function name.
     * @param {Pointer<PSTR>} pszOID If the high-order word of <i>pszOID</i> is nonzero, <i>pszOID</i> specifies the object identifier for which a case insensitive match search is performed. If the high-order word of <i>pszOID</i> is zero, <i>pszOID</i> is used to match a numeric object identifier. Setting this parameter to <b>NULL</b> matches any object identifier. Setting this parameter to CRYPT_DEFAULT_OID restricts the enumeration to only the default functions.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Void>} pvArg A pointer to arguments to be passed through to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nc-wincrypt-pfn_crypt_enum_oid_func">CRYPT_ENUM_OID_FUNCTION</a> callback function.
     * @param {Pointer<PFN_CRYPT_ENUM_OID_FUNC>} pfnEnumOIDFunc A pointer to the callback function that is executed for each OID function that matches the input parameters. For details, see <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nc-wincrypt-pfn_crypt_enum_oid_func">CRYPT_ENUM_OID_FUNCTION</a>.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptenumoidfunction
     * @since windows5.1.2600
     */
    static CryptEnumOIDFunction(dwEncodingType, pszFuncName, pszOID, dwFlags, pvArg, pfnEnumOIDFunc) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptEnumOIDFunction", "uint", dwEncodingType, "ptr", pszFuncName, "ptr", pszOID, "uint", dwFlags, "ptr", pvArg, "ptr", pfnEnumOIDFunc, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the first predefined or registered CRYPT_OID_INFO structure that matches a specified key type and key. The search can be limited to object identifiers (OIDs) within a specified OID group.
     * @remarks
     * The <b>CryptFindOIDInfo</b> function performs a lookup in the active directory to retrieve the friendly names of OIDs under the following conditions:
     * <ul>
     * <li>The key type  in the <i>dwKeyType</i> parameter is set to <b>CRYPT_OID_INFO_OID_KEY</b> or <b>CRYPT_OID_INFO_NAME_KEY</b>.</li>
     * <li>No group identifier is specified in the  <i>dwGroupId</i> parameter or the GroupID refers to EKU OIDs, policy OIDs or template OIDs.</li>
     * </ul>Network retrieval of the friendly name can be suppressed by calling the function with the <b>CRYPT_OID_DISABLE_SEARCH_DS_FLAG</b> flag.
     * 
     * The bit length shifted left 16 bits can be specified in the <i>dwGroupId</i> parameter by using the logical <b>OR</b> operator (|). This is only applicable to the <b>CRYPT_ENCRYPT_ALG_OID_GROUP_ID</b> group entries that have a bit length specified in the <b>ExtraInfo</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_oid_info">CRYPT_OID_INFO</a> structure. Currently, only the AES encryption algorithms have this. The constant <b>CRYPT_OID_INFO_OID_GROUP_BIT_LEN_SHIFT</b> can be used for doing the shift. For example, to find the OID information for <b>BCRYPT_AES_ALGORITHM</b> with bit length equal to 192, call <b>CryptFindOIDInfo</b> as follows.
     * 
     * 
     * ```cpp
     * 
     * DWORD dwBitLen = 192;
     * 
     * PCCRYPT_OID_INFO pOIDInfo = CryptFindOIDInfo(
     *      CRYPT_OID_INFO_CNG_ALGID_KEY,
     *      (void *) BCRYPT_AES_ALGORITHM,
     *      CRYPT_ENCRYPT_ALG_OID_GROUP_ID |
     *          (dwBitLen << CRYPT_OID_INFO_OID_GROUP_BIT_LEN_SHIFT)
     *      );
     * 
     * 
     * ```
     * @param {Integer} dwKeyType Specifies the key type to use when finding OID information. 
     * 
     * 
     * This parameter can be one of the following key types.
     * @param {Pointer<Void>} pvKey The address of a buffer that contains additional search information. This parameter depends on the value of the <i>dwKeyType</i> parameter. For more information, see the table under <i>dwKeyType</i>.
     * @param {Integer} dwGroupId The group identifier to use when finding OID information. Setting this parameter to zero searches all groups according to the <i>dwKeyType</i> parameter. Otherwise, only the indicated <i>dwGroupId</i> is searched.
     * 
     * For information about code that lists the OID information by group identifier, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptenumoidinfo">CryptEnumOIDInfo</a>.
     * 
     * 
     * Optionally, the following flag can be specified in the <i>dwGroupId</i> parameter by using the logical <b>OR</b> operator (|).
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_OID_DISABLE_SEARCH_DS_FLAG"></a><a id="crypt_oid_disable_search_ds_flag"></a><dl>
     * <dt><b>CRYPT_OID_DISABLE_SEARCH_DS_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Disables searching the directory server.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The bit length shifted left 16 bits can be specified in the <i>dwGroupId</i> parameter by using the logical <b>OR</b> operator (|). For more information, see Remarks.
     * @returns {Pointer<CRYPT_OID_INFO>} Returns a pointer to a constant structure of type <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_oid_info">CRYPT_OID_INFO</a>. The returned pointer must not be freed. When the specified key and group is not found, <b>NULL</b> is returned.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptfindoidinfo
     * @since windows5.1.2600
     */
    static CryptFindOIDInfo(dwKeyType, pvKey, dwGroupId) {
        result := DllCall("CRYPT32.dll\CryptFindOIDInfo", "uint", dwKeyType, "ptr", pvKey, "uint", dwGroupId, "ptr")
        return result
    }

    /**
     * The CryptRegisterOIDInfo function registers the OID information specified in the CRYPT_OID_INFO structure, persisting it to the registry.
     * @remarks
     * When you have finished using the OID information, unregister it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptunregisteroidinfo">CryptUnregisterOIDInfo</a>  function.
     * @param {Pointer<CRYPT_OID_INFO>} pInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_oid_info">CRYPT_OID_INFO</a> structure with the OID information to register. Specify the group that the OID information is to be registered for by setting the <b>dwGroupId</b> member of the structure.
     * 
     * <div class="alert"><b>Note</b>  <p class="note">When registering OID information for <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">Suite B</a> algorithms implemented with <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-portal">Cryptography API: Next Generation</a> (CNG), you must set the <b>Algid</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_oid_info">CRYPT_OID_INFO</a> structure to <b>CALG_OID_INFO_CNG_ONLY</b> (0xFFFFFFFF).
     * 
     * </div>
     * <div> </div>
     * @param {Integer} dwFlags By default, the registered OID information is installed after Crypt32.dll's OID entries. If CRYPT_INSTALL_OID_INFO_BEFORE_FLAG is set, new OID information is install before Crypt32.dll's entries.
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptregisteroidinfo
     * @since windows5.1.2600
     */
    static CryptRegisterOIDInfo(pInfo, dwFlags) {
        result := DllCall("CRYPT32.dll\CryptRegisterOIDInfo", "ptr", pInfo, "uint", dwFlags, "int")
        return result
    }

    /**
     * The CryptUnregisterOIDInfo function removes the registration of a specified CRYPT_OID_INFO OID information structure. The structure to be unregistered is identified by the structure's pszOID and dwGroupId members.
     * @param {Pointer<CRYPT_OID_INFO>} pInfo Specifies the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) information for which the registration is to be removed. The group that the registration is removed for is specified by the <b>dwGroupId</b> member in the <i>pInfo</i>.
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptunregisteroidinfo
     * @since windows5.1.2600
     */
    static CryptUnregisterOIDInfo(pInfo) {
        result := DllCall("CRYPT32.dll\CryptUnregisterOIDInfo", "ptr", pInfo, "int")
        return result
    }

    /**
     * Enumerates predefined and registered object identifier (OID) CRYPT_OID_INFO structures. This function enumerates either all of the predefined and registered structures or only structures identified by a selected OID group.
     * @param {Integer} dwGroupId Indicates which OID groups to be matched. Setting <i>dwGroupId</i> to zero matches all groups. If <i>dwGroupId</i> is greater than zero, only the OID entries in the specified group are enumerated. 
     * 
     * 
     * 
     * 
     * The currently defined OID group IDs are:
     * 
     * <ul>
     * <li>CRYPT_HASH_ALG_OID_GROUP_ID</li>
     * <li>CRYPT_ENCRYPT_ALG_OID_GROUP_ID</li>
     * <li>CRYPT_PUBKEY_ALG_OID_GROUP_ID</li>
     * <li>CRYPT_SIGN_ALG_OID_GROUP_ID</li>
     * <li>CRYPT_RDN_ATTR_OID_GROUP_ID</li>
     * <li>CRYPT_EXT_OR_ATTR_OID_GROUP_ID</li>
     * <li>CRYPT_ENHKEY_USAGE_OID_GROUP_ID</li>
     * <li>CRYPT_POLICY_OID_GROUP_ID</li>
     * <li>CRYPT_TEMPLATE_OID_GROUP_ID</li>
     * <li>CRYPT_KDF_OID_GROUP_ID <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>The CRYPT_KDF_OID_GROUP_ID value is not supported.
     * 
     * </li>
     * <li>CRYPT_LAST_OID_GROUP_ID</li>
     * <li>CRYPT_FIRST_ALG_OID_GROUP_ID</li>
     * <li>CRYPT_LAST_ALG_OID_GROUP_ID</li>
     * </ul>
     * @param {Integer} dwFlags This parameter is reserved for future use. It must be zero.
     * @param {Pointer<Void>} pvArg A pointer to arguments to be passed through to the callback function.
     * @param {Pointer<PFN_CRYPT_ENUM_OID_INFO>} pfnEnumOIDInfo A pointer to the callback function that is executed for each OID information entry enumerated. For information about the callback parameters, see <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nc-wincrypt-pfn_crypt_enum_oid_info">CRYPT_ENUM_OID_INFO</a>.
     * @returns {Integer} If the callback function  completes the enumeration, this function returns <b>TRUE</b>. 
     * 
     * If the callback function has stopped the enumeration, this function returns <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptenumoidinfo
     * @since windows5.1.2600
     */
    static CryptEnumOIDInfo(dwGroupId, dwFlags, pvArg, pfnEnumOIDInfo) {
        result := DllCall("CRYPT32.dll\CryptEnumOIDInfo", "uint", dwGroupId, "uint", dwFlags, "ptr", pvArg, "ptr", pfnEnumOIDInfo, "int")
        return result
    }

    /**
     * Finds the localized name for the specified name, such as the localize name of the &quot;Root&quot; system store.
     * @remarks
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetoidfunctionvalue">CryptSetOIDFunctionValue</a> can be called as follows to register additional localized strings.
     * 
     * <i>dwEncodingType</i> = CRYPT_LOCALIZED_NAME_ENCODING_TYPE
     * 
     * <i>pszFuncName</i> = CRYPT_OID_FIND_LOCALIZED_NAME_FUNC
     * 
     * <i>pszOID</i> = CRYPT_LOCALIZED_NAME_OID
     * 
     * <i>pwszValueName</i> = Name to be localized, for example, L"ApplicationStore"
     * 
     * <i>dwValueType</i> = REG_SZ
     * 
     * <i>pbValueData</i> = pointer to the Unicode localized string
     * 
     * <i>cbValueData</i> = (wcslen(Unicode localized string) + 1) * sizeof(WCHAR)
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetoidfunctionvalue">CryptSetOIDFunctionValue</a> can be called as follows to unregister the localized strings.
     * 
     * <i>pbValueData</i> = <b>NULL</b>
     * 
     * <i>cbValueData</i> = 0.
     * 
     * The registered names are searched before the preinstalled names.
     * 
     * <table>
     * <tr>
     * <td>CRYPT_LOCALIZED_NAME_
     * ENCODING_TYPE
     * 
     * </td>
     * <td>0</td>
     * </tr>
     * <tr>
     * <td>CRYPT_LOCALIZED_NAME_
     * OID
     * 
     * </td>
     * <td>"LocalizedNames"</td>
     * </tr>
     * <tr>
     * <td>CRYPT_OID_FIND_LOCALIZED_
     * NAME_FUNC
     * 
     * </td>
     * <td>"CryptDLLFindLocalizedName"</td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} pwszCryptName A pointer to a specified name. An internal table is searched to compare a predefined localized name to the specified name. The search matches the localized name by using a case insensitive string comparison. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  Localized names for the predefined system stores ("Root", "My") and predefined physical stores (".Default", ".LocalMachine") are preinstalled as resource strings in Crypt32.dll.</div>
     * <div> </div>
     * @returns {Pointer<PWSTR>} If the specified name is found, a pointer to the localized name is returned. The returned pointer must not be freed.
     * 						
     * 
     * If the specified name is not found, <b>NULL</b> is returned.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptfindlocalizedname
     * @since windows5.1.2600
     */
    static CryptFindLocalizedName(pwszCryptName) {
        result := DllCall("CRYPT32.dll\CryptFindLocalizedName", "ptr", pwszCryptName, "ptr")
        return result
    }

    /**
     * Opens a cryptographic message for encoding and returns a handle of the opened message.
     * @remarks
     * For functions that perform encryption, the encrypted <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">symmetric keys</a> are reversed from <a href="https://docs.microsoft.com/windows/desktop/SecGloss/l-gly">little-endian</a> format to <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">big-endian</a> format after 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a> is called internally. For functions that perform decryption, the encrypted symmetric keys are reversed from big-endian format to little-endian format before 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a> is called.
     * 
     * 
     * CRYPT_NO_SALT is specified when symmetric keys are generated and imported with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a> and <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a>.
     * 
     * Messages encrypted with the RC2 encryption algorithm use KP_EFFECTIVE_KEYLEN with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetkeyparam">CryptGetKeyParam</a> to determine the effective <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key length</a> of the RC2 key importing or exporting keys.
     * 
     * 
     * 
     * For messages encrypted with the RC2 encryption algorithm, encode and decode operations have been updated to handle ASN RC2 parameters for the <b>ContentEncryptionAlgorithm</b> member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_enveloped_encode_info">CMSG_ENVELOPED_ENCODE_INFO</a> structure.
     * 
     * 
     * 
     * For messages encrypted with the RC4, DES, and 3DES encryption algorithms, encode and decode operations now handle the ASN IV octet string parameter for the <b>ContentEncryptionAlgorithm</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_enveloped_encode_info">CMSG_ENVELOPED_ENCODE_INFO</a> structure.
     * @param {Integer} dwMsgEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Integer} dwFlags Currently defined <i>dwFlags</i> are shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_BARE_CONTENT_FLAG"></a><a id="cmsg_bare_content_flag"></a><dl>
     * <dt><b>CMSG_BARE_CONTENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The streamed output will not have an outer ContentInfo wrapper (as defined by PKCS #7). This makes it suitable to be streamed into an enclosing message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_DETACHED_FLAG"></a><a id="cmsg_detached_flag"></a><dl>
     * <dt><b>CMSG_DETACHED_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is detached data being supplied for the subsequent calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_AUTHENTICATED_ATTRIBUTES_FLAG"></a><a id="cmsg_authenticated_attributes_flag"></a><dl>
     * <dt><b>CMSG_AUTHENTICATED_ATTRIBUTES_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authenticated attributes are forced to be included in the SignerInfo (as defined by PKCS #7) in cases where they would not otherwise be required.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CONTENTS_OCTETS_FLAG"></a><a id="cmsg_contents_octets_flag"></a><dl>
     * <dt><b>CMSG_CONTENTS_OCTETS_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used when calculating the size of a message that has been encoded by using <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">Distinguished Encoding Rules</a> (DER) and that is nested inside an enveloped message. This is particularly useful when performing streaming.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CMS_ENCAPSULATED_CONTENT_FLAG"></a><a id="cmsg_cms_encapsulated_content_flag"></a><dl>
     * <dt><b>CMSG_CMS_ENCAPSULATED_CONTENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When set, non-data type-<a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">inner content</a> is encapsulated within an OCTET STRING. Applicable to both signed and enveloped messages.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CRYPT_RELEASE_CONTEXT_FLAG"></a><a id="cmsg_crypt_release_context_flag"></a><dl>
     * <dt><b>CMSG_CRYPT_RELEASE_CONTEXT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If set, the <b>hCryptProv</b> that is passed to this function is released on the final <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a>. The handle is not released if the function fails.
     * 
     * 
     * <div class="alert"><b>Note</b>  The <b>hCryptProv</b>s of the envelope recipients are not released.</div>
     * <div> </div>
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwMsgType 
     * @param {Pointer<Void>} pvMsgEncodeInfo The address of a structure that contains the encoding information. The type of data depends on the value of the <i>dwMsgType</i> parameter. For details, see <i>dwMsgType</i>.
     * @param {Pointer<PSTR>} pszInnerContentObjID If <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcalculateencodedlength">CryptMsgCalculateEncodedLength</a> is called and the data for 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a> has already been message encoded, the appropriate <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) is passed in <i>pszInnerContentObjID</i>. If <i>pszInnerContentObjID</i> is <b>NULL</b>, then the inner content type is assumed not to have been previously encoded and is therefore encoded as an octet string and given the type CMSG_DATA.
     * 
     * <div class="alert"><b>Note</b>  When streaming is being used, <i>pszInnerContentObjID</i> must be either <b>NULL</b> or szOID_RSA_data.</div>
     * <div> </div>
     * The following algorithm OIDs are commonly used. A user can define new inner content usage by ensuring that the sender and receiver of the message agree upon the semantics associated with the OID.
     * 
     * <ul>
     * <li>szOID_RSA_data</li>
     * <li>szOID_RSA_signedData</li>
     * <li>szOID_RSA_envelopedData</li>
     * <li>szOID_RSA_signEnvData</li>
     * <li>szOID_RSA_digestedData</li>
     * <li>szOID_RSA_encryptedData</li>
     * <li>SPC_INDIRECT_DATA_OBJID</li>
     * </ul>
     * @param {Pointer<CMSG_STREAM_INFO>} pStreamInfo When streaming is being used, this parameter is the address of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_stream_info">CMSG_STREAM_INFO</a> structure. The callback function specified by the <b>pfnStreamOutput</b> member of the <b>CMSG_STREAM_INFO</b> structure is called when 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a> is executed. The callback is passed the encoded bytes that result from the encoding. For more information about how to use the callback, see 
     * <b>CMSG_STREAM_INFO</b>.
     * 
     * <div class="alert"><b>Note</b>  When streaming is being used, the application must not release any data handles that are passed in the <i>pvMsgEncodeInfo</i> parameter, such as the provider handle in the <b>hCryptProv</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signer_encode_info">CMSG_SIGNER_ENCODE_INFO</a> structure, until after the message handle returned by this function is closed by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgclose">CryptMsgClose</a> function.</div>
     * <div> </div>
     * When streaming is not being used, this parameter is set to <b>NULL</b>.
     * 
     * Streaming is not used with the <b>CMSG_HASHED</b> message type. When dealing with hashed data, this parameter must be set to <b>NULL</b>.
     * 
     * Consider the case of a signed message being enclosed in an enveloped message. The encoded output from the streamed encoding of the signed message feeds into another streaming encoding of the enveloped message. The callback for the streaming encoding calls <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a> to encode the enveloped message. The callback for the enveloped message receives the encoded bytes of the nested signed message.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmsgopentoencode
     * @since windows5.1.2600
     */
    static CryptMsgOpenToEncode(dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, pStreamInfo) {
        A_LastError := 0

        DllCall("CRYPT32.dll\CryptMsgOpenToEncode", "uint", dwMsgEncodingType, "uint", dwFlags, "uint", dwMsgType, "ptr", pvMsgEncodeInfo, "ptr", pszInnerContentObjID, "ptr", pStreamInfo)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Calculates the maximum number of bytes needed for an encoded cryptographic message given the message type, encoding parameters, and total length of the data to be encoded.
     * @param {Integer} dwMsgEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Integer} dwFlags Currently defined flags are shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_BARE_CONTENT_FLAG"></a><a id="cmsg_bare_content_flag"></a><dl>
     * <dt><b>CMSG_BARE_CONTENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that streamed output will not have an outer ContentInfo wrapper (as defined by PKCS #7). This makes it suitable to be streamed into an enclosing message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_DETACHED_FLAG"></a><a id="cmsg_detached_flag"></a><dl>
     * <dt><b>CMSG_DETACHED_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that there is detached data being supplied for the subsequent calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CONTENTS_OCTETS_FLAG"></a><a id="cmsg_contents_octets_flag"></a><dl>
     * <dt><b>CMSG_CONTENTS_OCTETS_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used to calculate the size of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">DER</a> encoding of a message to be nested inside an enveloped message. This is particularly useful when streaming is being performed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CMS_ENCAPSULATED_CONTENT_FLAG"></a><a id="cmsg_cms_encapsulated_content_flag"></a><dl>
     * <dt><b>CMSG_CMS_ENCAPSULATED_CONTENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Non-Data type <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">inner content</a> is encapsulated within an OCTET STRING. This flag is applicable for both Signed and Enveloped messages.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwMsgType Currently defined message types are shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_DATA"></a><a id="cmsg_data"></a><dl>
     * <dt><b>CMSG_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An octet (BYTE) string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNED"></a><a id="cmsg_signed"></a><dl>
     * <dt><b>CMSG_SIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signed_encode_info">CMSG_SIGNED_ENCODE_INFO</a>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ENVELOPED"></a><a id="cmsg_enveloped"></a><dl>
     * <dt><b>CMSG_ENVELOPED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_enveloped_encode_info">CMSG_ENVELOPED_ENCODE_INFO</a>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNED_AND_ENVELOPED"></a><a id="cmsg_signed_and_enveloped"></a><dl>
     * <dt><b>CMSG_SIGNED_AND_ENVELOPED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not implemented.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_HASHED"></a><a id="cmsg_hashed"></a><dl>
     * <dt><b>CMSG_HASHED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_hashed_encode_info">CMSG_HASHED_ENCODE_INFO</a>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ENCRYPTED"></a><a id="cmsg_encrypted"></a><dl>
     * <dt><b>CMSG_ENCRYPTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not implemented.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvMsgEncodeInfo A pointer to the data to be encoded. The type of data pointed to depends on the value of <i>dwMsgType</i>. For details, see the <i>dwMsgType</i> table.
     * @param {Pointer<PSTR>} pszInnerContentObjID When calling <b>CryptMsgCalculateEncodedLength</b> with data provided to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a> already encoded, the appropriate object identifier is passed in <i>pszInnerContentObjID</i>. If <i>pszInnerContentObjID</i> is <b>NULL</b>, the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">inner content</a> type is assumed not to have been previously encoded, and is encoded as an octet string and given the type CMSG_DATA. 
     * 
     * 
     * 
     * 
     * When streaming is being used, <i>pszInnerContentObjID</i> must be either <b>NULL</b> or szOID_RSA_data.
     * 
     * The following algorithm object identifiers are commonly used:
     * 
     * <ul>
     * <li>szOID_RSA_data</li>
     * <li>szOID_RSA_signedData</li>
     * <li>szOID_RSA_envelopedData</li>
     * <li>szOID_RSA_signEnvData</li>
     * <li>szOID_RSA_digestedData</li>
     * <li>szOID_RSA_encryptedData</li>
     * <li>SPC_INDIRECT_DATA_OBJID</li>
     * </ul>
     * A user can define new <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">inner content</a> usage. The user must ensure that the sender and receiver of the message agree upon the semantics associated with the object identifier.
     * @param {Integer} cbData The size, in bytes, of the content.
     * @returns {Integer} Returns the required length for an encoded cryptographic message. This length might not be the exact length but it will not be less than the required length. Zero is returned if the function fails.
     * 
     * To retrieve extended error information, use the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function. The following table lists the error codes most commonly returned.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_INVALID_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message type is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNKNOWN_ALGO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The cryptographic algorithm is unknown.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmsgcalculateencodedlength
     * @since windows5.1.2600
     */
    static CryptMsgCalculateEncodedLength(dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, cbData) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgCalculateEncodedLength", "uint", dwMsgEncodingType, "uint", dwFlags, "uint", dwMsgType, "ptr", pvMsgEncodeInfo, "ptr", pszInnerContentObjID, "uint", cbData, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Opens a cryptographic message for decoding and returns a handle of the opened message.
     * @param {Integer} dwMsgEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Integer} dwFlags This parameter can be one of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_DETACHED_FLAG"></a><a id="cmsg_detached_flag"></a><dl>
     * <dt><b>CMSG_DETACHED_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the message to be decoded is detached. If this flag is not set, the message is not detached.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CRYPT_RELEASE_CONTEXT_FLAG"></a><a id="cmsg_crypt_release_context_flag"></a><dl>
     * <dt><b>CMSG_CRYPT_RELEASE_CONTEXT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If set, the <i>hCryptProv</i> passed to this function is released on the final <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a>. The handle is not released if the function fails.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwMsgType Specifies the type of message to decode. In most cases, the message type is determined from the message header and zero is passed for this parameter. In some cases, notably with Internet Explorer 3.0, messages do not have headers and the type of message to be decoded must be supplied in this function call. If the header is missing and zero is passed for this parameter, the function fails.
     * 
     * 
     * This parameter can be one of the following predefined message types.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_DATA"></a><a id="cmsg_data"></a><dl>
     * <dt><b>CMSG_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is encoded data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ENVELOPED"></a><a id="cmsg_enveloped"></a><dl>
     * <dt><b>CMSG_ENVELOPED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is an enveloped message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_HASHED"></a><a id="cmsg_hashed"></a><dl>
     * <dt><b>CMSG_HASHED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is a hashed message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNED"></a><a id="cmsg_signed"></a><dl>
     * <dt><b>CMSG_SIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is a signed message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNED_AND_ENVELOPED"></a><a id="cmsg_signed_and_enveloped"></a><dl>
     * <dt><b>CMSG_SIGNED_AND_ENVELOPED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is a signed and enveloped message.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>Specifies a handle for the cryptographic provider to use for <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hashing</a> the message. For signed messages, <i>hCryptProv</i> is used for signature verification.This parameter's data type is <b>HCRYPTPROV</b>.
     * 
     * Unless there is a strong reason for passing in a specific cryptographic provider in <i>hCryptProv</i>, set this parameter to <b>NULL</b>. Passing in <b>NULL</b> causes the default RSA or DSS provider to be acquired before performing hash, signature verification, or recipient encryption operations.
     * @param {Pointer<CMSG_STREAM_INFO>} pStreamInfo When streaming is not being used, this parameter must be set to <b>NULL</b>.
     * 
     * 
     * <div class="alert"><b>Note</b>  Streaming is not used with CMSG_HASHED messages. When dealing with hashed data, this parameter must be set to <b>NULL</b>.</div>
     * <div> </div>
     * 
     * 
     * When streaming is being used, the <i>pStreamInfo</i> parameter is a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_stream_info">CMSG_STREAM_INFO</a> structure that contains a pointer to a callback to be called when 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a> is executed or when 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcontrol">CryptMsgControl</a> is executed when decoding a streamed enveloped message.
     * 
     * For a signed message, the callback is passed a block of the decoded bytes from the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">inner content</a> of the message.
     * 
     * For an enveloped message, after each call to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a>, you must check to determine whether the CMSG_ENVELOPE_ALGORITHM_PARAM property is available by calling 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsggetparam">CryptMsgGetParam</a> function. <b>CryptMsgGetParam</b> will fail and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return CRYPT_E_STREAM_MSG_NOT_READY until 
     * <b>CryptMsgUpdate</b> has processed enough of the message to make the CMSG_ENVELOPE_ALGORITHM_PARAM property available. When the CMSG_ENVELOPE_ALGORITHM_PARAM property is available, you can iterate through the recipients, retrieving a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure for each recipient by using the <b>CryptMsgGetParam</b> function to retrieve the CMSG_RECIPIENT_INFO_PARAM property. To prevent a denial of service attack from an enveloped message that has an artificially large header block, you must keep track of the amount of memory that has been passed to the <b>CryptMsgUpdate</b> function during this process.  If the amount of data exceeds an application defined limit before the CMSG_ENVELOPE_ALGORITHM_PARAM property is available, you must stop processing the message and call the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgclose">CryptMsgClose</a> function to cause the operating system to release any memory that has been allocated for the message. A suggested limit is the maximum allowable size of a message. For example, if the maximum message size is 10 MB, the limit for this test should be 10 MB.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure is used to find a matching certificate in a previously opened <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a> by using 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetsubjectcertificatefromstore">CertGetSubjectCertificateFromStore</a> function. When the correct certificate is found, 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatecontextproperty">CertGetCertificateContextProperty</a> function with a CERT_KEY_PROV_INFO_PROP_ID parameter is called to retrieve a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a> structure. The structure contains the information necessary to acquire the recipient's private key by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>, using the <b>pwszContainerName</b>, <b>pwszProvName</b>, <b>dwProvType</b>, and <b>dwFlags</b> members of the <b>CRYPT_KEY_PROV_INFO</b> structure. The <b>hCryptProv</b> acquired and the <b>dwKeySpec</b> member of the <b>CRYPT_KEY_PROV_INFO</b> structure are passed to 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcontrol">CryptMsgControl</a> structure as a member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_ctrl_decrypt_para">CMSG_CTRL_DECRYPT_PARA</a> structure to permit the start of the decryption of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/i-gly">inner content</a>. The streaming code will then perform the decryption as the data is input. The resulting blocks of <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">plaintext</a> are passed to the callback function specified by the <b>pfnStreamOutput</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_stream_info">CMSG_STREAM_INFO</a> structure to handle the output of the decrypted message.
     * 
     * 
     * <div class="alert"><b>Note</b>  Streamed decoding of an enveloped message queues the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">ciphertext</a> in memory until <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcontrol">CryptMsgControl</a> is called to start the decryption. The application must initiate decrypting in a timely manner so that the data can be saved to disk or routed elsewhere before the accumulated <i>ciphertext</i> becomes too large and the system runs out of memory.</div>
     * <div> </div>
     * 
     * 
     * In the case of a signed message enclosed in an enveloped message, the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">plaintext</a> output from the streaming decode of the enveloped message can be fed into another streaming decode to process the signed message.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmsgopentodecode
     * @since windows5.1.2600
     */
    static CryptMsgOpenToDecode(dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pStreamInfo) {
        static pRecipientInfo := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        DllCall("CRYPT32.dll\CryptMsgOpenToDecode", "uint", dwMsgEncodingType, "uint", dwFlags, "uint", dwMsgType, "ptr", hCryptProv, "ptr", pRecipientInfo, "ptr", pStreamInfo)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The CryptMsgDuplicate function duplicates a cryptographic message handle by incrementing its reference count.
     * @remarks
     * <b>CryptMsgDuplicate</b> is used to increase the reference count on an <b>HCRYPTMSG</b> handle so that multiple calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgclose">CryptMsgClose</a> are required to actually release the handle.
     * @param {Pointer<Void>} hCryptMsg Handle of the cryptographic message to be duplicated. Duplication is done by incrementing the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> of the message. A copy of the message is not made.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmsgduplicate
     * @since windows5.1.2600
     */
    static CryptMsgDuplicate(hCryptMsg) {
        DllCall("CRYPT32.dll\CryptMsgDuplicate", "ptr", hCryptMsg)
    }

    /**
     * The CryptMsgClose function closes a cryptographic message handle. At each call to this function, the reference count on the message is reduced by one. When the reference count reaches zero, the message is fully released.
     * @param {Pointer<Void>} hCryptMsg Handle of the cryptographic message to be closed.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmsgclose
     * @since windows5.1.2600
     */
    static CryptMsgClose(hCryptMsg) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgClose", "ptr", hCryptMsg, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds contents to a cryptographic message.
     * @param {Pointer<Void>} hCryptMsg Cryptographic message handle of the message to be updated.
     * @param {Pointer<Byte>} pbData A pointer to the buffer holding the data to be encoded or decoded.
     * @param {Integer} cbData Number of bytes of data in the <i>pbData</i> buffer.
     * @param {Integer} fFinal Indicates that the last block of data for encoding or decoding is being processed. Correct usage of this flag is dependent upon whether the message being processed has detached data. The inclusion of detached data in a message is indicated by setting <i>dwFlags</i> to CMSG_DETACHED_FLAG in the call to the function that opened the message. 
     * 
     * 
     * 
     * 
     * If CMSG_DETACHED_FLAG was not set and the message was opened using either 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentoencode">CryptMsgOpenToEncode</a>, <i>fFinal</i> is set to <b>TRUE</b>, and <b>CryptMsgUpdate</b> is only called once.
     * 
     * If the CMSG_DETACHED_FLAG flag was set and a message is opened using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentoencode">CryptMsgOpenToEncode</a>, <i>fFinal</i> is set to <b>TRUE</b> only on the last call to <b>CryptMsgUpdate</b>.
     * 
     * If the CMSG_DETACHED_FLAG flag was set and a message is opened using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a>, <i>fFinal</i> is set to <b>TRUE</b> when the header is processed by a single call to <b>CryptMsgUpdate</b>. It is set to <b>FALSE</b> while processing the detached data in subsequent calls to <b>CryptMsgUpdate</b> until the last detached data block is to be processed. On the last call to <b>CryptMsgUpdate</b>, it is set to <b>TRUE</b>.
     * 
     * When detached data is decoded, the header and the content of a message are contained in different BLOBs. Each BLOB requires that <i>fFinal</i> be set to <b>TRUE</b> when the last call to the function is made for that BLOB.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * Errors encountered in the application defined callback function specified by <i>pStreamInfo</i> in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentoencode">CryptMsgOpenToEncode</a> might be propagated to <b>CryptMsgUpdate</b> if streaming is used. If this happens, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> is not called by <b>CryptMsgUpdate</b> after the callback function returns, which preserves any errors encountered under the control of the application. It is the responsibility of the callback function (or one of the APIs that it calls) to call <b>SetLastError</b> if an error occurs while the application is processing the streamed data.
     * 
     * The following table lists the error codes most commonly returned by the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_INVALID_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message type is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_MSG_ERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error was encountered doing a cryptographic operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_OID_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The object identifier is badly formatted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_ENCODING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is not encoded as expected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNKNOWN_ALGO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The cryptographic algorithm is unknown.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ran out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Propagated errors might be encountered from any of the following functions:<ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetkeyparam">CryptGetKeyParam</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencrypt">CryptEncrypt</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>
     * </li>
     * </ul>
     * 
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmsgupdate
     * @since windows5.1.2600
     */
    static CryptMsgUpdate(hCryptMsg, pbData, cbData, fFinal) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgUpdate", "ptr", hCryptMsg, "ptr", pbData, "uint", cbData, "int", fFinal, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Acquires a message parameter after a cryptographic message has been encoded or decoded.
     * @remarks
     * The following version numbers are returned by calls to <b>CryptMsgGetParam</b> with <i>dwParamType</i> set to CMSG_VERSION_PARAM are defined:
     * 
     * <ul>
     * <li>CMSG_SIGNED_DATA_V1</li>
     * <li>CMSG_SIGNED_DATA_V3</li>
     * <li>CMSG_SIGNED_DATA_PKCS_1_5_VERSION</li>
     * <li>CMSG_SIGNED_DATA_CMS_VERSION</li>
     * <li>CMSG_SIGNER_INFO_V1</li>
     * <li>CMSG_SIGNER_INFO_V3</li>
     * <li>CMSG_SIGNER_INFO_PKCS_1_5_VERSION</li>
     * <li>CMSG_SIGNER_INFO_CMS_VERSION</li>
     * <li>CMSG_HASHED_DATA_V0</li>
     * <li>CMSG_HASHED_DATA_V2</li>
     * <li>CMSG_HASHED_DATA_PKCS_1_5_VERSION</li>
     * <li>CMSG_HASHED_DATA_CMS_VERSION</li>
     * <li>CMSG_ENVELOPED_DATA_V0</li>
     * <li>CMSG_ENVELOPED_DATA_V2</li>
     * <li>CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION</li>
     * <li>CMSG_ENVELOPED_DATA_CMS_VERSION</li>
     * </ul>
     * @param {Pointer<Void>} hCryptMsg Handle of a cryptographic message.
     * @param {Integer} dwParamType Indicates the parameter types of data to be retrieved. The type of data to be retrieved determines the type of structure to use for <i>pvData</i>. 
     * 
     * 
     * 
     * 
     * For an encoded message, only the CMSG_BARE_CONTENT, CMSG_ENCODE_SIGNER, CMSG_CONTENT_PARAM and CMSG_COMPUTED_HASH_PARAM <i>dwParamType</i>s are valid.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ATTR_CERT_COUNT_PARAM"></a><a id="cmsg_attr_cert_count_param"></a><dl>
     * <dt><b>CMSG_ATTR_CERT_COUNT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>DWORD</b>
     * 
     *  Returns the count of the attribute certificates in a SIGNED or ENVELOPED message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ATTR_CERT_PARAM"></a><a id="cmsg_attr_cert_param"></a><dl>
     * <dt><b>CMSG_ATTR_CERT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Retrieves an attribute certificate. To get all the attribute certificates, call <b>CryptMsgGetParam</b> varying <i>dwIndex</i> set to 0 the number of attributes minus one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_BARE_CONTENT_PARAM"></a><a id="cmsg_bare_content_param"></a><dl>
     * <dt><b>CMSG_BARE_CONTENT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Retrieves the encoded content of an encoded cryptographic message, without the outer layer of the CONTENT_INFO structure. That is, only the encoding of the PKCS #7 defined ContentInfo.content field is returned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CERT_COUNT_PARAM"></a><a id="cmsg_cert_count_param"></a><dl>
     * <dt><b>CMSG_CERT_COUNT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to <b>DWORD</b>
     * 
     * Returns the number of certificates in a received SIGNED or ENVELOPED message.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CERT_PARAM"></a><a id="cmsg_cert_param"></a><dl>
     * <dt><b>CMSG_CERT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Returns a signer's certificate. To get all of the signer's certificates, call <b>CryptMsgGetParam</b>, varying <i>dwIndex</i> from 0 to the number of available certificates minus one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_COMPUTED_HASH_PARAM"></a><a id="cmsg_computed_hash_param"></a><dl>
     * <dt><b>CMSG_COMPUTED_HASH_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Returns the  hash calculated of the data in the message. This type is applicable to both encode and decode.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CONTENT_PARAM"></a><a id="cmsg_content_param"></a><dl>
     * <dt><b>CMSG_CONTENT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     *  
     * 
     * 
     * Returns the whole PKCS #7 message from a message opened to encode. Retrieves the inner content of a message opened to decode. If the message is enveloped, the inner type is data, and <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcontrol">CryptMsgControl</a> has been called to decrypt the message, the decrypted content is returned. If the inner type is not data, the encoded BLOB that requires further decoding is returned.
     * If the message is not enveloped and the inner content is DATA, the returned data is the octets of the inner content.
     * This type is applicable to both encode and decode.
     * 
     * For decoding, if the type is CMSG_DATA, the content's octets are returned; else, the encoded inner content is returned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CRL_COUNT_PARAM"></a><a id="cmsg_crl_count_param"></a><dl>
     * <dt><b>CMSG_CRL_COUNT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to <b>DWORD</b>
     * 
     * Returns the count of CRLs in a received, SIGNED or ENVELOPED message.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CRL_PARAM"></a><a id="cmsg_crl_param"></a><dl>
     * <dt><b>CMSG_CRL_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Returns a CRL. To get all the CRLs, call <b>CryptMsgGetParam</b>, varying <i>dwIndex</i> from 0 to the number of available CRLs minus one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ENCODED_MESSAGE"></a><a id="cmsg_encoded_message"></a><dl>
     * <dt><b>CMSG_ENCODED_MESSAGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Changes the contents of an already encoded message. The message must first be decoded with a call to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a>. Then the change to the message is made through a call to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcontrol">CryptMsgControl</a>, <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcountersign">CryptMsgCountersign</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcountersignencoded">CryptMsgCountersignEncoded</a>. The message is then encoded again with a call to <b>CryptMsgGetParam</b>, specifying CMSG_ENCODED_MESSAGE to get a new encoding that reflects the changes made. This can be used, for instance, to add a time-stamp attribute to a message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ENCODED_SIGNER"></a><a id="cmsg_encoded_signer"></a><dl>
     * <dt><b>CMSG_ENCODED_SIGNER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Returns the encoded CMSG_SIGNER_INFO signer information for a message signer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ENCRYPTED_DIGEST"></a><a id="cmsg_encrypted_digest"></a><dl>
     * <dt><b>CMSG_ENCRYPTED_DIGEST</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Returns the encrypted hash of a signature. Typically used for performing time-stamping.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ENCRYPT_PARAM"></a><a id="cmsg_encrypt_param"></a><dl>
     * <dt><b>CMSG_ENCRYPT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array for a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_algorithm_identifier">CRYPT_ALGORITHM_IDENTIFIER</a> structure.
     * 
     *  Returns the encryption algorithm used to encrypted the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_ENVELOPE_ALGORITHM_PARAM"></a><a id="cmsg_envelope_algorithm_param"></a><dl>
     * <dt><b>CMSG_ENVELOPE_ALGORITHM_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array for a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_algorithm_identifier">CRYPT_ALGORITHM_IDENTIFIER</a> structure.
     * 
     *  Returns the encryption algorithm used to encrypt an ENVELOPED message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_HASH_ALGORITHM_PARAM"></a><a id="cmsg_hash_algorithm_param"></a><dl>
     * <dt><b>CMSG_HASH_ALGORITHM_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array for a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_algorithm_identifier">CRYPT_ALGORITHM_IDENTIFIER</a> structure.
     * 
     *  Returns the hash algorithm used to hash the message when it was created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_HASH_DATA_PARAM"></a><a id="cmsg_hash_data_param"></a><dl>
     * <dt><b>CMSG_HASH_DATA_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array
     * 
     * Returns the hash value stored in the message when it was created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_INNER_CONTENT_TYPE_PARAM"></a><a id="cmsg_inner_content_type_param"></a><dl>
     * <dt><b>CMSG_INNER_CONTENT_TYPE_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a <b>null</b>-terminated <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) string.
     * 
     * Returns the inner content type of a received message. This type is not applicable to messages of type DATA.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_RECIPIENT_COUNT_PARAM"></a><a id="cmsg_recipient_count_param"></a><dl>
     * <dt><b>CMSG_RECIPIENT_COUNT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>DWORD</b>
     * 
     * Returns the number of key transport recipients of an ENVELOPED received message.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CMS_RECIPIENT_COUNT_PARAM"></a><a id="cmsg_cms_recipient_count_param"></a><dl>
     * <dt><b>CMSG_CMS_RECIPIENT_COUNT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to <b>DWORD</b>
     * 
     * Returns the total count of all message recipients including key agreement and mail list recipients.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_RECIPIENT_INDEX_PARAM"></a><a id="cmsg_recipient_index_param"></a><dl>
     * <dt><b>CMSG_RECIPIENT_INDEX_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>DWORD</b>
     * 
     * Returns the index of the key transport recipient used to decrypt an ENVELOPED message. This value is available only after a message has been decrypted.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CMS_RECIPIENT_INDEX_PARAM"></a><a id="cmsg_cms_recipient_index_param"></a><dl>
     * <dt><b>CMSG_CMS_RECIPIENT_INDEX_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>DWORD</b>
     * 
     * Returns the index of the key transport, key agreement, or mail list recipient used to decrypt an ENVELOPED message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM"></a><a id="cmsg_cms_recipient_encrypted_key_index_param"></a><dl>
     * <dt><b>CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>DWORD</b>
     * 
     * Returns the index of the encrypted key of a key agreement recipient used to decrypt an ENVELOPED message.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_RECIPIENT_INFO_PARAM"></a><a id="cmsg_recipient_info_param"></a><dl>
     * <dt><b>CMSG_RECIPIENT_INFO_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure.
     * 
     *  Returns certificate information about a key transport message's recipient. To get certificate information on all key transport message's recipients, repetitively call <b>CryptMsgGetParam</b>, varying <i>dwIndex</i> from 0 to the number of recipients minus one.
     * Only the Issuer, SerialNumber, and PublicKeyAlgorithm members of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure returned are available and valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CMS_RECIPIENT_INFO_PARAM"></a><a id="cmsg_cms_recipient_info_param"></a><dl>
     * <dt><b>CMSG_CMS_RECIPIENT_INFO_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_cms_recipient_info">CMSG_CMS_RECIPIENT_INFO</a> structure.
     * 
     * Returns information about a key transport, key agreement, or mail list recipient. It is not limited to key transport message recipients.
     * To get information on all of a message's recipients, repetitively call <b>CryptMsgGetParam</b>, varying <i>dwIndex</i> from 0 to the number of recipients minus one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNER_AUTH_ATTR_PARAM"></a><a id="cmsg_signer_auth_attr_param"></a><dl>
     * <dt><b>CMSG_SIGNER_AUTH_ATTR_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_attributes">CRYPT_ATTRIBUTES</a> structure.
     * 
     *  Returns the authenticated attributes of a message signer. To retrieve the authenticated attributes for a specified signer, call <b>CryptMsgGetParam</b> with <i>dwIndex</i> equal to that signer's index.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNER_CERT_INFO_PARAM"></a><a id="cmsg_signer_cert_info_param"></a><dl>
     * <dt><b>CMSG_SIGNER_CERT_INFO_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure.
     * 
     *  Returns information on a message signer needed to identify the signer's certificate. A certificate's Issuer and SerialNumber can be used to uniquely identify a certificate for retrieval. To retrieve information for all the signers, repetitively call <b>CryptMsgGetParam</b> varying <i>dwIndex</i> from 0 to the number of signers minus one.
     * Only the Issuer and SerialNumber fields in the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure returned contain available, valid data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNER_CERT_ID_PARAM"></a><a id="cmsg_signer_cert_id_param"></a><dl>
     * <dt><b>CMSG_SIGNER_CERT_ID_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_id">CERT_ID</a> structure.
     * 
     * Returns information on a message signer needed to identify the signer's public key. This could be a certificate's Issuer and SerialNumber, a KeyID, or a HashId. To retrieve information for all the signers, call <b>CryptMsgGetParam</b> varying <i>dwIndex</i> from 0 to the number of signers minus one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNER_COUNT_PARAM"></a><a id="cmsg_signer_count_param"></a><dl>
     * <dt><b>CMSG_SIGNER_COUNT_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>DWORD</b>
     * 
     * Returns the number of signers of a received SIGNED message.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNER_HASH_ALGORITHM_PARAM"></a><a id="cmsg_signer_hash_algorithm_param"></a><dl>
     * <dt><b>CMSG_SIGNER_HASH_ALGORITHM_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_algorithm_identifier">CRYPT_ALGORITHM_IDENTIFIER</a> structure.
     * 
     *  Returns the hash algorithm used by a signer of the message. To get the hash algorithm for a specified signer, call <b>CryptMsgGetParam</b> with <i>dwIndex</i> equal to that signer's index.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNER_INFO_PARAM"></a><a id="cmsg_signer_info_param"></a><dl>
     * <dt><b>CMSG_SIGNER_INFO_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signer_info">CMSG_SIGNER_INFO</a> structure.
     * 
     *  Returns information on a message signer. This includes the issuer and serial number of the signer's certificate and authenticated and unauthenticated attributes of the signer's certificate.
     * To retrieve signer information on all of the signers of a message, call <b>CryptMsgGetParam</b> varying <i>dwIndex</i> from 0 to the number of signers minus one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CMS_SIGNER_INFO_PARAM"></a><a id="cmsg_cms_signer_info_param"></a><dl>
     * <dt><b>CMSG_CMS_SIGNER_INFO_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_cms_signer_info">CMSG_CMS_SIGNER_INFO</a> structure.
     * 
     *  Returns information on a message signer. This includes a signerId and authenticated and unauthenticated attributes.
     * To retrieve signer information on all of the signers of a message, call <b>CryptMsgGetParam</b> varying <i>dwIndex</i> from 0 to the number of signers minus one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNER_UNAUTH_ATTR_PARAM"></a><a id="cmsg_signer_unauth_attr_param"></a><dl>
     * <dt><b>CMSG_SIGNER_UNAUTH_ATTR_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_attributes">CRYPT_ATTRIBUTES</a> structure.
     * 
     *  Returns a message signer's unauthenticated attributes. To retrieve the unauthenticated attributes for a specified signer, call <b>CryptMsgGetParam</b>  with <i>dwIndex</i> equal to that signer's index.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_TYPE_PARAM"></a><a id="cmsg_type_param"></a><dl>
     * <dt><b>CMSG_TYPE_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>DWORD</b>
     * 
     * Returns the message type of a decoded message of unknown type. The retrieved message type can be compared to supported types to determine whether processing can continued. For supported message types, see the <i>dwMessageType</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_UNPROTECTED_ATTR_PARAM"></a><a id="cmsg_unprotected_attr_param"></a><dl>
     * <dt><b>CMSG_UNPROTECTED_ATTR_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>BYTE</b> array to receive a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_attributes">CMSG_ATTR</a> structure.
     * 
     *  Returns the unprotected attributes in an enveloped message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_VERSION_PARAM"></a><a id="cmsg_version_param"></a><dl>
     * <dt><b>CMSG_VERSION_PARAM</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvData</i> data type: pointer to a <b>DWORD</b>
     * 
     *  Returns the version of the decoded message. For more information, see the table in the Remarks section.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwIndex Index for the parameter being retrieved, where applicable. When a parameter is not being retrieved, this parameter is ignored and is set to zero.
     * @param {Pointer<Void>} pvData A pointer to a buffer that receives the data retrieved. The form of this data will vary depending on the value of the <i>dwParamType</i> parameter. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * 
     * When processing the data returned in this buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.
     * @param {Pointer<UInt32>} pcbData A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, the variable pointed to by the <i>pcbData</i> parameter contains the number of bytes stored in the buffer.
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table lists the error codes most commonly returned by the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_ATTRIBUTES_MISSING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message does not contain the requested attributes.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_INVALID_INDEX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The index value is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_INVALID_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message type is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_DECRYPTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message content has not been decrypted yet.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_OID_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The object identifier is badly formatted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_ENCODING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is not encoded as expected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified buffer is not large enough to hold the returned data.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * For <i>dwParamType</i> CMSG_COMPUTED_HASH_PARAM, an error can be propagated from 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a>.
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmsggetparam
     * @since windows5.1.2600
     */
    static CryptMsgGetParam(hCryptMsg, dwParamType, dwIndex, pvData, pcbData) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgGetParam", "ptr", hCryptMsg, "uint", dwParamType, "uint", dwIndex, "ptr", pvData, "ptr", pcbData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Performs a control operation after a message has been decoded by a final call to the CryptMsgUpdate function.
     * @param {Pointer<Void>} hCryptMsg A handle of a cryptographic message for which a control is to be applied.
     * @param {Integer} dwFlags The following value is defined when the <i>dwCtrlType</i> parameter is one of the following:
     * 
     * <ul>
     * <li>CMSG_CTRL_DECRYPT</li>
     * <li>CMSG_CTRL_KEY_TRANS_DECRYPT</li>
     * <li>CMSG_CTRL_KEY_AGREE_DECRYPT</li>
     * <li>CMSG_CTRL_MAIL_LIST_DECRYPT</li>
     * </ul>
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CRYPT_RELEASE_CONTEXT_FLAG"></a><a id="cmsg_crypt_release_context_flag"></a><dl>
     * <dt><b>CMSG_CRYPT_RELEASE_CONTEXT_FLAG</b></dt>
     * <dt></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle to the cryptographic provider is released on the final call to the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgclose">CryptMsgClose</a> function. This handle is not released if the  <b>CryptMsgControl</b> function  fails.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the <i>dwCtrlType</i> parameter does not specify a decrypt operation, set this value to zero.
     * @param {Integer} dwCtrlType The type of operation to be performed. Currently defined message control types and the type of structure that should be passed to the <i>pvCtrlPara</i> parameter are shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_ADD_ATTR_CERT"></a><a id="cmsg_ctrl_add_attr_cert"></a><dl>
     * <dt><b>CMSG_CTRL_ADD_ATTR_CERT</b></dt>
     * <dt>14 (0xE)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a>  that contains the encoded bytes of attribute certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_ADD_CERT"></a><a id="cmsg_ctrl_add_cert"></a><dl>
     * <dt><b>CMSG_CTRL_ADD_CERT</b></dt>
     * <dt>10 (0xA)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A
     * 								<a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_INTEGER_BLOB</a>   structure that contains the encoded bytes of the certificate to be added to the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_ADD_CMS_SIGNER_INFO"></a><a id="cmsg_ctrl_add_cms_signer_info"></a><dl>
     * <dt><b>CMSG_CTRL_ADD_CMS_SIGNER_INFO</b></dt>
     * <dt>20 (0x14)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_cms_signer_info">CMSG_CMS_SIGNER_INFO</a> structure that contains signer information. This operation differs from <b>CMSG_CTRL_ADD_SIGNER</b> because the signer information contains the signature.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_ADD_CRL"></a><a id="cmsg_ctrl_add_crl"></a><dl>
     * <dt><b>CMSG_CTRL_ADD_CRL</b></dt>
     * <dt>12 (0xC)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A BLOB  that contains the encoded bytes of the CRL to be added to the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_ADD_SIGNER"></a><a id="cmsg_ctrl_add_signer"></a><dl>
     * <dt><b>CMSG_CTRL_ADD_SIGNER</b></dt>
     * <dt>6 (0x6)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signer_encode_info">CMSG_SIGNER_ENCODE_INFO</a>   structure that contains the signer information to be added to the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR"></a><a id="cmsg_ctrl_add_signer_unauth_attr"></a><dl>
     * <dt><b>CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR</b></dt>
     * <dt>8 (0x8)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-cmsg_ctrl_add_signer_unauth_attr_para">CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA</a>   structure that contains the index of the signer and a BLOB  that contains the unauthenticated attribute information to be added to the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DECRYPT"></a><a id="cmsg_ctrl_decrypt"></a><dl>
     * <dt><b>CMSG_CTRL_DECRYPT</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 
     * 								<a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_ctrl_decrypt_para">CMSG_CTRL_DECRYPT_PARA</a>  structure used to decrypt the message for the specified key transport recipient. This value is applicable to RSA recipients.  This operation specifies that the <b>CryptMsgControl</b> function search the recipient index to obtain the key transport recipient information.  If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return  <b>CRYPT_E_INVALID_INDEX</b> if no key transport recipient is found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_ATTR_CERT"></a><a id="cmsg_ctrl_del_attr_cert"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_ATTR_CERT</b></dt>
     * <dt>15 (0xF)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The index of the attribute certificate to be removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_CERT"></a><a id="cmsg_ctrl_del_cert"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_CERT</b></dt>
     * <dt>11 (0xB)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The index of the certificate to be deleted from the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_CRL"></a><a id="cmsg_ctrl_del_crl"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_CRL</b></dt>
     * <dt>13 (0xD)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The index of the CRL to be deleted from the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_SIGNER"></a><a id="cmsg_ctrl_del_signer"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_SIGNER</b></dt>
     * <dt>7 (0x7)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The index of the signer to be deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR"></a><a id="cmsg_ctrl_del_signer_unauth_attr"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR</b></dt>
     * <dt>9 (0x9)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-cmsg_ctrl_del_signer_unauth_attr_para">CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA</a>   structure that contains an index  that specifies the signer and the index  that specifies the signer's unauthenticated attribute to be deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_ENABLE_STRONG_SIGNATURE"></a><a id="cmsg_ctrl_enable_strong_signature"></a><dl>
     * <dt><b>CMSG_CTRL_ENABLE_STRONG_SIGNATURE</b></dt>
     * <dt>21 (0x15)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_strong_sign_para">CERT_STRONG_SIGN_PARA</a> structure used to perform strong signature checking.
     * 
     * To check for a strong signature, specify this control type before calling <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsggetandverifysigner">CryptMsgGetAndVerifySigner</a> or before calling <b>CryptMsgControl</b> with the following control types set:
     * 
     * <ul>
     * <li><b>CMSG_CTRL_VERIFY_SIGNATURE</b></li>
     * <li><b>CMSG_CTRL_VERIFY_SIGNATURE_EX</b></li>
     * </ul>
     * After the signature is successfully verified, this function checks for a strong signature. If the signature is not strong, the operation will fail and the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> value will be set to <b>NTE_BAD_ALGID</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_KEY_AGREE_DECRYPT"></a><a id="cmsg_ctrl_key_agree_decrypt"></a><dl>
     * <dt><b>CMSG_CTRL_KEY_AGREE_DECRYPT</b></dt>
     * <dt>17 (0x11)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_ctrl_key_agree_decrypt_para">CMSG_CTRL_KEY_AGREE_DECRYPT_PARA</a> structure used to decrypt the message for the specified key agreement session key. Key agreement is used with Diffie-Hellman encryption/decryption.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_KEY_TRANS_DECRYPT"></a><a id="cmsg_ctrl_key_trans_decrypt"></a><dl>
     * <dt><b>CMSG_CTRL_KEY_TRANS_DECRYPT</b></dt>
     * <dt>16 (0x10)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_ctrl_key_trans_decrypt_para">CMSG_CTRL_KEY_TRANS_DECRYPT_PARA</a> structure used to decrypt the message for the specified key transport recipient. Key transport is used with RSA encryption/decryption.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_MAIL_LIST_DECRYPT"></a><a id="cmsg_ctrl_mail_list_decrypt"></a><dl>
     * <dt><b>CMSG_CTRL_MAIL_LIST_DECRYPT</b></dt>
     * <dt>18 (0x12)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 
     * 								<a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_ctrl_mail_list_decrypt_para">CMSG_CTRL_MAIL_LIST_DECRYPT_PARA</a> structure used to decrypt the message for the specified recipient using a previously distributed key-encryption key (KEK).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_VERIFY_HASH"></a><a id="cmsg_ctrl_verify_hash"></a><dl>
     * <dt><b>CMSG_CTRL_VERIFY_HASH</b></dt>
     * <dt>5 (0x5)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_VERIFY_SIGNATURE"></a><a id="cmsg_ctrl_verify_signature"></a><dl>
     * <dt><b>CMSG_CTRL_VERIFY_SIGNATURE</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 
     * 								<a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a>  structure that identifies the signer of the message whose signature is to be verified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_VERIFY_SIGNATURE_EX"></a><a id="cmsg_ctrl_verify_signature_ex"></a><dl>
     * <dt><b>CMSG_CTRL_VERIFY_SIGNATURE_EX</b></dt>
     * <dt>19 (0x13)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-cmsg_ctrl_verify_signature_ex_para">CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA</a>   structure that specifies the signer index and public key to verify the message signature. The signer public key can be a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure, a certificate context, or a certificate chain context.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvCtrlPara A pointer to a structure determined by the value of <i>dwCtrlType</i>.
     * 
     * <table>
     * <tr>
     * <th><i>dwCtrlType</i> value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DECRYPT__CMSG_CTRL_KEY_TRANS_DECRYPT__CMSG_CTRL_KEY_AGREE_DECRYPT__or_CMSG_CTRL_MAIL_LIST_DECRYPT__and_the_streamed_enveloped_message_is_being_decoded"></a><a id="cmsg_ctrl_decrypt__cmsg_ctrl_key_trans_decrypt__cmsg_ctrl_key_agree_decrypt__or_cmsg_ctrl_mail_list_decrypt__and_the_streamed_enveloped_message_is_being_decoded"></a><a id="CMSG_CTRL_DECRYPT__CMSG_CTRL_KEY_TRANS_DECRYPT__CMSG_CTRL_KEY_AGREE_DECRYPT__OR_CMSG_CTRL_MAIL_LIST_DECRYPT__AND_THE_STREAMED_ENVELOPED_MESSAGE_IS_BEING_DECODED"></a><dl>
     * <dt><b>CMSG_CTRL_DECRYPT, CMSG_CTRL_KEY_TRANS_DECRYPT, CMSG_CTRL_KEY_AGREE_DECRYPT, or CMSG_CTRL_MAIL_LIST_DECRYPT, and the streamed enveloped message is being decoded</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Decoding will be done as if the streamed content were being decrypted. If any encrypted streamed content has accumulated prior to this call, some or all of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">plaintext</a>  that results from the decryption of the cipher text is passed back to the application through the callback function specified in the call to 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a> function.
     * 
     * <div class="alert"><b>Note</b>  When streaming an enveloped message, the <b>CryptMsgControl</b>  function is not called until the polling for the availability of the CMSG_ENVELOPE_ALGORITHM_PARAM succeeds. If the polling does not succeed, an error results. For a description of that polling, see 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a> function.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_VERIFY_HASH"></a><a id="cmsg_ctrl_verify_hash"></a><dl>
     * <dt><b>CMSG_CTRL_VERIFY_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> computed from the content of the message is compared against the hash contained in the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_ADD_SIGNER"></a><a id="cmsg_ctrl_add_signer"></a><dl>
     * <dt><b>CMSG_CTRL_ADD_SIGNER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvCtrlPara</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signer_encode_info">CMSG_SIGNER_ENCODE_INFO</a> structure that contains the signer information to be added to the message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_SIGNER"></a><a id="cmsg_ctrl_del_signer"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_SIGNER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * After a deletion is made, any other signer indices in use for this message are no longer valid and must be reacquired by calling 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsggetparam">CryptMsgGetParam</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR"></a><a id="cmsg_ctrl_del_signer_unauth_attr"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * After a deletion is made, any other unauthenticated attribute indices in use for this signer are no longer valid and must be reacquired by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsggetparam">CryptMsgGetParam</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_CERT"></a><a id="cmsg_ctrl_del_cert"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_CERT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * After a deletion is made, any other certificate indices in use for this message are no longer valid and must be reacquired by calling 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsggetparam">CryptMsgGetParam</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_CTRL_DEL_CRL"></a><a id="cmsg_ctrl_del_crl"></a><dl>
     * <dt><b>CMSG_CTRL_DEL_CRL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * After a deletion is made, any other CRL indices in use for this message are no longer valid and will need to be reacquired by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsggetparam">CryptMsgGetParam</a> function.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero and the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function   returns an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>. 
     * 
     * When a streamed, enveloped message is being decoded, errors encountered in the application-defined callback function specified by the <i>pStreamInfo</i>  parameter of the  
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a> function might be propagated to the <b>CryptMsgControl</b> function. If this happens, the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> function is not called by the <b>CryptMsgControl</b> function after the callback function returns. This preserves any errors encountered under the control of the application. It is the responsibility of the callback function (or one of the APIs that it calls) to call the <b>SetLastError</b> function if an error occurs while the application is processing the streamed data.
     * 
     * Propagated errors might be encountered from the following functions:<ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdecrypt">CryptDecrypt</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetuserkey">CryptGetUserKey</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea">CryptVerifySignature</a>
     * </li>
     * </ul>
     * 
     * 
     * The following  error codes are most commonly returned.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_ALREADY_DECRYPTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message content has already been decrypted. This error can be returned if the <i>dwCtrlType</i> parameter is set to   CMSG_CTRL_DECRYPT.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_AUTH_ATTR_MISSING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message does not contain an expected authenticated attribute. This error can be returned if the <i>dwCtrlType</i> parameter is set to   CMSG_CTRL_VERIFY_SIGNATURE.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_BAD_ENCODE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error was encountered while encoding or decoding. This error can be returned if the <i>dwCtrlType</i>  parameter is set to  CMSG_CTRL_VERIFY_SIGNATURE.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_CONTROL_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The control type is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_HASH_VALUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash value is incorrect.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_INVALID_INDEX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The index value is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_INVALID_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message type is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_OID_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The object identifier is badly formatted. This error can be returned if the <i>dwCtrlType</i>  parameter is set to  CMSG_CTRL_ADD_SIGNER.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_RECIPIENT_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The enveloped data message does not contain the specified recipient. This error can be returned if the <i>dwCtrlType</i>  parameter is set to CMSG_CTRL_DECRYPT.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_SIGNER_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified signer for the message was not found. This error can be returned if the <i>dwCtrlType</i>  parameter is set to  CMSG_CTRL_VERIFY_SIGNATURE.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNKNOWN_ALGO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The cryptographic algorithm is unknown.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_ENCODING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is not encoded as expected. This error can be returned if the <i>dwCtrlType</i>  parameter is set to  CMSG_CTRL_VERIFY_SIGNATURE.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid. This error can be returned if the <i>dwCtrlType</i> parameter is set to   CMSG_CTRL_DECRYPT.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not enough memory was available to complete the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmsgcontrol
     * @since windows5.1.2600
     */
    static CryptMsgControl(hCryptMsg, dwFlags, dwCtrlType, pvCtrlPara) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgControl", "ptr", hCryptMsg, "uint", dwFlags, "uint", dwCtrlType, "ptr", pvCtrlPara, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Verifies a countersignature in terms of the SignerInfo structure (as defined by PKCS
     * @remarks
     * Countersigner verification is done using the PKCS #7 <b>SIGNERINFO</b> structure. The signature must contain the encrypted hash of the encryptedDigest field of <i>pbSignerInfo</i>.
     * 
     * The issuer and serial number of the countersigner must match the countersigner information from <i>pbSignerInfoCountersignature</i>. The only fields referenced from <i>pciCountersigner</i> are SerialNumber, Issuer, and SubjectPublicKeyInfo. The SubjectPublicKeyInfo is used to access the public key that is then used to encrypt the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> from the <i>pciCountersigner</i> so compare it with the hash from the <i>pbSignerInfo</i>.
     * @param {Pointer} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b><b>NULL</b> or the handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic provider</a> to use to <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> the encryptedDigest field of <i>pbSignerInfo</i>.This parameter's data type is <b>HCRYPTPROV</b>.
     * 
     * Unless there is a strong reason for passing in a specific cryptographic provider in <i>hCryptProv</i>, pass <b>NULL</b> to cause the default RSA or DSS provider to be used.
     * @param {Integer} dwEncodingType Specifies the encoding type used. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. For either current encoding type, use: 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Pointer<Byte>} pbSignerInfo A pointer to the encoded <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a> that contains the signer of the contents of a message to be countersigned.
     * @param {Integer} cbSignerInfo Count, in bytes, of the encoded BLOB for the signer of the contents.
     * @param {Pointer<Byte>} pbSignerInfoCountersignature A pointer to the encoded BLOB containing the countersigner information.
     * @param {Integer} cbSignerInfoCountersignature Count, in bytes, of the encoded BLOB for the countersigner of the message.
     * @param {Pointer<CERT_INFO>} pciCountersigner A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> that includes with the issuer and serial number of the countersigner. For more information, see Remarks.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table lists the error codes most commonly returned by the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_AUTH_ATTR_MISSING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message does not contain an expected authenticated attribute.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_HASH_VALUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash value is not correct.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_ENCODING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is not encoded as expected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNKNOWN_ALGO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The cryptographic algorithm is unknown.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ran out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Propagated errors from the following functions might be returned.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea">CryptVerifySignature</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>
     * </li>
     * </ul>
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmsgverifycountersignatureencoded
     * @since windows5.1.2600
     */
    static CryptMsgVerifyCountersignatureEncoded(hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, pciCountersigner) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgVerifyCountersignatureEncoded", "ptr", hCryptProv, "uint", dwEncodingType, "ptr", pbSignerInfo, "uint", cbSignerInfo, "ptr", pbSignerInfoCountersignature, "uint", cbSignerInfoCountersignature, "ptr", pciCountersigner, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Verifies that the pbSignerInfoCounterSignature parameter contains the encrypted hash of the encryptedDigest field of the pbSignerInfo parameter structure.
     * @remarks
     * Countersigner verification is done using the PKCS #7 <b>SIGNERINFO</b> structure. The signature must contain the encrypted hash of the encryptedDigest field of <i>pbSignerInfo</i>.
     * 
     * The issuer and serial number of the countersigner must match the countersigner information from <i>pbSignerInfoCountersignature</i>. The only fields referenced from <i>pciCountersigner</i> are SerialNumber, Issuer, and SubjectPublicKeyInfo. The SubjectPublicKeyInfo is used to access the public key that is then used to encrypt the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> from the <i>pciCountersigner</i> so compare it with the hash from the <i>pbSignerInfo</i>.
     * @param {Pointer} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b><b>NULL</b> or the handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic provider</a> to use to <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> the encryptedDigest field of <i>pbSignerInfo</i>.This parameter's data type is <b>HCRYPTPROV</b>.
     * 
     * Unless there is a strong reason for passing in a specific cryptographic provider in <i>hCryptProv</i>, pass <b>NULL</b> to cause the default RSA or DSS provider to be used.
     * @param {Integer} dwEncodingType The encoding type used. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. For either current encoding type, use:  
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Pointer<Byte>} pbSignerInfo A pointer to the encoded <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a> that contains the signer of the contents of a message to be countersigned.
     * @param {Integer} cbSignerInfo The count, in bytes, of the encoded BLOB for the signer of the contents.
     * @param {Pointer<Byte>} pbSignerInfoCountersignature A pointer to the encoded BLOB containing the countersigner information.
     * @param {Integer} cbSignerInfoCountersignature The count, in bytes, of the encoded BLOB for the countersigner of the message.
     * @param {Integer} dwSignerType The structure that contains the signer information. The following table shows the predefined values and the structures indicated.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>CMSG_VERIFY_SIGNER_PUBKEY</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSigner</i> is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>CMSG_VERIFY_SIGNER_CERT</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSigner</i> is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>CMSG_VERIFY_SIGNER_CHAIN</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSigner</i> is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvSigner A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure, a certificate context, or a chain context depending on the value of <i>dwSignerType</i>.
     * @param {Integer} dwFlags Flags that modify the function behavior. This can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_VERIFY_COUNTER_SIGN_ENABLE_STRONG_FLAG"></a><a id="cmsg_verify_counter_sign_enable_strong_flag"></a><dl>
     * <dt><b>CMSG_VERIFY_COUNTER_SIGN_ENABLE_STRONG_FLAG</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Performs a strong signature check after successful signature verification. Set the <i>pvExtra</i> parameter to point to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_strong_sign_para">CERT_STRONG_SIGN_PARA</a> structure that contains the parameters needed to check the signature strength..
     * 
     * <b>Windows 8 and Windows Server 2012:  </b>Support for this flag begins.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvExtra If you set the <i>dwFlags</i> parameter to <b>CMSG_VERIFY_COUNTER_SIGN_ENABLE_STRONG_FLAG</b>, set this parameter (<i>pvExtra</i>) to point to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_strong_sign_para">CERT_STRONG_SIGN_PARA</a> structure that contains the parameters used to check the signature strength.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). 
     * 		  For extended error information, call 
     *            <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following error codes are most commonly returned by the 
     * 		       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_AUTH_ATTR_MISSING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message does not contain an expected authenticated attribute.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_HASH_VALUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash value is not correct.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_ENCODING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is not encoded as expected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNKNOWN_ALGO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The cryptographic algorithm is unknown.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ran out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Propagated errors from the following functions might be returned.
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea">CryptVerifySignature</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>
     * </li>
     * </ul>
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmsgverifycountersignatureencodedex
     * @since windows5.1.2600
     */
    static CryptMsgVerifyCountersignatureEncodedEx(hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, dwSignerType, pvSigner, dwFlags, pvExtra) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgVerifyCountersignatureEncodedEx", "ptr", hCryptProv, "uint", dwEncodingType, "ptr", pbSignerInfo, "uint", cbSignerInfo, "ptr", pbSignerInfoCountersignature, "uint", cbSignerInfoCountersignature, "uint", dwSignerType, "ptr", pvSigner, "uint", dwFlags, "ptr", pvExtra, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Countersigns an existing signature in a message.
     * @param {Pointer<Void>} hCryptMsg Cryptographic message handle to be used.
     * @param {Integer} dwIndex Zero-based index of the signer in the signed or signed-and-enveloped message to be countersigned.
     * @param {Integer} cCountersigners Number of countersigners in the <i>rgCountersigners</i> array.
     * @param {Pointer<CMSG_SIGNER_ENCODE_INFO>} rgCountersigners Array of countersigners' 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signer_encode_info">CMSG_SIGNER_ENCODE_INFO</a> structures.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * An error can be propagated from
     * 								<a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcountersignencoded">CryptMsgCountersignEncoded</a>.
     * 
     * The following error codes are returned most often.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ran out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified area is not large enough to hold the returned data.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmsgcountersign
     * @since windows5.1.2600
     */
    static CryptMsgCountersign(hCryptMsg, dwIndex, cCountersigners, rgCountersigners) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgCountersign", "ptr", hCryptMsg, "uint", dwIndex, "uint", cCountersigners, "ptr", rgCountersigners, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Countersigns an existing PKCS
     * @param {Integer} dwEncodingType Specifies the encoding type used. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. For either current encoding type, use: 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Pointer<Byte>} pbSignerInfo A pointer to the encoded SignerInfo that is to be countersigned.
     * @param {Integer} cbSignerInfo Count, in bytes, of the encoded SignerInfo data.
     * @param {Integer} cCountersigners Number of countersigners in the <i>rgCountersigners</i> array.
     * @param {Pointer<CMSG_SIGNER_ENCODE_INFO>} rgCountersigners Array of countersigners' 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signer_encode_info">CMSG_SIGNER_ENCODE_INFO</a> structures.
     * @param {Pointer<Byte>} pbCountersignature A pointer to a buffer to receive an encoded PKCS #9 <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">countersignature</a> attribute.
     * 
     * On input, this parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbCountersignature A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pbCountersignature</i> parameter. When the function returns, the variable pointed to by the <i>pcbCountersignature</i> parameter contains the number of bytes stored in the buffer.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table lists the error codes most commonly returned by the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_OID_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The object identifier is badly formatted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more arguments are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Ran out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Propagated errors might be returned from one of the following functions:
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentoencode">CryptMsgOpenToEncode</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgcontrol">CryptMsgControl</a>
     * </li>
     * </ul>
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmsgcountersignencoded
     * @since windows5.1.2600
     */
    static CryptMsgCountersignEncoded(dwEncodingType, pbSignerInfo, cbSignerInfo, cCountersigners, rgCountersigners, pbCountersignature, pcbCountersignature) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgCountersignEncoded", "uint", dwEncodingType, "ptr", pbSignerInfo, "uint", cbSignerInfo, "uint", cCountersigners, "ptr", rgCountersigners, "ptr", pbCountersignature, "ptr", pcbCountersignature, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Opens a certificate store by using a specified store provider type.
     * @remarks
     * A system store is a collection that consists of one or more physical sibling stores. For each system store, there are predefined physical sibling stores. After opening a system store such as "My" at CERT_SYSTEM_STORE_CURRENT_USER, <b>CertOpenStore</b> is called to open all of the physical stores in the system store collection. Each of these physical stores is added to the system store collection by using 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddstoretocollection">CertAddStoreToCollection</a> function. All certificates, CRLs, and CTLs in those physical stores are available through the logical system store collection.
     * 
     * <div class="alert"><b>Note</b>  The order of the certificate context may not be preserved within the store. 
     * To access a specific certificate you must iterate across the certificates in the store.</div>
     * <div> </div>
     * 
     * The following system store locations can be opened remotely:
     * 
     * <ul>
     * <li>CERT_SYSTEM_STORE_LOCAL_MACHINE</li>
     * <li>CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY</li>
     * <li>CERT_SYSTEM_STORE_SERVICES</li>
     * <li>CERT_SYSTEM_STORE_USERS</li>
     * </ul>
     * 
     * 
     * 
     * System store locations are opened remotely by prefixing the store name in the string passed to <i>pvPara</i> with the computer name. Examples of remote system store names are:
     * 
     * <ul>
     * <li><i>ComputerName</i>&#92;<i>CA</i></li>
     * <li>&#92;&#92;<i>ComputerName</i>&#92;<i>CA</i></li>
     * <li><i>ComputerName</i>&#92;<i>ServiceName</i>&#92;<i>Trust</i></li>
     * <li>&#92;&#92;<i>ComputerName</i>&#92;<i>ServiceName</i>&#92;<i>Trust</i></li>
     * </ul>
     * 
     * 
     * For more information about system stores, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/system-store-locations">System Store Locations</a>.
     * 
     * For more information about the stores that are automatically migrated, see <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/certificate-store-migration">Certificate Store Migration</a>.
     * @param {Pointer<PSTR>} lpszStoreProvider A pointer to a null-terminated ANSI string that contains the store provider type.
     * 
     * The following values  represent the predefined store types. The store provider type determines the contents of the <i>pvPara</i> parameter and the use and meaning of the high word of the <i>dwFlags</i> parameter. Additional store providers can be installed or registered by using 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptinstalloidfunctionaddress">CryptInstallOIDFunctionAddress</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptregisteroidfunction">CryptRegisterOIDFunction</a> function. For more information about adding store providers, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/extending-certopenstore-functionality">Extending CertOpenStore Functionality</a>.
     * 
     * 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_COLLECTION"></a><a id="cert_store_prov_collection"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_COLLECTION</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_COLLECTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Opens a store that will be a collection of other stores. Stores are added to or removed from the collection by using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddstoretocollection">CertAddStoreToCollection</a> and <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certremovestorefromcollection">CertRemoveStoreFromCollection</a>. When a store is added to a collection, all certificates, CRLs, and CTLs in that store become available to searches or enumerations of the collection store.
     * 
     * The high word of <i>dwFlags</i> is set to zero.
     * 
     * <b><i>pvPara</i> value:  </b>The <i>pvPara</i> parameter must be <b>NULL</b>.
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_FILE"></a><a id="cert_store_prov_file"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_FILE</b></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs read from a specified open file. This provider expects the file to contain only a serialized store and not either PKCS #7 signed messages or a single encoded certificate.
     * 
     * The file pointer must be positioned at the beginning of the serialized store information. After the data in the serialized store has been loaded into the certificate store, the file pointer is positioned at the beginning of any data that can follow the serialized store data in the file. If CERT_FILE_STORE_COMMIT_ENABLE is set in <i>dwFlags</i>, the file handle is duplicated and the store is always committed as a serialized store. The file is not closed when the store is closed.
     * 
     * <b><i>pvPara</i> value:  </b>The <i>pvPara</i> parameter must contain a pointer to the handle of a file opened by using <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>.
     * 
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_FILENAME_A"></a><a id="cert_store_prov_filename_a"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_FILENAME_A</b></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from a file. The provider opens the file and first attempts to read the file as a serialized store, then as a PKCS #7 signed message, and finally as a single encoded certificate.
     * 
     * 
     * The <i>dwEncodingType</i> parameter must contain the encoding types to be used with both messages and certificates. If the file contains an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/x-gly">X.509</a> encoded certificate, the open operation fails and a call to the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function will return <b>ERROR_ACCESS_DENIED</b>.
     *          If the <b>CERT_FILE_STORE_COMMIT_ENABLE</b> flag is set in <i>dwFlags</i>, the <i>dwCreationDisposition</i> value passed to <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> is as follows:
     * 
     * <ul>
     * <li>If the <b>CERT_STORE_CREATE_NEW_FLAG</b> flag is set, 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> uses <b>CREATE_NEW</b>.</li>
     * <li>If the <b>CERT_STORE_OPEN_EXISTING_FLAG</b> flag is set, <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> uses <b>OPEN_EXISTING</b>.</li>
     * <li>For all other settings of <i>dwFlags</i>, <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> uses <b>OPEN_ALWAYS</b>.</li>
     * </ul>
     * 
     * 
     * If <i>dwFlags</i> includes <b>CERT_FILE_STORE_COMMIT_ENABLE</b>, the file is committed as either a PKCS #7 or a serialized store depending on the file type opened. If the file was empty or if the file name has either a .p7c or .spc extension, the file is committed as a PKCS #7. Otherwise, the file is committed as a serialized store.
     * 
     * <b><i>pvPara</i> value:  </b>The <i>pvPara</i> parameter must contain a pointer to null-terminated ANSI string that contains the name of an existing, unopened file.
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_FILENAME__W_"></a><a id="cert_store_prov_filename__w_"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_FILENAME(_W)</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_FILENAME(_W)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Same as <b>CERT_STORE_PROV_FILENAME_A</b>.
     * 
     * <b><i>pvPara</i> value:  </b>The <i>pvPara</i> parameter must contain a pointer to null-terminated Unicode string that contains the name of an existing, unopened file.
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_LDAP__W_"></a><a id="cert_store_prov_ldap__w_"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_LDAP(_W)</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_LDAP(_W)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from the results of an LDAP query.
     * 
     * To perform write operations on the store, the query string must specify a BASE query with no filter and a single attribute.
     * 
     * <b><i>pvPara</i> value:  </b>If the <i>dwFlags</i> parameter contains  <b>CERT_LDAP_STORE_OPENED_FLAG</b>, set  <i>pvPara</i> to the address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_ldap_store_opened_para">CERT_LDAP_STORE_OPENED_PARA</a> structure that specifies the established LDAP session to use.
     * 
     * Otherwise,  set  <i>pvPara</i> to point to a null-terminated Unicode string that contains the LDAP query string. For more information about LDAP query strings, see <a href="https://docs.microsoft.com/windows/desktop/ADSI/ldap-dialect">LDAP Dialect</a>.
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_MEMORY"></a><a id="cert_store_prov_memory"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_MEMORY</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Creates a certificate store in cached memory. No certificates, <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate revocation lists</a> (CRLs), or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate trust lists</a> (CTLs) are initially loaded into the store. Typically used to create a temporary store.
     * 
     * Any addition of certificates, CRLs, or CTLs or changes in properties of certificates, CRLs, or CTLs in a memory store are not automatically saved. They can be saved to a file or to a memory <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a> by using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsavestore">CertSaveStore</a>.
     * 
     * <b><i>pvPara</i> value:  </b>The <i>pvPara</i> parameter is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_MSG"></a><a id="cert_store_prov_msg"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_MSG</b></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from the specified cryptographic message. The <i>dwEncodingType</i> parameter must contain the encoding types used with both messages and certificates.
     * 
     * <b><i>pvPara</i> value:  </b>The <i>pvPara</i> parameter contains an <b>HCRYPTMSG</b> handle of the encoded message, returned by a call to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentodecode">CryptMsgOpenToDecode</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_PHYSICAL__W_"></a><a id="cert_store_prov_physical__w_"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_PHYSICAL(_W)</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_PHYSICAL(_W)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from a specified physical store that is a member of a logical system store.
     * 
     * Two names are separated with an intervening backslash (\\), for example "Root\.Default". Here, "Root" is the name of the system store and ".Default" is the name of the physical store. The system and physical store names cannot contain any backslashes. The high word of <i>dwFlags</i> indicates the system store location, usually CERT_SYSTEM_STORE_CURRENT_USER. For more information, see <i>dwFlags</i> later in this topic and see <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/system-store-locations">System Store Locations</a>. Some physical store locations can be opened remotely.
     * 
     * <b><i>pvPara</i> value:  </b>The <i>pvPara</i> parameter points to a null-terminated Unicode string that contains both the system store name and physical names.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_PKCS7"></a><a id="cert_store_prov_pkcs7"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_PKCS7</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_PKCS7</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from an encoded PKCS #7 signed message. The <i>dwEncodingType</i> parameter must specify the encoding types to be used with both messages and certificates.
     * 
     * <b><i>pvPara</i> value:  </b>The <i>pvPara</i> parameter points to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure that represents the encoded message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_PKCS12"></a><a id="cert_store_prov_pkcs12"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_PKCS12</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_PKCS12</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with the contents of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">PKCS #12</a> packet.
     * 
     * If the PKCS #12 packet is protected with a NULL or empty password, this function will succeed in opening the store.
     * 
     * Beginning with Windows 8 and Windows Server 2012, if the password embedded in the PFX packet was protected to an Active Directory (AD) principal and the current user, as a member of that principal, has permission to decrypt the password, this function will succeed in opening the store. For more information, see the <i>pvPara</i> parameter and the <b>PKCS12_PROTECT_TO_DOMAIN_SIDS</b> flag of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-pfxexportcertstoreex">PFXExportCertStoreEx</a> function.
     * 
     * You can protect PFX passwords to an AD principal beginning in Windows 8 and Windows Server 2012.
     * 
     * <b><i>pvPara</i> value:  </b>The <i>pvPara</i> parameter points to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure that represents the PKCS #12 packet.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_REG"></a><a id="cert_store_prov_reg"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_REG</b></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from a registry subkey.
     * 
     * This provider opens or creates the registry subkeys <b>Certificates</b>, <b>CRLs</b>, and <b>CTLs</b> under the key passed in <i>pvPara</i>. The input key is not closed by the provider. Before returning, the provider opens its own copy of the key passed in <i>pvPara</i>. If CERT_STORE_READONLY_FLAG is set in the low word of <i>dwFlags</i>, registry subkeys are opened by using the <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regopenkeya">RegOpenKey</a> with KEY_READ_ACCESS. Otherwise, registry subkeys are created by using <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regcreatekeya">RegCreateKey</a> with KEY_ALL_ACCESS. Any changes to the contents of the opened store are immediately persisted to the registry. However, if CERT_STORE_READONLY_FLAG is set in the low word of <i>dwFlags</i>, any attempt to add to the contents of the store or to change a context's property results in an error with <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning the E_ACCESSDENIED code.
     * 
     * <b><i>pvPara</i> value:  </b>The <i>pvPara</i> parameter contains the handle of an open registry key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_SERIALIZED"></a><a id="cert_store_prov_serialized"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_SERIALIZED</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_SERIALIZED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from a memory location that contains a serialized store.
     * 
     * <b><i>pvPara</i> value:  </b>The <i>pvPara</i> parameter points to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure that contains the serialized memory BLOB.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_SMART_CARD__W_"></a><a id="cert_store_prov_smart_card__w_"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_SMART_CARD(_W)</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_SMART_CARD(_W)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not currently used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_SYSTEM_A"></a><a id="cert_store_prov_system_a"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_SYSTEM_A</b></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from the specified system store.
     * 
     * The system store is a logical, collection store that consists of one or more physical stores. A physical store associated with a system store is registered with the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certregisterphysicalstore">CertRegisterPhysicalStore</a> function. After the system store is opened, all of the physical stores that are associated with it are also opened by calls to <b>CertOpenStore</b> and are added to the system store collection by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddstoretocollection">CertAddStoreToCollection</a> function. The high word of <i>dwFlags</i> indicates the system store location, usually set to CERT_SYSTEM_STORE_CURRENT_USER. For details about registry locations, see <i>dwFlags</i> later in this topic and <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/system-store-locations">System Store Locations</a>. Some system store locations can be opened remotely; for more information, see System Store Locations.
     * 
     * <b><i>pvPara</i> value:  </b>The <i>pvPara</i> parameter points to a null-terminated ANSI string that contains a system store name, such as "My" or "Root".
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_SYSTEM__W_"></a><a id="cert_store_prov_system__w_"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_SYSTEM(_W)</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_SYSTEM(_W)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Same as <b>CERT_STORE_PROV_SYSTEM_A</b>.
     * 
     * <b><i>pvPara</i> value:  </b>The <i>pvPara</i> parameter points to a null-terminated Unicode string that contains a system store name, such as "My" or "Root".
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_PROV_SYSTEM_REGISTRY_A"></a><a id="cert_store_prov_system_registry_a"></a><dl>
     * <dt><b><b>CERT_STORE_PROV_SYSTEM_REGISTRY_A</b></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes the store with certificates, CRLs, and CTLs from a physical registry store. The physical store is not opened as a collection store. Enumerations and searches go through only the certificates, CRLs, and CTLs in that one physical store.
     * 
     * The high word of <i>dwFlags</i> indicates the system store location, usually set to CERT_SYSTEM_STORE_CURRENT_USER. For more information, see <i>dwFlags</i> later in this topic. Some system store locations can be open remotely; for more information, see <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/system-store-locations">System Store Locations</a>.
     * 
     * <b><i>pvPara</i> value:  </b>The <i>pvPara</i> parameter points to a null-terminated ANSI string that contains a system store name, such as "My" or "Root".
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="_CERT_STORE_PROV_SYSTEM_REGISTRY__W_"></a><a id="_cert_store_prov_system_registry__w_"></a><dl>
     * <dt><b><b> CERT_STORE_PROV_SYSTEM_REGISTRY(_W)</b></b></dt>
     * <dt><b>sz_CERT_STORE_PROV_SYSTEM_REGISTRY(_W)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Same as <b>CERT_STORE_PROV_SYSTEM_REGISTRY_A</b>.
     * 
     * <b><i>pvPara</i> value:  </b>The <i>pvPara</i> parameter points to a null-terminated Unicode string that contains a system store name, such as "My" or "Root".
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwEncodingType Specifies the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a> and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a>. Encoding is used only when the <i>dwSaveAs</i> parameter of  the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsavestore">CertSaveStore</a> function contains <b>CERT_STORE_SAVE_AS_PKCS7</b>. Otherwise, the <i>dwMsgAndCertEncodingType</i> parameter is not used.
     * 
     * This parameter is only applicable  when the <b>CERT_STORE_PROV_MSG</b>, <b>CERT_STORE_PROV_PKCS7</b>, or <b>CERT_STORE_PROV_FILENAME</b> provider type is specified in the <i>lpszStoreProvider</i> parameter. For all other provider types, this parameter is unused and should be set to zero.
     * @param {Integer} dwFlags These values consist of high-word and low-word values combined by using a bitwise-<b>OR</b> operation.
     * @param {Pointer<Void>} pvPara A 32-bit value that can contain additional information for this function. The contents of this parameter depends on the value of the <i>lpszStoreProvider</i> and other parameters.
     * @returns {Pointer<HCERTSTORE>} If the function succeeds, the function returns a handle to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a>. When you have finished using the store, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a> function.
     * 
     * If the function fails, it returns <b>NULL</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * <div class="alert"><b>Note</b>  <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>, <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-readfile">ReadFile</a>, or registry errors might be propagated and their error codes returned. <b>CertOpenStore</b> has a single error code of its own, the ERROR_FILE_NOT_FOUND code, which indicates that the function was unable to find the provider specified by the <i>lpszStoreProvider</i> parameter.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certopenstore
     * @since windows5.1.2600
     */
    static CertOpenStore(lpszStoreProvider, dwEncodingType, dwFlags, pvPara) {
        static hCryptProv := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertOpenStore", "ptr", lpszStoreProvider, "uint", dwEncodingType, "ptr", hCryptProv, "uint", dwFlags, "ptr", pvPara, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Duplicates a store handle by incrementing the store's reference count.
     * @param {Pointer<HCERTSTORE>} hCertStore A handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a> for which the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> is being incremented.
     * @returns {Pointer<HCERTSTORE>} Currently, a copy is not made of the handle, and the returned handle is the same as the handle that was input. If <b>NULL</b> is passed in, the called function will raise an access violation exception.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certduplicatestore
     * @since windows5.1.2600
     */
    static CertDuplicateStore(hCertStore) {
        result := DllCall("CRYPT32.dll\CertDuplicateStore", "ptr", hCertStore, "ptr")
        return result
    }

    /**
     * Saves the certificate store to a file or to a memory BLOB.
     * @param {Pointer<HCERTSTORE>} hCertStore The handle of the certificate store to be saved.
     * @param {Integer} dwEncodingType Specifies the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a> and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a>. Encoding is used only when <i>dwSaveAs</i> contains <b>CERT_STORE_SAVE_AS_PKCS7</b>. Otherwise, the <i>dwMsgAndCertEncodingType</i> parameter is not used.
     * @param {Integer} dwSaveAs Specifies how to save the certificate store.
     * @param {Integer} dwSaveTo Specifies where and how to save the certificate store. The contents of this parameter determines the format of the <i>pvSaveToPara</i> parameter.
     * @param {Pointer<Void>} pvSaveToPara A pointer that represents where the store should be saved to. The contents of this parameter depends on the value of the <i>dwSaveTo</i> parameter.
     * @param {Integer} dwFlags This parameter is reserved for future use and must be set to zero.
     * @returns {Integer} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * Note that <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> or <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefile">WriteFile</a> errors can be propagated to this function. One possible error code is <b>CRYPT_E_FILE_ERROR</b> which indicates that an error occurred while writing to the file.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certsavestore
     * @since windows5.1.2600
     */
    static CertSaveStore(hCertStore, dwEncodingType, dwSaveAs, dwSaveTo, pvSaveToPara, dwFlags) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSaveStore", "ptr", hCertStore, "uint", dwEncodingType, "uint", dwSaveAs, "uint", dwSaveTo, "ptr", pvSaveToPara, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Closes a certificate store handle and reduces the reference count on the store.
     * @remarks
     * While a certificate store is open, <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">contexts</a> from that store can be retrieved or duplicated. When a <i>context</i> is retrieved or duplicated, its reference count is incremented. When a context is freed by passing it to a search or enumeration function as a previous context or by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a>, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreectlcontext">CertFreeCTLContext</a>, its reference count is decremented. When a context's reference count reaches zero, memory allocated for that context is automatically freed. When the memory allocated for a context has been freed, any pointers to that context become not valid.
     * 
     * By default, memory used to store contexts with reference count greater than zero is not freed when a certificate store is closed. References to those contexts remain valid; however, this can cause memory leaks. Also, any changes made to the properties of a context after the store has been closed are not persisted.
     * 
     * To force the freeing of memory for all contexts associated with a store, set CERT_CLOSE_STORE_FORCE_FLAG. With this flag set, memory for all contexts associated with the store is freed and all pointers to certificate, CRL, or CTL contexts associated with the store become not valid. This flag should only be set when the store is opened in a function and neither the store handle nor any of its contexts were ever passed to any called functions.
     * 
     * The status of reference counts on contexts associated with a store can be checked when the store is closed by using CERT_CLOSE_STORE_CHECK_FLAG. When this flag is set, and all certificate, CRL, or CTL contexts have not been released, the function returns <b>FALSE</b> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns CRYPT_E_PENDING_CLOSE. Note that the store is still closed when <b>FALSE</b> is returned and the memory for any active contexts is not freed.
     * 
     * If CERT_STORE_NO_CRYPT_RELEASE_FLAG was not set when the store was opened, closing a store releases its CSP handle.
     * @param {Pointer<HCERTSTORE>} hCertStore Handle of the certificate store to be closed.
     * @param {Integer} dwFlags Typically, this parameter uses the default value zero. The default is to close the store with memory remaining allocated for contexts that have not been freed. In this case, no check is made to determine whether memory for contexts remains allocated. 
     * 
     * 
     * 
     * 
     * Set flags can force the freeing of memory for all of a store's <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a>, <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate revocation list</a> (CRL), and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate trust list</a> (CTL) contexts when the store is closed. Flags can also be set that check whether all of the store's certificate, CRL, and CTL contexts have been freed. The following values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CLOSE_STORE_CHECK_FLAG"></a><a id="cert_close_store_check_flag"></a><dl>
     * <dt><b>CERT_CLOSE_STORE_CHECK_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Checks for nonfreed certificate, CRL, and CTL contexts. A returned error code indicates that one or more store elements is still in use. This flag should only be used as a diagnostic tool in the development of applications.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CLOSE_STORE_FORCE_FLAG"></a><a id="cert_close_store_force_flag"></a><dl>
     * <dt><b>CERT_CLOSE_STORE_FORCE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Forces the freeing of memory for all contexts associated with the store. This flag can be safely used only when the store is opened in a function and neither the store handle nor any of its contexts are passed to any called functions. For details, see  Remarks.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If CERT_CLOSE_STORE_CHECK_FLAG is not set or if it is set and all contexts associated with the store have been freed, the return value is <b>TRUE</b>.
     * 
     * If CERT_CLOSE_STORE_CHECK_FLAG is set and memory for one or more contexts associated with the store remains allocated, the return value is <b>FALSE</b>. The store is always closed even when the function returns <b>FALSE</b>. For details, see  Remarks.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> is set to CRYPT_E_PENDING_CLOSE if memory for contexts associated with the store remains allocated. Any existing value returned by <b>GetLastError</b> is preserved unless CERT_CLOSE_STORE_CHECK_FLAG is set.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certclosestore
     * @since windows5.1.2600
     */
    static CertCloseStore(hCertStore, dwFlags) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertCloseStore", "ptr", hCertStore, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Returns from a certificate store a subject certificate context uniquely identified by its issuer and serial number.
     * @remarks
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certduplicatecertificatecontext">CertDuplicateCertificateContext</a> can be called to make a duplicate certificate.
     * @param {Pointer<HCERTSTORE>} hCertStore A handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a>.
     * @param {Integer} dwCertEncodingType The type of encoding used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_INFO>} pCertId A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure. Only the <b>Issuer</b> and <b>SerialNumber</b> members are used.
     * @returns {Pointer<CERT_CONTEXT>} If the function succeeds, the function returns a pointer to a read-only 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a>. The <b>CERT_CONTEXT</b> must be freed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a>.
     * 
     * The returned certificate might not be valid. Usually, it is verified when getting its issuer certificate (<a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetissuercertificatefromstore">CertGetIssuerCertificateFromStore</a>).
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The subject certificate was not found in the store.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certgetsubjectcertificatefromstore
     * @since windows5.1.2600
     */
    static CertGetSubjectCertificateFromStore(hCertStore, dwCertEncodingType, pCertId) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetSubjectCertificateFromStore", "ptr", hCertStore, "uint", dwCertEncodingType, "ptr", pCertId, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the first or next certificate in a certificate store. Used in a loop, this function can retrieve in sequence all certificates in a certificate store.
     * @remarks
     * The returned pointer is freed when passed as the <i>pPrevCertContext</i> parameter on a subsequent call. Otherwise, the pointer must be freed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a>. A non-<b>NULL</b> <i>pPrevCertContext</i> passed to <b>CertEnumCertificatesInStore</b> is always freed even for an error.
     * 
     * A duplicate of the currently enumerated certificate can be made by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certduplicatecertificatecontext">CertDuplicateCertificateContext</a>.
     * @param {Pointer<HCERTSTORE>} hCertStore A handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a>.
     * @param {Pointer<CERT_CONTEXT>} pPrevCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> of the previous <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a> found.
     * 
     * This parameter must be <b>NULL</b> to begin the enumeration and get the first certificate in the store. Successive certificates are enumerated by setting <i>pPrevCertContext</i> to the pointer returned by a previous call to the function. This function frees the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> referenced by non-<b>NULL</b> values of this parameter.
     * 
     * For <a href="https://docs.microsoft.com/windows/desktop/SecGloss/l-gly">logical stores</a>, including collection stores, a duplicate of the <i>pCertContext</i> returned by this function cannot be used to begin a new subsequence of enumerations because the duplicated certificate loses the initial enumeration <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">state</a>. The enumeration skips any certificate previously deleted by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certdeletecertificatefromstore">CertDeleteCertificateFromStore</a>.
     * @returns {Pointer<CERT_CONTEXT>} If the function succeeds, the function returns  a pointer to the next 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> in the store. If no more certificates exist in the store, the function returns <b>NULL</b>.
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hCertStore</i> parameter is not the same as that in the certificate context pointed to by <i>pPrevCertContext</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND </b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No certificates were found. This happens if the store is empty or if the function reached the end of the store's list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MORE_FILES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Applies to external stores. No certificates were found. This happens if the store is empty or if the function reached the end of the store's list.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certenumcertificatesinstore
     * @since windows5.1.2600
     */
    static CertEnumCertificatesInStore(hCertStore, pPrevCertContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertEnumCertificatesInStore", "ptr", hCertStore, "ptr", pPrevCertContext, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Finds the first or next certificate context in a certificate store that matches a search criteria established by the dwFindType and its associated pvFindPara.
     * @remarks
     * The <i>dwFindFlags</i> parameter is used to modify the criteria of some search types.
     * 
     * The CERT_UNICODE_IS_RDN_ATTRS_FLAG <i>dwFindFlags</i> value is used only with the CERT_FIND_SUBJECT_ATTR and CERT_FIND_ISSUER_ATTR values for <i>dwFindType</i>. CERT_UNICODE_IS_RDN_ATTRS_FLAG must be set if the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_rdn_attr">CERT_RDN_ATTR</a> structure pointed to by <i>pvFindPara</i> was initialized with Unicode strings. Before any comparison is made, the string to be matched is converted by using X509_UNICODE_NAME to provide for Unicode comparisons.
     * 
     * The following <i>dwFindFlags</i> values are used only with the CERT_FIND_ENKEY_USAGE value for <i>dwFindType</i>:
     * 
     * 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certduplicatecertificatecontext">CertDuplicateCertificateContext</a> can be called to make a duplicate of the returned context. The returned context can be added to a different <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a> by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddcertificatecontexttostore">CertAddCertificateContextToStore</a>, or a link to that certificate context can be added to a store that is not a collection store by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddcertificatelinktostore">CertAddCertificateLinkToStore</a>.
     * 
     * The returned pointer is freed when passed as the <i>pPrevCertContext</i> parameter on a subsequent call to the function. Otherwise, the pointer must be explicitly freed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a>. A <i>pPrevCertContext</i> that is not <b>NULL</b> is always freed by <b>CertFindCertificateInStore</b> using a call to <b>CertFreeCertificateContext</b>, even if there is an error in the function.
     * @param {Pointer<HCERTSTORE>} hCertStore A handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a> to be searched.
     * @param {Integer} dwCertEncodingType Specifies the type of encoding used. Both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> must be specified by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Integer} dwFindFlags Used with some <i>dwFindType</i> values to modify the search criteria. For most <i>dwFindType</i> values, <i>dwFindFlags</i> is not used and should be set to zero. For detailed information, see  Remarks.
     * @param {Integer} dwFindType 
     * @param {Pointer<Void>} pvFindPara Points to a data item or structure used with <i>dwFindType</i>.
     * @param {Pointer<CERT_CONTEXT>} pPrevCertContext A pointer to the last 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure returned by this function. This parameter must be <b>NULL</b> on the first call of the function. To find successive certificates meeting the search criteria,  set <i>pPrevCertContext</i> to the pointer returned by the previous call to the function. This function frees the <b>CERT_CONTEXT</b> referenced by non-<b>NULL</b> values of this parameter.
     * @returns {Pointer<CERT_CONTEXT>} If the function succeeds, the function returns a pointer to a read-only <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure.
     * 
     * If the function fails and a certificate that matches the search criteria is not found, the return value is <b>NULL</b>.
     * 
     * A non-<b>NULL</b> <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> that <b>CertFindCertificateInStore</b> returns must be freed by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> or by being passed as the <i>pPrevCertContext</i> parameter on a subsequent call to <b>CertFindCertificateInStore</b>.
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No certificate was found matching the search criteria. This can happen if the store is empty or the end of the store's list is reached.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hCertStore</i> parameter is not the same as that in the certificate <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a> pointed to by the <i>pPrevCertContext</i> parameter, or a value that is not valid was specified in the <i>dwFindType</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certfindcertificateinstore
     * @since windows5.1.2600
     */
    static CertFindCertificateInStore(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertFindCertificateInStore", "ptr", hCertStore, "uint", dwCertEncodingType, "uint", dwFindFlags, "uint", dwFindType, "ptr", pvFindPara, "ptr", pPrevCertContext, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the certificate context from the certificate store for the first or next issuer of the specified subject certificate. The new Certificate Chain Verification Functions are recommended instead of the use of this function.
     * @remarks
     * The returned pointer is freed when passed as the <i>pPrevIssuerContext</i> parameter on a subsequent call to the function. Otherwise, the pointer must be explicitly freed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a>. A <i>pPrevIssuerContext</i> that is not <b>NULL</b> is always freed by <b>CertGetIssuerCertificateFromStore</b> using a call to <b>CertFreeCertificateContext</b>, even if there is an error in the function.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certduplicatecertificatecontext">CertDuplicateCertificateContext</a> can be called to make a duplicate of the issuer certificate.
     * 
     * The hexadecimal values for <i>dwFlags</i> can be combined using a bitwise-<b>OR</b> operation to enable multiple verifications. For example, to enable both signature and time validity, the value 0x00000003 is passed in <i>dwFlags</i> on input. In this case, if CERT_STORE_SIGNATURE_FLAG verification succeeds but CERT_STORE_TIME_VALIDITY_FLAG verification fails, <i>dwFlags</i> returns as 0x00000002 on output.
     * @param {Pointer<HCERTSTORE>} hCertStore Handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a>.
     * @param {Pointer<CERT_CONTEXT>} pSubjectContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure that contains the subject information. This parameter can be obtained from any certificate store or can be created by the calling application using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certcreatecertificatecontext">CertCreateCertificateContext</a> function.
     * @param {Pointer<CERT_CONTEXT>} pPrevIssuerContext A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure that contains the issuer information. An issuer can have multiple certificates, especially when a validity period is about to change. This parameter must be <b>NULL</b> on the call to get the first issuer certificate. To get the next certificate for the issuer, set <i>pPrevIssuerContext</i> to the <b>CERT_CONTEXT</b> structure returned by the previous call. 
     * 
     * This function frees the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> referenced by non-<b>NULL</b> values of this parameter.
     * @param {Pointer<UInt32>} pdwFlags The following flags enable verification checks on the returned certificate. They can be combined using a bitwise-<b>OR</b> operation to enable multiple verifications. 
     * 
     * 
     * 
     * 
     * 						
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_NO_CRL_FLAG"></a><a id="cert_store_no_crl_flag"></a><dl>
     * <dt><b>CERT_STORE_NO_CRL_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates no matching CRL was found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_NO_ISSUER_FLAG"></a><a id="cert_store_no_issuer_flag"></a><dl>
     * <dt><b>CERT_STORE_NO_ISSUER_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates no issuer certificate was found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_REVOCATION_FLAG"></a><a id="cert_store_revocation_flag"></a><dl>
     * <dt><b>CERT_STORE_REVOCATION_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Checks whether the subject certificate is on the issuer's revocation list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_SIGNATURE_FLAG"></a><a id="cert_store_signature_flag"></a><dl>
     * <dt><b>CERT_STORE_SIGNATURE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uses the public key in the issuer's certificate to verify the signature on the subject certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_TIME_VALIDITY_FLAG"></a><a id="cert_store_time_validity_flag"></a><dl>
     * <dt><b>CERT_STORE_TIME_VALIDITY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Gets the current time and verifies that it is within the subject certificate's validity period.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If a verification check of an enabled type succeeds, its flag is set to zero. If it fails, its flag remains set upon return. For CERT_STORE_REVOCATION_FLAG, the verification succeeds if the function does not find a CRL related to the subject certificate.
     * 
     * If CERT_STORE_REVOCATION_FLAG is set and the issuer does not have a CRL in the store, CERT_STORE_NO_CRL_FLAG is set and CERT_STORE_REVOCATION_FLAG remains set.
     * 
     * If CERT_STORE_SIGNATURE_FLAG or CERT_STORE_REVOCATION_FLAG is set, CERT_STORE_NO_ISSUER_FLAG is set if the function does not find an issuer certificate in the store. For more details, see  Remarks.
     * 
     * In the case of a verification check failure, a pointer to the issuer's 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> is still returned and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> is not updated.
     * @returns {Pointer<CERT_CONTEXT>} If the function succeeds, the return value is a pointer to a read-only issuer <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a>.
     * 
     * If the function fails and the first or next issuer certificate is not found, the return value is <b>NULL</b>.
     * 
     * Only the last returned <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure must be freed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a>. When the returned <b>CERT_CONTEXT</b> from one call to the function is supplied as the <i>pPrevIssuerContext</i> parameter on a subsequent call, the context is freed as part of the action of the function.
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No issuer was found for the subject certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_SELF_SIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The issuer certificate is the same as the subject certificate. It is a self-signed <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">root certificate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hCertStore</i> parameter is not the same as that of the certificate context pointed to by the <i>pPrevIssuerContext</i> parameter, or an unsupported flag was set in <i>pdwFlags</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certgetissuercertificatefromstore
     * @since windows5.1.2600
     */
    static CertGetIssuerCertificateFromStore(hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetIssuerCertificateFromStore", "ptr", hCertStore, "ptr", pSubjectContext, "ptr", pPrevIssuerContext, "ptr", pdwFlags, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertVerifySubjectCertificateContext function performs the enabled verification checks on a certificate by checking the validity of the certificate's issuer. The new Certificate Chain Verification Functions are recommended instead of this function.
     * @remarks
     * The hexadecimal value of the flags can be combined using bitwise-<b>OR</b> operations to enable multiple verifications. For example, to enable both signature and time validity, the value
     * 
     * 
     * ``` syntax
     * CERT_STORE_SIGNATURE_FLAG | CERT_STORE_TIME_VALIDITY_FLAG
     * 
     * ```
     * 
     * is placed in the <i>pdwFlags</i> <b>DWORD</b> value as an input parameter. If CERT_STORE_SIGNATURE_FLAG verification succeeds, but CERT_STORE_TIME_VALIDITY_FLAG verification fails, <i>pdwFlags</i> is set to CERT_STORE_TIME_VALIDITY_FLAG when the function returns.
     * @param {Pointer<CERT_CONTEXT>} pSubject A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure containing the subject's certificate.
     * @param {Pointer<CERT_CONTEXT>} pIssuer A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> containing the issuer's certificate. When checking just CERT_STORE_TIME_VALIDITY_FLAG, <i>pIssuer</i> can be <b>NULL</b>.
     * @param {Pointer<UInt32>} pdwFlags A pointer to a <b>DWORD</b> value contain verification check flags. The following flags can be set to enable verification checks on the subject certificate. They can be combined using a bitwise-<b>OR</b> operation to enable multiple verifications.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_REVOCATION_FLAG"></a><a id="cert_store_revocation_flag"></a><dl>
     * <dt><b>CERT_STORE_REVOCATION_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Checks whether the subject certificate is on the issuer's revocation list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_SIGNATURE_FLAG"></a><a id="cert_store_signature_flag"></a><dl>
     * <dt><b>CERT_STORE_SIGNATURE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uses the public key in the issuer's certificate to verify the signature on the subject certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_TIME_VALIDITY_FLAG"></a><a id="cert_store_time_validity_flag"></a><dl>
     * <dt><b>CERT_STORE_TIME_VALIDITY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Gets the current time and verifies that it is within the subject certificate's validity period.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If an enabled verification check succeeds, its flag is set to zero. If it fails, then its flag is set upon return.
     * 
     * If CERT_STORE_REVOCATION_FLAG was enabled and the issuer does not have a CRL in the store, then CERT_STORE_NO_CRL_FLAG is set in addition to CERT_STORE_REVOCATION_FLAG.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>.
     * 
     * For a verification check failure, <b>TRUE</b> is still returned. <b>FALSE</b> is returned only when a bad parameter is passed in.
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unsupported bit was set in <i>pdwFlags</i>. Any combination of CERT_STORE_SIGNATURE_FLAG, CERT_STORE_TIME_VALIDITY_FLAG, and CERT_STORE_REVOCATION_FLAG can be set. If <i>pIssuer</i> is <b>NULL</b>, only CERT_STORE_TIME_VALIDITY_FLAG can be set.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certverifysubjectcertificatecontext
     * @since windows5.1.2600
     */
    static CertVerifySubjectCertificateContext(pSubject, pIssuer, pdwFlags) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertVerifySubjectCertificateContext", "ptr", pSubject, "ptr", pIssuer, "ptr", pdwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Duplicates a certificate context by incrementing its reference count.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure for which the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> is incremented.
     * @returns {Pointer<CERT_CONTEXT>} Currently, a copy is not made of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a>, and the returned pointer to a context has the same value as the pointer to a context that was input. If the pointer passed into this function is <b>NULL</b>, <b>NULL</b> is returned. When you have finished using the duplicate context, decrease its reference count by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certduplicatecertificatecontext
     * @since windows5.1.2600
     */
    static CertDuplicateCertificateContext(pCertContext) {
        result := DllCall("CRYPT32.dll\CertDuplicateCertificateContext", "ptr", pCertContext, "ptr")
        return result
    }

    /**
     * Creates a certificate context from an encoded certificate. The created context is not persisted to a certificate store. The function makes a copy of the encoded certificate within the created context.
     * @remarks
     * The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> must be freed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a>. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certduplicatecertificatecontext">CertDuplicateCertificateContext</a> can be called to make a duplicate. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsetcertificatecontextproperty">CertSetCertificateContextProperty</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatecontextproperty">CertGetCertificateContextProperty</a> can be called to store and read properties for the certificate.
     * @param {Integer} dwCertEncodingType Specifies the type of encoding used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<Byte>} pbCertEncoded A pointer to a buffer that contains the encoded certificate from which the context is to be created.
     * @param {Integer} cbCertEncoded The size, in bytes, of the <i>pbCertEncoded</i> buffer.
     * @returns {Pointer<CERT_CONTEXT>} If the function succeeds, the function returns a pointer to a read-only 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a>. When you have finished using the certificate context, free it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function.
     * 
     * If the function is unable to decode and create the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a>, it returns <b>NULL</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A certificate encoding type that is not valid was specified. Currently, only the X509_ASN_ENCODING type is supported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certcreatecertificatecontext
     * @since windows5.1.2600
     */
    static CertCreateCertificateContext(dwCertEncodingType, pbCertEncoded, cbCertEncoded) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertCreateCertificateContext", "uint", dwCertEncodingType, "ptr", pbCertEncoded, "uint", cbCertEncoded, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Frees a certificate context by decrementing its reference count. When the reference count goes to zero, CertFreeCertificateContext frees the memory used by a certificate context.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> to be freed.
     * @returns {Integer} The function always returns nonzero.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certfreecertificatecontext
     * @since windows5.1.2600
     */
    static CertFreeCertificateContext(pCertContext) {
        result := DllCall("CRYPT32.dll\CertFreeCertificateContext", "ptr", pCertContext, "int")
        return result
    }

    /**
     * Sets an extended property for a specified certificate context.
     * @remarks
     * If a property already exists, its old value is replaced.
     * 
     * <h3><a id="dwpropid_macro"></a><a id="DWPROPID_MACRO"></a></h3>
     * Your code can use a macro to evaluate the class of hash for a certificate context. The Wincrypt.h header  defines the following macros for this purpose. These macros are used internally by the <b>CertSetCertificateContextProperty</b> function.
     * 
     * <b>IS_CERT_HASH_PROP_ID(X)</b>
     * <b>IS_PUBKEY_HASH_PROP_ID(X)</b>
     * <b>IS_CHAIN_HASH_PROP_ID(X)</b>
     * Each macro takes the <i>dwPropId</i> (X) value as input and evaluates to a Boolean value. The following table  shows the <i>dwPropId</i> values that evaluate to <b>TRUE</b> for each macro.
     * 
     * <table>
     * <tr>
     * <th>Macro</th>
     * <th>Evaluates to <b>TRUE</b> if <i>dwPropId</i> is</th>
     * </tr>
     * <tr>
     * <td>
     * <b>IS_CERT_HASH_PROP_ID</b>(<i>dwPropId</i>)
     * 
     * </td>
     * <td>
     * 
     * <dl>
     * <dd><b>CERT_SHA1_HASH_PROP_ID</b>,</dd>
     * <dd><b>CERT_MD5_HASH_PROP_ID</b>, or</dd>
     * <dd><b>CERT_SIGNATURE_HASH_PROP_ID</b></dd>
     * </dl>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>IS_PUBKEY_HASH_PROP_ID</b>(<i>dwPropId</i>)
     * 
     * </td>
     * <td>
     * 
     * <dl>
     * <dd><b>CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID</b> or</dd>
     * <dd><b>CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID</b></dd>
     * </dl>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>IS_CHAIN_HASH_PROP_ID</b>(<i>dwPropId</i>)
     * 
     * </td>
     * <td>
     * 
     * <dl>
     * <dd><b>CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID</b>,</dd>
     * <dd><b>CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID</b>,</dd>
     * <dd><b>CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID</b>, or</dd>
     * <dd><b>CERT_SUBJECT_NAME_MD5_HASH_PROP_ID</b></dd>
     * </dl>
     * 
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The <b>IS_STRONG_SIGN_PROP_ID(x)</b> macro evaluates to <b>TRUE</b> if the <b>CERT_SIGN_HASH_CNG_ALG_PROP_ID</b>,
     * <b>CERT_SUBJECT_PUB_KEY_BIT_LENGTH_PROP_ID</b>, or <b>CERT_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID</b> properties are set
     * in the <i>dwPropId</i> parameter.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure.
     * @param {Integer} dwPropId The property to be set. The value of <i>dwPropId</i> determines the type and content of the <i>pvData</i> parameter. Currently defined identifiers and their related <i>pvData</i> types are as follows.
     * 
     * <div class="alert"><b>Note</b>  <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a> and <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> are described in the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_INTEGER_BLOB</a> topic.</div>
     * <div> </div>
     * @param {Integer} dwFlags CERT_STORE_NO_CRYPT_RELEASE_FLAG can be set for the CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_CONTEXT_PROP_ID <i>dwPropId</i> properties.
     * 
     * If the CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG value is set, any provider-write errors are ignored and the cached context's properties are always set.
     * 
     * If CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG is set, any context property set is not persisted.
     * @param {Pointer<Void>} pvData A pointer to a data type determined by the value of <i>dwPropId</i>.
     * 
     * <div class="alert"><b>Note</b>  For any <i>dwPropId</i>, setting <i>pvData</i> to <b>NULL</b> deletes the property.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, the function returns <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property is not valid. The identifier specified was greater than 0x0000FFFF, or, for the CERT_KEY_CONTEXT_PROP_ID property, a <b>cbSize</b> member that is not valid was specified in the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certsetcertificatecontextproperty
     * @since windows5.1.2600
     */
    static CertSetCertificateContextProperty(pCertContext, dwPropId, dwFlags, pvData) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSetCertificateContextProperty", "ptr", pCertContext, "uint", dwPropId, "uint", dwFlags, "ptr", pvData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the information contained in an extended property of a certificate context.
     * @remarks
     * Properties are not stored inside a certificate. Typically, they are associated with a certificate after the certificate response is received and then saved with the certificate in the store. For security reasons, we recommend that you validate property values before saving  them and that you save only informational properties such as the <b>CERT_FRIENDLY_NAME_PROP_ID</b> value in user stores. All other property types should be saved in local computer stores.
     * 
     * Your code can use a macro to evaluate the class of hash for a certificate context. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsetcertificatecontextproperty">CertSetCertificateContextProperty</a>.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a> that contains the property to be retrieved.
     * @param {Integer} dwPropId The property to be retrieved. 
     * 			 Currently defined identifiers and the data type to be 
     * 			 returned in <i>pvData</i> are listed in the 
     * 			 following table.
     * @param {Pointer<Void>} pvData A pointer to a buffer to receive the data as determined by <i>dwPropId</i>. Structures pointed to by members of a structure returned are also returned following the base structure. Therefore, the size contained in <i>pcbData</i> often exceeds the size of the base structure.
     * 
     * This parameter can be <b>NULL</b> to set the size of the information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbData A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes to be stored in the buffer.
     * 
     * To obtain the required size of a buffer at run time, pass <b>NULL</b> for the <i>pvData</i> parameter, and set the value pointed to by this parameter to zero. If the <i>pvData</i> parameter is not <b>NULL</b> and the size specified in <i>pcbData</i>   is less than the number of bytes required to  contain the data, the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_MORE_DATA</b>, and the required size is placed in the variable pointed to by the <i>pcbData</i> parameter.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     *  Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The certificate does not have the specified property.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pvData</i> parameter is not large enough to hold the returned data, the function sets the <b>ERROR_MORE_DATA</b> code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbData</i>.
     * 							
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Errors from the called function 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a> can be propagated to this function.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certgetcertificatecontextproperty
     * @since windows5.1.2600
     */
    static CertGetCertificateContextProperty(pCertContext, dwPropId, pvData, pcbData) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetCertificateContextProperty", "ptr", pCertContext, "uint", dwPropId, "ptr", pvData, "ptr", pcbData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertEnumCertificateContextProperties function retrieves the first or next extended property associated with a certificate context.
     * @remarks
     * CERT_KEY_PROV_HANDLE_PROP_ID and CERT_KEY_SPEC_PROP_ID properties are stored as members of the CERT_KEY_CONTEXT_PROP_ID property. They are not enumerated individually.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure of the certificate containing the properties to be enumerated.
     * @param {Integer} dwPropId Property number of the last property enumerated. To get the first property, <i>dwPropId</i> is zero. To retrieve subsequent properties, <i>dwPropId</i> is set to the property number returned by the last call to the function. To enumerate all the properties, function calls continue until the function returns zero. 
     * 
     * 
     * 
     * 
     * Applications can call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatecontextproperty">CertGetCertificateContextProperty</a> with the <i>dwPropId</i> returned by this function to retrieve that property's data.
     * @returns {Integer} The return value is a <b>DWORD</b> value that identifies a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context's</a> property. The <b>DWORD</b> value returned by one call of the function can be supplied as the <i>dwPropId</i> in a subsequent call to the function. If there are no more properties to be enumerated or if the function fails, zero is returned.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certenumcertificatecontextproperties
     * @since windows5.1.2600
     */
    static CertEnumCertificateContextProperties(pCertContext, dwPropId) {
        result := DllCall("CRYPT32.dll\CertEnumCertificateContextProperties", "ptr", pCertContext, "uint", dwPropId, "uint")
        return result
    }

    /**
     * The CertCreateCTLEntryFromCertificateContextProperties function creates a certificate trust list (CTL) entry whose attributes are the properties of the certificate context. The SubjectIdentifier in the CTL entry is the SHA1 hash of the certificate.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> used to create the CTL.
     * @param {Integer} cOptAttr A <b>DWORD</b> that specifies the number of additional attributes to be added.
     * @param {Pointer<CRYPT_ATTRIBUTE>} rgOptAttr A pointer to any array of <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_attribute">CRYPT_ATTRIBUTE</a> attributes to be added to the CTL.
     * @param {Integer} dwFlags A <b>DWORD</b>. Can be set to CTL_ENTRY_FROM_PROP_CHAIN_FLAG to force the inclusion of the chain building hash properties as attributes.
     * @param {Pointer<CTL_ENTRY>} pCtlEntry Address of a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_entry">CTL_ENTRY</a> structure. Call this function twice to retrieve a CTL entry. Set this parameter to <b>NULL</b> on the first call. When the function returns, use the number of bytes retrieved from the <i>pcbCtlEntry</i> parameter to allocate memory. Call the function again, setting this parameter to the address of the allocated memory.
     * @param {Pointer<UInt32>} pcbCtlEntry Pointer to a <b>DWORD</b> that contains the number of bytes that must be allocated for the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_entry">CTL_ENTRY</a> structure.  Call this function twice to retrieve the number of bytes. For the first call, set this parameter to the address of a <b>DWORD</b> value that contains zero and set the <i>pCtlEntry</i> parameter to <b>NULL</b>. If the first call succeeds, the <b>DWORD</b> value will contain the number of bytes that you must allocate for the <b>CTL_ENTRY</b> structure. Allocate the required memory and call the function again, supplying the address of the memory in the <i>pCtlEntry</i> parameter.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns  zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certcreatectlentryfromcertificatecontextproperties
     * @since windows5.1.2600
     */
    static CertCreateCTLEntryFromCertificateContextProperties(pCertContext, cOptAttr, rgOptAttr, dwFlags, pCtlEntry, pcbCtlEntry) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertCreateCTLEntryFromCertificateContextProperties", "ptr", pCertContext, "uint", cOptAttr, "ptr", rgOptAttr, "uint", dwFlags, "ptr", pvReserved, "ptr", pCtlEntry, "ptr", pcbCtlEntry, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the properties on the certificate context by using the attributes in the specified certificate trust list (CTL) entry.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> whose attributes are to be set.
     * @param {Pointer<CTL_ENTRY>} pCtlEntry A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_entry">CTL_ENTRY</a> structure used to set the attributes on the certificate.
     * @param {Integer} dwFlags A <b>DWORD</b>. This parameter can be set to CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG to ignore any persisted error flags.
     * @returns {Integer} If the function succeeds, the function returns nonzero.
     * 
     *   If the function fails, it returns zero.  For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certsetcertificatecontextpropertiesfromctlentry
     * @since windows5.1.2600
     */
    static CertSetCertificateContextPropertiesFromCTLEntry(pCertContext, pCtlEntry, dwFlags) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSetCertificateContextPropertiesFromCTLEntry", "ptr", pCertContext, "ptr", pCtlEntry, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Gets the first or next certificate revocation list (CRL) context from the certificate store for the specified issuer.
     * @remarks
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certduplicatecrlcontext">CertDuplicateCRLContext</a> can be called to make a duplicate CRL.
     * 
     * The hexadecimal values of the flags can be combined using a bitwise-<b>OR</b> operation to enable both verifications. For example, to enable both verifications, the <b>DWORD</b> value pointed to by <i>pdwFlags</i> is set to value CERT_STORE_SIGNATURE_FLAG | CERT_STORE_TIME_VALIDITY_FLAG. If the CERT_STORE_SIGNATURE_FLAG verification succeeded, but CERT_STORE_TIME_VALIDITY_FLAG verification failed, the <b>DWORD</b> value pointed to by <i>pdwFlags</i> is set to CERT_STORE_TIME_VALIDITY_FLAG when the function returns.
     * @param {Pointer<HCERTSTORE>} hCertStore Handle of a certificate store.
     * @param {Pointer<CERT_CONTEXT>} pIssuerContext A pointer to an issuer 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a>. The <i>pIssuerContext</i> pointer can come from this store or another store, or could have been created by the calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certcreatecertificatecontext">CertCreateCertificateContext</a>. If <b>NULL</b> is passed for this parameter, all the CRLs in the store are found.
     * @param {Pointer<CRL_CONTEXT>} pPrevCrlContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a>. An issuer can have multiple CRLs. For example, it can generate delta CRLs by using an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/x-gly">X.509</a> version 3 extension. This parameter must be <b>NULL</b> on the first call to get the CRL. To get the next CRL for the issuer, the parameter is set to the <b>CRL_CONTEXT</b> returned by a previous call. A non-<b>NULL</b><i>pPrevCrlContext</i> is always freed by this function by calling <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a>, even for an error.
     * @param {Pointer<UInt32>} pdwFlags The following flag values are defined to enable verification checks on the returned CRL. These flags can be combined using a bitwise-<b>OR</b> operation. 
     * 
     * 
     * 
     * 
     * 						
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_SIGNATURE_FLAG"></a><a id="cert_store_signature_flag"></a><dl>
     * <dt><b>CERT_STORE_SIGNATURE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uses the public key in the issuer's certificate to verify the signature on the returned CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_TIME_VALIDITY_FLAG"></a><a id="cert_store_time_validity_flag"></a><dl>
     * <dt><b>CERT_STORE_TIME_VALIDITY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Gets the current time and verifies that it is within the time between the CRL's ThisUpdate and NextUpdate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_BASE_CRL_FLAG"></a><a id="cert_store_base_crl_flag"></a><dl>
     * <dt><b>CERT_STORE_BASE_CRL_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Gets a base CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_DELTA_CRL_FLAG"></a><a id="cert_store_delta_crl_flag"></a><dl>
     * <dt><b>CERT_STORE_DELTA_CRL_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Gets a delta CRL.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If an enabled verification check succeeds, its flag is set to zero. 
     * 						
     * 
     * If an enabled verification check fails, its flag remains set upon return. If <i>pIssuerContext</i> is <b>NULL</b>, then an enabled CERT_STORE_SIGNATURE_FLAG always fails and the CERT_STORE_NO_ISSUER_FLAG is also set. For more details, see  Remarks.
     * 
     * If only one of CERT_STORE_BASE_CRL_FLAG or CERT_STORE_DELTA_CRL_FLAG is set, this function returns either a base or delta CRL and the appropriate base or delta flag will be cleared on return. If both flags are set, only one of the flags will be cleared.
     * 
     * For a verification check failure, a pointer to the first or next 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> is still returned and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> is not updated.
     * @returns {Pointer<CRL_CONTEXT>} If the function succeeds, the return value is a pointer to a read-only <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a>.
     * 
     * If the function fails and the first or next CRL is not found, the return value is <b>NULL</b>.
     * 
     * The returned <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> must be freed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a>. However, when the returned <b>CRL_CONTEXT</b> is supplied for <i>pPrevCrlContext</i> on a subsequent call, the function frees it.
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hCertStore</i> parameter is not the same as that in the CRL context pointed to by the <i>pPrevCrlContext</i> parameter, or an unsupported flag was set in <i>pdwFlags</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either no CRLs existed in the store for the issuer, or the function reached the end of the store's list.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certgetcrlfromstore
     * @since windows5.1.2600
     */
    static CertGetCRLFromStore(hCertStore, pIssuerContext, pPrevCrlContext, pdwFlags) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetCRLFromStore", "ptr", hCertStore, "ptr", pIssuerContext, "ptr", pPrevCrlContext, "ptr", pdwFlags, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertEnumCRLsInStore function retrieves the first or next certificate revocation list (CRL) context in a certificate store. Used in a loop, this function can retrieve in sequence all CRL contexts in a certificate store.
     * @remarks
     * The returned pointer is freed when it is passed as the <i>pPrevCrlContext</i> on a subsequent call to the function. Otherwise, the pointer must explicitly be freed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a>. A <i>pPrevCrlContext</i> that is not <b>NULL</b> is always freed when passed to this function through a call to <b>CertFreeCRLContext</b>, even if the function itself returns an error.
     * 
     * A duplicate of the CRL <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a> returned by this function can be made by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certduplicatecrlcontext">CertDuplicateCRLContext</a>.
     * @param {Pointer<HCERTSTORE>} hCertStore Handle of a certificate store.
     * @param {Pointer<CRL_CONTEXT>} pPrevCrlContext A pointer to the previous 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure found. The <i>pPrevCrlContext</i> parameter must be <b>NULL</b> to get the first CRL in the store. Successive CRLs are enumerated by setting <i>pPrevCrlContext</i> to the pointer returned by a previous call to the function.  This function frees the <b>CRL_CONTEXT</b> referenced by non-<b>NULL</b> values of this parameter. The enumeration skips any CRLs previously deleted by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certdeletecrlfromstore">CertDeleteCRLFromStore</a>.
     * @returns {Pointer<CRL_CONTEXT>} If the function succeeds, the return value is a pointer to the next 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> in the store.
     * 
     * <b>NULL</b> is returned if the function fails. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hCertStore</i> parameter is not the same as that in the certificate context pointed to by <i>pPrevCrlContext</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No CRL was found. This happens if the store is empty or the end of the store's list is reached.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certenumcrlsinstore
     * @since windows5.1.2600
     */
    static CertEnumCRLsInStore(hCertStore, pPrevCrlContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertEnumCRLsInStore", "ptr", hCertStore, "ptr", pPrevCrlContext, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Finds the first or next certificate revocation list (CRL) context in a certificate store that matches a search criterion established by the dwFindType parameter and the associated pvFindPara parameter.
     * @remarks
     * The returned pointer is freed when passed as the <i>pPrevCrlContext</i> parameter on a subsequent call to the function. Otherwise, the pointer must be explicitly freed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a>. A <i>pPrevCrlContext</i> that is not <b>NULL</b> is always freed by <b>CertFindCRLInStore</b> using a call to <b>CertFreeCRLContext</b>, even if there is an error in the function.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certduplicatecrlcontext">CertDuplicateCRLContext</a> can be called to make a duplicate of the returned context. The returned CRL context can be added to a different certificate store by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddcrlcontexttostore">CertAddCRLContextToStore</a>, or a link to that CRL context can be added to a noncollection store by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddcrllinktostore">CertAddCRLLinkToStore</a>.
     * @param {Pointer<HCERTSTORE>} hCertStore A handle of the certificate store to be searched.
     * @param {Integer} dwCertEncodingType This parameter is not currently used. It must be set to zero.
     * @param {Integer} dwFindFlags If <i>dwFindType</i> is CRL_FIND_ISSUED_BY, by default, only issuer name matching is done. The following flags can be used to do additional filtering.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_ISSUED_BY_AKI_FLAG"></a><a id="crl_find_issued_by_aki_flag"></a><dl>
     * <dt><b>CRL_FIND_ISSUED_BY_AKI_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Checks for a CRL that has an Authority Key Identifier (AKI) extension. If the CRL has an AKI, only a CRL whose AKI matches the issuer is returned.
     * 
     * <div class="alert"><b>Note</b>  The AKI extension has the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) value szOID_AUTHORITY_KEY_IDENTIFIER2 and its corresponding data structure.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_ISSUED_BY_SIGNATURE_FLAG"></a><a id="crl_find_issued_by_signature_flag"></a><dl>
     * <dt><b>CRL_FIND_ISSUED_BY_SIGNATURE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the public key in the issuer's certificate to verify the signature on the CRL. Only returns a CRL that has a valid signature.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_ISSUED_BY_DELTA_FLAG"></a><a id="crl_find_issued_by_delta_flag"></a><dl>
     * <dt><b>CRL_FIND_ISSUED_BY_DELTA_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finds and returns a delta CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_ISSUED_BY_BASE_FLAG"></a><a id="crl_find_issued_by_base_flag"></a><dl>
     * <dt><b>CRL_FIND_ISSUED_BY_BASE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Finds and returns a base CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_ISSUED_FOR_SET_STRONG_PROPERTIES_FLAG"></a><a id="crl_find_issued_for_set_strong_properties_flag"></a><dl>
     * <dt><b>CRL_FIND_ISSUED_FOR_SET_STRONG_PROPERTIES_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature is checked for strength after successful verification. This flag applies only when the <i>dwFindType</i> parameter is set to <b>CRL_FIND_ISSUED_FOR</b>. You must also set <b>CRL_FIND_ISSUED_BY_SIGNATURE_FLAG</b>. If successful, the following strong signature properties will be set on the CRL context:
     * 
     * <ul>
     * <li><b>CERT_SIGN_HASH_CNG_ALG_PROP_ID</b></li>
     * <li><b>CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID</b></li>
     * </ul>
     * <b>Windows 8 and Windows Server 2012:  </b>Support for this flag begins.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFindType Specifies the type of search being made. The value of <i>dwFindType</i> determines the data type, contents, and use of the <i>pvFindPara</i> parameter. Currently defined search types and their <i>pvFindPara</i> requirements are as follows.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_ANY"></a><a id="crl_find_any"></a><dl>
     * <dt><b>CRL_FIND_ANY</b></dt>
     * <dt>The <i>pvFindPara</i> parameter is not used. It must be set to <b>NULL</b>.</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No search criteria. The next CRL in the store is returned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_ISSUED_BY"></a><a id="crl_find_issued_by"></a><dl>
     * <dt><b>CRL_FIND_ISSUED_BY</b></dt>
     * <dt>A pointer to a CERT_CONTEXT.</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches for the next CRL in the store matching the issuer in the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_EXISTING"></a><a id="crl_find_existing"></a><dl>
     * <dt><b>CRL_FIND_EXISTING</b></dt>
     * <dt>A pointer to a CRL_CONTEXT.</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches for the next CRL that matches the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> in the following ways:
     * 
     * <ul>
     * <li> Both are base or delta CRLs.</li>
     * <li>The issuer-name BLOBs for both are identical.</li>
     * <li>If they exist, the Authority/KeyIdentifier and IssuingDistributionPoint encoded extension BLOBs match.</li>
     * </ul>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRL_FIND_ISSUED_FOR"></a><a id="crl_find_issued_for"></a><dl>
     * <dt><b>CRL_FIND_ISSUED_FOR</b></dt>
     * <dt>A pointer to a CRL_FIND_ISSUED_FOR_PARA.</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches for the next CRL in the store that matches the issuer of the subject certificate in the CRL_FIND_ISSUED_FOR_PARA structure.
     * 
     * If no CRL is found, searches for the next CRL in the store that matches the issuer in the CRL_FIND_ISSUED_FOR_PARA structure.
     * 
     * <div class="alert"><b>Note</b>  When using cross certificates, the subject name in the issuer's certificate might not match the issuer name in the subject certificate and its corresponding CRL.</div>
     * <div> </div>
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvFindPara This parameter is determined by the value of <i>dwFindType</i>. For details, see the table earlier in this topic.
     * @param {Pointer<CRL_CONTEXT>} pPrevCrlContext A pointer to the last 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> returned by this function. Must be <b>NULL</b> to get the first CRL in the store meeting the search criteria. Successive CRLs meeting the search criteria can be found by setting <i>pPrevCrlContext</i> to the <b>PCCRL_CONTEXT</b> pointer returned by a previous call to the function. The search process skips any CRLs that do not match the search criteria or that have been previously deleted from the store by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certdeletecrlfromstore">CertDeleteCRLFromStore</a>. This function frees the <b>CRL_CONTEXT</b> referenced by values of this parameter that are not <b>NULL</b>.
     * @returns {Pointer<CRL_CONTEXT>} If the function succeeds, the function returns a pointer to a read-only CRL context. When you have finished using the returned CRL context, free it by calling 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a> function or implicitly free it by passing it as the <i>pPrevCrlContext</i> parameter on a subsequent call to the <b>CertFindCRLInStore</b> function.
     * 						
     * 						
     * 
     * If the function fails and a CRL that matches the search criteria is not found, the return value is <b>NULL</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hCertStore</i> parameter is not the same as that in the CRL context pointed to by the <i>pPrevCrlContext</i> parameter, or a search type that is not valid was specified in the <i>dwFindType</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No CRLs are in the store, no CRL was found that matched the search criteria, or the end of the store's list was reached.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certfindcrlinstore
     * @since windows5.1.2600
     */
    static CertFindCRLInStore(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCrlContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertFindCRLInStore", "ptr", hCertStore, "uint", dwCertEncodingType, "uint", dwFindFlags, "uint", dwFindType, "ptr", pvFindPara, "ptr", pPrevCrlContext, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertDuplicateCRLContext function duplicates a certificate revocation list (CRL) context by incrementing its reference count.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure for which the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> is being incremented.
     * @returns {Pointer<CRL_CONTEXT>} Currently, a copy is not made of the context, and the returned context is the same as the context that was input. If the pointer passed into this function is <b>NULL</b>, <b>NULL</b> is returned.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certduplicatecrlcontext
     * @since windows5.1.2600
     */
    static CertDuplicateCRLContext(pCrlContext) {
        result := DllCall("CRYPT32.dll\CertDuplicateCRLContext", "ptr", pCrlContext, "ptr")
        return result
    }

    /**
     * The CertCreateCRLContext function creates a certificate revocation list (CRL) context from an encoded CRL. The created context is not persisted to a certificate store. It makes a copy of the encoded CRL within the created context.
     * @remarks
     * The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> must be freed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a>. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certduplicatecrlcontext">CertDuplicateCRLContext</a> can be called to make a duplicate. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsetcrlcontextproperty">CertSetCRLContextProperty</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcrlcontextproperty">CertGetCRLContextProperty</a> can be called to store and read properties for the CRL.
     * @param {Integer} dwCertEncodingType Specifies the type of encoding used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<Byte>} pbCrlEncoded A pointer to a buffer containing the encoded <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CRL</a> from which the context is to be created.
     * @param {Integer} cbCrlEncoded The size, in bytes, of the <i>pbCrlEncoded</i> buffer.
     * @returns {Pointer<CRL_CONTEXT>} If the function succeeds, the return value is a pointer to a read-only 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a>.
     * 
     * If the function fails and is unable to decode and create the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a>, the return value is <b>NULL</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following table shows a possible error code.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Currently, only the encoding type X509_ASN_ENCODING is supported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certcreatecrlcontext
     * @since windows5.1.2600
     */
    static CertCreateCRLContext(dwCertEncodingType, pbCrlEncoded, cbCrlEncoded) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertCreateCRLContext", "uint", dwCertEncodingType, "ptr", pbCrlEncoded, "uint", cbCrlEncoded, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Frees a certificate revocation list (CRL) context by decrementing its reference count.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> to be freed.
     * @returns {Integer} The function always returns <b>TRUE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certfreecrlcontext
     * @since windows5.1.2600
     */
    static CertFreeCRLContext(pCrlContext) {
        result := DllCall("CRYPT32.dll\CertFreeCRLContext", "ptr", pCrlContext, "int")
        return result
    }

    /**
     * Sets an extended property for the specified certificate revocation list (CRL) context.
     * @remarks
     * If a property already exists, its old value is replaced.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure.
     * @param {Integer} dwPropId Identifies the property to be set. The value of <i>dwPropId</i> determines the type and content of the <i>pvData</i> parameter. Currently defined identifiers and the data type to be returned in <i>pvData</i> are listed in the following table.
     * 
     * Usually, only the following properties are set:<ul>
     * <li>CERT_HASH_PROP_ID</li>
     * <li>CERT_SHA1_HASH_PROP_ID</li>
     * <li>CERT_MD5_HASH_PROP_ID</li>
     * <li>CERT_SIGNATURE_HASH_PROP_ID</li>
     * </ul>
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ACCESS_STATE_PROP_ID"></a><a id="cert_access_state_prop_id"></a><dl>
     * <dt><b>CERT_ACCESS_STATE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>DWORD</b>
     * 
     * Sets a <b>DWORD</b> value indicating whether write operations to the certificate are persisted. The <b>DWORD</b> value is not set if the certificate is in a memory store or in a registry-based store that is opened as read-only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ARCHIVED_PROP_ID"></a><a id="cert_archived_prop_id"></a><dl>
     * <dt><b>CERT_ARCHIVED_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: <b>NULL</b>
     * 
     * Indicates the certificate is skipped during enumerations. A certificate with this property set is found with explicit search operations, such as those used to find a certificate with a specific hash or a serial number. No data in <i>pvData</i> is associated with this property.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_AUTO_ENROLL_PROP_ID"></a><a id="cert_auto_enroll_prop_id"></a><dl>
     * <dt><b>CERT_AUTO_ENROLL_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets a <b>null</b>-terminated Unicode string naming the certificate type for which the certificate has been auto enrolled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CTL_USAGE_PROP_ID"></a><a id="cert_ctl_usage_prop_id"></a><dl>
     * <dt><b>CERT_CTL_USAGE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets an array of bytes containing an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoded <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CTL_USAGE</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_DESCRIPTION_PROP_ID"></a><a id="cert_description_prop_id"></a><dl>
     * <dt><b>CERT_DESCRIPTION_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets the property displayed by the certificate UI. This property allows the user to describe the certificate's use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ENHKEY_USAGE_PROP_ID"></a><a id="cert_enhkey_usage_prop_id"></a><dl>
     * <dt><b>CERT_ENHKEY_USAGE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: 
     * 
     * Sets an array of bytes containing an ASN.1 encoded <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CERT_ENHKEY_USAGE</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_FRIENDLY_NAME_PROP_ID"></a><a id="cert_friendly_name_prop_id"></a><dl>
     * <dt><b>CERT_FRIENDLY_NAME_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets a <b>null</b>-terminated Unicode character string that contains the display name for the CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID"></a><a id="cert_issuer_chain_pub_key_cng_alg_bit_length_prop_id"></a><dl>
     * <dt><b>CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/dpapi/ns-dpapi-crypt_integer_blob">CRYPT_DATA_BLOB</a> structure.
     * 
     * 
     * 
     * Sets a string containing a set of L"<i>&lt;PUBKEY&gt;</i>/<i>&lt;BITLENGTH&gt;</i>" public key algorithm and bit length pairs. The semicolon, L";", is used as the delimiter.
     * 
     * The <i>&lt;PUBKEY&gt;</i> value identifies the CNG public key algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"RSA" (BCRYPT_RSA_ALGORITHM)</li>
     * <li>L"DSA" (BCRYPT_DSA_ALGORITHM)</li>
     * <li>L"ECDSA" (SSL_ECDSA_ALGORITHM)</li>
     * </ul>
     * A <i>&lt;PUBKEY&gt;</i>/<i>&lt;BITLENGTH&gt;</i> pair is set for each certificate in the CRL issuer chain excluding the leaf. This property can be set when an OCSP response with an independent signer chain is converted to a CRL.
     * 
     * <div class="alert"><b>Note</b>  This property should not be set for a delegated OCSP signer certificate. A delegated signer certificate is signed with the same key used to sign the subject certificate and is checked there.</div>
     * <div> </div>
     * The following is an example:
     * 
     * : L"RSA/2048;RSA/4096"
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID"></a><a id="cert_issuer_chain_sign_hash_cng_alg_prop_id"></a><dl>
     * <dt><b>CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/dpapi/ns-dpapi-crypt_integer_blob">CRYPT_DATA_BLOB</a> structure.
     * 
     * 
     * 
     * Sets a string that contains a set of L"<i>&lt;SIGNATURE&gt;</i>/<i>&lt;HASH&gt;</i>" algorithm pairs. The semicolon, L";", is used as the delimiter between pairs.
     * 
     * This property is set only when an OCSP response is converted to a CRL. For a delegated OCSP signer certificate, only the algorithm pair for the signer certificate is returned. For an independent OCSP signer certificate chain, an algorithm pair is returned for each certificate in the chain excluding the root.
     * 
     * The <i>&lt;SIGNATURE&gt;</i> value identifies the CNG public key algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"RSA" (BCRYPT_RSA_ALGORITHM)</li>
     * <li>L"DSA" (BCRYPT_DSA_ALGORITHM)</li>
     * <li>L"ECDSA" (SSL_ECDSA_ALGORITHM)</li>
     * </ul>
     * The <i>&lt;HASH&gt;</i> value identifies the CNG hash algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"MD5" (BCRYPT_MD5_ALGORITHM)</li>
     * <li>L"SHA1" (BCRYPT_SHA1_ALGORITHM)</li>
     * <li>L"SHA256" (BCRYPT_SHA256_ALGORITHM)</li>
     * <li>L"SHA384" (BCRYPT_SHA384_ALGORITHM)</li>
     * <li>L"SHA512" (BCRYPT_SHA512_ALGORITHM)</li>
     * </ul>
     * The following is an  example:
     * 
     * <ul>
     * <li>L"RSA/SHA256;RSA/SHA256"</li>
     * </ul>
     * This property is explicitly set by the verify revocation functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID"></a><a id="cert_issuer_pub_key_bit_length_prop_id"></a><dl>
     * <dt><b>CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/dpapi/ns-dpapi-crypt_integer_blob">CRYPT_DATA_BLOB</a> structure.
     * 
     * 
     * 
     * Sets the length, in bits, of the public key in the CRL issuer certificate. This property is also applicable to an OCSP that has been converted to a CRL.
     * 
     * This property is explicitly set by the verify revocation functions.
     * 
     * <b>Windows 8 and Windows Server 2012:  </b>Support for this property begins.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_CONTEXT_PROP_ID"></a><a id="cert_key_context_prop_id"></a><dl>
     * <dt><b>CERT_KEY_CONTEXT_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a>
     * 
     * 
     * Sets a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_IDENTIFIER_PROP_ID"></a><a id="cert_key_identifier_prop_id"></a><dl>
     * <dt><b>CERT_KEY_IDENTIFIER_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_PROV_HANDLE_PROP_ID"></a><a id="cert_key_prov_handle_prop_id"></a><dl>
     * <dt><b>CERT_KEY_PROV_HANDLE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>:  pointer to an <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a>
     * 
     * 
     * Sets the provider handle obtained from the CERT_KEY_CONTEXT_PROP_ID.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_PROV_INFO_PROP_ID"></a><a id="cert_key_prov_info_prop_id"></a><dl>
     * <dt><b>CERT_KEY_PROV_INFO_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>:  pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a>
     * 
     * 
     * Sets a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_SPEC_PROP_ID"></a><a id="cert_key_spec_prop_id"></a><dl>
     * <dt><b>CERT_KEY_SPEC_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>DWORD</b>
     * 
     * Sets a <b>DWORD</b> value specifying the private key obtained from CERT_KEY_CONTEXT_PROP_ID property if it exists. Otherwise, if CERT_KEY_PROV_INFO_PROP_ID exists, it is the source of the <i>dwKeySpec</i>.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_MD5_HASH_PROP_ID"></a><a id="cert_md5_hash_prop_id"></a><dl>
     * <dt><b>CERT_MD5_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets the MD5 hash. You can compute the hash by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NEXT_UPDATE_LOCATION_PROP_ID"></a><a id="cert_next_update_location_prop_id"></a><dl>
     * <dt><b>CERT_NEXT_UPDATE_LOCATION_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets the ASN.1 encoded 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_alt_name_info">CERT_ALT_NAME_INFO</a> structure on a CTL.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_PVK_FILE_PROP_ID"></a><a id="cert_pvk_file_prop_id"></a><dl>
     * <dt><b>CERT_PVK_FILE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets a <b>null</b>-terminated Unicode, wide character string specifying the name of the file that contains the private key associated with the certificate's public key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SHA1_HASH_PROP_ID"></a><a id="cert_sha1_hash_prop_id"></a><dl>
     * <dt><b>CERT_SHA1_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets the SHA1 hash. You can compute the hash by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SIGN_HASH_CNG_ALG_PROP_ID"></a><a id="cert_sign_hash_cng_alg_prop_id"></a><dl>
     * <dt><b>CERT_SIGN_HASH_CNG_ALG_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/dpapi/ns-dpapi-crypt_integer_blob">CRYPT_DATA_BLOB</a> structure.
     * 
     * Sets the L”<i>&lt;SIGNATURE&gt;</i>/<i>&lt;HASH&gt;</i>” string representing the certificate signature. The <i>&lt;SIGNATURE&gt;</i> value identifies the CNG public key algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"RSA" (BCRYPT_RSA_ALGORITHM)</li>
     * <li>L"DSA" (BCRYPT_DSA_ALGORITHM)</li>
     * <li>L"ECDSA" (SSL_ECDSA_ALGORITHM)</li>
     * </ul>
     * The <i>&lt;HASH&gt;</i> value identifies the CNG hash algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"MD5" (BCRYPT_MD5_ALGORITHM)</li>
     * <li>L"SHA1" (BCRYPT_SHA1_ALGORITHM)</li>
     * <li>L"SHA256" (BCRYPT_SHA256_ALGORITHM)</li>
     * <li>L"SHA384" (BCRYPT_SHA384_ALGORITHM)</li>
     * <li>L"SHA512" (BCRYPT_SHA512_ALGORITHM)</li>
     * </ul>
     * The following are common examples:
     * 
     * <ul>
     * <li>L”RSA/SHA1”</li>
     * <li>L”RSA/SHA256”</li>
     * <li>L”ECDSA/SHA256” </li>
     * </ul>
     * This property is also applicable to an OCSP response that has been converted to a  CRL.
     * 
     * This property is explicitly set by the verify revocation functions.
     * 
     * <b>Windows 8 and Windows Server 2012:  </b>Support for this property begins.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SIGNATURE_HASH_PROP_ID"></a><a id="cert_signature_hash_prop_id"></a><dl>
     * <dt><b>CERT_SIGNATURE_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Sets the signature hash. If the hash does not exist, it is computed with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashtobesigned">CryptHashToBeSigned</a>. The length of the hash is 20 bytes for SHA and 16 for MD5.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The user can define additional <i>dwPropId</i> types by using <b>DWORD</b> values from CERT_FIRST_USER_PROP_ID to CERT_LAST_USER_PROP_ID. For all user-defined <i>dwPropId</i> types, <i>pvData</i> points to an encoded <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>.
     * 
     * For all the other property identifiers, <i>pvData</i> points to an encoded <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure.
     * @param {Integer} dwFlags CERT_STORE_NO_CRYPT_RELEASE_FLAG can be set for the CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_CONTEXT_PROP_ID <i>dwPropId</i> properties. 
     * 
     * 
     * 
     * 
     * If the CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG value is set, any provider-write errors are ignored and the cached context's properties are always set.
     * 
     * If the CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG is set, any property set is not persisted.
     * @param {Pointer<Void>} pvData A pointer to a data type that is determined by the value passed in <i>dwPropId</i>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  For any <i>dwPropId</i>, setting <i>pvData</i> to <b>NULL</b> deletes the property.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The property is not valid. The identifier specified was greater than 0x0000FFFF, or, for the CERT_KEY_CONTEXT_PROP_ID property, a <b>cbSize</b> member that is not valid was specified in the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certsetcrlcontextproperty
     * @since windows5.1.2600
     */
    static CertSetCRLContextProperty(pCrlContext, dwPropId, dwFlags, pvData) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSetCRLContextProperty", "ptr", pCrlContext, "uint", dwPropId, "uint", dwFlags, "ptr", pvData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Gets an extended property for the specified certificate revocation list (CRL) context.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure.
     * @param {Integer} dwPropId Identifies the property to be retrieved. Currently defined identifiers and the data type to be returned in <i>pvData</i> are listed in the following table. 
     * 
     * 
     * 
     * 
     * 						
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ACCESS_STATE_PROP_ID"></a><a id="cert_access_state_prop_id"></a><dl>
     * <dt><b>CERT_ACCESS_STATE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>DWORD</b>
     * 
     * Returns a <b>DWORD</b> value indicating whether write operations to the certificate are persisted. The <b>DWORD</b> value is not set if the certificate is in a memory store or in a registry-based store that is opened as read-only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ARCHIVED_PROP_ID"></a><a id="cert_archived_prop_id"></a><dl>
     * <dt><b>CERT_ARCHIVED_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: <b>NULL</b>
     * 
     * Indicates the certificate is skipped during enumerations. A certificate with this property set is found with explicit search operations, such as those used to find a certificate with a specific hash or a serial number. No data in <i>pvData</i> is associated with this property.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_AUTO_ENROLL_PROP_ID"></a><a id="cert_auto_enroll_prop_id"></a><dl>
     * <dt><b>CERT_AUTO_ENROLL_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns a <b>null</b>-terminated Unicode string naming the certificate type for which the certificate has been auto enrolled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CTL_USAGE_PROP_ID"></a><a id="cert_ctl_usage_prop_id"></a><dl>
     * <dt><b>CERT_CTL_USAGE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns an array of bytes containing an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoded <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CTL_USAGE</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_DESCRIPTION_PROP_ID"></a><a id="cert_description_prop_id"></a><dl>
     * <dt><b>CERT_DESCRIPTION_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the property displayed by the certificate UI. This property allows the user to describe the certificate's use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ENHKEY_USAGE_PROP_ID"></a><a id="cert_enhkey_usage_prop_id"></a><dl>
     * <dt><b>CERT_ENHKEY_USAGE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: 
     * 
     * Returns an array of bytes containing an ASN.1 encoded <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CERT_ENHKEY_USAGE</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_FRIENDLY_NAME_PROP_ID"></a><a id="cert_friendly_name_prop_id"></a><dl>
     * <dt><b>CERT_FRIENDLY_NAME_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns a <b>null</b>-terminated Unicode character string that contains the display name for the CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID"></a><a id="cert_issuer_chain_pub_key_cng_alg_bit_length_prop_id"></a><dl>
     * <dt><b>CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: Pointer to a null-terminated Unicode string.
     * 
     * Returns a string containing a set of L"<i>&lt;PUBKEY&gt;</i>/<i>&lt;BITLENGTH&gt;</i>" public key algorithm and bit length pairs. The semicolon, L";", is used as the delimiter.
     * 
     * The <i>&lt;PUBKEY&gt;</i> value identifies the CNG public key algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"RSA" (BCRYPT_RSA_ALGORITHM)</li>
     * <li>L"DSA" (BCRYPT_DSA_ALGORITHM)</li>
     * <li>L"ECDSA" (SSL_ECDSA_ALGORITHM)</li>
     * </ul>
     * An <i>&lt;PUBKEY&gt;</i>/<i>&lt;BITLENGTH&gt;</i> pair is returned for each certificate in the CRL issuer chain excluding the leaf. This property is only set when an OCSP response with an independent signer chain is converted to a CRL.
     * 
     * <div class="alert"><b>Note</b>  This property cannot be retrieved for a delegated OCSP signer certificate. A delegated signer certificate is signed with the same key used to sign the subject certificate and is checked there.</div>
     * <div> </div>
     * The following is an example:
     * 
     * : L"RSA/2048;RSA/4096"
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID"></a><a id="cert_issuer_chain_sign_hash_cng_alg_prop_id"></a><dl>
     * <dt><b>CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: Pointer to a null-terminated Unicode string.
     * 
     * Returns a string that contains a set of L"<i>&lt;SIGNATURE&gt;</i>/<i>&lt;HASH&gt;</i>" algorithm pairs. The semicolon, L";", is used as the delimiter between pairs.
     * 
     * This property is set only when an OCSP response is converted to a CRL. For a delegated OCSP signer certificate, only the algorithm pair for the signer certificate is returned. For an independent OCSP signer certificate chain, an algorithm pair is returned for each certificate in the chain excluding the root.
     * 
     * The <i>&lt;SIGNATURE&gt;</i> value identifies the CNG public key algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"RSA" (BCRYPT_RSA_ALGORITHM)</li>
     * <li>L"DSA" (BCRYPT_DSA_ALGORITHM)</li>
     * <li>L"ECDSA" (SSL_ECDSA_ALGORITHM)</li>
     * </ul>
     * The <i>&lt;HASH&gt;</i> value identifies the CNG hash algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"MD5" (BCRYPT_MD5_ALGORITHM)</li>
     * <li>L"SHA1" (BCRYPT_SHA1_ALGORITHM)</li>
     * <li>L"SHA256" (BCRYPT_SHA256_ALGORITHM)</li>
     * <li>L"SHA384" (BCRYPT_SHA384_ALGORITHM)</li>
     * <li>L"SHA512" (BCRYPT_SHA512_ALGORITHM)</li>
     * </ul>
     * The following shows an  example:
     * 
     * <ul>
     * <li>L"RSA/SHA256;RSA/SHA256"</li>
     * </ul>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID"></a><a id="cert_issuer_pub_key_bit_length_prop_id"></a><dl>
     * <dt><b>CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: Pointer to a <b>DWORD</b> value.
     * 
     * Returns the length, in bits, of the public key in the CRL issuer certificate. This property is also applicable to an OCSP response that has been converted to a CRL.
     * 
     * <b>Windows 8 and Windows Server 2012:  </b>Support for this property begins.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_CONTEXT_PROP_ID"></a><a id="cert_key_context_prop_id"></a><dl>
     * <dt><b>CERT_KEY_CONTEXT_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a>
     * 
     * 
     * Returns a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_IDENTIFIER_PROP_ID"></a><a id="cert_key_identifier_prop_id"></a><dl>
     * <dt><b>CERT_KEY_IDENTIFIER_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * If nonexistent, searches for the szOID_SUBJECT_KEY_IDENTIFIER extension. If that fails, a SHA1 hash is done on the certificate's <b>SubjectPublicKeyInfo</b> member to produce the identifier values.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_PROV_HANDLE_PROP_ID"></a><a id="cert_key_prov_handle_prop_id"></a><dl>
     * <dt><b>CERT_KEY_PROV_HANDLE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>:  pointer to an <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a>
     * 
     * 
     * Returns the provider handle obtained from the CERT_KEY_CONTEXT_PROP_ID.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_PROV_INFO_PROP_ID"></a><a id="cert_key_prov_info_prop_id"></a><dl>
     * <dt><b>CERT_KEY_PROV_INFO_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>:  pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a>
     * 
     * 
     * Returns a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_SPEC_PROP_ID"></a><a id="cert_key_spec_prop_id"></a><dl>
     * <dt><b>CERT_KEY_SPEC_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>DWORD</b>
     * 
     * Returns a <b>DWORD</b> value specifying the private key obtained from CERT_KEY_CONTEXT_PROP_ID property if it exists. Otherwise, if CERT_KEY_PROV_INFO_PROP_ID exists, it is the source of the <i>dwKeySpec</i>.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_MD5_HASH_PROP_ID"></a><a id="cert_md5_hash_prop_id"></a><dl>
     * <dt><b>CERT_MD5_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the MD5 hash. If the hash does not exist, it is computed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NEXT_UPDATE_LOCATION_PROP_ID"></a><a id="cert_next_update_location_prop_id"></a><dl>
     * <dt><b>CERT_NEXT_UPDATE_LOCATION_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the ASN.1 encoded 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_alt_name_info">CERT_ALT_NAME_INFO</a> structure. 
     * 
     * 
     * 
     * 
     * CERT_NEXT_UPDATE_LOCATION_PROP_ID is currently used only with CTLs.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_PVK_FILE_PROP_ID"></a><a id="cert_pvk_file_prop_id"></a><dl>
     * <dt><b>CERT_PVK_FILE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns a <b>null</b>-terminated Unicode, wide character string specifying the file name containing the private key associated with the certificate's public key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SHA1_HASH_PROP_ID"></a><a id="cert_sha1_hash_prop_id"></a><dl>
     * <dt><b>CERT_SHA1_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the SHA1 hash. If the hash does not exist, it is computed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SIGN_HASH_CNG_ALG_PROP_ID"></a><a id="cert_sign_hash_cng_alg_prop_id"></a><dl>
     * <dt><b>CERT_SIGN_HASH_CNG_ALG_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: Pointer to a null-terminated Unicode string.
     * 
     * Returns the L”<i>&lt;SIGNATURE&gt;</i>/<i>&lt;HASH&gt;</i>” string representing the certificate signature. The <i>&lt;SIGNATURE&gt;</i> value identifies the CNG public key algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"RSA" (BCRYPT_RSA_ALGORITHM)</li>
     * <li>L"DSA" (BCRYPT_DSA_ALGORITHM)</li>
     * <li>L"ECDSA" (SSL_ECDSA_ALGORITHM)</li>
     * </ul>
     * The <i>&lt;HASH&gt;</i> value identifies the CNG hash algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"MD5" (BCRYPT_MD5_ALGORITHM)</li>
     * <li>L"SHA1" (BCRYPT_SHA1_ALGORITHM)</li>
     * <li>L"SHA256" (BCRYPT_SHA256_ALGORITHM)</li>
     * <li>L"SHA384" (BCRYPT_SHA384_ALGORITHM)</li>
     * <li>L"SHA512" (BCRYPT_SHA512_ALGORITHM)</li>
     * </ul>
     * The following are common examples:
     * 
     * <ul>
     * <li>L”RSA/SHA1”</li>
     * <li>L”RSA/SHA256”</li>
     * <li>L”ECDSA/SHA256” </li>
     * </ul>
     * This property is also applicable to an OCSP response that has been converted to a CRL.
     * 
     * <b>Windows 8 and Windows Server 2012:  </b>Support for this property begins.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SIGNATURE_HASH_PROP_ID"></a><a id="cert_signature_hash_prop_id"></a><dl>
     * <dt><b>CERT_SIGNATURE_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the signature hash. If the hash does not exist, it is computed with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashtobesigned">CryptHashToBeSigned</a>. The length of the hash is 20 bytes for SHA and 16 for MD5.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * For many property identifiers, <i>pvData</i> points to an array of bytes and not a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> as pointed to by the <i>pvData</i> parameter in <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsetcrlcontextproperty">CertSetCRLContextProperty</a>.
     * 
     * For more information about each property identifier, see the documentation on the <i>dwPropId</i> parameter in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsetcertificatecontextproperty">CertSetCertificateContextProperty</a>.
     * @param {Pointer<Void>} pvData A pointer to a buffer to receive the data as determined by <i>dwPropId</i>. Structures pointed to by members of a structure returned are also returned following the base structure. Therefore, the size contained in <i>pcbData</i> often exceed the size of the base structure. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of the information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbData A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes to be stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. 
     * 
     * Note that errors from the called function 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a> can be propagated to this function. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CRL does not have the specified property.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pvData</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbData</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certgetcrlcontextproperty
     * @since windows5.1.2600
     */
    static CertGetCRLContextProperty(pCrlContext, dwPropId, pvData, pcbData) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetCRLContextProperty", "ptr", pCrlContext, "uint", dwPropId, "ptr", pvData, "ptr", pcbData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertEnumCRLContextProperties function retrieves the first or next extended property associated with a certificate revocation list (CRL) context.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure.
     * @param {Integer} dwPropId Property number of the last property enumerated. To get the first property, <i>dwPropId</i> is zero. To retrieve subsequent properties, <i>dwPropId</i> is set to the property number returned by the last call to the function. To enumerate all the properties, function calls continue until the function returns zero. 
     * 
     * 
     * 
     * 
     * Applications can call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcrlcontextproperty">CertGetCRLContextProperty</a> with the <i>dwPropId</i> returned by this function to retrieve that property's data.
     * @returns {Integer} The return value is a <b>DWORD</b> value that identifies a CRL context's property. The <b>DWORD</b> value returned by one call of the function can be supplied as the <i>dwPropId</i> in a subsequent call to the function. If there are no more properties to be enumerated or if the function fails, zero is returned.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certenumcrlcontextproperties
     * @since windows5.1.2600
     */
    static CertEnumCRLContextProperties(pCrlContext, dwPropId) {
        result := DllCall("CRYPT32.dll\CertEnumCRLContextProperties", "ptr", pCrlContext, "uint", dwPropId, "uint")
        return result
    }

    /**
     * The CertFindCertificateInCRL function searches the certificate revocation list (CRL) for the specified certificate.
     * @param {Pointer<CERT_CONTEXT>} pCert A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> of the certificate to be searched for in the CRL.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> to be searched.
     * @param {Integer} dwFlags Reserved for future use. Must be set to zero.
     * @param {Pointer<CRL_ENTRY>} ppCrlEntry If the certificate is found in the CRL, this pointer is updated with a pointer to the entry. Otherwise, it is set to <b>NULL</b>. The returned entry is not allocated and must not be freed.
     * @returns {Integer} <b>TRUE</b> if the list was searched; otherwise <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certfindcertificateincrl
     * @since windows5.1.2600
     */
    static CertFindCertificateInCRL(pCert, pCrlContext, dwFlags, ppCrlEntry) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("CRYPT32.dll\CertFindCertificateInCRL", "ptr", pCert, "ptr", pCrlContext, "uint", dwFlags, "ptr", pvReserved, "ptr", ppCrlEntry, "int")
        return result
    }

    /**
     * The CertIsValidCRLForCertificate function checks a CRL to find out if it is a CRL that would include a specific certificate if that certificate were revoked.
     * @remarks
     * For the CRL to be valid for the certificate, the <b>CertIsValidCRLForCertificate</b> function does not require the CRL to be issued by the same <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certification authority</a> (CA) as the issuer of the certificate.
     * @param {Pointer<CERT_CONTEXT>} pCert A pointer to a certificate <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a>.
     * @param {Pointer<CRL_CONTEXT>} pCrl A pointer to a CRL. The function checks this CRL to determine whether it could contain the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a> pointed to by <i>pCert</i>. The function does not look for the certificate in the CRL.
     * @param {Integer} dwFlags Currently not used and must be set to zero.
     * @returns {Integer} The function returns <b>TRUE</b> if the CRL is a valid CRL to be searched for the specific certificate. It returns <b>FALSE</b> if the CRL is not a valid CRL for searching for the certificate.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certisvalidcrlforcertificate
     * @since windows5.1.2600
     */
    static CertIsValidCRLForCertificate(pCert, pCrl, dwFlags) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("CRYPT32.dll\CertIsValidCRLForCertificate", "ptr", pCert, "ptr", pCrl, "uint", dwFlags, "ptr", pvReserved, "int")
        return result
    }

    /**
     * Creates a certificate context from an encoded certificate and adds it to the certificate store.
     * @param {Pointer<HCERTSTORE>} hCertStore A handle to the certificate store.
     * @param {Integer} dwCertEncodingType Specifies the type of encoding used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<Byte>} pbCertEncoded A pointer to a buffer containing the encoded certificate that is to be added to the certificate store.
     * @param {Integer} cbCertEncoded The size, in bytes, of the <i>pbCertEncoded</i> buffer.
     * @param {Integer} dwAddDisposition Specifies the action to take if a matching certificate or link to a matching certificate exists in the store. Currently defined disposition values and their uses are as follows.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function makes no check for an existing matching certificate or link to a matching certificate. A new certificate is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or a link to a matching certificate exists in the store, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or link to a matching certificate exists in the store, the existing certificate or link is deleted and a new certificate is created and added to the store. If a matching certificate or link to a matching certificate does not exist, a new certificate is created and added to the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES"></a><a id="cert_store_add_replace_existing_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate exists in the store, that existing context is deleted before creating and adding the new context. The new context inherits properties from the existing certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or a link to a matching certificate exists, that existing certificate or link is used and properties from the new certificate are added. The function does not fail, but it does not add a new context. If <i>ppCertContext</i> is not <b>NULL</b>, the existing context is duplicated.
     * 
     * If a matching certificate or link to a matching certificate does not exist, a new certificate is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CERT_CONTEXT>} ppCertContext A pointer to a pointer to the decoded <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a>. This is an optional parameter that can be <b>NULL</b>, indicating that the calling application does not require a copy of the new or existing certificate. When a copy is made, its context must be freed by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a>.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This code is returned if CERT_STORE_ADD_NEW is set and the certificate already exists in the store, or if CERT_STORE_ADD_NEWER is set and there is a certificate in the store with a <b>NotBefore</b> date greater than or equal to the <b>NotBefore</b> date on the certificate to be added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A disposition value that is not valid was specified in the <i>dwAddDisposition</i> parameter, or a certificate encoding type that is not valid was specified. Currently, only the X509_ASN_ENCODING type is supported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>  returns an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certaddencodedcertificatetostore
     * @since windows5.1.2600
     */
    static CertAddEncodedCertificateToStore(hCertStore, dwCertEncodingType, pbCertEncoded, cbCertEncoded, dwAddDisposition, ppCertContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddEncodedCertificateToStore", "ptr", hCertStore, "uint", dwCertEncodingType, "ptr", pbCertEncoded, "uint", cbCertEncoded, "uint", dwAddDisposition, "ptr", ppCertContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds a certificate context to the certificate store.
     * @remarks
     * The certificate <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a> is not duplicated using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certduplicatecertificatecontext">CertDuplicateCertificateContext</a>. Instead, the function creates a new copy of the context and adds it to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">store</a>.
     * 
     * In addition to the encoded certificate, <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certduplicatecertificatecontext">CertDuplicateCertificateContext</a> also copies the context's properties, with the exception of the CERT_KEY_PROV_HANDLE_PROP_ID and CERT_KEY_CONTEXT_PROP_ID properties.
     * 
     * To remove the certificate context from the certificate store, use the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certdeletecertificatefromstore">CertDeleteCertificateFromStore</a> function.
     * 
     * <div class="alert"><b>Note</b>  The order of the certificate context may not be preserved within the store. 
     * To access a specific certificate you must iterate across the certificates in the store.</div>
     * <div> </div>
     * @param {Pointer<HCERTSTORE>} hCertStore Handle of a certificate store.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure to be added to the store.
     * @param {Integer} dwAddDisposition Specifies the action to take if a matching certificate or a link to a matching certificate already exists in the store. Currently defined disposition values and their uses are as follows. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function makes no check for an existing matching certificate or link to a matching certificate. A new certificate is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or a link to a matching certificate exists, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="___CERT_STORE_ADD_NEWER"></a><a id="___cert_store_add_newer"></a><dl>
     * <dt><b>   CERT_STORE_ADD_NEWER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or a link to a matching certificate exists  and the NotBefore
     * time of the existing context is equal to or greater than the
     * NotBefore time of the new context being added, the operation fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code. 
     * 
     * If the NotBefore
     * time of the existing context is less than the
     * NotBefore time of the new context being added, the existing certificate or link is deleted and a new certificate is created and added to the store. If a matching certificate or a link to a matching certificate does not exist, a new link is added.      
     * 
     * If <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate revocation lists</a> (CRLs) or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate trust list</a> (CTLs) are being compared, the ThisUpdate time is  used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES"></a><a id="cert_store_add_newer_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or a link to a matching certificate exists and the NotBefore
     * time of the existing context is equal to or greater than the
     * NotBefore time of the new context being added, the operation fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code. 
     * 
     * If the NotBefore
     * time of the existing context is less than the
     * NotBefore time of the new context being added, the existing context is deleted before creating and adding the new context. The new added context inherits properties from the existing certificate.
     * 
     * If CRLs or CTLs are being compared, the ThisUpdate time is  used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a link to a matching certificate exists, that existing certificate or link is deleted and a new certificate is created and added to the store. If a matching certificate or a link to a matching certificate does not exist, a new link is added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES"></a><a id="cert_store_add_replace_existing_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate exists in the store, the existing context is not replaced. The existing context inherits properties from the new certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or a link to a matching certificate exists, that existing certificate or link is used and properties from the new certificate are added. The function does not fail, but it does not add a new context. If <i>pCertContext</i> is not <b>NULL</b>, the existing context is duplicated. 
     * 
     * 
     * 
     * 
     * If a matching certificate or a link to a matching certificate does not exist, a new certificate is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CERT_CONTEXT>} ppStoreContext A pointer to a pointer to the copy to be made of the certificate that was added to the store. 
     * 
     * 
     * 
     * 
     * The <i>ppStoreContext</i> parameter can be <b>NULL</b>, indicating that the calling application does not require a copy of the added certificate. If a copy is made, it must be freed by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a>.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value is returned if CERT_STORE_ADD_NEW is set and the certificate already exists in the store, or if CERT_STORE_ADD_NEWER is set and a certificate exists in the store with a <b>NotBefore</b> date greater than or equal to the <b>NotBefore</b> date on the certificate to be added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A disposition value that is not valid was specified in the <i>dwAddDisposition</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Errors from the called functions, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddencodedcertificatetostore">CertAddEncodedCertificateToStore</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsetcertificatecontextproperty">CertSetCertificateContextProperty</a>, can be propagated to this function.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certaddcertificatecontexttostore
     * @since windows5.1.2600
     */
    static CertAddCertificateContextToStore(hCertStore, pCertContext, dwAddDisposition, ppStoreContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddCertificateContextToStore", "ptr", hCertStore, "ptr", pCertContext, "uint", dwAddDisposition, "ptr", ppStoreContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds a serialized certificate, certificate revocation list (CRL), or certificate trust list (CTL) element to the store.
     * @param {Pointer<HCERTSTORE>} hCertStore The handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a> where the created certificate will be stored. If <i>hCertStore</i> is <b>NULL</b>, the function creates a copy of a certificate, CRL, or CTL context with its extended properties, but the certificate, CRL, or CTL is not persisted in any store.
     * @param {Pointer<Byte>} pbElement A pointer to a buffer that contains the certificate, CRL, or CTL information to be serialized and added to the certificate store.
     * @param {Integer} cbElement The size, in bytes, of the <i>pbElement</i> buffer.
     * @param {Integer} dwAddDisposition Specifies the action to take if the certificate, CRL, or CTL already exists in the store. Currently defined disposition values are shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate, CRL, or CTL is new, it is created and persisted to the store. The operation fails if an identical certificate, CRL, or CTL already exists in the store. The last error code is set to CRYPT_E_EXISTS.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate, CRL, or CTL is new, it is added to the store. If an identical certificate, CRL, or CTL already exists, the existing element is used. If <i>ppvContext</i> is not <b>NULL</b>, the existing context is duplicated. The function only adds properties that do not already exist. The SHA-1 and MD5 hash properties are not copied.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If an identical certificate, CRL, or CTL already exists in the store, the existing certificate, CRL, or CTL context is deleted before creating and adding the new context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No check is made to determine whether an identical certificate, CRL, or CTL already exists. A new element is always created. This can lead to duplicates in the store. To determine whether the element already exists in the store, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcrlfromstore">CertGetCRLFromStore</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetsubjectcertificatefromstore">CertGetSubjectCertificateFromStore</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER"></a><a id="cert_store_add_newer"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or CTL or a link to a matching CRL or CTL exists, the function compares the <b>NotBefore</b> times on the CRL or CTL. If the existing CRL or CTL has a <b>NotBefore</b> time less than the <b>NotBefore</b> time on the new element, the old element or link is replaced just as with CERT_STORE_ADD_REPLACE_EXISTING. If the existing element has a <b>NotBefore</b> time greater than or equal to the <b>NotBefore</b> time on the element to be added, the function fails with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning the CRYPT_E_EXISTS code.
     * 
     * If a matching CRL or CTL or a link to a matching CRL or CTL is not found in the store, a new element is added to the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES"></a><a id="cert_store_add_newer_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The action is the same as for CERT_STORE_ADD_NEWER. However, if an older CRL or CTL is replaced, the properties of the older element are incorporated into the replacement.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES"></a><a id="cert_store_add_replace_existing_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate exists in the store, the existing context is deleted before creating and adding the new context. The new added context inherits properties from the existing certificate.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Integer} dwContextTypeFlags Specifics the contexts that can be added. For example, to add either a certificate, CRL, or CTL, set <i>dwContextTypeFlags</i> to <b>CERT_STORE_CERTIFICATE_CONTEXT_FLAG</b> or <b>CERT_STORE_CRL_CONTEXT_FLAG</b>.
     * 						
     * 
     * Currently defined context type flags are shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ALL_CONTEXT_FLAG"></a><a id="cert_store_all_context_flag"></a><dl>
     * <dt><b>CERT_STORE_ALL_CONTEXT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Adds any context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CERTIFICATE_CONTEXT_FLAG"></a><a id="cert_store_certificate_context_flag"></a><dl>
     * <dt><b>CERT_STORE_CERTIFICATE_CONTEXT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Adds only a certificate context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CRL_CONTEXT_FLAG"></a><a id="cert_store_crl_context_flag"></a><dl>
     * <dt><b>CERT_STORE_CRL_CONTEXT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Adds only a CRL context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CTL_CONTEXT_FLAG"></a><a id="cert_store_ctl_context_flag"></a><dl>
     * <dt><b>CERT_STORE_CTL_CONTEXT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Adds only a CTL context.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UInt32>} pdwContextType A pointer to the context type of the added serialized element. This is an optional parameter and can be <b>NULL</b>, which indicates that the calling application does not require the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a> type.
     * 
     * Currently defined context types are shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CERTIFICATE_CONTEXT"></a><a id="cert_store_certificate_context"></a><dl>
     * <dt><b>CERT_STORE_CERTIFICATE_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Certificates
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CRL_CONTEXT"></a><a id="cert_store_crl_context"></a><dl>
     * <dt><b>CERT_STORE_CRL_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * CRLs
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CTL_CONTEXT"></a><a id="cert_store_ctl_context"></a><dl>
     * <dt><b>CERT_STORE_CTL_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * CTLs
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} ppvContext A pointer to a pointer to the decoded certificate, CRL, or CTL context. This is an optional parameter and can be <b>NULL</b>, which indicates that the calling application does not require the context of the added or existing certificate, CRL, or CTL.
     * 
     * If <i>ppvContext</i> is not <b>NULL</b>, it must be the address of a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a>, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a>. When the application is finished with the context, the context must be freed by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> for a certificate, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a> for a CRL, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreectlcontext">CertFreeCTLContext</a> for a CTL.
     * @returns {Integer} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the <i>dwAddDisposition</i> parameter is set to CERT_STORE_ADD_NEW, the certificate, CRL, or CTL already exists in the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A disposition value that is not valid was specified in the <i>dwAddDisposition</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certaddserializedelementtostore
     * @since windows5.1.2600
     */
    static CertAddSerializedElementToStore(hCertStore, pbElement, cbElement, dwAddDisposition, dwFlags, dwContextTypeFlags, pdwContextType, ppvContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddSerializedElementToStore", "ptr", hCertStore, "ptr", pbElement, "uint", cbElement, "uint", dwAddDisposition, "uint", dwFlags, "uint", dwContextTypeFlags, "ptr", pdwContextType, "ptr", ppvContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertDeleteCertificateFromStore function deletes the specified certificate context from the certificate store.
     * @remarks
     * After a certificate is deleted from a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">store</a>, all subsequent attempts to get or find that certificate in that store will fail. However, memory allocated for the certificate is not freed until all duplicated contexts have also been freed.
     * 
     * The <b>CertDeleteCertificateFromStore</b> function always frees <i>pCertContext</i> by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function, even if an error is encountered. Freeing the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a> reduces the context's <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> by one. If the reference count reaches zero, memory allocated for the certificate is freed.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure to be deleted.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 						
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_ACCESSDENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates the store was opened as read-only and a delete operation is not allowed.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certdeletecertificatefromstore
     * @since windows5.1.2600
     */
    static CertDeleteCertificateFromStore(pCertContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertDeleteCertificateFromStore", "ptr", pCertContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a certificate revocation list (CRL) context from an encoded CRL and adds it to the certificate store.
     * @param {Pointer<HCERTSTORE>} hCertStore Handle of a certificate store.
     * @param {Integer} dwCertEncodingType Specifies the type of encoding used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<Byte>} pbCrlEncoded A pointer to a buffer containing the encoded CRL to be added to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a>.
     * @param {Integer} cbCrlEncoded The size, in bytes, of the <i>pbCrlEncoded</i> buffer.
     * @param {Integer} dwAddDisposition Specifies the action to take if a matching CRL or a link to a matching CRL already exists in the store. Currently defined disposition values and their uses are as follows.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Makes no check for an existing matching CRL or link to a matching CRL. A new CRL is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER"></a><a id="cert_store_add_newer"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, the <b>ThisUpdate</b> times on the CRLs are compared. If the existing CRL has a <b>ThisUpdate</b> time less than the <b>ThisUpdate</b> time on the new CRL, the old CRL or link is replaced just as with CERT_STORE_ADD_REPLACE_EXISTING. If the existing CRL has a <b>ThisUpdate</b> time greater than or equal to the <b>ThisUpdate</b> time on the CRL to be added, the function fails with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning the CRYPT_E_EXISTS code.
     * 
     * If a matching CRL or a link to a matching CRL is not found in the store, a new CRL is added to the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES"></a><a id="cert_store_add_newer_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The action is the same as for CERT_STORE_ADD_NEWER, except that if an older CRL is replaced, the properties of the older CRL are incorporated into the replacement CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, that existing CRL or link is deleted and a new CRL is created and added to the store. If a matching CRL or a link to a matching CRL does not exist, one is added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES"></a><a id="cert_store_add_replace_existing_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL exists in the store, that existing context is deleted before creating and adding the new context. The new context inherits properties from the existing CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, that existing CRL is used and properties from the new CRL are added. The function does not fail, but no new CRL is added. If <i>ppCertContext</i> is not <b>NULL</b>, the existing context is duplicated. 
     * 
     * 
     * 
     * 
     * If a matching CRL or a link to a matching CRL does not exist, a new CRL is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CRL_CONTEXT>} ppCrlContext A pointer to a pointer to the decoded 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure. This is an optional parameter that can be <b>NULL</b>, indicating that the calling application does not require a copy of the new or existing CRL. If a copy is made, that context must be freed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a>.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * CERT_STORE_ADD_NEW is set and the CRL already exists in the store, or CERT_STORE_ADD_NEWER is set and there is a CRL in the store with a <b>ThisUpdate</b> time greater than or equal to the <b>ThisUpdate</b> time for the CRL to be added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A disposition value that is not valid was specified in the <i>dwAddDisposition</i> parameter, or an encoding type that is not valid was specified. Currently, only the encoding type X509_ASN_ENCODING is supported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certaddencodedcrltostore
     * @since windows5.1.2600
     */
    static CertAddEncodedCRLToStore(hCertStore, dwCertEncodingType, pbCrlEncoded, cbCrlEncoded, dwAddDisposition, ppCrlContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddEncodedCRLToStore", "ptr", hCertStore, "uint", dwCertEncodingType, "ptr", pbCrlEncoded, "uint", cbCrlEncoded, "uint", dwAddDisposition, "ptr", ppCrlContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds a certificate revocation list (CRL) context to the specified certificate store.
     * @remarks
     * The CRL context is not duplicated using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certduplicatecrlcontext">CertDuplicateCRLContext</a>. Instead, a new copy is created and added to the store. In addition to copying the encoded CRL, the function copies the context's properties.
     * 
     * To remove the CRL context from the certificate store, use the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certdeletecrlfromstore">CertDeleteCRLFromStore</a> function.
     * @param {Pointer<HCERTSTORE>} hCertStore Handle of a certificate store.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure to be added.
     * @param {Integer} dwAddDisposition Specifies the action to take if a matching CRL or a link to a matching CRL already exists in the store. Currently defined disposition values and their uses are as follows.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Makes no check for an existing matching CRL or link to a matching CRL. A new CRL is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER"></a><a id="cert_store_add_newer"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, the function compares the <b>ThisUpdate</b> times on the CRLs. If the existing CRL has a <b>ThisUpdate</b> time less than the <b>ThisUpdate</b> time on the new CRL, the old CRL or link is replaced just as with CERT_STORE_ADD_REPLACE_EXISTING. If the existing CRL has a <b>ThisUpdate</b> time greater than or equal to the <b>ThisUpdate</b> time on the CRL to be added, the function fails with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning the CRYPT_E_EXISTS code.
     * 
     * If a matching CRL or a link to a matching CRL is not found in the store, a new CRL is added to the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES"></a><a id="cert_store_add_newer_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The action is the same as for CERT_STORE_ADD_NEWER, except that if an older CRL is replaced, the properties of the older CRL are incorporated into the replacement CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, the existing CRL or link is deleted and a new CRL is created and added to the store. If a matching CRL or a link to a matching CRL does not exist, one is added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES"></a><a id="cert_store_add_replace_existing_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL exists in the store, the existing context is deleted before creating and adding the new context. The added context inherits properties from the existing CRL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, that existing CRL is used and properties from the new CRL are added. The function does not fail, but no new CRL is added. If <i>ppCertContext</i> is not <b>NULL</b>, the existing context is duplicated. 
     * 
     * 
     * 
     * 
     * If a matching CRL or a link to a matching CRL does not exist, a new CRL is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CRL_CONTEXT>} ppStoreContext A pointer to a pointer to the decoded CRL context. This is an optional parameter and can be <b>NULL</b>, indicating that the calling application does not require a copy of the added or existing CRL. If a copy is made, that context must be freed by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a>.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddencodedcrltostore">CertAddEncodedCRLToStore</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsetcrlcontextproperty">CertSetCRLContextProperty</a> can be propagated to this function.
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This error is returned if CERT_STORE_ADD_NEW is set and the CRL already exists in the store or if CERT_STORE_ADD_NEWER is set and a CRL exists in the store with a <b>ThisUpdate</b> date greater than or equal to the <b>ThisUpdate</b> date on the CRL to be added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwAddDisposition</i> parameter specified a disposition value that is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certaddcrlcontexttostore
     * @since windows5.1.2600
     */
    static CertAddCRLContextToStore(hCertStore, pCrlContext, dwAddDisposition, ppStoreContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddCRLContextToStore", "ptr", hCertStore, "ptr", pCrlContext, "uint", dwAddDisposition, "ptr", ppStoreContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertDeleteCRLFromStore function deletes the specified certificate revocation list (CRL) context from the certificate store.
     * @remarks
     * All subsequent get or find operations for the CRL in this store fail. However, memory allocated for the CRL is not freed until all duplicated contexts have also been freed.
     * 
     * The <i>pCrlContext</i> parameter is always freed by this function by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a>, even for an error.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure to be deleted.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_ACCESSDENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The store was opened read-only, and a delete operation is not allowed.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certdeletecrlfromstore
     * @since windows5.1.2600
     */
    static CertDeleteCRLFromStore(pCrlContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertDeleteCRLFromStore", "ptr", pCrlContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertSerializeCertificateStoreElement function serializes a certificate context's encoded certificate and its encoded properties. The result can be persisted to storage so that the certificate and properties can be retrieved at a later time.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> to be serialized.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Byte>} pbElement A pointer to a buffer that receives the serialized output, including the encoded certificate and possibly its properties. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbElement A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pbElement</i> parameter. When the function returns, <b>DWORD</b> value contains the number of bytes stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certserializecertificatestoreelement
     * @since windows5.1.2600
     */
    static CertSerializeCertificateStoreElement(pCertContext, dwFlags, pbElement, pcbElement) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSerializeCertificateStoreElement", "ptr", pCertContext, "uint", dwFlags, "ptr", pbElement, "ptr", pcbElement, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertSerializeCRLStoreElement function serializes an encoded certificate revocation list (CRL) context and the encoded representation of its properties.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure being serialized.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Byte>} pbElement A pointer to a buffer to receive the serialized output, including the encoded CRL, and possibly its properties. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbElement A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pbElement</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certserializecrlstoreelement
     * @since windows5.1.2600
     */
    static CertSerializeCRLStoreElement(pCrlContext, dwFlags, pbElement, pcbElement) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSerializeCRLStoreElement", "ptr", pCrlContext, "uint", dwFlags, "ptr", pbElement, "ptr", pcbElement, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertDuplicateCTLContext function duplicates a certificate trust list (CTL) context by incrementing its reference count.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure for which the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> is being incremented.
     * @returns {Pointer<CTL_CONTEXT>} Currently, a copy is not made of the context, and the returned pointer to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> is the same as pointer input. If the pointer passed into this function is <b>NULL</b>, <b>NULL</b> is returned.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certduplicatectlcontext
     * @since windows5.1.2600
     */
    static CertDuplicateCTLContext(pCtlContext) {
        result := DllCall("CRYPT32.dll\CertDuplicateCTLContext", "ptr", pCtlContext, "ptr")
        return result
    }

    /**
     * The CertCreateCTLContext function creates a certificate trust list (CTL) context from an encoded CTL. The created context is not persisted to a certificate store. The function makes a copy of the encoded CTL within the created context.
     * @remarks
     * The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> must be freed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreectlcontext">CertFreeCTLContext</a>. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certduplicatectlcontext">CertDuplicateCTLContext</a> can be called to make a duplicate. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsetctlcontextproperty">CertSetCTLContextProperty</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetctlcontextproperty">CertGetCTLContextProperty</a> can be called to store and read properties for the CTL.
     * @param {Integer} dwMsgAndCertEncodingType Specifies the type of encoding used. Both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> must be specified by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<Byte>} pbCtlEncoded A pointer to a buffer containing the encoded CTL from which the context is to be created.
     * @param {Integer} cbCtlEncoded The size, in bytes, of the <i>pbCtlEncoded</i> buffer.
     * @returns {Pointer<CTL_CONTEXT>} If the function succeeds, the return value is a pointer to a read-only 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a>.
     * 
     * If the function fails and is unable to decode and create the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a>, the return value is <b>NULL</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following table shows a possible error code.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Only PKCS_7_ASN_ENCODING and X509_ASN_ENCODING are supported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certcreatectlcontext
     * @since windows5.1.2600
     */
    static CertCreateCTLContext(dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertCreateCTLContext", "uint", dwMsgAndCertEncodingType, "ptr", pbCtlEncoded, "uint", cbCtlEncoded, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Frees a certificate trust list (CTL) context by decrementing its reference count.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> to be freed.
     * @returns {Integer} The function always returns <b>TRUE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certfreectlcontext
     * @since windows5.1.2600
     */
    static CertFreeCTLContext(pCtlContext) {
        result := DllCall("CRYPT32.dll\CertFreeCTLContext", "ptr", pCtlContext, "int")
        return result
    }

    /**
     * Sets an extended property for the specified certificate trust list (CTL) context.
     * @remarks
     * If a property already exists, its old value is replaced.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure.
     * @param {Integer} dwPropId Identifies the property to be set. The value of <i>dwPropId</i> determines the type and content of the <i>pvData</i> parameter. Currently defined identifiers and their related <i>pvData</i> types are as follows. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ARCHIVED_PROP_ID"></a><a id="cert_archived_prop_id"></a><dl>
     * <dt><b>CERT_ARCHIVED_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: <b>NULL</b>
     * 
     * Indicates the certificate is skipped during enumerations. A certificate with this property set is still found with explicit search operations—such as finding a certificate with a specific <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> or a specific serial number.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_AUTO_ENROLL_PROP_ID"></a><a id="cert_auto_enroll_prop_id"></a><dl>
     * <dt><b>CERT_AUTO_ENROLL_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>
     * 
     * 
     * Property set after a certificate has been enrolled using Auto Enroll. The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure pointed to by <i>pvData</i> includes a <b>null</b>-terminated, Unicode name of the certificate type for which the certificates has been auto enrolled. Any subsequent calls to Auto Enroll for the certificate checks for this property to determine whether the certificate has been enrolled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CTL_USAGE_PROP_ID"></a><a id="cert_ctl_usage_prop_id"></a><dl>
     * <dt><b>CERT_CTL_USAGE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>
     * 
     * 
     * <i>pvData</i> points to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure containing an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoded 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CTL_USAGE</a> structure. This structure was encoded using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencodeobject">CryptEncodeObject</a> with X509_ENHANCED_KEY_USAGE value set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_DESCRIPTION_PROP_ID"></a><a id="cert_description_prop_id"></a><dl>
     * <dt><b>CERT_DESCRIPTION_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>
     * 
     * 
     * Property set and displayed by the certificate UI. This property allows the user to describe the certificate's use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ENHKEY_USAGE_PROP_ID"></a><a id="cert_enhkey_usage_prop_id"></a><dl>
     * <dt><b>CERT_ENHKEY_USAGE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>
     * 
     * 
     * The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure containing an ASN.1 encoded <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CERT_ENHKEY_USAGE</a> structure. This structure was encoded using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencodeobject">CryptEncodeObject</a> with X509_ENHANCED_KEY_USAGE value set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_FRIENDLY_NAME_PROP_ID"></a><a id="cert_friendly_name_prop_id"></a><dl>
     * <dt><b>CERT_FRIENDLY_NAME_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>
     * 
     * 
     * The  <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure specifies the display name of the certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_HASH_PROP_ID"></a><a id="cert_hash_prop_id"></a><dl>
     * <dt><b>CERT_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a>
     * 
     * 
     * This property is implicitly set by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatecontextproperty">CertGetCertificateContextProperty</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_CONTEXT_PROP_ID"></a><a id="cert_key_context_prop_id"></a><dl>
     * <dt><b>CERT_KEY_CONTEXT_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a>
     * 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a> structure  contains both the <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a> value and the key specification for the private key. For more information about the <b>hCryptProv</b> member and <i>dwFlags</i> settings, see CERT_KEY_PROV_HANDLE_PROP_ID, following. Note that more <b>CERT_KEY_CONTEXT</b> structure members can be added for this property. If so, the <b>cbSize</b> member value will be adjusted accordingly. The <b>cbSize</b> member must be set to the size of the <b>CERT_KEY_CONTEXT</b> structure
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_IDENTIFIER_PROP_ID"></a><a id="cert_key_identifier_prop_id"></a><dl>
     * <dt><b>CERT_KEY_IDENTIFIER_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>
     * 
     * 
     * This property is typically implicitly set by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatecontextproperty">CertGetCertificateContextProperty</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_PROV_HANDLE_PROP_ID"></a><a id="cert_key_prov_handle_prop_id"></a><dl>
     * <dt><b>CERT_KEY_PROV_HANDLE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a>
     * 
     * 
     * An <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a> handle for the certificate's private key is passed. The <b>hCryptProv</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a> structure is updated if it exists. If it does not exist, it is created with <b>dwKeySpec</b> initialized by CERT_KEY_PROV_INFO_PROP_ID. If CERT_STORE_NO_CRYPT_RELEASE_FLAG is not set, the <b>hCryptProv</b> value is implicitly released either when the property is set to <b>NULL</b> or on the final freeing of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_PROV_INFO_PROP_ID"></a><a id="cert_key_prov_info_prop_id"></a><dl>
     * <dt><b>CERT_KEY_PROV_INFO_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a>
     * 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a> structure specifies the certificate's private key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_SPEC_PROP_ID"></a><a id="cert_key_spec_prop_id"></a><dl>
     * <dt><b>CERT_KEY_SPEC_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <b>DWORD</b>
     * 
     * The <b>DWORD</b> value specifies the private key. The <b>dwKeySpec</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a> structure is updated if it exists. If it does not, it is created with <b>hCryptProv</b> set to zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_MD5_HASH_PROP_ID"></a><a id="cert_md5_hash_prop_id"></a><dl>
     * <dt><b>CERT_MD5_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a>
     * 
     * 
     * This property is implicitly set by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatecontextproperty">CertGetCertificateContextProperty</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NEXT_UPDATE_LOCATION_PROP_ID"></a><a id="cert_next_update_location_prop_id"></a><dl>
     * <dt><b>CERT_NEXT_UPDATE_LOCATION_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>
     * 
     * 
     * The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure contains an ASN.1 encoded 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_alt_name_info">CERT_ALT_NAME_INFO</a> structure encoded using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencodeobject">CryptEncodeObject</a> with the X509_ALTERNATE_NAME value set. CERT_NEXT_UPDATE_LOCATION_PROP_ID is currently used only with CTLs.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_PVK_FILE_PROP_ID"></a><a id="cert_pvk_file_prop_id"></a><dl>
     * <dt><b>CERT_PVK_FILE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>
     * 
     * 
     * The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure specifies the name of a file containing the private key associated with the certificate's public key. Inside the <b>CRYPT_DATA_BLOB</b> structure, the <b>pbData</b> member is a pointer to a <b>null</b>-terminated Unicode, wide-character string, and the <b>cbData</b> member indicates the length of the string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SHA1_HASH_PROP_ID"></a><a id="cert_sha1_hash_prop_id"></a><dl>
     * <dt><b>CERT_SHA1_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a>
     * 
     * 
     * This property is implicitly set by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatecontextproperty">CertGetCertificateContextProperty</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SIGNATURE_HASH_PROP_ID"></a><a id="cert_signature_hash_prop_id"></a><dl>
     * <dt><b>CERT_SIGNATURE_HASH_PROP_ID</b></dt>
     * <dt>
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a>
     * </dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type of <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a>
     * 
     * 
     * If a signature hash does not exist, it is computed with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashtobesigned">CryptHashToBeSigned</a>. <i>pvData</i> points to an existing or computed hash. Usually, the length of the hash is 20 bytes for SHA and 16 for MD5.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Typically, only the CERT_NEXT_UPDATE_LOCATION_PROP_ID property is set.
     * 
     * Additional <i>dwPropId</i> types can be defined by the user using <b>DWORD</b> values from CERT_FIRST_USER_PROP_ID to CERT_LAST_USER_PROP_ID. For all user-defined <i>dwPropId</i> types, <i>pvData</i> points to an encoded <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure.
     * @param {Integer} dwFlags CERT_STORE_NO_CRYPT_RELEASE_FLAG can be set for the CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_CONTEXT_PROP_ID <i>dwPropId</i> properties. 
     * 
     * 
     * 
     * 
     * If the CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG value is set, any provider-write errors are ignored and the cached context's properties are always set.
     * 
     * If CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG is set, any property set is not persisted.
     * @param {Pointer<Void>} pvData A pointer to a data type that is determined by the value passed in <i>dwPropId</i>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  For any <i>dwPropId</i>, setting <i>pvData</i> to <b>NULL</b> deletes the property.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid property identifier. For details, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsetcertificatecontextproperty">CertSetCertificateContextProperty</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certsetctlcontextproperty
     * @since windows5.1.2600
     */
    static CertSetCTLContextProperty(pCtlContext, dwPropId, dwFlags, pvData) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSetCTLContextProperty", "ptr", pCtlContext, "uint", dwPropId, "uint", dwFlags, "ptr", pvData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves an extended property of a certificate trust list (CTL) context.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure.
     * @param {Integer} dwPropId Identifies the property to be retrieved. Currently defined identifiers and the data type to be returned in <i>pvData</i> are listed in the following table. 
     * 
     * 
     * 
     * 
     * 						
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ACCESS_STATE_PROP_ID"></a><a id="cert_access_state_prop_id"></a><dl>
     * <dt><b>CERT_ACCESS_STATE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>DWORD</b>
     * 
     * Returns a <b>DWORD</b> value indicating whether write operations to the certificate are persisted. The <b>DWORD</b> value is not set if the certificate is in a memory store or in a registry-based store that is opened as read-only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ARCHIVED_PROP_ID"></a><a id="cert_archived_prop_id"></a><dl>
     * <dt><b>CERT_ARCHIVED_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: <b>NULL</b>
     * 
     * Indicates the certificate is skipped during enumerations. A certificate with this property set is found with explicit search operations, such as those used to find a certificate with a specific hash or a serial number. No data in <i>pvData</i> is associated with this property.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_AUTO_ENROLL_PROP_ID"></a><a id="cert_auto_enroll_prop_id"></a><dl>
     * <dt><b>CERT_AUTO_ENROLL_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns a <b>null</b>-terminated Unicode string naming the certificate type for which the certificate has been auto enrolled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CTL_USAGE_PROP_ID"></a><a id="cert_ctl_usage_prop_id"></a><dl>
     * <dt><b>CERT_CTL_USAGE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns an array of bytes containing an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoded <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CTL_USAGE</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_DESCRIPTION_PROP_ID"></a><a id="cert_description_prop_id"></a><dl>
     * <dt><b>CERT_DESCRIPTION_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the property displayed by the certificate UI. This property allows the user to describe the certificate's use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_ENHKEY_USAGE_PROP_ID"></a><a id="cert_enhkey_usage_prop_id"></a><dl>
     * <dt><b>CERT_ENHKEY_USAGE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns an array of bytes containing an ASN.1 encoded <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CERT_ENHKEY_USAGE</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_FRIENDLY_NAME_PROP_ID"></a><a id="cert_friendly_name_prop_id"></a><dl>
     * <dt><b>CERT_FRIENDLY_NAME_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns a <b>null</b>-terminated Unicode character string that contains the display name for the CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_HASH_PROP_ID"></a><a id="cert_hash_prop_id"></a><dl>
     * <dt><b>CERT_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the SHA1 hash. If the hash does not exist, it is computed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_CONTEXT_PROP_ID"></a><a id="cert_key_context_prop_id"></a><dl>
     * <dt><b>CERT_KEY_CONTEXT_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a>
     * 
     * 
     * Returns a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_key_context">CERT_KEY_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_IDENTIFIER_PROP_ID"></a><a id="cert_key_identifier_prop_id"></a><dl>
     * <dt><b>CERT_KEY_IDENTIFIER_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * If nonexistent, searches for the szOID_SUBJECT_KEY_IDENTIFIER extension. If that fails, a SHA1 hash is done on the certificate's <b>SubjectPublicKeyInfo</b> member to produce the identifier values.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_PROV_HANDLE_PROP_ID"></a><a id="cert_key_prov_handle_prop_id"></a><dl>
     * <dt><b>CERT_KEY_PROV_HANDLE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to an <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a>
     * 
     * 
     * Returns the provider handle obtained from the CERT_KEY_CONTEXT_PROP_ID.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_PROV_INFO_PROP_ID"></a><a id="cert_key_prov_info_prop_id"></a><dl>
     * <dt><b>CERT_KEY_PROV_INFO_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a> structure
     * 
     * Returns a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_KEY_SPEC_PROP_ID"></a><a id="cert_key_spec_prop_id"></a><dl>
     * <dt><b>CERT_KEY_SPEC_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>DWORD</b>
     * 
     * Returns a <b>DWORD</b> value specifying the private key obtained from CERT_KEY_CONTEXT_PROP_ID property if it exists. Otherwise, if CERT_KEY_PROV_INFO_PROP_ID exists, it is the source of the <i>dwKeySpec</i>.
     * 							
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_MD5_HASH_PROP_ID"></a><a id="cert_md5_hash_prop_id"></a><dl>
     * <dt><b>CERT_MD5_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the MD5 hash. If the hash does not exist, it is computed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NEXT_UPDATE_LOCATION_PROP_ID"></a><a id="cert_next_update_location_prop_id"></a><dl>
     * <dt><b>CERT_NEXT_UPDATE_LOCATION_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the ASN.1 encoded 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_alt_name_info">CERT_ALT_NAME_INFO</a> structure. 
     * 
     * 
     * 
     * 
     * CERT_NEXT_UPDATE_LOCATION_PROP_ID is currently used only with CTLs.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_PVK_FILE_PROP_ID"></a><a id="cert_pvk_file_prop_id"></a><dl>
     * <dt><b>CERT_PVK_FILE_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns a <b>null</b>-terminated Unicode, wide character string specifying the file name containing the private key associated with the certificate's public key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SHA1_HASH_PROP_ID"></a><a id="cert_sha1_hash_prop_id"></a><dl>
     * <dt><b>CERT_SHA1_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the SHA1 hash. If the hash does not exist, it is computed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SIGNATURE_HASH_PROP_ID"></a><a id="cert_signature_hash_prop_id"></a><dl>
     * <dt><b>CERT_SIGNATURE_HASH_PROP_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Data type for <i>pvData</i>: pointer to a <b>BYTE</b> array
     * 
     * Returns the signature hash. If the hash does not exist, it is computed with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashtobesigned">CryptHashToBeSigned</a>. The length of the hash is 20 bytes for SHA and 16 for MD5.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * For all other property identifiers, <i>pvData</i> points to an array of bytes and not a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> as pointed to by the <i>pvData</i> parameter in <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsetcertificatecontextproperty">CertSetCertificateContextProperty</a>.
     * 
     * For more information about each property identifier, see the documentation on the <i>dwPropId</i> parameter in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsetcertificatecontextproperty">CertSetCertificateContextProperty</a>. CERT_SHA1_HASH_PROP_ID and CERT_NEXT_UPDATE_LOCATION_PROP_ID are the predefined properties of most interest.
     * @param {Pointer<Void>} pvData A pointer to a buffer to receive the data as determined by <i>dwPropId</i>. Structures pointed to by members of a structure returned are also returned following the base structure. Therefore, the size contained in <i>pcbData</i> often exceed the size of the base structure. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of the information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbData A pointer to a <b>DWORD</b> value specifying the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, the <b>DWORD</b> value contains the number of bytes to be stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. 
     * 
     * Errors from the called function, <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashcertificate">CryptHashCertificate</a>, can be propagated to this function. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * Some possible error codes follow.
     * 						
     * 					
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CTL does not have the specified property.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pvData</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbData</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certgetctlcontextproperty
     * @since windows5.1.2600
     */
    static CertGetCTLContextProperty(pCtlContext, dwPropId, pvData, pcbData) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetCTLContextProperty", "ptr", pCtlContext, "uint", dwPropId, "ptr", pvData, "ptr", pcbData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertEnumCTLContextProperties function retrieves the first or next extended property associated with a certificate trust list (CTL) context. Used in a loop, this function can retrieve in sequence all extended properties associated with a CTL context.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure.
     * @param {Integer} dwPropId Property number of the last property enumerated. To get the first property, <i>dwPropId</i> is zero. To retrieve subsequent properties, <i>dwPropId</i> is set to the property number returned by the last call to the function. To enumerate all the properties, function calls continue until the function returns zero. 
     * 
     * 
     * 
     * 
     * Applications can call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetctlcontextproperty">CertGetCTLContextProperty</a> with the <i>dwPropId</i> returned by this function to retrieved that property's data.
     * @returns {Integer} The return value is a <b>DWORD</b> value that identifies a CTL context's property. The <b>DWORD</b> value returned by one call of the function can be supplied as the <i>dwPropId</i> in a subsequent call to the function. If there are no more properties to be enumerated or if the function fails, zero is returned.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certenumctlcontextproperties
     * @since windows5.1.2600
     */
    static CertEnumCTLContextProperties(pCtlContext, dwPropId) {
        result := DllCall("CRYPT32.dll\CertEnumCTLContextProperties", "ptr", pCtlContext, "uint", dwPropId, "uint")
        return result
    }

    /**
     * The CertEnumCTLsInStore function retrieves the first or next certificate trust list (CTL) context in a certificate store. Used in a loop, this function can retrieve in sequence all CTL contexts in a certificate store.
     * @remarks
     * The returned pointer is freed when passed as the <i>pPrevCtlContext</i> on a subsequent call. Otherwise, the pointer must be explicitly freed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreectlcontext">CertFreeCTLContext</a>. A <i>pPrevCtlContext</i> that is not <b>NULL</b> is always freed by this function (through a call to <b>CertFreeCTLContext</b>), even for an error.
     * 
     * A duplicate can be made by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certduplicatectlcontext">CertDuplicateCTLContext</a>.
     * @param {Pointer<HCERTSTORE>} hCertStore Handle of a certificate store.
     * @param {Pointer<CTL_CONTEXT>} pPrevCtlContext A pointer to the previous 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure found. It must be <b>NULL</b> to get the first CTL in the store. Successive CTLs are enumerated by setting <i>pPrevCtlContext</i> to the pointer returned by a previous call. This function frees the <b>CTL_CONTEXT</b> referenced by non-<b>NULL</b> values of this parameter. The enumeration skips any CTLs previously deleted by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certdeletectlfromstore">CertDeleteCTLFromStore</a>.
     * @returns {Pointer<CTL_CONTEXT>} If the function succeeds, the return value is a pointer to a read-only 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a>.
     * 
     * If the function fails and a CTL is not found, the return value is <b>NULL</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either no CTLs exist in the store, or the function reached the end of the store's list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hCertStore</i> parameter is not the same as that in the CTL context pointed to by the <i>pPrevCtlContext</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certenumctlsinstore
     * @since windows5.1.2600
     */
    static CertEnumCTLsInStore(hCertStore, pPrevCtlContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertEnumCTLsInStore", "ptr", hCertStore, "ptr", pPrevCtlContext, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertFindSubjectInCTL function attempts to find the specified subject in a certificate trust list (CTL).
     * @remarks
     * The certificate's hash or the <b>SubjectIdentifier</b> member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_any_subject_info">CTL_ANY_SUBJECT_INFO</a> structure is used as the key in searching the subject entries. A binary memory comparison is done between the key and the entry's <b>SubjectIdentifier</b>.
     * @param {Integer} dwEncodingType Specifies the encoding type used. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. For either current encoding type, use: 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Integer} dwSubjectType Specifies the type of subject to be searched for in the CTL. May be <b>NULL</b> for a default search.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CTL_CERT_SUBJECT_TYPE"></a><a id="ctl_cert_subject_type"></a><dl>
     * <dt><b>CTL_CERT_SUBJECT_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSubject</i> data type: Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure.
     * 
     * The CTL's <b>SubjectAlgorithm</b> is examined to determine the representation of the subject's identity. Initially, only SHA1 and MD5 hashes are supported as values for <b>SubjectAlgorithm</b>. The appropriate hash property is obtained from the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CTL_ANY_SUBJECT_TYPE"></a><a id="ctl_any_subject_type"></a><dl>
     * <dt><b>CTL_ANY_SUBJECT_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSubject</i> data type: Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_any_subject_info">CTL_ANY_SUBJECT_INFO</a> structure.
     * 
     * The <b>SubjectAlgorithm</b> member of this structure must match the algorithm type of the CTL, and the <b>SubjectIdentifier</b> member must match one of the CTL entries.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The certificate's <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> or the <b>SubjectIdentifier</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_any_subject_info">CTL_ANY_SUBJECT_INFO</a> structure is used as the key in searching the subject entries. A binary memory comparison is done between the key and the entry's SubjectIdentifier.
     * 
     * If <i>dwSubjectType</i> is set to either preceding value, <i>dwEncodingType</i> is not used.
     * @param {Pointer<Void>} pvSubject Pointer used in conjunction with the <i>dwSubjectType</i> parameter.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure being searched.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @returns {Pointer<CTL_ENTRY>} If the function succeeds, the return value is the entry, if it is found.
     * 
     * If the function fails, the return value is <b>NULL</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The subject was not found in the CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwSubjectType</i> parameter was not either CTL_CERT_SUBJECT_TYPE or CTL_ANY_SUBJECT_TYPE.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The CTL's <b>SubjectAlgorithm</b> member did not map to either SHA1 or MD5.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certfindsubjectinctl
     * @since windows5.1.2600
     */
    static CertFindSubjectInCTL(dwEncodingType, dwSubjectType, pvSubject, pCtlContext, dwFlags) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertFindSubjectInCTL", "uint", dwEncodingType, "uint", dwSubjectType, "ptr", pvSubject, "ptr", pCtlContext, "uint", dwFlags, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Finds the first or next certificate trust list (CTL) context that matches search criteria established by the dwFindType and its associated pvFindPara.
     * @remarks
     * A returned pointer is freed when passed as the <i>pPrevCtlContext</i> on a subsequent call to the function. Otherwise, the pointer must be freed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreectlcontext">CertFreeCTLContext</a>. A non-<b>NULL</b><i>pPrevCtlContext</i> passed to the function is always freed with a call to <b>CertFreeCTLContext</b>, even if the function generates an error.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certduplicatectlcontext">CertDuplicateCTLContext</a> can be called to make a duplicate of the returned context. The returned CTL context can be added to a different certificate store using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddctlcontexttostore">CertAddCTLContextToStore</a>, or a link to that CTL context can be added to a noncollection store using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddctllinktostore">CertAddCTLLinkToStore</a>. If a CTL matching the search criteria is not found, <b>NULL</b> is returned.
     * @param {Pointer<HCERTSTORE>} hCertStore Handle of the certificate store to be searched.
     * @param {Integer} dwMsgAndCertEncodingType Specifies the type of encoding used on the CTL. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * 
     * 
     * This parameter is used only when the <i>dwFindType</i> parameter is set to CTL_FIND_USAGE.
     * @param {Integer} dwFindFlags Can be set when <i>dwFindType</i> is set to CTL_FIND_USAGE. For details, see the comments under CTL_FIND_USAGE, following.
     * @param {Integer} dwFindType 
     * @param {Pointer<Void>} pvFindPara A pointer to the search value associated with the <i>dwFindType</i> parameter.
     * @param {Pointer<CTL_CONTEXT>} pPrevCtlContext A pointer to the last 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> returned by this function. It must be <b>NULL</b> to get the first CTL in the store. Successive CTLs are retrieved by setting <i>pPrevCtlContext</i> to the pointer to the <b>CTL_CONTEXT</b> returned by a previous function call. Any certificates that do not meet the search criteria or that have been previously deleted by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certdeletectlfromstore">CertDeleteCTLFromStore</a> are skipped. This function frees the <b>CTL_CONTEXT</b> referenced by non-<b>NULL</b> values of this parameter.
     * @returns {Pointer<CTL_CONTEXT>} If the function succeeds, the return value is a pointer to a read-only <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CTL</a><a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a>.
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either no CTLs were found in the store, no CTL was found matching the search criteria, or the function reached the end of the store's list.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle in the <i>hCertStore</i> parameter is not the same as that in the CTL context pointed to by the <i>pPrevCtlContext</i> parameter, or a value that is not valid was specified in the <i>dwFindType</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certfindctlinstore
     * @since windows5.1.2600
     */
    static CertFindCTLInStore(hCertStore, dwMsgAndCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCtlContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertFindCTLInStore", "ptr", hCertStore, "uint", dwMsgAndCertEncodingType, "uint", dwFindFlags, "uint", dwFindType, "ptr", pvFindPara, "ptr", pPrevCtlContext, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a certificate trust list (CTL) context from an encoded CTL and adds it to the certificate store.
     * @param {Pointer<HCERTSTORE>} hCertStore Handle of a certificate store.
     * @param {Integer} dwMsgAndCertEncodingType Specifies the type of encoding used. Both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> must be specified by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:<ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<Byte>} pbCtlEncoded A pointer to a buffer containing the encoded CTL to be added to the certificate store.
     * @param {Integer} cbCtlEncoded The size, in bytes, of the <i>pbCtlEncoded</i> buffer.
     * @param {Integer} dwAddDisposition Specifies the action to take if a matching CTL or a link to a matching CTL already exists in the store. Currently defined disposition values and their uses are as follows 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Makes no check for an existing matching CTL or link to a matching CTL. A new CTL is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER"></a><a id="cert_store_add_newer"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the <b>ThisUpdate</b> times on the CTLs are compared. If the existing CTL has a <b>ThisUpdate</b> time less than the <b>ThisUpdate</b> time on the new CTL, the old CTL or link is replaced just as with CERT_STORE_ADD_REPLACE_EXISTING. If the existing CTL has a <b>ThisUpdate</b> time greater than or equal to the <b>ThisUpdate</b> time on the CTL to be added, the function fails with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning the CRYPT_E_EXISTS code. 
     * 
     * 
     * 
     * 
     * If a matching CTL or a link to a matching CTL is not found in the store, a new CTL is added to the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES"></a><a id="cert_store_add_newer_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The action is the same as for CERT_STORE_ADD_NEWER, except that if an older CTL is replaced, the properties of the older CTL are incorporated into the replacement CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the existing CTL or link is deleted and a new CTL is created and added to the store. If a matching CTL or a link to a matching CTL does not exist, one is added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES"></a><a id="cert_store_add_replace_existing_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL exists in the store, that existing context is deleted before creating and adding the new context. The added context inherits properties from the existing CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, that existing CTL is used and properties from the new CTL are added. The function does not fail, but no new CTL is added. If <i>ppCertContext</i> is not <b>NULL</b>, the existing context is duplicated. 
     * 
     * 
     * 
     * 
     * If a matching CTL or a link to a matching CTL does not exist, a new CTL is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CTL_CONTEXT>} ppCtlContext A pointer to a pointer to the decoded 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure. Can be <b>NULL</b> indicating that the calling application does not require a copy of the added or existing CTL. If a copy is made, it must be freed by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreectlcontext">CertFreeCTLContext</a>.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * Some possible error codes follow.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * CERT_STORE_ADD_NEW is set, and the CTL already exists in the store; or CERT_STORE_ADD_NEWER is set and there is a CTL in the store with a <b>ThisUpdate</b> time greater than or equal to the <b>ThisUpdate</b> time on the CTL to be added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A disposition value that is not valid was specified in the <i>dwAddDisposition</i> parameter, or an encoding type that is not valid was specified. Currently, only the encoding types X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are supported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certaddencodedctltostore
     * @since windows5.1.2600
     */
    static CertAddEncodedCTLToStore(hCertStore, dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded, dwAddDisposition, ppCtlContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddEncodedCTLToStore", "ptr", hCertStore, "uint", dwMsgAndCertEncodingType, "ptr", pbCtlEncoded, "uint", cbCtlEncoded, "uint", dwAddDisposition, "ptr", ppCtlContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds a certificate trust list (CTL) context to a certificate store.
     * @remarks
     * The CTL context is not duplicated using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certduplicatectlcontext">CertDuplicateCTLContext</a>. Instead, a new copy is created and added to the store. In addition to the encoded CTL, the context's properties are copied.
     * 
     * To remove the CTL context from the certificate store, use the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certdeletectlfromstore">CertDeleteCTLFromStore</a> function.
     * @param {Pointer<HCERTSTORE>} hCertStore Handle of a certificate store.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure to be added to the store.
     * @param {Integer} dwAddDisposition Specifies the action to take if a matching CTL or a link to a matching CTL already exists in the store. Currently defined disposition values and their uses are as follows.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Makes no check for an existing matching CTL or link to a matching CTL. A new CTL is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER"></a><a id="cert_store_add_newer"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the <b>ThisUpdate</b> times on the CTLs are compared. If the existing CTL has a <b>ThisUpdate</b> time less than the <b>ThisUpdate</b> time on the new CTL, the old CTL or link is replaced just as with CERT_STORE_ADD_REPLACE_EXISTING. If the existing CTL has a <b>ThisUpdate</b> time greater than or equal to the <b>ThisUpdate</b> time on the CTL to be added, the function fails with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning the CRYPT_E_EXISTS code.
     * 
     * If a matching CTL or a link to a matching CTL is not found in the store, a new CTL is added to the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES"></a><a id="cert_store_add_newer_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The action is the same as for CERT_STORE_ADD_NEWER, except that if an older CTL is replaced, the properties of the older CTL are incorporated into the replacement CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the existing CTL or link is deleted and a new CTL is created and added to the store. If a matching CTL or a link to a matching CTL does not exist, one is added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES"></a><a id="cert_store_add_replace_existing_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL exists in the store, that existing context is deleted before creating and adding the new context. The added context inherits properties from the existing CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, that existing CTL is used and properties from the new CTL are added. The function does not fail, but no new CTL is added. If <i>ppCertContext</i> is not <b>NULL</b>, the existing context is duplicated.
     * 
     * If a matching CTL or a link to a matching CTL does not exist, a new CTL is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CTL_CONTEXT>} ppStoreContext Pointer to a pointer to the decoded CTL <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a>. This optional parameter can be <b>NULL</b> indicating that the calling application does not require a copy of the added or existing CTL. If a copy is made, that context must be freed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreectlcontext">CertFreeCTLContext</a>.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddencodedcrltostore">CertAddEncodedCRLToStore</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certsetcrlcontextproperty">CertSetCRLContextProperty</a> can be propagated to this function.
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This error is returned if CERT_STORE_ADD_NEW is set and the CTL exists in the store or if CERT_STORE_ADD_NEWER is set and a CTL exists in the store with a <b>ThisUpdate</b> date greater than or equal to the <b>ThisUpdate</b> date on the CTL to be added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An add disposition that is not valid was specified by the <i>dwAddDisposition</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certaddctlcontexttostore
     * @since windows5.1.2600
     */
    static CertAddCTLContextToStore(hCertStore, pCtlContext, dwAddDisposition, ppStoreContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddCTLContextToStore", "ptr", hCertStore, "ptr", pCtlContext, "uint", dwAddDisposition, "ptr", ppStoreContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertSerializeCTLStoreElement function serializes an encoded certificate trust list (CTL) context and the encoded representation of its properties. The result can be persisted to storage so that the CTL and properties can be retrieved later.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure being serialized.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Byte>} pbElement A pointer to a buffer that receives the serialized output, including the encoded CTL and, possibly, its properties. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbElement A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the buffer that is pointed to by the <i>pbElement</i> parameter. When the function returns the <b>DWORD</b> value contains the number of bytes stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certserializectlstoreelement
     * @since windows5.1.2600
     */
    static CertSerializeCTLStoreElement(pCtlContext, dwFlags, pbElement, pcbElement) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSerializeCTLStoreElement", "ptr", pCtlContext, "uint", dwFlags, "ptr", pbElement, "ptr", pcbElement, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertDeleteCTLFromStore function deletes the specified certificate trust list (CTL) context from a certificate store.
     * @remarks
     * All subsequent get or find operations for the CTL in this store fail. However, memory allocated for the CTL is not freed until all duplicated contexts have also been freed.
     * 
     * The <i>pCtlContext</i> parameter is always freed by this function by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreectlcontext">CertFreeCTLContext</a>, even for an error.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure to be deleted.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_ACCESSDENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The store was opened read-only, and a delete operation is not allowed.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certdeletectlfromstore
     * @since windows5.1.2600
     */
    static CertDeleteCTLFromStore(pCtlContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertDeleteCTLFromStore", "ptr", pCtlContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds a link in a certificate store to a certificate context in a different store.
     * @remarks
     * Because the link provides access to the original certificate <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a>, setting an extended property in the linked <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a> changes that extended property in the certificate's original location and in any other links to that certificate.
     * 
     * Links cannot be added to a store opened as a collection. Stores opened as collections include all stores opened with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopensystemstorea">CertOpenSystemStore</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenstore">CertOpenStore</a> using CERT_STORE_PROV_SYSTEM or CERT_STORE_PROV_COLLECTION. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddstoretocollection">CertAddStoreToCollection</a>.
     * 
     * If links are used and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a> is called with CERT_CLOSE_STORE_FORCE_FLAG, the store that uses links must be closed before the store that contains the original contexts is closed. If CERT_CLOSE_STORE_FORCE_FLAG is not used, the two stores can be closed in either order.
     * 
     * To remove the certificate context link from the certificate store, use the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certdeletecertificatefromstore">CertDeleteCertificateFromStore</a> function.
     * @param {Pointer<HCERTSTORE>} hCertStore A handle to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a> where the link is to be added.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure to be linked.
     * @param {Integer} dwAddDisposition Specifies the action if a matching certificate or a link to a matching certificate already exists in the store. Currently defined disposition values and their uses are as follows. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function makes no check for an existing matching certificate or link to a matching certificate. A new certificate is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or a link to a matching certificate exists, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a link to a matching certificate exists, that existing link is deleted and a new link is created and added to the store. If no matching certificate or link to a matching certificate exists, one is added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching certificate or a link to a matching certificate exists, the existing certificate is used. The function does not fail, but no new link is added. If no matching certificate or link to a matching certificate exists, a new link is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CERT_CONTEXT>} ppStoreContext A pointer to a pointer to a copy of the link created. The <i>ppStoreContext</i> parameter can be <b>NULL</b> to indicate that a copy of the link is not needed. If a copy of the link is created, that copy must be freed using 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a <i>dwAddDisposition</i> parameter of CERT_STORE_ADD_NEW, the certificate already exists in the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A disposition value that is not valid was specified in the <i>dwAddDisposition</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certaddcertificatelinktostore
     * @since windows5.1.2600
     */
    static CertAddCertificateLinkToStore(hCertStore, pCertContext, dwAddDisposition, ppStoreContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddCertificateLinkToStore", "ptr", hCertStore, "ptr", pCertContext, "uint", dwAddDisposition, "ptr", ppStoreContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds a link in a store to a certificate revocation list (CRL) context in a different store.
     * @remarks
     * Because the link provides access to an original CRL context, setting an extended property in the linked CRL context changes that extended property in the CRL's original location and in any other links to that CRL.
     * 
     * Links cannot be added to a store that is opened as a collection. Stores opened as collections include all stores opened with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopensystemstorea">CertOpenSystemStore</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenstore">CertOpenStore</a> using CERT_STORE_PROV_SYSTEM or CERT_STORE_PROV_COLLECTION. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddstoretocollection">CertAddStoreToCollection</a>.
     * 
     * If links are used and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a> is called with CERT_CLOSE_STORE_FORCE_FLAG, the store using links must be closed before the store containing the original contexts can be closed. If CERT_CLOSE_STORE_FORCE_FLAG is not used, the two stores can be closed in either order.
     * 
     * To remove the CRL context link from the certificate store, use the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certdeletecrlfromstore">CertDeleteCRLFromStore</a> function.
     * @param {Pointer<HCERTSTORE>} hCertStore Handle of a certificate store where the link is to be added.
     * @param {Pointer<CRL_CONTEXT>} pCrlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure to be linked.
     * @param {Integer} dwAddDisposition Specifies the action to take if a matching CRL or a link to a matching CRL exists in the store. Currently defined disposition values and their uses are as follows.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Makes no check for an existing matching CRL or link to a matching CRL. A new link is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER"></a><a id="cert_store_add_newer"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, the <b>ThisUpdate</b> times on the CRLs are compared. If the existing CRL has a <b>ThisUpdate</b> time less than the <b>ThisUpdate</b> time on the new CRL, the old link is replaced just as with CERT_STORE_ADD_REPLACE_EXISTING. If the existing CRL has a <b>ThisUpdate</b> time greater than or equal to the <b>ThisUpdate</b> time on the CRL to be added, the function fails with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning the CRYPT_E_EXISTS code. 
     * 
     * 
     * 
     * 
     * If a matching CRL or a link to a matching CRL is not found in the store, a new link is added to the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a link to the matching CRL exists, that existing link is deleted and a new link is created and added to the store. If a matching CRL or a link to a matching CRL does not exist, a new link is added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CRL or a link to a matching CRL exists, that existing link is used. The function does not fail, but no new link is added. If a matching CRL or link to a CRL does not exist, a new link is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CRL_CONTEXT>} ppStoreContext A pointer to a pointer of a copy of the link created. The <i>ppStoreContext</i> parameter can be <b>NULL</b> to indicate that a copy of the link is not needed. If a copy of the link is created, that copy must be freed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a>.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a <i>dwAddDisposition</i> of CERT_STORE_ADD_NEW, the CTL already exists in the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A disposition value that is not valid was specified in the <i>dwAddDisposition</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certaddcrllinktostore
     * @since windows5.1.2600
     */
    static CertAddCRLLinkToStore(hCertStore, pCrlContext, dwAddDisposition, ppStoreContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddCRLLinkToStore", "ptr", hCertStore, "ptr", pCrlContext, "uint", dwAddDisposition, "ptr", ppStoreContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertAddCTLLinkToStore function adds a link in a store to a certificate trust list (CTL) context in a different store. Instead of creating and adding a duplicate of a CTL context, this function adds a link to the original CTL context.
     * @remarks
     * Because the link provides access to the original <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CTL</a> context, setting an extended property in the linked CTL context changes that extended property in the original CTL's location and in any other links to that CTL.
     * 
     * Links cannot be added to a store that is opened as a collection. Stores opened as collections include all stores opened with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopensystemstorea">CertOpenSystemStore</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenstore">CertOpenStore</a> using CERT_STORE_PROV_SYSTEM or CERT_STORE_PROV_COLLECTION. Also see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddstoretocollection">CertAddStoreToCollection</a>.
     * 
     * When links are used and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a> is called with CERT_CLOSE_STORE_FORCE_FLAG, the store using links must be closed before the store containing the original contexts is closed. If CERT_CLOSE_STORE_FORCE_FLAG is not used, the two stores can be closed in either order.
     * 
     * To remove the CTL context link from the certificate store, use the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certdeletectlfromstore">CertDeleteCTLFromStore</a> function.
     * @param {Pointer<HCERTSTORE>} hCertStore Handle of the certificate store where the link is to be added.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure to be linked.
     * @param {Integer} dwAddDisposition Specifies the action to take if a matching CTL or a link to a matching CTL already exists in the store. Currently defined disposition values and their uses are as follows.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_ALWAYS"></a><a id="cert_store_add_always"></a><dl>
     * <dt><b>CERT_STORE_ADD_ALWAYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Makes no check for an existing matching CTL or link to a matching CTL. A new CTL is always added to the store. This can lead to duplicates in a store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEW"></a><a id="cert_store_add_new"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the operation fails. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the CRYPT_E_EXISTS code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER"></a><a id="cert_store_add_newer"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the <b>ThisUpdate</b> times on the CTLs are compared. If the existing CTL has a <b>ThisUpdate</b> time less than the <b>ThisUpdate</b> time on the new CTL, the old CTL or link is replaced just as with CERT_STORE_ADD_REPLACE_EXISTING. If the existing CTL has a <b>ThisUpdate</b> time greater than or equal to the <b>ThisUpdate</b> time on the CTL to be added, the function fails with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returning the CRYPT_E_EXISTS code. 
     * 
     * 
     * 
     * 
     * If a matching CTL or a link to a matching CTL is not found in the store, a new CTL is added to the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES"></a><a id="cert_store_add_newer_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The action is the same as for CERT_STORE_ADD_NEWER, except that if an older CTL is replaced, the properties of the older CTL are incorporated into the replacement CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING"></a><a id="cert_store_add_replace_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, the existing CTL or link is deleted and a new CTL is created and added to the store. If a matching CTL or a link to a matching CTL does not exist, one is added.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES"></a><a id="cert_store_add_replace_existing_inherit_properties"></a><dl>
     * <dt><b>CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL exists in the store, that existing context is deleted before creating and adding the new context. The added context inherits properties from the existing CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_ADD_USE_EXISTING"></a><a id="cert_store_add_use_existing"></a><dl>
     * <dt><b>CERT_STORE_ADD_USE_EXISTING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a matching CTL or a link to a matching CTL exists, that existing CTL is used and properties from the new CTL are added. The function does not fail, but no new CTL is added. If <i>ppCertContext</i> is not <b>NULL</b>, the existing context is duplicated.
     * 
     * If a matching CTL or a link to a matching CTL does not exist, a new CTL is added.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CTL_CONTEXT>} ppStoreContext A pointer to a pointer to a copy of the link created. <i>ppStoreContext</i> can be <b>NULL</b> to indicate that a copy of the link is not needed. If a copy of the link is created, that copy must be freed using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreectlcontext">CertFreeCTLContext</a>.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes follow.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a <i>dwAddDisposition</i> of CERT_STORE_ADD_NEW, the CTL already exists in the store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The add disposition specified by the <i>dwAddDisposition</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certaddctllinktostore
     * @since windows5.1.2600
     */
    static CertAddCTLLinkToStore(hCertStore, pCtlContext, dwAddDisposition, ppStoreContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddCTLLinkToStore", "ptr", hCertStore, "ptr", pCtlContext, "uint", dwAddDisposition, "ptr", ppStoreContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertAddStoreToCollection function adds a sibling certificate store to a collection certificate store.
     * @remarks
     * A collection store has the same <b>HCERTSTORE</b> handle as a single store; thus, almost all functions that apply to any <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a> also apply to any collection store. Enumeration and search processes span all of the stores in a collection store; however, functions such as 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddcertificatelinktostore">CertAddCertificateLinkToStore</a> that add links to stores cannot be used with collection stores.
     * 
     * When a certificate, CRL, or CTL is added to a collection store, the list of sibling stores in the collection is searched in priority order to find the first store that allows adding. Adding is enabled if CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG was set in the <b>CertAddStoreToCollection</b> call. With any function that adds elements to a store, if a store that allows adding does not return success, the addition function continues on to the next store without providing notification.
     * 
     * When a collection store and its sibling stores are closed with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a> using CERT_CLOSE_STORE_FORCE_FLAG, the collection store must be closed before its sibling stores. If CERT_CLOSE_STORE_FORCE_FLAG is not used, the stores can be closed in any order.
     * @param {Pointer<HCERTSTORE>} hCollectionStore Handle of a certificate store.
     * @param {Pointer<HCERTSTORE>} hSiblingStore Handle of a sibling store to be added to the collection store. For more information, see  Remarks.
     * @param {Integer} dwUpdateFlags Indicates whether <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificates</a>, CRLs, and CTLs can be added to the new sibling store member of the collection store. To enable addition, set <i>dwUpdateFlag</i> to CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG.   To disable additions, set <i>dwUpdateFlag</i> to zero.
     * @param {Integer} dwPriority Sets a priority level of the new store in the collection, with zero being the lowest priority. If zero is passed for this parameter, the specified store is appended as the last store in the collection. The priority levels of the stores in a collection determine the order in which the stores are enumerated, and the search order of the stores when attempting to retrieve a certificate, CRL, or CTL. Priority levels also determine to which store of a collection a new certificate, CRL, or CTL is added. For more information, see  Remarks.
     * @returns {Integer} If the function succeeds, the function returns nonzero and a new store is added to the collection of stores.
     * 
     * If the function fails, it returns zero and the store was not added.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certaddstoretocollection
     * @since windows5.1.2600
     */
    static CertAddStoreToCollection(hCollectionStore, hSiblingStore, dwUpdateFlags, dwPriority) {
        result := DllCall("CRYPT32.dll\CertAddStoreToCollection", "ptr", hCollectionStore, "ptr", hSiblingStore, "uint", dwUpdateFlags, "uint", dwPriority, "int")
        return result
    }

    /**
     * Removes a sibling certificate store from a collection store.
     * @param {Pointer<HCERTSTORE>} hCollectionStore A handle of the collection certificate store.
     * @param {Pointer<HCERTSTORE>} hSiblingStore Handle of the sibling certificate store to be removed from the collection store.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certremovestorefromcollection
     * @since windows5.1.2600
     */
    static CertRemoveStoreFromCollection(hCollectionStore, hSiblingStore) {
        DllCall("CRYPT32.dll\CertRemoveStoreFromCollection", "ptr", hCollectionStore, "ptr", hSiblingStore)
    }

    /**
     * Allows an application to be notified when there is a difference between the contents of a cached store in use and the contents of that store as it is persisted to storage.
     * @remarks
     * Resynchronization of a store can be done at any time. It need not follow a signaled notification change event.
     * 
     * CERT_STORE_CTRL_NOTIFY_CHANGE is supported on registry-based store providers by using the <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regnotifychangekeyvalue">RegNotifyChangeKeyValue</a> function.
     * 
     * <b>CertControlStore</b> using CERT_STORE_CTRL_NOTIFY_CHANGE is called once for each event handle to be passed with CERT_STORE_CTRL_RESYNC. These calls using CERT_STORE_CTRL_NOTIFY_CHANGE must be made after each event is created and not after an event has been signaled.
     * @param {Pointer<HCERTSTORE>} hCertStore Handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a>.
     * @param {Integer} dwFlags 
     * @param {Integer} dwCtrlType Control action to be taken by <b>CertControlStore</b>. The interpretations of <i>pvCtrlPara</i> and <i>dwFlags</i> depend on the value of <i>dwCtrlType</i>. Currently, the following  actions are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CTRL_RESYNC"></a><a id="cert_store_ctrl_resync"></a><dl>
     * <dt><b>CERT_STORE_CTRL_RESYNC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The cached store is resynchronized and made to match the persisted store.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CTRL_NOTIFY_CHANGE"></a><a id="cert_store_ctrl_notify_change"></a><dl>
     * <dt><b>CERT_STORE_CTRL_NOTIFY_CHANGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A signal is returned in the space pointed to by <i>pvCtrlPara</i> to indicate that the current contents of the cached store differ from the store's persisted <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">state</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CTRL_COMMIT"></a><a id="cert_store_ctrl_commit"></a><dl>
     * <dt><b>CERT_STORE_CTRL_COMMIT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Any changes made to the cached store are copied to persisted storage. If no changes were made since the cached store was opened or since the last commit, the call is ignored. The call is also ignored if the store provider is a provider that automatically persists changes immediately.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CTRL_AUTO_RESYNC"></a><a id="cert_store_ctrl_auto_resync"></a><dl>
     * <dt><b>CERT_STORE_CTRL_AUTO_RESYNC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * At the start of every enumeration or find store call, a check is made to determine whether a change has been made in the store. If the store has changed, a re-synchronization is done. This check is only done on first enumeration or find calls, when the <i>pPrevContext</i> is <b>NULL</b>.
     * 
     * 
     * The <b>pvCtrPara</b> member is not used and must be set to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CTRL_CANCEL_NOTIFY"></a><a id="cert_store_ctrl_cancel_notify"></a><dl>
     * <dt><b>CERT_STORE_CTRL_CANCEL_NOTIFY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Cancels notification signaling of the event HANDLE passed in a previous CERT_STORE_CTRL_NOTIFY_CHANGE or CERT_STORE_CTRL_RESYNC. The <i>pvCtrlPara</i> parameter points to the event HANDLE to be canceled.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvCtrlPara If <i>dwCtrlType</i> is CERT_STORE_NOTIFY_CHANGE, <i>pvCtrlPara</i> is set to the address of a handle where the system signals the notification change event when a change from the persisted <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">state</a> of the store is detected. The handle must be initialized with a call to the function <a href="https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-createeventa">CreateEvent</a>. The <i>pvCtrlPara</i> parameter can be set to <b>NULL</b> for registry-based stores. If <i>pvCtrlPara</i> is <b>NULL</b>, an internal notification change event is created and registered to be signaled. Using the internal notification change event allows resynchronization operations only if the store was changed. 
     * 
     * 
     * 
     * 
     * If <i>dwCtrlType</i> is CERT_STORE_CTRL_RESYNC, set <i>pvCtrlPara</i> to the address of the event handle to be signaled on the next change in the persisted store. Typically, this address is the address of the event handle passed with CERT_STORE_CTRL_NOTIFY_CHANGE during initialization. The event handle passed is rearmed. If <i>pvCtrlPara</i> is set to <b>NULL</b>, no event is rearmed.
     * 
     * If <i>dwCtrlType</i> CERT_STORE_CTRL_COMMIT, <i>pvCtrlPara</i> is not used and must be set to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <i>dwCtrlType</i> is CERT_STORE_NOTIFY_CHANGE, the function returns nonzero if a handle for the event signal was successfully set up. The function returns zero if the event handle was not set up.
     * 
     * If <i>dwCtrlType</i> is CERT_STORE_CTRL_RESYNC, the function returns nonzero if the resynchronization succeeded. The function returns zero if the resynchronization failed.
     * 
     * If <i>dwCtrlType</i> is CERT_STORE_CTRL_COMMIT, the function returns nonzero to indicate the successful completion of the commit to persisted storage. The function returns zero if the commit failed.
     * 
     * Some providers might not support specific control types. In these cases, <b>CertControlStore</b> returns zero and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> is set to the ERROR_NOT_SUPPORTED code.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certcontrolstore
     * @since windows5.1.2600
     */
    static CertControlStore(hCertStore, dwFlags, dwCtrlType, pvCtrlPara) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertControlStore", "ptr", hCertStore, "uint", dwFlags, "uint", dwCtrlType, "ptr", pvCtrlPara, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertSetStoreProperty function sets a store property.
     * @remarks
     * Store property identifiers are properties applicable to an entire store. They are not properties for an individual <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a>, <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CRL</a>, or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CTL</a> context. Currently, no store properties are persisted.
     * @param {Pointer<HCERTSTORE>} hCertStore Handle for the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a>.
     * @param {Integer} dwPropId Indicates one of a range of store properties. Values for user-defined properties must be outside the current range of predefined context property values. Currently, user-defined <i>dwPropId</i> values begin at 4,096. There is one predefined store property, CERT_STORE_LOCALIZED_NAME_PROP_ID, the localized name of the store.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Void>} pvData The type definition for <i>pvData</i> depends on the <i>dwPropId</i> value. If <i>dwPropId</i> is CERT_STORE_LOCALIZED_NAME_PROP_ID, <i>pvData</i> points to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure. The <b>pbData</b> member of that structure is a pointer to a <b>null</b>-terminated Unicode character string. The <b>cbData</b> member of that structure is a <b>DWORD</b> value holding the length of the string. 
     * 
     * 
     * 
     * 
     * For user-defined <i>dwPropId</i> values, <i>pvData</i> is a pointer to an encoded <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a>.
     * 
     * If a value already exists for the selected property, the old value is replaced.
     * 
     * Calling this function with <i>pvData</i> set to <b>NULL</b> deletes a property.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certsetstoreproperty
     * @since windows5.1.2600
     */
    static CertSetStoreProperty(hCertStore, dwPropId, dwFlags, pvData) {
        result := DllCall("CRYPT32.dll\CertSetStoreProperty", "ptr", hCertStore, "uint", dwPropId, "uint", dwFlags, "ptr", pvData, "int")
        return result
    }

    /**
     * Retrieves a store property.
     * @remarks
     * Store property identifiers are properties applicable to an entire store. They are not properties on an individual <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a>, <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate revocation list</a> (CRL), or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate trust list</a> (CTL) context. Currently, no store properties are persisted.
     * 
     * To find the localized name of a store, you can also use the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptfindlocalizedname">CryptFindLocalizedName</a> function.
     * @param {Pointer<HCERTSTORE>} hCertStore A handle of an open <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a>.
     * @param {Integer} dwPropId Indicates one of a range of store properties. There is one predefined store property, CERT_STORE_LOCALIZED_NAME_PROP_ID, the localized name of the store.
     * 
     * User defined properties must be outside the current range of values for predefined context properties. Currently, user defined <i>dwPropId</i> values begin at 4,096.
     * @param {Pointer<Void>} pvData A pointer to a buffer that receives the data as determined by <i>dwPropId</i>. For CERT_STORE_LOCALIZED_NAME_PROP_ID, this is the localized name of the store, and <i>pvData</i> points to a null-terminated Unicode wide-character string. For other <i>dwPropId</i>s, <i>pvData</i> points to an array of bytes.
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbData A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the <i>pvData</i> buffer. When the function returns, the <b>DWORD</b> value contains the number of bytes stored in the buffer.
     * @returns {Integer} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero.
     * 
     * If the store property is found, the function returns nonzero, <i>pvData</i> points to the property, and <i>pcbData</i> points to the length of the string. If the store property is not found, the function returns zero and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns CRYPT_E_NOT_FOUND.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certgetstoreproperty
     * @since windows5.1.2600
     */
    static CertGetStoreProperty(hCertStore, dwPropId, pvData, pcbData) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetStoreProperty", "ptr", hCertStore, "uint", dwPropId, "ptr", pvData, "ptr", pcbData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates the specified context from the encoded bytes. The context created does not include any extended properties.
     * @param {Integer} dwContextType Specifies the contexts that can be created. For example, to create a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a> <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">context</a>, set <i>dwContextType</i> to CERT_STORE_CERTIFICATE_CONTEXT.
     * 						
     * 
     * Currently defined context type flags are shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CERTIFICATE_CONTEXT"></a><a id="cert_store_certificate_context"></a><dl>
     * <dt><b>CERT_STORE_CERTIFICATE_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Certificate context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CRL_CONTEXT"></a><a id="cert_store_crl_context"></a><dl>
     * <dt><b>CERT_STORE_CRL_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * CRL context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CTL_CONTEXT"></a><a id="cert_store_ctl_context"></a><dl>
     * <dt><b>CERT_STORE_CTL_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * CTL context.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwEncodingType Specifies the encoding type used. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. For either current encoding type, use: 
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Pointer<Byte>} pbEncoded A pointer to a buffer that contains the existing encoded context content to be copied.
     * @param {Integer} cbEncoded The size, in bytes, of the <i>pbEncoded</i> buffer.
     * @param {Integer} dwFlags The following flag values are defined and can be combined by using a bitwise-<b>OR</b> operation.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CREATE_CONTEXT_NOCOPY_FLAG"></a><a id="cert_create_context_nocopy_flag"></a><dl>
     * <dt><b>CERT_CREATE_CONTEXT_NOCOPY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The created context points directly to the content pointed to by <i>pbEncoded</i> instead of an allocated copy.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CREATE_CONTEXT_SORTED_FLAG"></a><a id="cert_create_context_sorted_flag"></a><dl>
     * <dt><b>CERT_CREATE_CONTEXT_SORTED_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function creates a context with sorted entries. Currently, this flag only applies to a CTL context.
     * 
     * For CTLs, the <b>cCTLEntry</b> member of the returned 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_info">CTL_INFO</a> structure is always zero. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfindsubjectinsortedctl">CertFindSubjectInSortedCTL</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certenumsubjectinsortedctl">CertEnumSubjectInSortedCTL</a> must be called to find or enumerate the CTL entries.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG"></a><a id="cert_create_context_no_hcryptmsg_flag"></a><dl>
     * <dt><b>CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * By default, when a CTL context is created, a HCRYTPMSG handle to its <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/signeddata">SignedData</a> message is created. This flag can be set to improve performance by not creating this handle. This flag can only be used when <i>dwContextType</i> is CERT_STORE_CTL_CONTEXT.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CREATE_CONTEXT_NO_ENTRY_FLAG"></a><a id="cert_create_context_no_entry_flag"></a><dl>
     * <dt><b>CERT_CREATE_CONTEXT_NO_ENTRY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * By default, when a CTL context is created, its entries are decoded. When this flag is set, the entries are not decoded and performance is improved. This flag can only be used when <i>dwContextType</i> is CERT_STORE_CTL_CONTEXT.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CERT_CREATE_CONTEXT_PARA>} pCreatePara A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_create_context_para">CERT_CREATE_CONTEXT_PARA</a> structure. 
     * 
     * 
     * 
     * 
     * If <i>pCreatePara</i> and its <b>pfnFree</b> member are both non-<b>NULL</b>, the <b>pfnFree</b> member is used to free the memory specified by the <b>pvFree</b> member. If the <b>pvFree</b> member is <b>NULL</b>, the <b>pfnFree</b> member is used to free the <i>pbEncoded</i> pointer.
     * 
     * If <i>pCreatePara</i> or its <b>pfnFree</b> member is <b>NULL</b>, no attempt is made to free <i>pbEncoded</i>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certcreatecontext
     * @since windows5.1.2600
     */
    static CertCreateContext(dwContextType, dwEncodingType, pbEncoded, cbEncoded, dwFlags, pCreatePara) {
        A_LastError := 0

        DllCall("CRYPT32.dll\CertCreateContext", "uint", dwContextType, "uint", dwEncodingType, "ptr", pbEncoded, "uint", cbEncoded, "uint", dwFlags, "ptr", pCreatePara)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Registers a system store.
     * @remarks
     * To unregister a system store that has been registered by this function, call <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certunregistersystemstore">CertUnregisterSystemStore</a>.
     * @param {Pointer<Void>} pvSystemStore Identifies the system store to be registered. If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in the <i>dwFlags</i> parameter, <i>pvSystemStore</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure. Otherwise, it points to a <b>null</b>-terminated Unicode string that names the system store. 
     * 
     * 
     * 
     * 
     * With appropriate settings in <i>dwFlags</i>, the identified store can be a system store on a remote local computer. Stores on remote computers can be registered with the computer name as a prefix to the name of the system store. For example, a remote local computer store can be registered with <i>pvSystemStore</i> pointing to the string "\\ComputerName\Trust" or "ComputerName\Trust".
     * 
     * Leading "\\" backslashes are optional before a ComputerName.
     * @param {Integer} dwFlags The high word of the <i>dwFlags</i> parameter is used to specify the location of the system store. 
     * 
     * 
     * 
     * 						
     * 						
     * 						
     * 						
     * 					
     * 
     * 
     * The following high-word values are defined.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_CURRENT_SERVICE"></a><a id="cert_system_store_current_service"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_CURRENT_SERVICE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSystemStore</i> can be a system store name that is prefixed with the ServiceName.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_CURRENT_USER"></a><a id="cert_system_store_current_user"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_CURRENT_USER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSystemStore</i> can be a system store name that is prefixed with the UserName.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_LOCAL_MACHINE"></a><a id="cert_system_store_local_machine"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_LOCAL_MACHINE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSystemStore</i> can be a system store that is on a remote computer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY"></a><a id="cert_system_store_local_machine_group_policy"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSystemStore</i> is a group policy store and can be on a remote computer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_SERVICES"></a><a id="cert_system_store_services"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_SERVICES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSystemStore</i> must be a system store name prefixed with the ServiceName.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_USERS"></a><a id="cert_system_store_users"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_USERS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSystemStore</i> must be a system store name that is prefixed with the UserName.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Stores on remote computers can be registered for CERT_SYSTEM_STORE_LOCAL_MACHINE, CERT_SYSTEM_STORE_SERVICES, CERT_SYSTEM_STORE_USERS, or CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY.
     * 
     * 
     * The following low-word values are also defined and can be combined using a bitwise-<b>OR</b> operation with high-word values.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_RELOCATE_FLAG"></a><a id="cert_system_store_relocate_flag"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_RELOCATE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system store is not in its default register location and <i>pvSystemStore</i> must be a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CREATE_NEW_FLAG"></a><a id="cert_store_create_new_flag"></a><dl>
     * <dt><b>CERT_STORE_CREATE_NEW_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function fails if the system store already exists in the store location.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UInt32>} pStoreInfo Reserved for future use and must be set to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certregistersystemstore
     * @since windows5.1.2600
     */
    static CertRegisterSystemStore(pvSystemStore, dwFlags, pStoreInfo) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("CRYPT32.dll\CertRegisterSystemStore", "ptr", pvSystemStore, "uint", dwFlags, "ptr", pStoreInfo, "ptr", pvReserved, "int")
        return result
    }

    /**
     * Adds a physical store to a registry system store collection.
     * @param {Pointer<Void>} pvSystemStore The system store collection to which the physical store is added. This parameter points either to a <b>null</b>-terminated Unicode string or to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure. For information about using the structure and on adding a ServiceName or ComputerName before the system store name string, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certregistersystemstore">CertRegisterSystemStore</a>.
     * @param {Integer} dwFlags The high word of the <i>dwFlags</i> parameter specifies the location of the system store. For information about defined high-word flags and appending ServiceName, UserNames, and ComputerNames to the end of the system store name, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certregistersystemstore">CertRegisterSystemStore</a>. 
     * 
     * 
     * 
     * 
     * The following low-word flags are also defined and can be combined with high-word flags using a bitwise-<b>OR</b> operation.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_RELOCATE_FLAG"></a><a id="cert_system_store_relocate_flag"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_RELOCATE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system store is not in its default registry location and the <i>pvSystemStore</i> parameter must be a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_CREATE_NEW_FLAG"></a><a id="cert_store_create_new_flag"></a><dl>
     * <dt><b>CERT_STORE_CREATE_NEW_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function fails if the physical store already exists in the store location.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} pwszStoreName A pointer to a Unicode string that names the physical store to be added to the system store collection. To remove a physical store from the system store collection, call the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certunregisterphysicalstore">CertUnregisterPhysicalStore</a> function.
     * @param {Pointer<CERT_PHYSICAL_STORE_INFO>} pStoreInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_physical_store_info">CERT_PHYSICAL_STORE_INFO</a> structure that provides basic information about the physical store.
     * @returns {Integer} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certregisterphysicalstore
     * @since windows5.1.2600
     */
    static CertRegisterPhysicalStore(pvSystemStore, dwFlags, pwszStoreName, pStoreInfo) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("CRYPT32.dll\CertRegisterPhysicalStore", "ptr", pvSystemStore, "uint", dwFlags, "ptr", pwszStoreName, "ptr", pStoreInfo, "ptr", pvReserved, "int")
        return result
    }

    /**
     * The CertUnregisterSystemStore function unregisters a specified system store.
     * @param {Pointer<Void>} pvSystemStore Identifies the system store to be unregistered. It points either to a null-terminated Unicode string or to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure. For information about using the structure and on appending a ServiceName or ComputerName to the end of the system store name string, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certregistersystemstore">CertRegisterSystemStore</a>.
     * @param {Integer} dwFlags The high word of the <i>dwFlags</i> parameter specifies the location of the system store. For information about defined high-word flags and on appending ServiceName, UserNames, and ComputerNames to the end of the system store name, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certregistersystemstore">CertRegisterSystemStore</a>. 
     * 
     * 
     * 
     * 
     * The following low-word values are also defined and can be combined with high-word values using a bitwise-<b>OR</b> operation.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_RELOCATE_FLAG"></a><a id="cert_system_store_relocate_flag"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_RELOCATE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system store is not in its default registry location and <i>pvSystemStore</i> must be a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_DELETE_FLAG"></a><a id="cert_store_delete_flag"></a><dl>
     * <dt><b>CERT_STORE_DELETE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system store is deleted after it has been unregistered.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certunregistersystemstore
     * @since windows5.1.2600
     */
    static CertUnregisterSystemStore(pvSystemStore, dwFlags) {
        result := DllCall("CRYPT32.dll\CertUnregisterSystemStore", "ptr", pvSystemStore, "uint", dwFlags, "int")
        return result
    }

    /**
     * The CertUnregisterPhysicalStore function removes a physical store from a specified system store collection. CertUnregisterPhysicalStore can also be used to delete the physical store.
     * @param {Pointer<Void>} pvSystemStore A pointer to an identifier of the system store collection from which the physical store is to be removed. It is either to a null-terminated Unicode string or to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure. For information about using the structure and on appending a ServiceName or ComputerName to the end of the system store name string, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certregistersystemstore">CertRegisterSystemStore</a>.
     * @param {Integer} dwFlags The high word of the <i>dwFlags</i> parameter specifies the location of the system store. For information about defined high-word flags and on appending ServiceName, UserNames, and ComputerNames to the end of the system store name, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certregistersystemstore">CertRegisterSystemStore</a>. 
     * 
     * 
     * 
     * 						
     * 					
     * 
     * 
     * The following low-word values are also defined. They can be combined using bitwise-<b>OR</b> operations with high-word values.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SYSTEM_STORE_RELOCATE_FLAG"></a><a id="cert_system_store_relocate_flag"></a><dl>
     * <dt><b>CERT_SYSTEM_STORE_RELOCATE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system store is not in its default registry location and <i>pvSystemStore</i> must be a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_STORE_DELETE_FLAG"></a><a id="cert_store_delete_flag"></a><dl>
     * <dt><b>CERT_STORE_DELETE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The physical store is first removed from the system store collection and is then deleted.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} pwszStoreName Null-terminated Unicode string that contains the name of the physical store.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certunregisterphysicalstore
     * @since windows5.1.2600
     */
    static CertUnregisterPhysicalStore(pvSystemStore, dwFlags, pwszStoreName) {
        result := DllCall("CRYPT32.dll\CertUnregisterPhysicalStore", "ptr", pvSystemStore, "uint", dwFlags, "ptr", pwszStoreName, "int")
        return result
    }

    /**
     * The CertEnumSystemStoreLocation function retrieves all of the system store locations. The function calls the provided callback function for each system store location found.
     * @remarks
     * To use <b>CertEnumSystemStoreLocation</b>, an application must declare and define the <b>ENUM_ARG</b> structure and an enumeration callback function.
     * @param {Integer} dwFlags Reserved for future use; must be zero.
     * @param {Pointer<Void>} pvArg A pointer to a <b>void</b>  that allows the application to declare, define, and initialize a structure to hold any information to be passed to the callback enumeration function.
     * @param {Pointer<PFN_CERT_ENUM_SYSTEM_STORE_LOCATION>} pfnEnum A pointer to the callback function used to show the details for each store location. This callback function determines the content and format for the presentation of information on each store location. For the signature and parameters of the callback function, see <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nc-wincrypt-pfn_cert_enum_system_store_location">CertEnumSystemStoreLocationCallback</a>.
     * @returns {Integer} If the function succeeds, the function returns <b>TRUE</b>.
     * 						
     * 						
     * 
     * If the function fails, it returns <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certenumsystemstorelocation
     * @since windows5.1.2600
     */
    static CertEnumSystemStoreLocation(dwFlags, pvArg, pfnEnum) {
        result := DllCall("CRYPT32.dll\CertEnumSystemStoreLocation", "uint", dwFlags, "ptr", pvArg, "ptr", pfnEnum, "int")
        return result
    }

    /**
     * The CertEnumSystemStore function retrieves the system stores available. The function calls the provided callback function for each system store found.
     * @remarks
     * To use <b>CertEnumSystemStore</b>, the application must declare and define the <b>ENUM_ARG</b> structure and the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nc-wincrypt-pfn_cert_enum_system_store">CertEnumSystemStoreCallback</a> callback function.
     * @param {Integer} dwFlags Specifies the location of the system store. This parameter can be one of the following flags: 
     * 
     * 
     * 
     * 
     * <ul>
     * <li>CERT_SYSTEM_STORE_CURRENT_USER</li>
     * <li>CERT_SYSTEM_STORE_CURRENT_SERVICE</li>
     * <li>CERT_SYSTEM_STORE_LOCAL_MACHINE</li>
     * <li>CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY</li>
     * <li>CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY</li>
     * <li>CERT_SYSTEM_STORE_SERVICES</li>
     * <li>CERT_SYSTEM_STORE_USERS</li>
     * <li>CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE</li>
     * </ul>
     * In addition, the CERT_SYSTEM_STORE_RELOCATE_FLAG can be combined, by using a bitwise-<b>OR</b> operation, with any of the high-word location flags.
     * @param {Pointer<Void>} pvSystemStoreLocationPara If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in the <i>dwFlags</i> parameter, <i>pvSystemStoreLocationPara</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure that indicates both the name and the location of the system store. Otherwise, <i>pvSystemStoreLocationPara</i> is a pointer to a Unicode string that names the system store. 
     * 
     * 
     * 
     * 
     * For CERT_SYSTEM_STORE_LOCAL_MACHINE or CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY, <i>pvSystemStoreLocationPara</i> can optionally be set to a Unicode computer name for enumerating local computer stores on a remote computer, for example "&#92;&#92;<i>computer_name</i>" or "<i>computer_name</i>". The leading backslashes (\\) are optional in the <i>computer_name</i>.
     * 
     * For CERT_SYSTEM_STORE_SERVICES or CERT_SYSTEM_STORE_USERS, if <i>pvSystemStoreLocationPara</i> is <b>NULL</b>, the function enumerates both the service/user names and the stores for each service/user name. Otherwise, <i>pvSystemStoreLocationPara</i> is a Unicode string that contains a remote computer name and, if available, a service/user name, for example, "<i>service_name</i>", "&#92;&#92;<i>computer_name</i>", or "<i>computer_name</i>\".
     * 
     * If only the <i>computer_name</i> is specified, it must have either the leading backslashes (\\) or a trailing backslash (\\). Otherwise, it is interpreted as the <i>service_name</i> or <i>user_name</i>.
     * @param {Pointer<Void>} pvArg A pointer to a <b>void</b>  that allows the application to declare, define, and initialize a structure to hold any information to be passed to the callback enumeration function.
     * @param {Pointer<PFN_CERT_ENUM_SYSTEM_STORE>} pfnEnum A pointer to the callback function used to show the details for each system store. This callback function determines the content and format for the presentation of information on each system store. The application must provide the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nc-wincrypt-pfn_cert_enum_system_store">CertEnumSystemStoreCallback</a> callback function.
     * @returns {Integer} If the function succeeds, the function returns  <b>TRUE</b>.
     * 
     * If the function fails, it returns  <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certenumsystemstore
     * @since windows5.1.2600
     */
    static CertEnumSystemStore(dwFlags, pvSystemStoreLocationPara, pvArg, pfnEnum) {
        result := DllCall("CRYPT32.dll\CertEnumSystemStore", "uint", dwFlags, "ptr", pvSystemStoreLocationPara, "ptr", pvArg, "ptr", pfnEnum, "int")
        return result
    }

    /**
     * The CertEnumPhysicalStore function retrieves the physical stores on a computer. The function calls the provided callback function for each physical store found.
     * @remarks
     * To use <b>CertEnumPhysicalStore</b>, an application must declare and define the <b>ENUM_ARG</b> structure and an enumeration callback function.
     * @param {Pointer<Void>} pvSystemStore If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in <i>dwFlags</i>, <i>pvSystemStore</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_system_store_relocate_para">CERT_SYSTEM_STORE_RELOCATE_PARA</a> structure that indicates both the name and the location of the system store to be enumerated. Otherwise, <i>pvSystemStore</i> is a pointer to a Unicode string that names the system store whose physical stores are to be enumerated. For information about prefixing a ServiceName or ComputerName to the system store name, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certregistersystemstore">CertRegisterSystemStore</a>.
     * @param {Integer} dwFlags Specifies the location of the system store. The following flag values are defined:
     * 
     * <ul>
     * <li>CERT_SYSTEM_STORE_CURRENT_USER</li>
     * <li>CERT_SYSTEM_STORE_CURRENT_SERVICE</li>
     * <li>CERT_SYSTEM_STORE_LOCAL_MACHINE</li>
     * <li>CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY</li>
     * <li>CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY</li>
     * <li>CERT_SYSTEM_STORE_SERVICES</li>
     * <li>CERT_SYSTEM_STORE_USERS</li>
     * <li>CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE</li>
     * </ul>
     * In addition, CERT_SYSTEM_STORE_RELOCATE_FLAG or CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG can be combined using a bitwise-<b>OR</b> operation with any of the high-word location flags.
     * @param {Pointer<Void>} pvArg A pointer to a <b>void</b> that allows the application to declare, define, and initialize a structure to hold any information to be passed to the callback enumeration function.
     * @param {Pointer<PFN_CERT_ENUM_PHYSICAL_STORE>} pfnEnum A pointer to the callback function used to show the details for each physical store. This callback function determines the content and format for the presentation of information on each physical store. The application must provide the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nc-wincrypt-pfn_cert_enum_physical_store">CertEnumPhysicalStoreCallback</a> callback function.
     * @returns {Integer} If the function succeeds and another physical store was found, the return value is <b>TRUE</b>.
     * 
     * If the system store location only supports system stores and does not support physical stores, the function returns <b>FALSE</b> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the ERROR_NOT_SUPPORTED code.
     * 
     * If the function fails and another physical store was not found, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certenumphysicalstore
     * @since windows5.1.2600
     */
    static CertEnumPhysicalStore(pvSystemStore, dwFlags, pvArg, pfnEnum) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertEnumPhysicalStore", "ptr", pvSystemStore, "uint", dwFlags, "ptr", pvArg, "ptr", pfnEnum, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Returns information from the enhanced key usage (EKU) extension or the EKU extended property of a certificate.
     * @remarks
     * If a certificate has an EKU extension, that extension lists <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifiers</a> (OIDs) for valid uses of that certificate. In a Microsoft environment, a certificate might also have EKU extended properties that specify valid uses for the certificate.
     * 
     * <ul>
     * <li>If a certificate has neither an EKU extension nor EKU extended properties, it is assumed to be valid for all uses.</li>
     * <li>If it has either an EKU extension or EKU extended properties but not both, it is valid only for the uses indicated in the extension or extended properties that it has.</li>
     * <li>If a certificate has both an EKU extension and EKU extended properties, it is valid only for the uses that are on both lists.</li>
     * </ul>
     * If <i>dwFlags</i> is set to zero, the <b>cUsageIdentifier</b> member of the <b>CERT_ENHKEY_USAGE</b> structure is set to the number of valid uses of the certificate determined by the value of both the EKU extension and the EKU extended property value.
     * 
     * If the <b>cUsageIdentifier</b> member is zero, the certificate might be valid for all uses or the certificate might have no valid uses. The return from a call to <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> can be used to determine whether the certificate is good for all uses or for none. If <b>GetLastError</b> returns CRYPT_E_NOT_FOUND, the certificate is good for all uses. If it returns zero, the certificate has no valid uses.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> certificate context.
     * @param {Integer} dwFlags Indicates whether the function will report on extensions of a certificate, its extended properties, or both. If set to zero, the function returns the valid uses of a certificate based on both the EKU extension and the EKU extended property value of the certificate. 
     * 
     * 
     * 
     * 
     * To return only the EKU extension or EKU property value, set the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG"></a><a id="cert_find_ext_only_enhkey_usage_flag"></a><dl>
     * <dt><b>CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Get only the extension.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG"></a><a id="cert_find_prop_only_enhkey_usage_flag"></a><dl>
     * <dt><b>CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Get only the extended property value.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CTL_USAGE>} pUsage A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CERT_ENHKEY_USAGE</a> structure (<b>CERT_ENHKEY_USAGE</b> is an alternate typedef name for the <b>CTL_USAGE</b> structure) that receives the valid uses of the certificate. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of the key usage for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbUsage A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the structure pointed to by <i>pUsage</i>. When the function returns, the <b>DWORD</b> contains the size, in bytes, of the structure.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certgetenhancedkeyusage
     * @since windows5.1.2600
     */
    static CertGetEnhancedKeyUsage(pCertContext, dwFlags, pUsage, pcbUsage) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetEnhancedKeyUsage", "ptr", pCertContext, "uint", dwFlags, "ptr", pUsage, "ptr", pcbUsage, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertSetEnhancedKeyUsage function sets the enhanced key usage (EKU) property for the certificate.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> of the specified certificate.
     * @param {Pointer<CTL_USAGE>} pUsage Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CERT_ENHKEY_USAGE</a> structure (equivalent to a 
     * <b>CTL_USAGE</b> structure) that contains an array of EKU <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifiers</a> (OIDs) to be set as extended properties of the certificate.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certsetenhancedkeyusage
     * @since windows5.1.2600
     */
    static CertSetEnhancedKeyUsage(pCertContext, pUsage) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSetEnhancedKeyUsage", "ptr", pCertContext, "ptr", pUsage, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertAddEnhancedKeyUsageIdentifier function adds a usage identifier object identifier (OID) to the enhanced key usage (EKU) extended property of the certificate.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> of the certificate for which the usage identifier is to be added.
     * @param {Pointer<PSTR>} pszUsageIdentifier Specifies the usage identifier OID to add.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certaddenhancedkeyusageidentifier
     * @since windows5.1.2600
     */
    static CertAddEnhancedKeyUsageIdentifier(pCertContext, pszUsageIdentifier) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddEnhancedKeyUsageIdentifier", "ptr", pCertContext, "ptr", pszUsageIdentifier, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertRemoveEnhancedKeyUsageIdentifier function removes a usage identifier object identifier (OID) from the enhanced key usage (EKU) extended property of the certificate.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> of the certificate for which the usage identifier OID is to be removed.
     * @param {Pointer<PSTR>} pszUsageIdentifier A pointer to the usage identifier OID to remove.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certremoveenhancedkeyusageidentifier
     * @since windows5.1.2600
     */
    static CertRemoveEnhancedKeyUsageIdentifier(pCertContext, pszUsageIdentifier) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertRemoveEnhancedKeyUsageIdentifier", "ptr", pCertContext, "ptr", pszUsageIdentifier, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Returns an array of usages that consist of the intersection of the valid usages for all certificates in an array of certificates.
     * @param {Integer} cCerts The number of certificates in the array to be checked.
     * @param {Pointer<CERT_CONTEXT>} rghCerts An array of certificates to be checked for valid usage.
     * @param {Pointer<Int32>} cNumOIDs The number of valid usages found as the intersection of the valid usages of all certificates in the array. If all of the certificates are valid for all usages, <i>cNumOIDs</i> is set to negative one (–1).
     * @param {Pointer<PSTR>} rghOIDs An array of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifiers</a> (OIDs) of the valid usages that are shared by all of the certificates in the <i>rghCerts</i> array. This parameter can be <b>NULL</b> to set the size of this structure for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbOIDs A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the <i>rghOIDs</i> array and the strings pointed to. When the function returns, the <b>DWORD</b> value contains the number of bytes needed for the array.
     * @returns {Integer} If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certgetvalidusages
     * @since windows5.1.2600
     */
    static CertGetValidUsages(cCerts, rghCerts, cNumOIDs, rghOIDs, pcbOIDs) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetValidUsages", "uint", cCerts, "ptr", rghCerts, "ptr", cNumOIDs, "ptr", rghOIDs, "ptr", pcbOIDs, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptMsgGetAndVerifySigner function verifies a cryptographic message's signature.
     * @param {Pointer<Void>} hCryptMsg Handle of a cryptographic message.
     * @param {Integer} cSignerStore Number of stores in the <i>rghSignerStore</i> array.
     * @param {Pointer<HCERTSTORE>} rghSignerStore Array of certificate store handles that can be searched for a signer's certificate.
     * @param {Integer} dwFlags Indicates particular use of the function. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_TRUSTED_SIGNER_FLAG"></a><a id="cmsg_trusted_signer_flag"></a><dl>
     * <dt><b>CMSG_TRUSTED_SIGNER_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The stores in <i>rghSignerStore</i> are assumed trusted and they are the only stores searched to find the certificate corresponding to the signer's issuer and serial number. Otherwise, signer stores can be provided to supplement the message's store of certificates. If a signer certificate is found, its public key is used to verify the message signature.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_SIGNER_ONLY_FLAG"></a><a id="cmsg_signer_only_flag"></a><dl>
     * <dt><b>CMSG_SIGNER_ONLY_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Return the signer without doing the signature verification.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CMSG_USE_SIGNER_INDEX_FLAG"></a><a id="cmsg_use_signer_index_flag"></a><dl>
     * <dt><b>CMSG_USE_SIGNER_INDEX_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Only the signer specified by *<i>pdwSignerIndex</i> is returned. Otherwise, iterate through all the signers until a signature is verified or there are no more signers.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CERT_CONTEXT>} ppSigner If the signature is verified, <i>ppSigner</i> is updated to point to the signer's <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a>. When you have finished using the certificate, free the context by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function. This parameter can be <b>NULL</b> if the application has no need for the signer's certificate.
     * @param {Pointer<UInt32>} pdwSignerIndex If the signature is verified, <i>pdwSigner</i> is updated to point to the index of the signer in the array of signers. This parameter can be <b>NULL</b> if the application has no need for the index of the signer.
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmsggetandverifysigner
     * @since windows5.1.2600
     */
    static CryptMsgGetAndVerifySigner(hCryptMsg, cSignerStore, rghSignerStore, dwFlags, ppSigner, pdwSignerIndex) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgGetAndVerifySigner", "ptr", hCryptMsg, "uint", cSignerStore, "ptr", rghSignerStore, "uint", dwFlags, "ptr", ppSigner, "ptr", pdwSignerIndex, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptMsgSignCTL function creates a signed message containing an encoded CTL.
     * @param {Integer} dwMsgEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<Byte>} pbCtlContent The encoded 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_info">CTL_INFO</a> that can be a member of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure or can be created using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencodeobject">CryptEncodeObject</a> function.
     * @param {Integer} cbCtlContent The size, in bytes, of the content pointed to by <i>pbCtlContent</i>.
     * @param {Pointer<CMSG_SIGNED_ENCODE_INFO>} pSignInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signed_encode_info">CMSG_SIGNED_ENCODE_INFO</a> structure containing an array of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signer_encode_info">CMSG_SIGNER_ENCODE_INFO</a> structures.
     * 
     * The message can be encoded without signers if the <b>cbSize</b> member of the structure is set to the size of the structure and all of the other members are set to zero.
     * @param {Integer} dwFlags If CMS_PKCS7 is defined, can be set to CMSG_CMS_ENCAPSULATED_CTL_FLAG to encode a CMS compatible V3 SignedData message.
     * @param {Pointer<Byte>} pbEncoded A pointer to a buffer to receives the encoded message.
     * 
     * This parameter can be <b>NULL</b> to get the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbEncoded A pointer to a <b>DWORD</b> specifying the size, in bytes, of the <i>pbEncoded</i> buffer. When the function returns, the <b>DWORD</b> contains the number of bytes stored or to be stored in the buffer.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. This function can return errors propagated from calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentoencode">CryptMsgOpenToEncode</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmsgsignctl
     * @since windows5.1.2600
     */
    static CryptMsgSignCTL(dwMsgEncodingType, pbCtlContent, cbCtlContent, pSignInfo, dwFlags, pbEncoded, pcbEncoded) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgSignCTL", "uint", dwMsgEncodingType, "ptr", pbCtlContent, "uint", cbCtlContent, "ptr", pSignInfo, "uint", dwFlags, "ptr", pbEncoded, "ptr", pcbEncoded, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptMsgEncodeAndSignCTL function encodes a CTL and creates a signed message containing the encoded CTL.This function first encodes the CTL pointed to by pCtlInfo and then calls CryptMsgSignCTL to sign the encoded message.
     * @param {Integer} dwMsgEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CTL_INFO>} pCtlInfo A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_info">CTL_INFO</a> structure containing the CTL to be encoded and signed.
     * @param {Pointer<CMSG_SIGNED_ENCODE_INFO>} pSignInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signed_encode_info">CMSG_SIGNED_ENCODE_INFO</a> structure that contains an array of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cmsg_signer_encode_info">CMSG_SIGNER_ENCODE_INFO</a> structures.
     * 
     * The message can be encoded without signers if the <b>cbSize</b> member of the structure is set to the size of the structure and all of the other members are set to zero.
     * @param {Integer} dwFlags CMSG_ENCODE_SORTED_CTL_FLAG is set if the CTL entries are to be sorted before encoding. This flag is set if the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfindsubjectinsortedctl">CertFindSubjectInSortedCTL</a> or <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certenumsubjectinsortedctl">CertEnumSubjectInSortedCTL</a> functions will be called.
     * 
     * CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG is set if CMSG_ENCODE_SORTED_CTL_FLAG is set, and the identifier for the TrustedSubjects is a hash, such as MD5 or SHA1.
     * 
     * If CMS_PKCS7 is defined, <i>dwFlags</i> can be set to CMSG_CMS_ENCAPSULATED_CTL_FLAG to encode a CMS compatible V3 SignedData message.
     * @param {Pointer<Byte>} pbEncoded A pointer to a buffer that receives the encoded, signed message created.
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbEncoded A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the <i>pbEncoded</i> buffer. When the function returns, the <b>DWORD</b> contains the number of bytes stored or to be stored in the buffer.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Errors can be propagated from calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgopentoencode">CryptMsgOpenToEncode</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmsgupdate">CryptMsgUpdate</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmsgencodeandsignctl
     * @since windows5.1.2600
     */
    static CryptMsgEncodeAndSignCTL(dwMsgEncodingType, pCtlInfo, pSignInfo, dwFlags, pbEncoded, pcbEncoded) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptMsgEncodeAndSignCTL", "uint", dwMsgEncodingType, "ptr", pCtlInfo, "ptr", pSignInfo, "uint", dwFlags, "ptr", pbEncoded, "ptr", pcbEncoded, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertFindSubjectInSortedCTL function attempts to find the specified subject in a sorted certificate trust list (CTL).
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pSubjectIdentifier A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure uniquely identifying the subject. The information in this structure can be a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> or any unique byte sequence.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure to be searched.
     * @param {Integer} dwFlags Reserved for future use and must be <b>NULL</b>.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pEncodedAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DER_BLOB</a> structure containing a byte count and a pointer to the subject's encoded attributes.
     * @returns {Integer} If the function succeeds and the subject identifier exists in the CTL, the return value is <b>TRUE</b>.
     * 
     * If the function fails and does not locate a matching subject identifier, the return value is <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certfindsubjectinsortedctl
     * @since windows5.1.2600
     */
    static CertFindSubjectInSortedCTL(pSubjectIdentifier, pCtlContext, dwFlags, pEncodedAttributes) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("CRYPT32.dll\CertFindSubjectInSortedCTL", "ptr", pSubjectIdentifier, "ptr", pCtlContext, "uint", dwFlags, "ptr", pvReserved, "ptr", pEncodedAttributes, "int")
        return result
    }

    /**
     * Retrieves the first or next TrustedSubject in a sorted certificate trust list (CTL).
     * @remarks
     * The <b>pbData</b> members of <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DER_BLOB</a> structures point directly to the encoded bytes. The <b>CRYPT_DER_BLOB</b> structures, themselves, must be allocated and freed by the application, but the memory addressed by the <b>pbData</b> members of these structures is not allocated by the application and must not be freed by the application.
     * 
     * If the CTL is not sorted with the CERT_CREATE_CONTEXT_SORTED_FLAG flag set, an error results.
     * @param {Pointer<CTL_CONTEXT>} pCtlContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure to be searched.
     * @param {Pointer<Void>} ppvNextSubject A pointer to the address of the last TrustedSubject found. To start the enumeration, <i>ppvNextSubject</i> must point to a pointer  set to <b>NULL</b>. Upon return, the pointer addressed by <i>ppvNextSubject</i> is updated to point to the next TrustedSubject in the encoded sequence.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pSubjectIdentifier A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DER_BLOB</a> structure, uniquely identifying a TrustedSubject. The information in this structure can be a hash or any unique byte sequence.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pEncodedAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DER_BLOB</a> structure containing a byte count and a pointer to the TrustedSubject's encoded attributes.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>, with <i>ppvNextSubject</i> updated to point to the next TrustedSubject in the encoded sequence.
     * 
     * If the function fails, the return value is <b>FALSE</b>. The return value is <b>FALSE</b> if there are no more subjects or there is an argument that is not valid.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certenumsubjectinsortedctl
     * @since windows5.1.2600
     */
    static CertEnumSubjectInSortedCTL(pCtlContext, ppvNextSubject, pSubjectIdentifier, pEncodedAttributes) {
        result := DllCall("CRYPT32.dll\CertEnumSubjectInSortedCTL", "ptr", pCtlContext, "ptr", ppvNextSubject, "ptr", pSubjectIdentifier, "ptr", pEncodedAttributes, "int")
        return result
    }

    /**
     * Verifies that a subject is trusted for a specified usage by finding a signed and time-valid certificate trust list (CTL) with the usage identifiers that contain the subject.
     * @remarks
     * <b>CertVerifyCTLUsage</b> is a dispatcher to functions that can be installed by using an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID). First, it tries to find an OID function that matches the first usage object identifier in the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CLT_USAGE</a> structure pointed to by <i>pSubjectUsage</i>. If this fails, it uses the default <b>CertDllVerifyCTLUsage</b> functions.
     * 
     * The <b>CertDllVerifyCTLUsage</b> function in Cryptnet.dll can be installed by using an OID; it has the following properties:
     * 
     * <ul>
     * <li>If CTL stores are specified by <b>rghCtlStore</b> in <i>pVerifyUsagePara</i>, only those stores are searched to find a CTL. Otherwise, the Trust system store is searched to find a CTL.</li>
     * <li>If CERT_VERIFY_TRUSTED_SIGNERS_FLAG is set, only the signer stores specified by <b>rghSignerStore</b> in <i>pVerifyUsagePara</i> are searched to find the certificate that corresponds to the signer's issuer and serial number. Otherwise, the CTL message's store, the signer stores specified by <b>rghSignerStore</b> in <i>pVerifyUsagePara</i>, the Trust system store, CA system store, ROOT, and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">Software Publisher Certificate</a> (SPC) system stores are searched to find the signer's certificate. In either case, the public key in the found certificate is used to verify the signature of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CTL</a>.</li>
     * <li>If the CTL has a set <b>NextUpdate</b> member and CERT_VERIFY_NO_TIME_CHECK is not set, it is verified for time validity.</li>
     * <li>If the CTL obtained from the store has a time that is not valid, an attempt is made to get a time-valid version. The <b>CertDllVerifyCTLUsage</b> function uses the <b>NextUpdateLocation</b> property or the <b>NextUpdateLocation</b> extension of the CTL, or it searches the signer's information for a <b>NextUpdateLocation</b> attribute.</li>
     * </ul>
     * @param {Integer} dwEncodingType Specifies the encoding type used. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types can be added in the future. For either current encoding type, use  
     * 
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Integer} dwSubjectType If the <i>dwSubjectType</i> parameter is set to CTL_CERT_SUBJECT_TYPE, <i>pvSubject</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure. The structure's <b>SubjectAlgorithm</b> member is examined to determine the representation of the subject's identity. Initially, only SHA1 and MD5 hashes are supported as values for <b>SubjectAlgorithm</b>. The appropriate hash property is obtained from the <b>CERT_CONTEXT</b> structure.
     * 
     * If the <i>dwSubjectType</i> parameter is set to CTL_ANY_SUBJECT_TYPE, <i>pvSubject</i> points to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_any_subject_info">CTL_ANY_SUBJECT_INFO</a> structure. The <b>SubjectAlgorithm</b> member of this structure must match the algorithm type of the CTL, and the <b>SubjectIdentifier</b> member must match one of the CTL entries.
     * 
     * If <i>dwSubjectType</i> is set to either preceding value, <i>dwEncodingType</i> is not used.
     * @param {Pointer<Void>} pvSubject Value used in conjunction with the <i>dwSubjectType</i> parameter.
     * @param {Pointer<CTL_USAGE>} pSubjectUsage A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_usage">CTL_USAGE</a> structure used to specify the intended usage of the subject.
     * @param {Integer} dwFlags If the CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG is not set, a CTL whose time is no longer valid in one of the stores specified by <b>rghCtlStore</b> in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_verify_usage_para">CTL_VERIFY_USAGE_PARA</a> can be replaced. When replaced, the CERT_VERIFY_UPDATED_CTL_FLAG is set in the  <b>dwFlags</b> member of <i>pVerifyUsageStatus</i>. If this flag is set, an update will not be made, even if a time-valid, updated CTL is received for a CTL that is in the store and whose time is no longer valid.
     * 
     * If the CERT_VERIFY_TRUSTED_SIGNERS_FLAG is set, only the signer stores specified by <b>rghSignerStore</b> in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_verify_usage_para">CTL_VERIFY_USAGE_PARA</a> are searched to find the signer. Otherwise, the signer stores provide additional sources to find the signer's certificate. For more information, see Remarks.
     * 
     * If CERT_VERIFY_NO_TIME_CHECK_FLAG is set, the CTLs are not checked for time validity. Otherwise, they are.
     * 
     * If CERT_VERIFY_ALLOW_MORE_USAGE_FLAG is set, the CTL can contain usage identifiers in addition to those specified by <i>pSubjectUsage</i>. Otherwise, the found CTL will contain no additional usage identifiers.
     * @param {Pointer<CTL_VERIFY_USAGE_PARA>} pVerifyUsagePara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_verify_usage_para">CTL_VERIFY_USAGE_PARA</a> structure that specifies the stores to be searched to find the CTL and the stores that contain acceptable CTL signers. Setting the <b>ListIdentifier</b> member further limits the search.
     * @param {Pointer<CTL_VERIFY_USAGE_STATUS>} pVerifyUsageStatus A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_verify_usage_status">CTL_VERIFY_USAGE_STATUS</a> structure. The <b>cbSize</b> member of the structure must to be set to the size, in bytes, of the structure, and all other fields must be set to zero before <b>CertVerifyCTLUsage</b> is called. For more information, see 
     * <b>CTL_VERIFY_USAGE_STATUS</b>.
     * @returns {Integer} If the subject is trusted for the specified usage, <b>TRUE</b> is returned. Otherwise, <b>FALSE</b> is returned. <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_VERIFY_USAGE_DLL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No DLL or exported function was found to verify subject usage.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_VERIFY_USAGE_CHECK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The called function was not able to do a usage check on the subject.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_VERIFY_USAGE_OFFLINE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The server was offline; therefore, the called function could not complete the usage check.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_IN_CTL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The subject was not found in a CTL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_TRUSTED_SIGNER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No trusted signer was found to verify the signature of the message or trust list.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The <b>dwError</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_verify_usage_para">CTL_VERIFY_USAGE_PARA</a> pointed to by <i>pVerifyUsageStatus</i> is set to the same error code.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certverifyctlusage
     * @since windows5.1.2600
     */
    static CertVerifyCTLUsage(dwEncodingType, dwSubjectType, pvSubject, pSubjectUsage, dwFlags, pVerifyUsagePara, pVerifyUsageStatus) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertVerifyCTLUsage", "uint", dwEncodingType, "uint", dwSubjectType, "ptr", pvSubject, "ptr", pSubjectUsage, "uint", dwFlags, "ptr", pVerifyUsagePara, "ptr", pVerifyUsageStatus, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Checks the revocation status of the certificates contained in the rgpvContext array. If a certificate in the list is found to be revoked, no further checking is done.
     * @remarks
     * The following example shows how <i>pRevStatus</i> is updated when a revocation verification problem is encountered:
     * 
     * Consider the case where <i>cContext</i> is four: 
     * 
     * If <b>CertVerifyRevocation</b> can verify that <i>rgpvContext</i>[0] and <i>rgpvContext</i>[1] are not revoked, but cannot check <i>rgpvContext</i>[2], the <i>pRevStatus</i> member <b>dwIndex</b> is set to two, indicating that the context at index two has the problem, the <b>dwError</b> member of <i>pRevStatus</i> is set to CRYPT_E_NO_REVOCATION_CHECK, and <b>FALSE</b> is returned.
     * 
     * If <i>rgpvContext</i>[2] is found to be revoked, the <b>dwIndex</b> member of <i>pRevStatus</i> is set to two, and the <b>dwError</b> member of <i>pRevStatus</i> is set to CRYPT_E_REVOKED, <b>dwReason</b> is updated, and <b>FALSE</b> is returned.
     * 
     *  In either case, both <i>rgpvContext</i>[0] and <i>rgpvContext</i>[1] are verified not to be revoked, <i>rgpvContext</i>[2] is the last array index checked, and <i>rgpvContext</i>[3] has not been checked at all.
     * @param {Integer} dwEncodingType Specifies the encoding type used. Currently, only X509_ASN_ENCODING and PKCS_7_ASN_ENCODING are being used; however, additional encoding types may be added in the future. For either current encoding type, use X509_ASN_ENCODING | PKCS_7_ASN_ENCODING.
     * @param {Integer} dwRevType Indicates the type of the context structure passed in <i>rgpvContext</i>. Currently only CERT_CONTEXT_REVOCATION_TYPE, the revocation of certificates, is defined.
     * @param {Integer} cContext Count of elements in the <i>rgpvContext</i> array.
     * @param {Pointer<Void>} rgpvContext When the <i>dwRevType</i> is CERT_CONTEXT_REVOCATION_TYPE, <i>rgpvContext</i> is an array of pointers to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structures. These contexts must contain sufficient information to allow the installable or registered revocation DLLs to find the revocation server. This information would normally be conveyed in an extension such as the CRLDistributionsPoints extension defined by the Internet Engineering Task Force (IETF) in PKIX Part 1. 
     * 
     * 
     * 
     * 
     * For efficiency, the more contexts that are passed in at one time, the better.
     * @param {Integer} dwFlags Indicates any special processing needs. This parameter can be one of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_VERIFY_REV_CHAIN_FLAG"></a><a id="cert_verify_rev_chain_flag"></a><dl>
     * <dt><b>CERT_VERIFY_REV_CHAIN_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Verification of the chain of certificates is done assuming each certificate except the first certificate is the issuer of the certificate that precedes it. If <i>dwRevType</i> is not CERT_CONTEXT_REVOCATION_TYPE, no assumptions are made about the order of the contexts.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION"></a><a id="cert_verify_cache_only_based_revocation"></a><dl>
     * <dt><b>CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Prevents the revocation handler from accessing any network-based resources for revocation checking.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG"></a><a id="cert_verify_rev_accumulative_timeout_flag"></a><dl>
     * <dt><b>CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When set, <b>dwUrlRetrievalTimeout</b> is the cumulative time-out across all URL wire retrievals.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_VERIFY_REV_SERVER_OCSP_FLAG"></a><a id="cert_verify_rev_server_ocsp_flag"></a><dl>
     * <dt><b>CERT_VERIFY_REV_SERVER_OCSP_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When set, this function only uses <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">online certificate status protocol</a> (OCSP) for revocation checking. If the certificate does not have any OCSP AIA URLs, the <b>dwError</b> member of the <i>pRevStatus</i> parameter is set to CRYPT_E_NOT_IN_REVOCATION_DATABASE.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CERT_REVOCATION_PARA>} pRevPara Optionally set to assist in finding the issuer. For details, see the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_revocation_para">CERT_REVOCATION_PARA</a> structure.
     * @param {Pointer<CERT_REVOCATION_STATUS>} pRevStatus Only the <b>cbSize</b> member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_revocation_status">CERT_REVOCATION_STATUS</a> pointed to by <i>pRevStatus</i> needs to be set before <b>CertVerifyRevocation</b> is called.
     * 
     * If the function returns <b>FALSE</b>, this structure's members will contain error status information. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_revocation_status">CERT_REVOCATION_STATUS</a>. For a description of how <i>pRevStatus</i> is updated when a revocation verification problem is encountered, see Remarks.
     * @returns {Integer} If the function successfully checks all of the contexts and none were revoked, the function returns <b>TRUE</b>. If the function fails, it returns <b>FALSE</b> and updates the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_revocation_status">CERT_REVOCATION_STATUS</a> structure pointed to by <i>pRevStatus</i> as described in 
     * <b>CERT_REVOCATION_STATUS</b>.
     * 
     * When the revocation handler for any of the contexts returns <b>FALSE</b> due to an error, the <b>dwError</b> member in the structure pointed to by <i>pRevStatus</i> will be set by the handler to specify which error was encountered. 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns an error code equal to the error specified in the <b>dwError</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_revocation_status">CERT_REVOCATION_STATUS</a> structure. <b>GetLastError</b> can be one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_REVOCATION_CHECK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An installed or registered revocation function was not able to do a revocation check on the context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_REVOCATION_DLL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No installed or registered DLL was found that was able to verify revocation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_IN_REVOCATION_DATABASE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The context to be checked was not found in the revocation server's database.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_REVOCATION_OFFLINE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * It was not possible to connect to the revocation server.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_REVOKED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The context was revoked. <b>dwReason</b> in <i>pRevStatus</i> contains the reason for revocation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The context was good.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>cbSize</b> in <i>pRevStatus</i> is less than sizeof(<a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_revocation_status">CERT_REVOCATION_STATUS</a>). Note that <b>dwError</b> in <i>pRevStatus</i> is not updated for this error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certverifyrevocation
     * @since windows5.1.2600
     */
    static CertVerifyRevocation(dwEncodingType, dwRevType, cContext, rgpvContext, dwFlags, pRevPara, pRevStatus) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertVerifyRevocation", "uint", dwEncodingType, "uint", dwRevType, "uint", cContext, "ptr", rgpvContext, "uint", dwFlags, "ptr", pRevPara, "ptr", pRevStatus, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertCompareIntegerBlob function compares two integer BLOBs to determine whether they represent equal numeric values.
     * @remarks
     * Before doing the comparison, most significant bytes with a value of 0x00 are removed from a positive number. Positive here means that the most significant bit in the next nonzero byte is not set.
     * 
     * Most significant bytes with a value of 0xFF are removed from a negative number. Negative here means that the most significant bit in the next non-0xFF byte is set. This produces the unique representation of that integer, as shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Original bytes</th>
     * <th>Reduced form</th>
     * </tr>
     * <tr>
     * <td>0xFFFFFF88</td>
     * <td>0xFF88</td>
     * </tr>
     * <tr>
     * <td>0xFF23</td>
     * <td>0xFF23</td>
     * </tr>
     * <tr>
     * <td>0x007F</td>
     * <td>0x7F</td>
     * </tr>
     * <tr>
     * <td>0x00000080</td>
     * <td>0x80</td>
     * </tr>
     * </table>
     *  
     * 
     * Multiple-byte integers are treated as <a href="https://docs.microsoft.com/windows/desktop/SecGloss/l-gly">little-endian</a>. The least significant byte is <i>pbData</i>[0]. The most significant byte is <i>pbData</i>[<i>cbData</i> - 1], that is, 0xFFFFFF88 is stored in four bytes as:
     * 
     * {0x88, 0xFF, 0xFF, 0xFF}
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pInt1 A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_INTEGER_BLOB</a> structure that contains the first integer in the comparison.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pInt2 A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_INTEGER_BLOB</a> structure that contains the second integer in the comparison.
     * @returns {Integer} If the representations of the integer BLOBs are identical and the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certcompareintegerblob
     * @since windows5.1.2600
     */
    static CertCompareIntegerBlob(pInt1, pInt2) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertCompareIntegerBlob", "ptr", pInt1, "ptr", pInt2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether two certificates are identical by comparing the issuer name and serial number of the certificates.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_INFO>} pCertId1 A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> for the first certificate in the comparison.
     * @param {Pointer<CERT_INFO>} pCertId2 A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> for the second certificate in the comparison.
     * @returns {Integer} If the certificates are identical and the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certcomparecertificate
     * @since windows5.1.2600
     */
    static CertCompareCertificate(dwCertEncodingType, pCertId1, pCertId2) {
        result := DllCall("CRYPT32.dll\CertCompareCertificate", "uint", dwCertEncodingType, "ptr", pCertId1, "ptr", pCertId2, "int")
        return result
    }

    /**
     * The CertCompareCertificateName function compares two certificate CERT_NAME_BLOB structures to determine whether they are identical. The CERT_NAME_BLOB structures are used for the subject and the issuer of certificates.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pCertName1 A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CERT_NAME_BLOB</a> for the first name in the comparison. For more information, see 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_INTEGER_BLOB</a>.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pCertName2 A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CERT_NAME_BLOB</a> for the second name in the comparison.
     * @returns {Integer} If the names are identical and the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certcomparecertificatename
     * @since windows5.1.2600
     */
    static CertCompareCertificateName(dwCertEncodingType, pCertName1, pCertName2) {
        result := DllCall("CRYPT32.dll\CertCompareCertificateName", "uint", dwCertEncodingType, "ptr", pCertName1, "ptr", pCertName2, "int")
        return result
    }

    /**
     * The CertIsRDNAttrsInCertificateName function compares the attributes in the certificate name with the specified CERT_RDN to determine whether all attributes are included there.
     * @remarks
     * Currently, only an exact, case-sensitive match is supported.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Integer} dwFlags CERT_UNICODE_IS_RDN_ATTRS_FLAG must be set if the <i>pRDN</i> was initialized with Unicode strings as in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencodeobject">CryptEncodeObject</a> with <i>lpszStructType</i> set to X509_UNICODE_NAME.
     * 
     * CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG is set to do a case insensitive match. Otherwise, an exact, case sensitive match is done.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pCertName A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_INTEGER_BLOB</a> that contains the encoded subject or issuer name.
     * @param {Pointer<CERT_RDN>} pRDN Array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_rdn">CERT_RDN</a> structures that contain the attributes to be found in the name. The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_rdn_attr">CERT_RDN_ATTR</a> member of the <b>CERT_RDN</b> structure behaves according to the following rules.
     * 
     * <ul>
     * <li>If <b>pszObjId</b> is <b>NULL</b>, the attribute <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) is ignored.</li>
     * <li>If <b>dwValueType</b> is CERT_RDN_ANY_TYPE, the value type is ignored.</li>
     * <li>If the <b>pbData</b> member of <b>Value</b> is  <b>NULL</b>, any value can be a match.</li>
     * </ul>
     * @returns {Integer} If the function succeeds and all of the RDN values in the specified <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_rdn">CERT_RDN</a> are in the certificate name, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, or if there are  RDN values in the specified <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_rdn">CERT_RDN</a> that are not in the certificate name, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table lists some possible error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_MATCH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not all the attributes were found and matched.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Currently only X509_ASN_ENCODING is supported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certisrdnattrsincertificatename
     * @since windows5.1.2600
     */
    static CertIsRDNAttrsInCertificateName(dwCertEncodingType, dwFlags, pCertName, pRDN) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertIsRDNAttrsInCertificateName", "uint", dwCertEncodingType, "uint", dwFlags, "ptr", pCertName, "ptr", pRDN, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertComparePublicKeyInfo function compares two encoded public keys to determine whether they are identical.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pPublicKey1 A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> for the first public key in the comparison.
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pPublicKey2 A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> for the second public key in the comparison.
     * @returns {Integer} If the public keys are identical and the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certcomparepublickeyinfo
     * @since windows5.1.2600
     */
    static CertComparePublicKeyInfo(dwCertEncodingType, pPublicKey1, pPublicKey2) {
        result := DllCall("CRYPT32.dll\CertComparePublicKeyInfo", "uint", dwCertEncodingType, "ptr", pPublicKey1, "ptr", pPublicKey2, "int")
        return result
    }

    /**
     * The CertGetPublicKeyLength function acquires the bit length of public/private keys from a public key BLOB.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pPublicKey A pointer to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key BLOB</a> containing the keys for which the length is being retrieved.
     * @returns {Integer} Returns the length of the public/private keys in bits. If unable to determine the key's length, returns zero.
     * 
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to see the reason for any failures.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certgetpublickeylength
     * @since windows5.1.2600
     */
    static CertGetPublicKeyLength(dwCertEncodingType, pPublicKey) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetPublicKeyLength", "uint", dwCertEncodingType, "ptr", pPublicKey, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Verifies the signature of a certificate, certificate revocation list (CRL), or certificate request by using the public key in a CERT_PUBLIC_KEY_INFO structure.
     * @remarks
     * This function currently calls the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifycertificatesignatureex">CryptVerifyCertificateSignatureEx</a> function to perform the verification.
     * @param {Pointer} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>A handle to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) used to verify the signature.This parameter's data type is <b>HCRYPTPROV</b>.
     * 
     * <b>NULL</b> is passed unless there is a strong reason for passing in a specific cryptographic provider. Passing in <b>NULL</b> causes the default RSA or DSS provider to be acquired.
     * @param {Integer} dwCertEncodingType The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a> that was used to encrypt the subject. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> identifier, contained in the high <b>WORD</b> of this value, is ignored by this function.
     * 
     * 
     * This parameter can be the following currently defined certificate encoding type.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies <a href="https://docs.microsoft.com/windows/desktop/SecGloss/x-gly">X.509</a> certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} pbEncoded A pointer to an encoded <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a> of <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_signed_content_info">CERT_SIGNED_CONTENT_INFO</a> content on which the signature is to be verified.
     * @param {Integer} cbEncoded The size, in bytes, of the encoded content in <i>pbEncoded</i>.
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pPublicKey A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure that contains the public key to use when verifying the signature.
     * @returns {Integer} Returns nonzero if successful or zero otherwise.
     * 						
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea">CryptVerifySignature</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> may be propagated to this function.</div>
     * <div> </div>
     * On failure, this function will cause the following error codes to be returned from <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Currently only <b>X509_ASN_ENCODING</b> is supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature algorithm's <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) does not map to a known or supported <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature was not valid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>  may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptverifycertificatesignature
     * @since windows5.1.2600
     */
    static CryptVerifyCertificateSignature(hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pPublicKey) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptVerifyCertificateSignature", "ptr", hCryptProv, "uint", dwCertEncodingType, "ptr", pbEncoded, "uint", cbEncoded, "ptr", pPublicKey, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Verifies the signature of a subject certificate, certificate revocation list, certificate request, or keygen request by using the issuer's public key.
     * @remarks
     * The subject buffer can contain an encoded <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a> or a context for a certificate or CRL. In the case of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a>, if the certificate's public key parameters are missing and if these parameters can be inherited from the certificate's issuer for example from the DSS public key parameter, the context's CERT_PUBKEY_ALG_PARA_PROP_ID property is updated with the issuer's public key algorithm parameters for a valid signature.
     * @param {Pointer} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>A handle to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> used to verify the signature.This parameter's data type is <b>HCRYPTPROV</b>.
     * 
     * <b>NULL</b> is passed unless there is a strong reason for passing in a specific cryptographic provider. Passing in <b>NULL</b> causes the default RSA or DSS provider to be acquired.
     * @param {Integer} dwCertEncodingType The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a>   that was used to encrypt the subject.
     * 					 The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> identifier, contained in the high <b>WORD</b> of this value, is ignored by this function.
     * 
     * 
     * This parameter can be the following currently defined certificate encoding type.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies X.509 certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwSubjectType The subject type. This parameter can be one of the following subject types.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB"></a><a id="crypt_verify_cert_sign_subject_blob"></a><dl>
     * <dt><b>CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSubject</i> is a pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT"></a><a id="crypt_verify_cert_sign_subject_cert"></a><dl>
     * <dt><b>CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSubject</i> is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CCERT_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL"></a><a id="crypt_verify_cert_sign_subject_crl"></a><dl>
     * <dt><b>CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL</b></dt>
     * <dt>3 (0x3)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSubject</i> is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CCRL_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CERT_SIGN_SUBJECT_OCSP_BASIC_SIGNED_RESPONSE"></a><a id="crypt_verify_cert_sign_subject_ocsp_basic_signed_response"></a><dl>
     * <dt><b>CRYPT_VERIFY_CERT_SIGN_SUBJECT_OCSP_BASIC_SIGNED_RESPONSE</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvSubject</i> is a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ocsp_basic_signed_response_info">OCSP_BASIC_SIGNED_RESPONSE_INFO</a> structure.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>This subject type is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvSubject A pointer to a structure of the type indicated by <i>dwSubjectType</i> that contains the signature to be verified.
     * @param {Integer} dwIssuerType The issuer type. This parameter can be one of the following issuer types.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY"></a><a id="crypt_verify_cert_sign_issuer_pubkey"></a><dl>
     * <dt><b>CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvIssuer</i> is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT"></a><a id="crypt_verify_cert_sign_issuer_cert"></a><dl>
     * <dt><b>CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvIssuer</i> is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CCERT_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN"></a><a id="crypt_verify_cert_sign_issuer_chain"></a><dl>
     * <dt><b>CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN</b></dt>
     * <dt>3 (0x3)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvIssuer</i> is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CCERT_CHAIN_CONTEXT</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL"></a><a id="crypt_verify_cert_sign_issuer_null"></a><dl>
     * <dt><b>CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvIssuer</i> must be <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  If <i>dwIssuerType</i> is <b>CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL</b> and the signature algorithm is a hashing algorithm, the signature is expected to contain only unencrypted hash octets. Only <b>CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL</b> can be specified in this nonencrypted signature case. If any other <i>dwIssuerType</i> is specified, verification fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns E_INVALIDARG.</div>
     * <div> </div>
     * @param {Pointer<Void>} pvIssuer A pointer to a structure of the type indicated by the value of <i>dwIssuerType</i>. The structure contains access to the public key needed to verify the signature.
     * @param {Integer} dwFlags 
     * @param {Pointer<Void>} pvExtra Pointer to a <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-crypt_verify_cert_sign_strong_properties_info">CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO</a> structure if the <i>dwFlags</i> parameter is set to <b>CRYPT_VERIFY_CERT_SIGN_RETURN_STRONG_PROPERTIES_FLAG</b>.
     * 
     * You must call <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmemfree">CryptMemFree</a> to free the structure.
     * @returns {Integer} Returns nonzero if successful or zero otherwise. 
     * 						
     * 						
     * 						
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea">CryptVerifySignature</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> may be propagated to this function.</div>
     * <div> </div>
     * On failure, this function will cause the following error codes to be returned from <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Currently only <b>X509_ASN_ENCODING</b> is supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature algorithm's <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) does not map to a known or supported <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature was not valid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptverifycertificatesignatureex
     * @since windows5.1.2600
     */
    static CryptVerifyCertificateSignatureEx(hCryptProv, dwCertEncodingType, dwSubjectType, pvSubject, dwIssuerType, pvIssuer, dwFlags, pvExtra) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptVerifyCertificateSignatureEx", "ptr", hCryptProv, "uint", dwCertEncodingType, "uint", dwSubjectType, "ptr", pvSubject, "uint", dwIssuerType, "ptr", pvIssuer, "uint", dwFlags, "ptr", pvExtra, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether the specified hash algorithm and the public key in the signing certificate can be used to perform strong signing.
     * @param {Pointer<CERT_STRONG_SIGN_PARA>} pStrongSignPara Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_strong_sign_para">CERT_STRONG_SIGN_PARA</a> structure that contains information about supported signing and hashing algorithms.
     * @param {Pointer<PWSTR>} pwszCNGHashAlgid Pointer to a Unicode string that contains the name of the hashing algorithm. The following algorithms are supported:
     * 
     * <ul>
     * <li>L"MD5" (BCRYPT_MD5_ALGORITHM)</li>
     * <li>L"SHA1" (BCRYPT_SHA1_ALGORITHM)</li>
     * <li>L"SHA256" (BCRYPT_SHA256_ALGORITHM)</li>
     * <li>L"SHA256" (BCRYPT_SHA256_ALGORITHM)</li>
     * <li>L"SHA512" (BCRYPT_SHA512_ALGORITHM)</li>
     * </ul>
     * @param {Pointer<CERT_CONTEXT>} pSigningCert Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure that  contains the signing certificate. The public key algorithm in the signing certificate is checked for strength. The public key (asymmetric) algorithm is used for signing. The following signature algorithms are supported:
     * 
     * <ul>
     * <li>L"RSA" (BCRYPT_RSA_ALGORITHM)</li>
     * <li>L"DSA" (BCRYPT_DSA_ALGORITHM)</li>
     * <li>L"ECDSA" (SSL_ECDSA_ALGORITHM)</li>
     * </ul>
     * This parameter can be <b>NULL</b> if you want to check only whether the hashing algorithm is strong.
     * @returns {Integer} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>.
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. This function has the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the input arguments is not correct.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A specified algorithm is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certisstronghashtosign
     * @since windows8.0
     */
    static CertIsStrongHashToSign(pStrongSignPara, pwszCNGHashAlgid, pSigningCert) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertIsStrongHashToSign", "ptr", pStrongSignPara, "ptr", pwszCNGHashAlgid, "ptr", pSigningCert, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Important  This API is deprecated. (CryptHashToBeSigned)
     * @param {Pointer} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>A handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) to use to compute the hash.This parameter's data type is <b>HCRYPTPROV</b>.
     * 
     * Unless there is a strong reason for passing in a specific cryptographic provider in <i>hCryptProv</i>, zero is passed in. Passing in zero causes the default <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">RSA</a> or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">Digital Signature Standard</a> (DSS) provider to be acquired before doing hash, <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">signature verification</a>, or recipient <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">encryption</a> operations.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a> and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<Byte>} pbEncoded Address of a buffer that contains the content to be hashed. This is the encoded form of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_signed_content_info">CERT_SIGNED_CONTENT_INFO</a>.
     * @param {Integer} cbEncoded The size, in bytes, of the buffer.
     * @param {Pointer<Byte>} pbComputedHash A pointer to a buffer to receive the computed hash.
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbComputedHash A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pbComputedHash</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> might be propagated to this function. This function has the following error codes.</div>
     * <div> </div>
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbComputedHash</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbComputedHash</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Currently only X509_ASN_ENCODING is supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) of the signature algorithm does not map to a known or supported hash algorithm.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-crypthashtobesigned
     * @since windows5.1.2600
     */
    static CryptHashToBeSigned(hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptHashToBeSigned", "ptr", hCryptProv, "uint", dwCertEncodingType, "ptr", pbEncoded, "uint", cbEncoded, "ptr", pbComputedHash, "ptr", pcbComputedHash, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptHashCertificate function hashes the entire encoded content of a certificate including its signature.
     * @param {Pointer} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>A handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) to use to compute the hash. 
     * 
     * 
     * This parameter's data type is <b>HCRYPTPROV</b>.
     * 
     * Unless there is a strong reason for passing in a specific CSP in <i>hCryptProv</i>, zero is passed in. Passing in zero causes the default <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">RSA</a> or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">Digital Signature Standard</a> (DSS) provider to be acquired before doing hash, signature verification, or recipient encryption operations.
     * @param {Integer} Algid An 
     * 						<a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> structure that specifies the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash algorithm</a> to use. If <i>Algid</i> is zero, the default hash algorithm, SHA1, is used.
     * @param {Integer} dwFlags Value to be passed to the hash API. For details, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>.
     * @param {Pointer<Byte>} pbEncoded Address of the encoded content to be hashed.
     * @param {Integer} cbEncoded The size, in bytes, of the encoded content.
     * @param {Pointer<Byte>} pbComputedHash A pointer to a buffer to receive the computed hash. 
     * 
     * 
     * 
     * 
     * To set the size of this information for memory allocation purposes, this parameter can be <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbComputedHash A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pbComputedHash</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> might be propagated to this function.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-crypthashcertificate
     * @since windows5.1.2600
     */
    static CryptHashCertificate(hCryptProv, Algid, dwFlags, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptHashCertificate", "ptr", hCryptProv, "uint", Algid, "uint", dwFlags, "ptr", pbEncoded, "uint", cbEncoded, "ptr", pbComputedHash, "ptr", pcbComputedHash, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Hashes a block of data by using a CNG hash provider.
     * @param {Pointer<PWSTR>} pwszCNGHashAlgid The address of a null-terminated Unicode string that contains the CNG hash algorithm identifier of the hash algorithm to use to hash the certificate. This can be one of the <a href="https://docs.microsoft.com/windows/desktop/SecCNG/cng-algorithm-identifiers">CNG Algorithm Identifiers</a> that represents a hash algorithm or any other registered hash algorithm identifier.
     * @param {Integer} dwFlags A set of flags that modify the behavior of this function. No flags are defined for this function.
     * @param {Pointer<Byte>} pbEncoded The address of an array of bytes to be hashed. The <i>cbEncoded</i> parameter contains the size of this array.
     * @param {Integer} cbEncoded The number of elements in the <i>pbEncoded</i> array.
     * @param {Pointer<Byte>} pbComputedHash The address of a buffer that receives the computed hash. The variable pointed to by the <i>pcbComputedHash</i> parameter contains the size of this buffer.
     * @param {Pointer<UInt32>} pcbComputedHash The address of a <b>DWORD</b> variable that, on entry, contains the size, in bytes, of the  <i>pbComputedHash</i> buffer. After this function returns, this variable contains the number of bytes copied to the <i>pbComputedHash</i> buffer.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some of the possible error codes are identified in the following topics.<dl>
     * <dd>
     * <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptopenalgorithmprovider">BCryptOpenAlgorithmProvider</a>
     * </dd>
     * <dd>
     * <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptcreatehash">BCryptCreateHash</a>
     * </dd>
     * <dd>
     * <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptgetproperty">BCryptGetProperty</a>
     * </dd>
     * <dd>
     * <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcrypthashdata">BCryptHashData</a>
     * </dd>
     * <dd>
     * <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptfinishhash">BCryptFinishHash</a>
     * </dd>
     * </dl>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-crypthashcertificate2
     * @since windows6.0.6000
     */
    static CryptHashCertificate2(pwszCNGHashAlgid, dwFlags, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptHashCertificate2", "ptr", pwszCNGHashAlgid, "uint", dwFlags, "ptr", pvReserved, "ptr", pbEncoded, "uint", cbEncoded, "ptr", pbComputedHash, "ptr", pcbComputedHash, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptSignCertificate function signs the &quot;to be signed&quot; information in the encoded signed content.
     * @param {Pointer} hCryptProvOrNCryptKey 
     * @param {Integer} dwKeySpec Identifies the private key to use from the provider's container. It can be AT_KEYEXCHANGE or AT_SIGNATURE. This parameter is ignored if an <b>NCRYPT_KEY_HANDLE</b> is used in the <i>hCryptProvOrNCryptKey</i> parameter.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<Byte>} pbEncodedToBeSigned A pointer to the encoded content to be signed.
     * @param {Integer} cbEncodedToBeSigned The size, in bytes, of the encoded content, <i>pbEncodedToBeSigned</i>.
     * @param {Pointer<CRYPT_ALGORITHM_IDENTIFIER>} pSignatureAlgorithm A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_algorithm_identifier">CRYPT_ALGORITHM_IDENTIFIER</a> structure with a <b>pszObjId</b> member set to one of the following:
     * 
     * <ul>
     * <li>szOID_RSA_MD5RSA</li>
     * <li>szOID_RSA_SHA1RSA</li>
     * <li>szOID_X957_SHA1DSA</li>
     * <li>szOID_RSA_SSA_PSS</li>
     * <li>szOID_ECDSA_SPECIFIED</li>
     * </ul>
     * If the signature algorithm is a hash algorithm, the signature contains only the un-encrypted hash octets. A private key is not used to encrypt the hash. <i>dwKeySpec</i> is not used and <i>hCryptProvOrNCryptKey</i> can be <b>NULL</b> if an appropriate default CSP can be used for hashing.
     * @param {Pointer<Void>} pvHashAuxInfo Not currently used. Must be <b>NULL</b>.
     * @param {Pointer<Byte>} pbSignature A pointer to a buffer to receive the signed <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> of the content.
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbSignature A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pbSignature</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored or to be stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> might be propagated to this function.</div>
     * <div> </div>
     * This function has the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbSignature</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbSignature</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature algorithm's <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) does not map to a known or supported hash algorithm.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptsigncertificate
     * @since windows5.1.2600
     */
    static CryptSignCertificate(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pbEncodedToBeSigned, cbEncodedToBeSigned, pSignatureAlgorithm, pvHashAuxInfo, pbSignature, pcbSignature) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptSignCertificate", "ptr", hCryptProvOrNCryptKey, "uint", dwKeySpec, "uint", dwCertEncodingType, "ptr", pbEncodedToBeSigned, "uint", cbEncodedToBeSigned, "ptr", pSignatureAlgorithm, "ptr", pvHashAuxInfo, "ptr", pbSignature, "ptr", pcbSignature, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Encodes and signs a certificate, certificate revocation list (CRL), certificate trust list (CTL), or certificate request.
     * @param {Pointer} hCryptProvOrNCryptKey 
     * @param {Integer} dwKeySpec 
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. This can be the following value.
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies <a href="https://docs.microsoft.com/windows/desktop/SecGloss/x-gly">X.509</a> certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PSTR>} lpszStructType A pointer to a null-terminated ANSI string that contains the type of data to be encoded and signed. The following predefined <i>lpszStructType</i> constants are used with encode operations.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_CERT_CRL_TO_BE_SIGNED"></a><a id="x509_cert_crl_to_be_signed"></a><dl>
     * <dt><b>X509_CERT_CRL_TO_BE_SIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvStructInfo</i> is the address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_info">CRL_INFO</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_CERT_REQUEST_TO_BE_SIGNED"></a><a id="x509_cert_request_to_be_signed"></a><dl>
     * <dt><b>X509_CERT_REQUEST_TO_BE_SIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvStructInfo</i> is the address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_request_info">CERT_REQUEST_INFO</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_CERT_TO_BE_SIGNED"></a><a id="x509_cert_to_be_signed"></a><dl>
     * <dt><b>X509_CERT_TO_BE_SIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvStructInfo</i> is the address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_KEYGEN_REQUEST_TO_BE_SIGNED"></a><a id="x509_keygen_request_to_be_signed"></a><dl>
     * <dt><b>X509_KEYGEN_REQUEST_TO_BE_SIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvStructInfo</i> is the address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_keygen_request_info">CERT_KEYGEN_REQUEST_INFO</a> structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvStructInfo The address of a structure that contains the data to be signed and encoded. The format of this structure is determined by the <i>lpszStructType</i> parameter.
     * @param {Pointer<CRYPT_ALGORITHM_IDENTIFIER>} pSignatureAlgorithm A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_algorithm_identifier">CRYPT_ALGORITHM_IDENTIFIER</a> structure that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) of the signature algorithm and any additional parameters needed. This function uses the following algorithm OIDs:
     * 
     * <ul>
     * <li>szOID_RSA_MD5RSA</li>
     * <li>szOID_RSA_SHA1RSA</li>
     * <li>szOID_X957_SHA1DSA</li>
     * </ul>
     * If the signature algorithm is a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> algorithm, the signature contains only the unencrypted hash octets. A private key is not used to encrypt the hash. <i>dwKeySpec</i> is not used and <i>hCryptProvOrNCryptKey</i> can be <b>NULL</b> if an appropriate default CSP can be used for hashing.
     * @param {Pointer<Void>} pvHashAuxInfo Reserved. Must be <b>NULL</b>.
     * @param {Pointer<Byte>} pbEncoded A pointer to a buffer to receive the signed and encoded output.
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbEncoded A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pbEncoded</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored or to be stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> might be propagated to this function.</div>
     * <div> </div>
     * Possible error codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbEncoded</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbEncoded</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Currently only X509_ASN_ENCODING is supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The signature algorithm's OID does not map to a known or supported hash algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_BAD_ENCODE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error was encountered while encoding or decoding. The most likely cause of this error is the improper initialization of the fields in the structure pointed to by <i>pvStructInfo</i>.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptsignandencodecertificate
     * @since windows5.1.2600
     */
    static CryptSignAndEncodeCertificate(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, lpszStructType, pvStructInfo, pSignatureAlgorithm, pvHashAuxInfo, pbEncoded, pcbEncoded) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptSignAndEncodeCertificate", "ptr", hCryptProvOrNCryptKey, "uint", dwKeySpec, "uint", dwCertEncodingType, "ptr", lpszStructType, "ptr", pvStructInfo, "ptr", pSignatureAlgorithm, "ptr", pvHashAuxInfo, "ptr", pbEncoded, "ptr", pcbEncoded, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertVerifyTimeValidity function verifies the time validity of a certificate.
     * @param {Pointer<FILETIME>} pTimeToVerify A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure containing the comparison time. If <b>NULL</b>, the current time is used.
     * @param {Pointer<CERT_INFO>} pCertInfo A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure of the certificate for which the time is being verified.
     * @returns {Integer} Returns a minus one if the comparison time is before the <b>NotBefore</b> member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure. Returns a plus one if the comparison time is after the <b>NotAfter</b> member. Returns zero for valid time for the certificate.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certverifytimevalidity
     * @since windows5.1.2600
     */
    static CertVerifyTimeValidity(pTimeToVerify, pCertInfo) {
        result := DllCall("CRYPT32.dll\CertVerifyTimeValidity", "ptr", pTimeToVerify, "ptr", pCertInfo, "int")
        return result
    }

    /**
     * The CertVerifyCRLTimeValidity function verifies the time validity of a CRL.
     * @param {Pointer<FILETIME>} pTimeToVerify A pointer to <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure containing the time to be used in the verification. If set to <b>NULL</b>, the current time is used.
     * @param {Pointer<CRL_INFO>} pCrlInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_info">CRL_INFO</a> structure containing the CRL for which the time is to be verified.
     * @returns {Integer} Returns a minus one (–1) if the comparison time is before the <b>ThisUpdate</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_info">CRL_INFO</a> pointed to by <i>pCrlInfo</i>. Returns a plus one (+1) if the comparison time is after the <b>NextUpdate</b> time. Returns zero for valid time for the CRL.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certverifycrltimevalidity
     * @since windows5.1.2600
     */
    static CertVerifyCRLTimeValidity(pTimeToVerify, pCrlInfo) {
        result := DllCall("CRYPT32.dll\CertVerifyCRLTimeValidity", "ptr", pTimeToVerify, "ptr", pCrlInfo, "int")
        return result
    }

    /**
     * The CertVerifyValidityNesting function verifies that a subject certificate's time validity nests correctly within its issuer's time validity.
     * @param {Pointer<CERT_INFO>} pSubjectInfo A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure of the subject certificate.
     * @param {Pointer<CERT_INFO>} pIssuerInfo A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure of the issuer certificate.
     * @returns {Integer} Returns <b>TRUE</b> if the <b>NotBefore</b> time of the subject's certificate is after the <b>NotBefore</b> time of the issuer's certificate and the <b>NotAfter</b> time of the subject's certificate is not after the <b>NotAfter</b> time of the issuer's certificate. Otherwise, returns <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certverifyvaliditynesting
     * @since windows5.1.2600
     */
    static CertVerifyValidityNesting(pSubjectInfo, pIssuerInfo) {
        result := DllCall("CRYPT32.dll\CertVerifyValidityNesting", "ptr", pSubjectInfo, "ptr", pIssuerInfo, "int")
        return result
    }

    /**
     * Check a certificate revocation list (CRL) to determine whether a subject's certificate has or has not been revoked.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_INFO>} pCertId A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure of the certificate to be checked against the CRL.
     * @param {Integer} cCrlInfo Number of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_info">CRL_INFO</a> pointers in the <i>rgpCrlInfo</i> array.
     * @param {Pointer<CRL_INFO>} rgpCrlInfo Array of pointers to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_info">CRL_INFO</a> structures.
     * @returns {Integer} Returns <b>TRUE</b> if the certificate is not on the CRL and therefore is valid.
     * 						
     * 
     * It returns <b>FALSE</b> if the certificate is on the list and therefore has been revoked and is not valid.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certverifycrlrevocation
     * @since windows5.1.2600
     */
    static CertVerifyCRLRevocation(dwCertEncodingType, pCertId, cCrlInfo, rgpCrlInfo) {
        result := DllCall("CRYPT32.dll\CertVerifyCRLRevocation", "uint", dwCertEncodingType, "ptr", pCertId, "uint", cCrlInfo, "ptr", rgpCrlInfo, "int")
        return result
    }

    /**
     * Converts a CryptoAPI algorithm identifier (ALG_ID) to an Abstract Syntax Notation One (ASN.1) object identifier (OID) string.
     * @param {Integer} dwAlgId Value to be converted to an OID.
     * @returns {Pointer<PSTR>} If the function succeeds, the function returns the null-terminated OID string.
     * 
     * If no OID string corresponds to the algorithm identifier, the function returns <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certalgidtooid
     * @since windows5.1.2600
     */
    static CertAlgIdToOID(dwAlgId) {
        result := DllCall("CRYPT32.dll\CertAlgIdToOID", "uint", dwAlgId, "ptr")
        return result
    }

    /**
     * Use the CryptFindOIDInfo function instead of this function because ALG_ID identifiers are no longer supported in CNG.
     * @param {Pointer<PSTR>} pszObjId Pointer to the ASN.1 OID to be converted to an algorithm identifier.
     * @returns {Integer} Returns the 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> that corresponds to the object identifier (OID) or zero if no <b>ALG_ID</b> corresponds to the OID.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certoidtoalgid
     * @since windows5.1.2600
     */
    static CertOIDToAlgId(pszObjId) {
        result := DllCall("CRYPT32.dll\CertOIDToAlgId", "ptr", pszObjId, "uint")
        return result
    }

    /**
     * The CertFindExtension function finds the first extension in the CERT_EXTENSION array, as identified by its object identifier (OID).
     * @param {Pointer<PSTR>} pszObjId A pointer to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) to use in the search.
     * @param {Integer} cExtensions Number of extensions in the <i>rgExtensions</i> array.
     * @param {Pointer<CERT_EXTENSION>} rgExtensions Array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_extension">CERT_EXTENSION</a> structures.
     * @returns {Pointer<CERT_EXTENSION>} Returns a pointer to the extension, if one is found. Otherwise, <b>NULL</b> is returned.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certfindextension
     * @since windows5.1.2600
     */
    static CertFindExtension(pszObjId, cExtensions, rgExtensions) {
        result := DllCall("CRYPT32.dll\CertFindExtension", "ptr", pszObjId, "uint", cExtensions, "ptr", rgExtensions, "ptr")
        return result
    }

    /**
     * The CertFindAttribute function finds the first attribute in the CRYPT_ATTRIBUTE array, as identified by its object identifier (OID).
     * @param {Pointer<PSTR>} pszObjId A pointer to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) to use in the search.
     * @param {Integer} cAttr Number of attributes in the <i>rgAttr</i> array.
     * @param {Pointer<CRYPT_ATTRIBUTE>} rgAttr Array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_attribute">CRYPT_ATTRIBUTE</a> structures.
     * @returns {Pointer<CRYPT_ATTRIBUTE>} Returns a pointer to the attribute, if one is found. Otherwise, <b>NULL</b> is returned.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certfindattribute
     * @since windows5.1.2600
     */
    static CertFindAttribute(pszObjId, cAttr, rgAttr) {
        result := DllCall("CRYPT32.dll\CertFindAttribute", "ptr", pszObjId, "uint", cAttr, "ptr", rgAttr, "ptr")
        return result
    }

    /**
     * The CertFindRDNAttr function finds the first RDN attribute identified by its object identifier (OID) in a list of the Relative Distinguished Names (RDN).
     * @param {Pointer<PSTR>} pszObjId A pointer to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) to use In the search.
     * @param {Pointer<CERT_NAME_INFO>} pName A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_name_info">CERT_NAME_INFO</a> structure containing the list of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">Relative Distinguished Names</a> to be searched.
     * @returns {Pointer<CERT_RDN_ATTR>} Returns a pointer to the attribute, if one is found. Otherwise, <b>NULL</b> is returned.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certfindrdnattr
     * @since windows5.1.2600
     */
    static CertFindRDNAttr(pszObjId, pName) {
        result := DllCall("CRYPT32.dll\CertFindRDNAttr", "ptr", pszObjId, "ptr", pName, "ptr")
        return result
    }

    /**
     * Acquires the intended key usage bytes from a certificate.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_INFO>} pCertInfo A pointer to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_info">CERT_INFO</a> structure of the specified certificate.
     * @param {Pointer<Byte>} pbKeyUsage A pointer to a buffer to receive the intended key usage. The following list shows currently defined values. These can be combined by using bitwise-<b>OR</b> operations.
     * 
     * <ul>
     * <li>CERT_DATA_ENCIPHERMENT_KEY_USAGE</li>
     * <li>CERT_DIGITAL_SIGNATURE_KEY_USAGE</li>
     * <li>CERT_KEY_AGREEMENT_KEY_USAGE</li>
     * <li>CERT_KEY_CERT_SIGN_KEY_USAGE</li>
     * <li>CERT_KEY_ENCIPHERMENT_KEY_USAGE</li>
     * <li>CERT_NON_REPUDIATION_KEY_USAGE</li>
     * <li>CERT_OFFLINE_CRL_SIGN_KEY_USAGE</li>
     * </ul>
     * @param {Integer} cbKeyUsage The size, in bytes, of the buffer pointed to by <i>pbKeyUsage</i>. Currently, the intended key usage occupies 1 or 2 bytes of data.
     * @returns {Integer} If the certificate does not have any intended key usage bytes, <b>FALSE</b> is returned and <i>pbKeyUsage</i> is zeroed. Otherwise, <b>TRUE</b> is returned and up to <i>cbKeyUsage</i> number of bytes are copied into <i>pbKeyUsage</i>. Any remaining bytes not copied are zeroed.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns zero if none of the required extensions is found.
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certgetintendedkeyusage
     * @since windows5.1.2600
     */
    static CertGetIntendedKeyUsage(dwCertEncodingType, pCertInfo, pbKeyUsage, cbKeyUsage) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetIntendedKeyUsage", "uint", dwCertEncodingType, "ptr", pCertInfo, "ptr", pbKeyUsage, "uint", cbKeyUsage, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Installs a specific provider to be the default context provider for the specified algorithm.
     * @remarks
     * The installed default context providers are stack ordered, thus when searching for a default context provider, the system starts with the most recently installed provider. The per-thread list of providers is searched before the per-process list of providers. After a match is found, the system does not continue to search for other matches.
     * 
     * The installed provider handle must remain available for use until <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptuninstalldefaultcontext">CryptUninstallDefaultContext</a> is called, or the thread or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">process</a> exits.
     * @param {Pointer} hCryptProv The handle of the cryptographic service provider to be used as the default context. This handle is obtained by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function.
     * @param {Integer} dwDefaultType 
     * @param {Pointer<Void>} pvDefaultPara Specifies the object or objects to install the default context provider for. The format of this parameter depends on the contents of the <i>dwDefaultType</i> parameter.
     * @param {Integer} dwFlags 
     * @param {Pointer<Void>} phDefaultContext The address of an <b>HCRYPTDEFAULTCONTEXT</b> variable that receives the default context handle. This handle is passed to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptuninstalldefaultcontext">CryptUninstallDefaultContext</a> function to uninstall the default context provider.
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE). If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptinstalldefaultcontext
     * @since windows5.1.2600
     */
    static CryptInstallDefaultContext(hCryptProv, dwDefaultType, pvDefaultPara, dwFlags, phDefaultContext) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptInstallDefaultContext", "ptr", hCryptProv, "uint", dwDefaultType, "ptr", pvDefaultPara, "uint", dwFlags, "ptr", pvReserved, "ptr", phDefaultContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Important  This API is deprecated. (CryptUninstallDefaultContext)
     * @param {Pointer<Void>} hDefaultContext Handle of the context to be released.
     * @param {Integer} dwFlags Reserved for future use.
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE) .If the function fails, the return value is zero (FALSE). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptuninstalldefaultcontext
     * @since windows5.1.2600
     */
    static CryptUninstallDefaultContext(hDefaultContext, dwFlags) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptUninstallDefaultContext", "ptr", hDefaultContext, "uint", dwFlags, "ptr", pvReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptExportPublicKeyInfo function exports the public key information associated with the corresponding private key of the provider. For an updated version of this function, see CryptExportPublicKeyInfoEx.
     * @param {Pointer} hCryptProvOrNCryptKey Handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) to use when exporting the public key information. This handle must be an <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a> handle that has been created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function or an <b>NCRYPT_KEY_HANDLE</b> handle that has been created by using the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenkey">NCryptOpenKey</a> function. New applications should always pass in the <b>NCRYPT_KEY_HANDLE</b> handle of a CNG CSP.
     * @param {Integer} dwKeySpec Identifies the private key to use from the container of the provider. It can be AT_KEYEXCHANGE or AT_SIGNATURE. This parameter is ignored if an <b>NCRYPT_KEY_HANDLE</b> is used in the <i>hCryptProvOrNCryptKey</i> parameter.
     * @param {Integer} dwCertEncodingType Specifies the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">encoding type</a> used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a>  structure to receive the public key information to be exported.
     * 
     * To set the size of this information for memory allocation purposes, this parameter can be <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbInfo A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pInfo</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes needed for the return buffer.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetuserkey">CryptGetUserKey</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a> might be propagated to this function.</div>
     * <div> </div>
     * This function has the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pInfo</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbInfo</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Currently only X509_ASN_ENCODING is supported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptexportpublickeyinfo
     * @since windows5.1.2600
     */
    static CryptExportPublicKeyInfo(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pInfo, pcbInfo) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptExportPublicKeyInfo", "ptr", hCryptProvOrNCryptKey, "uint", dwKeySpec, "uint", dwCertEncodingType, "ptr", pInfo, "ptr", pcbInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Exports the public key information associated with the provider's corresponding private key.
     * @param {Pointer} hCryptProvOrNCryptKey A handle of the CSP to use when exporting the public key information. This handle must be an <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a> handle that has been created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function or an <b>NCRYPT_KEY_HANDLE</b> handle that has been created by using the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenkey">NCryptOpenKey</a> function. New applications should always pass in the <b>NCRYPT_KEY_HANDLE</b> handle of a CNG CSP.
     * @param {Integer} dwKeySpec Identifies the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key</a> to use from the provider's container. It can be AT_KEYEXCHANGE or AT_SIGNATURE. This parameter is ignored if an <b>NCRYPT_KEY_HANDLE</b> is used in the <i>hCryptProvOrNCryptKey</i> parameter.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<PSTR>} pszPublicKeyObjId Specifies the public key algorithm.
     * 
     * <div class="alert"><b>Note</b>  <i>pszPublicKeyObjId</i> and <i>dwCertEncodingType</i> are used together to determine the installable <b>CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC</b> to call. If an installable function was not found for the <i>pszPublicKeyObjId</i> parameter, an attempt is made to export the key as an RSA Public Key (szOID_RSA_RSA).</div>
     * <div> </div>
     * @param {Integer} dwFlags A <b>DWORD</b> flag value that indicates how the public key information  is exported. The flag value is passed directly to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptfindoidinfo">CryptFindOIDInfo</a> function when mapping the public key <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> to the corresponding CNG public key algorithm Unicode string. The following flag values can be set.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Skips public keys in the <b>CRYPT_PUBKEY_ALG_OID_GROUP_ID</b> group explicitly flagged with the <b>CRYPT_OID_PUBKEY_ENCRYPT_ONLY_FLAG</b> flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Skips public keys in the <b>CRYPT_PUBKEY_ALG_OID_GROUP_ID</b> group explicitly flagged with the <b>CRYPT_OID_PUBKEY_SIGN_ONLY_FLAG</b> flag.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvAuxInfo This parameter is reserved for future use and  must be set to <b>NULL</b>.
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a>  structure to receive the public key information to be exported.
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbInfo A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pInfo</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetuserkey">CryptGetUserKey</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a> can be propagated to this function.</div>
     * <div> </div>
     * This function has the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An export function that can be installed or registered could not be found for the specified <i>dwCertEncodingType</i> and <i>pszPublicKeyObjId</i> parameters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pInfo</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by the <i>pcbInfo</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptexportpublickeyinfoex
     * @since windows5.1.2600
     */
    static CryptExportPublicKeyInfoEx(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptExportPublicKeyInfoEx", "ptr", hCryptProvOrNCryptKey, "uint", dwKeySpec, "uint", dwCertEncodingType, "ptr", pszPublicKeyObjId, "uint", dwFlags, "ptr", pvAuxInfo, "ptr", pInfo, "ptr", pcbInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Exports the public key information associated with a provider's corresponding private key.
     * @remarks
     * If the <b>CryptExportPublicKeyInfoFromBCryptKeyHandle</b> function is unable to find an installable OID function for the OID specified by the <i>pszPublicKeyObjId</i> parameter, it attempts to export the key as a RSA Public Key (<b>szOID_RSA_RSA</b>).
     *  If the key is exported as a RSA Public Key, the values of the <i>dwFlags</i> and <i>pvAuxInfo</i> parameters are not used.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} hBCryptKey The handle of the key from which to export the public key information.
     * @param {Integer} dwCertEncodingType Specifies the encoding type to be matched.  
     * 
     * 
     * 
     * 						
     * 
     * This value can be a bitwise combination of the currently defined encoding types:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<PSTR>} pszPublicKeyObjId A pointer to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) that identifies the installable function to  use to export the key. If the high-order word of the OID is nonzero, <i>pszPublicKeyObjId</i> is a pointer to either an OID string such as "2.5.29.1" or an ASCII string such as "file." If the high-order word of the OID is zero, the low-order word specifies the integer identifier to be used as the object identifier.
     * @param {Integer} dwFlags A <b>DWORD</b> value that indicates how the public key information  is exported.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG"></a><a id="crypt_oid_info_pubkey_sign_key_flag"></a><dl>
     * <dt><b>CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG</b></dt>
     * <dt>0x80000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Skips public keys in the <b>CRYPT_PUBKEY_ALG_OID_GROUP_ID</b> group that are explicitly flagged with the <b>CRYPT_OID_PUBKEY_ENCRYPT_ONLY_FLAG</b> flag.
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG"></a><a id="crypt_oid_info_pubkey_encrypt_key_flag"></a><dl>
     * <dt><b>CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG</b></dt>
     * <dt>0x40000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Skips public keys in the <b>CRYPT_PUBKEY_ALG_OID_GROUP_ID</b> group that are explicitly flagged with the <b>CRYPT_OID_PUBKEY_SIGN_ONLY_FLAG</b> flag.
     * 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvAuxInfo This parameter is reserved for future use and  must be set to <b>NULL</b>.
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a>  structure to receive the public key information to be exported.
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbInfo A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pInfo</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer.
     * @returns {Integer} The function returns <b>TRUE</b> if it succeeds; otherwise, it returns <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptexportpublickeyinfofrombcryptkeyhandle
     * @since windows6.1
     */
    static CryptExportPublicKeyInfoFromBCryptKeyHandle(hBCryptKey, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo) {
        result := DllCall("CRYPT32.dll\CryptExportPublicKeyInfoFromBCryptKeyHandle", "ptr", hBCryptKey, "uint", dwCertEncodingType, "ptr", pszPublicKeyObjId, "uint", dwFlags, "ptr", pvAuxInfo, "ptr", pInfo, "ptr", pcbInfo, "int")
        return result
    }

    /**
     * Converts and imports the public key information into the provider and returns a handle of the public key.
     * @remarks
     * This function is normally used to retrieve the public key from a certificate. This is done by passing the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure from a filled-in certificate structure as shown in the following pseudocode.
     * 
     * 
     * ``` syntax
     * PCCERT_CONTEXT pCertContext
     * 
     * // Get the certificate context structure from a certificate.
     * pCertContext = CertCreateCertificateContext(...)
     * if(pCertContext)
     * {
     *     HCRYPTKEY hCertPubKey
     * 
     *     // Get the public key information for the certificate.
     *     CryptImportPublicKeyInfo(
     *         hCryptProv, 
     *         X509_ASN_ENCODING, 
     *         &amp;pCertContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo, 
     *         &amp;hCertPubKey)
     * 
     *     CertFreeCertificateContext(pCertContext)
     * }
     * ```
     * @param {Pointer} hCryptProv The handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) to use when importing the public key. This handle must have already been created using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pInfo The address of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure that contains the public key to import into the provider.
     * @param {Pointer<UIntPtr>} phKey The address of an <b>HCRYPTKEY</b> variable that receives the handle of the imported public key. When you have finished using the public key, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetuserkey">CryptGetUserKey</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a> might be propagated to this function. This function has the following error code.</div>
     * <div> </div>
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An import function that can be installed or registered could not be found for the specified <i>dwCertEncodingType</i> and
     * 								<i>pInfo-&gt;Algorithm.pszObjId</i> parameters.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptimportpublickeyinfo
     * @since windows5.1.2600
     */
    static CryptImportPublicKeyInfo(hCryptProv, dwCertEncodingType, pInfo, phKey) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptImportPublicKeyInfo", "ptr", hCryptProv, "uint", dwCertEncodingType, "ptr", pInfo, "ptr", phKey, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Important  This API is deprecated. (CryptImportPublicKeyInfoEx)
     * @remarks
     * This function is normally used to retrieve the public key from a certificate. This is done by passing the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure from a filled-in certificate structure as shown in the following pseudocode.
     * 
     * 
     * ``` syntax
     * PCCERT_CONTEXT pCertContext
     * 
     * // Get the certificate context structure from a certificate.
     * pCertContext = CertCreateCertificateContext(...)
     * if(pCertContext)
     * {
     *     HCRYPTKEY hCertPubKey
     * 
     *     // Get the public key information for the certificate.
     *     CryptImportPublicKeyInfo(
     *         hCryptProv, 
     *         X509_ASN_ENCODING, 
     *         &amp;pCertContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo, 
     *         &amp;hCertPubKey)
     * 
     *     CertFreeCertificateContext(pCertContext)
     * }
     * ```
     * @param {Pointer} hCryptProv The handle of the CSP to receive the imported public key. This handle must have already been created using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pInfo the address of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure that contains the public key to import into the provider.
     * 
     * <div class="alert"><b>Note</b>  The <b>pzObjId</b> member of the <b>Algorithm</b> member pointed to by the <i>pInfo</i>  and <i>dwCertEncodingType</i> parameters determine an installable <b>CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC</b> callback function. If an installable function is not found, an attempt is made to import the key as an RSA Public Key (szOID_RSA_RSA).</div>
     * <div> </div>
     * @param {Integer} aiKeyAlg An <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> structure that contains a CSP-specific algorithm to override the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CALG_RSA_KEYX</a> default algorithm.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Void>} pvAuxInfo Reserved for future use and must be <b>NULL</b>.
     * @param {Pointer<UIntPtr>} phKey The address of an <b>HCRYPTKEY</b> variable that receives the handle of the imported public key. When you have finished using the public key, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroykey">CryptDestroyKey</a> function.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgetuserkey">CryptGetUserKey</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a> might be propagated to this function. This function has the following error code.</div>
     * <div> </div>
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An import function that can be installed or registered could not be found for the specified <i>dwCertEncodingType</i> and <i>pInfo</i> parameters.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptimportpublickeyinfoex
     * @since windows5.1.2600
     */
    static CryptImportPublicKeyInfoEx(hCryptProv, dwCertEncodingType, pInfo, aiKeyAlg, dwFlags, pvAuxInfo, phKey) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptImportPublicKeyInfoEx", "ptr", hCryptProv, "uint", dwCertEncodingType, "ptr", pInfo, "uint", aiKeyAlg, "uint", dwFlags, "ptr", pvAuxInfo, "ptr", phKey, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Imports a public key into the CNG asymmetric provider that corresponds to the public key object identifier (OID) and returns a CNG handle to the key.
     * @param {Integer} dwCertEncodingType The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a> that was used to encrypt the subject. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> identifier, contained in the high <b>WORD</b> of this value, is ignored by this function.
     * 
     * 
     * This parameter can be the following currently defined certificate encoding type.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies <a href="https://docs.microsoft.com/windows/desktop/SecGloss/x-gly">X.509</a> certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pInfo The address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure that contains the public key information to import into the provider.
     * @param {Integer} dwFlags 
     * @param {Pointer<Void>} pvAuxInfo This parameter is reserved for future use and must be set to <b>NULL</b>.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} phKey The address of a <b>BCRYPT_KEY_HANDLE</b> variable that receives the handle of the imported key.
     * 
     * When this handle is no longer needed, you must release it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/bcrypt/nf-bcrypt-bcryptdestroykey">BCryptDestroyKey</a> function.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An import function that can be installed or registered could not be found for the specified <i>dwCertEncodingType</i> and <i>pInfo</i> parameters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptimportpublickeyinfoex2
     * @since windows6.0.6000
     */
    static CryptImportPublicKeyInfoEx2(dwCertEncodingType, pInfo, dwFlags, pvAuxInfo, phKey) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptImportPublicKeyInfoEx2", "uint", dwCertEncodingType, "ptr", pInfo, "uint", dwFlags, "ptr", pvAuxInfo, "ptr", phKey, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Obtains the private key for a certificate.
     * @remarks
     * When <b>CRYPT_ACQUIRE_WINDOW_HANDLE_FLAG</b> is set, the caller must ensure the <b>HWND</b> is valid. If the <b>HWND</b> is no longer valid, for CSP the caller should call <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsetprovparam">CryptSetProvParam</a> using flag PP_CLIENT_HWND with <b>NULL</b> for the <b>HWND</b> and <b>NULL</b>  for the HCRYPTPROV. For KSP, the caller should set the  NCRYPT_WINDOW_HANDLE_PROPERTY of the ncrypt key to be <b>NULL</b>. When <b>CRYPT_ACQUIRE_WINDOW_HANDLE_FLAG</b> flag is set for KSP, the NCRYPT_WINDOW_HANDLE_PROPERTY is set on the storage provider and the key. If both calls fail, then the function fails. If only one fails, the function succeeds. Note that setting <b>HWND</b> to <b>NULL</b>  effectively removes <b>HWND</b> from the HCRYPTPROV or ncrypt key.
     * @param {Pointer<CERT_CONTEXT>} pCert The address of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a> for which a private key will be obtained.
     * @param {Integer} dwFlags 
     * @param {Pointer<Void>} pvParameters If the <b>CRYPT_ACQUIRE_WINDOW_HANDLE_FLAG</b>  is set, then this is the address of an <b>HWND</b>. If the <b>CRYPT_ACQUIRE_WINDOW_HANDLE_FLAG</b> is not set, then this parameter must be <b>NULL</b>.
     * 
     * 
     * <b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This parameter was  named <i>pvReserved</i> and reserved for future use and must be <b>NULL</b>.
     * @param {Pointer<UIntPtr>} phCryptProvOrNCryptKey The address of an <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov-or-ncrypt-key-handle">HCRYPTPROV_OR_NCRYPT_KEY_HANDLE</a> variable that receives the handle of either the CryptoAPI provider or the CNG key. If the <i>pdwKeySpec</i> variable receives the <b>CERT_NCRYPT_KEY_SPEC</b> flag, this is a CNG key handle of type <b>NCRYPT_KEY_HANDLE</b>; otherwise, this is a CryptoAPI provider handle of type <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a>.
     * 
     * For more information about when and how to release this handle, see the description of the <i>pfCallerFreeProvOrNCryptKey</i> parameter.
     * @param {Pointer<UInt32>} pdwKeySpec 
     * @param {Pointer<Int32>} pfCallerFreeProvOrNCryptKey The address of a <b>BOOL</b> variable that receives a value that indicates whether the caller must free the handle returned in the <i>phCryptProvOrNCryptKey</i> variable. This receives <b>FALSE</b> if any of the following is true:
     * 
     * <ul>
     * <li>Public key acquisition or comparison fails.</li>
     * <li>The <i>dwFlags</i> parameter contains the <b>CRYPT_ACQUIRE_CACHE_FLAG</b> flag.</li>
     * <li>The <i>dwFlags</i> parameter contains the <b>CRYPT_ACQUIRE_USE_PROV_INFO_FLAG</b> flag, the certificate context property is set to <b>CERT_KEY_PROV_INFO_PROP_ID</b> with the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a> structure, and the <i>dwFlags</i> member of the <b>CRYPT_KEY_PROV_INFO</b> structure is set to <b>CERT_SET_KEY_CONTEXT_PROP_ID</b>.</li>
     * </ul>
     * If this variable receives <b>FALSE</b>, the calling application must not release the handle returned in the <i>phCryptProvOrNCryptKey</i> variable. The handle will be released on the last free action of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a>.
     * 
     * If this variable receives <b>TRUE</b>, the caller is responsible for releasing the handle returned in the <i>phCryptProvOrNCryptKey</i> variable. If the <i>pdwKeySpec</i> variable receives the <b>CERT_NCRYPT_KEY_SPEC</b> value, the handle must be released by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptfreeobject">NCryptFreeObject</a> function; otherwise, the handle is released by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptreleasecontext">CryptReleaseContext</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. One possible error code is the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_PUBLIC_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key</a> in the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a> does not match the public key returned by the CSP. This error code is returned if the CRYPT_ACQUIRE_COMPARE_KEY_FLAG is set and the public key in the certificate does not match the public key returned by the cryptographic provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_SILENT_CONTEXT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter contained the <b>CRYPT_ACQUIRE_SILENT_FLAG</b> flag and the CSP could not continue an operation without displaying a user interface.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecertificateprivatekey
     * @since windows5.1.2600
     */
    static CryptAcquireCertificatePrivateKey(pCert, dwFlags, pvParameters, phCryptProvOrNCryptKey, pdwKeySpec, pfCallerFreeProvOrNCryptKey) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptAcquireCertificatePrivateKey", "ptr", pCert, "uint", dwFlags, "ptr", pvParameters, "ptr", phCryptProvOrNCryptKey, "ptr", pdwKeySpec, "ptr", pfCallerFreeProvOrNCryptKey, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the cryptographic providers and their containers to find the private key that corresponds to the certificate's public key.
     * @remarks
     * This function enumerates the cryptographic providers and their containers to find the private key that corresponds to the certificate's <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key</a>. For a match, the function updates the certificate's <b>CERT_KEY_PROV_INFO_PROP_ID</b> property. If the <b>CERT_KEY_PROV_INFO_PROP_ID</b> is already set, it is checked to determine whether it matches the provider's public key. For a match, the function skips the previously mentioned enumeration.
     * @param {Pointer<CERT_CONTEXT>} pCert A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure of the certificate to use when exporting public key information.
     * @param {Integer} dwFlags 
     * @returns {Integer} <b>TRUE</b> if the function finds a private key that corresponds to the certificate's public key within a searched <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">container</a>; <b>FALSE</b> if the function fails to find a container or a private key within a container.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the following error:
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No container found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptfindcertificatekeyprovinfo
     * @since windows5.1.2600
     */
    static CryptFindCertificateKeyProvInfo(pCert, dwFlags) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptFindCertificateKeyProvInfo", "ptr", pCert, "uint", dwFlags, "ptr", pvReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Imports the private key in PKCS
     * @remarks
     * <b>CryptImportPKCS8</b>  calls the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nc-wincrypt-pcrypt_resolve_hcryptprov_func">PCRYPT_RESOLVE_HCRYPTPROV_FUNC</a> function  by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_pkcs8_import_params">CRYPT_PKCS8_IMPORT_PARAMS</a> structure contained in the <i>sPrivateKeyAndParams</i> parameter to retrieve a handle of the provider to which to import the key.  If  <b>PCRYPT_RESOLVE_HCRYPTPROV_FUNC</b> is <b>NULL</b>, then the default provider is used.
     * 
     * This function is only supported for asymmetric keys.
     * @param {Pointer} sPrivateKeyAndParams A <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_pkcs8_import_params">CRYPT_PKCS8_IMPORT_PARAMS</a> structure that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key BLOB</a> and corresponding parameters.
     * @param {Integer} dwFlags 
     * @param {Pointer<UIntPtr>} phCryptProv A pointer to the <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a>  to receive the handle of the provider into which the key is
     * imported by calling the <b>CryptImportPKCS8</b> function.  
     * 
     * When you have finished using the handle, free the handle by calling <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptreleasecontext">CryptReleaseContext</a>. 
     * 
     * This parameter can be <b>NULL</b>, in which case the handle of the provider is not returned.
     * @param {Pointer<Void>} pvAuxInfo This parameter must be <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following error code is specific to this function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNSUPPORTED_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The algorithm <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) of the private
     *       key is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>  may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptimportpkcs8
     * @since windows5.1.2600
     */
    static CryptImportPKCS8(sPrivateKeyAndParams, dwFlags, phCryptProv, pvAuxInfo) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptImportPKCS8", "ptr", sPrivateKeyAndParams, "uint", dwFlags, "ptr", phCryptProv, "ptr", pvAuxInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Exports the private key in PKCS (CryptExportPKCS8)
     * @remarks
     * This function is only supported for asymmetric keys.
     * @param {Pointer} hCryptProv An <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a>  variable that contains  the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP). This is a handle to the CSP obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.
     * @param {Integer} dwKeySpec A <b>DWORD</b>  variable that contains  the key specification. The following <i>dwKeySpec</i> values are defined for the default provider.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AT_KEYEXCHANGE"></a><a id="at_keyexchange"></a><dl>
     * <dt><b>AT_KEYEXCHANGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Keys used to encrypt/decrypt session keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AT_SIGNATURE"></a><a id="at_signature"></a><dl>
     * <dt><b>AT_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Keys used to create and verify digital signatures.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PSTR>} pszPrivateKeyObjId An  <b>LPSTR</b>  variable that contains  the private key <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly"> object identifier</a> (OID).
     * @param {Integer} dwFlags This parameter should be zero if <i>pbPrivateKeyBlob</i> is <b>NULL</b> and 0x8000 otherwise.
     * @param {Pointer<Void>} pvAuxInfo This parameter must be set to <b>NULL</b>.
     * @param {Pointer<Byte>} pbPrivateKeyBlob A pointer to an 
     * array of <b>BYTE</b> structures to receive the private key  to be exported. 
     * 
     * 
     * The private key will contain the information in a PKCS #8 PrivateKeyInfo <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) type found in the PKCS #8 standard.
     * 
     * For memory allocation purposes, you can get the size of the private key  to be exported by setting this parameter to <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbPrivateKeyBlob A pointer to a <b>DWORD</b> that may contain, on input, the size, in  bytes,  of the memory allocation needed to contain the <i>pbPrivateKeyBlob</i>. If <i>pbPrivateKeyBlob</i> is <b>NULL</b>, this parameter will return the size of the memory allocation needed for a second call to the function. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @returns {Integer} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following error codes are specific to this function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNSUPPORTED_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An export function that can be installed or registered could not be found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbPrivateKeyBlob</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by the <i>pcbPrivateKeyBlob</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>  may return an ASN.1 encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptexportpkcs8
     * @since windows5.1.2600
     */
    static CryptExportPKCS8(hCryptProv, dwKeySpec, pszPrivateKeyObjId, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptExportPKCS8", "ptr", hCryptProv, "uint", dwKeySpec, "ptr", pszPrivateKeyObjId, "uint", dwFlags, "ptr", pvAuxInfo, "ptr", pbPrivateKeyBlob, "ptr", pcbPrivateKeyBlob, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Encodes the public key information in a CERT_PUBLIC_KEY_INFO structure and computes the hash of the encoded bytes.
     * @param {Pointer} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>A handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP) to use to compute the hash.This parameter's data type is <b>HCRYPTPROV</b>.
     * 
     * Unless there is a strong reason for passing in a specific cryptographic provider in <i>hCryptProv</i>, zero is passed in. Passing in zero causes the default <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">RSA</a> or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">Digital Signature Standard</a> (DSS) provider to be acquired before doing hash, <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">signature verification</a>, or recipient <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">encryption</a> operations.
     * @param {Integer} Algid An <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> structure that specifies the CryptoAPI hash algorithm to use. If <i>Algid</i> is zero, the default hash algorithm, MD5, is used.
     * @param {Integer} dwFlags Values to be passed on to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>.
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a> and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key</a> information to be encoded and hashed.
     * @param {Pointer<Byte>} pbComputedHash A pointer to a buffer to receive the computed hash.
     * 
     * To set the size of this information for memory allocation purposes, this parameter can be <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbComputedHash A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pbComputedHash</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a> can be propagated to this function. This function has the following error codes.</div>
     * <div> </div>
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbComputedHash</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbComputedHash</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid certificate encoding type. Currently only X509_ASN_ENCODING is supported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-crypthashpublickeyinfo
     * @since windows5.1.2600
     */
    static CryptHashPublicKeyInfo(hCryptProv, Algid, dwFlags, dwCertEncodingType, pInfo, pbComputedHash, pcbComputedHash) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptHashPublicKeyInfo", "ptr", hCryptProv, "uint", Algid, "uint", dwFlags, "uint", dwCertEncodingType, "ptr", pInfo, "ptr", pbComputedHash, "ptr", pcbComputedHash, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertRDNValueToStr function converts a name in a CERT_RDN_VALUE_BLOB to a null-terminated character string. (ANSI)
     * @remarks
     * If <i>psz</i> is not <b>NULL</b> and <i>csz</i> is not zero, the returned <i>psz</i> is always a possibly empty <b>null</b>-terminated string.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The wincrypt.h header defines CertRDNValueToStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} dwValueType Indicates the kind of RDN value to be converted.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pValue A pointer to an 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CERT_RDN_VALUE_BLOB</a> of a type appropriate for the <i>dwValueType</i>.
     * @param {Pointer<PSTR>} psz A pointer to a buffer to receive the returned string.
     * @param {Integer} csz Size, in characters, allocated for the returned string. The size must include the terminating <b>NULL</b> character.
     * @returns {Integer} Returns the number of characters converted, including the terminating <b>NULL</b> character. If <i>psz</i> is <b>NULL</b> or <i>csz</i> is zero, returns the required size of the destination string.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certrdnvaluetostra
     * @since windows5.1.2600
     */
    static CertRDNValueToStrA(dwValueType, pValue, psz, csz) {
        result := DllCall("CRYPT32.dll\CertRDNValueToStrA", "uint", dwValueType, "ptr", pValue, "ptr", psz, "uint", csz, "uint")
        return result
    }

    /**
     * The CertRDNValueToStr function converts a name in a CERT_RDN_VALUE_BLOB to a null-terminated character string. (Unicode)
     * @remarks
     * If <i>psz</i> is not <b>NULL</b> and <i>csz</i> is not zero, the returned <i>psz</i> is always a possibly empty <b>null</b>-terminated string.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The wincrypt.h header defines CertRDNValueToStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} dwValueType Indicates the kind of RDN value to be converted.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pValue A pointer to an 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CERT_RDN_VALUE_BLOB</a> of a type appropriate for the <i>dwValueType</i>.
     * @param {Pointer<PWSTR>} psz A pointer to a buffer to receive the returned string.
     * @param {Integer} csz Size, in characters, allocated for the returned string. The size must include the terminating <b>NULL</b> character.
     * @returns {Integer} Returns the number of characters converted, including the terminating <b>NULL</b> character. If <i>psz</i> is <b>NULL</b> or <i>csz</i> is zero, returns the required size of the destination string.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certrdnvaluetostrw
     * @since windows5.1.2600
     */
    static CertRDNValueToStrW(dwValueType, pValue, psz, csz) {
        result := DllCall("CRYPT32.dll\CertRDNValueToStrW", "uint", dwValueType, "ptr", pValue, "ptr", psz, "uint", csz, "uint")
        return result
    }

    /**
     * Converts an encoded name in a CERT_NAME_BLOB structure to a null-terminated character string. (ANSI)
     * @remarks
     * If <i>psz</i> is not <b>NULL</b> and <i>csz</i> is not zero, the returned <i>psz</i> is always a null-terminated string.
     * 
     * We recommend against using multicomponent RDNs (e.g., CN=James+O=Microsoft) to avoid possible ordering problems when decoding occurs. Instead, consider using single valued RDNs (e.g., CN=James, O=Microsoft).  
     * 
     * The string representation follows the distinguished name specifications in <a href="https://www.ietf.org/rfc/rfc1779.txt">RFC 1779</a> except for the deviations described in the following list.
     * 
     * <ul>
     * <li>Names that contain quotes are enclosed within double quotation marks.</li>
     * <li>Empty strings are enclosed within double quotation marks.</li>
     * <li>Strings that contain consecutive spaces are not enclosed within quotation marks.</li>
     * <li>Relative Distinguished Name (RDN) values of type <b>CERT_RDN_ENCODED_BLOB</b> or <b>CERT_RDN_OCTET_STRING</b> are formatted in hexadecimal.</li>
     * <li>If an OID does not have a corresponding X.500 name, the “OID” prefix is used before OID.</li>
     * <li>RDN values are enclosed with double quotation marks (instead of "\") if they contain  leading white space, trailing white space, or one of the following characters:<ul>
     * <li>Comma (,)</li>
     * <li>Plus sign (+)</li>
     * <li>Equal sign (=)</li>
     * <li>Inch mark (")</li>
     * <li>Backslash (/)</li>
     * <li>Less than sign (&lt;)</li>
     * <li>Greater than sign (&gt;)</li>
     * <li>Number sign (#)</li>
     * <li>Semicolon (;)</li>
     * </ul>
     * </li>
     * <li>The X.500 key name  for stateOrProvinceName (2.5.4.8) OID is "S". This value is different from the RFC 1779 X.500 key name ("ST").</li>
     * </ul>
     * In addition, the following X.500 key names are not mentioned in RFC 1779, but may be returned by this API:
     * 
     * <table>
     * <tr>
     * <th>Key</th>
     * <th>Object identifier string</th>
     * </tr>
     * <tr>
     * <td>
     * E
     * 
     * </td>
     * <td>
     * 1.2.840.113549.1.9.1
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * T
     * 
     * </td>
     * <td>
     * 2.5.4.12
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * G
     * 
     * </td>
     * <td>
     * 2.5.4.42
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * I
     * 
     * </td>
     * <td>
     * 2.5.4.43
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SN
     * 
     * </td>
     * <td>
     * 2.5.4.4
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwCertEncodingType The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a>   that was used to encode the name. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> identifier, contained in the high <b>WORD</b> of this value, is ignored by this function.
     * 
     * 
     * This parameter can be the following currently defined certificate encoding type.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies X.509 certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pName A pointer to the 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CERT_NAME_BLOB</a> structure to be converted.
     * @param {Integer} dwStrType This parameter specifies the format of the output string. This parameter also specifies other options for the contents of the string.
     * @param {Pointer<PSTR>} psz A pointer to a character buffer that receives the returned string. The size of this buffer is specified in the <i>csz</i> parameter.
     * @param {Integer} csz The size, in characters, of the <i>psz</i> buffer. The size must include the terminating null character.
     * @returns {Integer} Returns the number of characters converted, including the terminating null character. 
     * 
     * If <i>psz</i> is <b>NULL</b> or <i>csz</i> is zero, returns the required size of the destination string.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certnametostra
     * @since windows5.1.2600
     */
    static CertNameToStrA(dwCertEncodingType, pName, dwStrType, psz, csz) {
        result := DllCall("CRYPT32.dll\CertNameToStrA", "uint", dwCertEncodingType, "ptr", pName, "uint", dwStrType, "ptr", psz, "uint", csz, "uint")
        return result
    }

    /**
     * Converts an encoded name in a CERT_NAME_BLOB structure to a null-terminated character string. (Unicode)
     * @remarks
     * If <i>psz</i> is not <b>NULL</b> and <i>csz</i> is not zero, the returned <i>psz</i> is always a null-terminated string.
     * 
     * We recommend against using multicomponent RDNs (e.g., CN=James+O=Microsoft) to avoid possible ordering problems when decoding occurs. Instead, consider using single valued RDNs (e.g., CN=James, O=Microsoft).  
     * 
     * The string representation follows the distinguished name specifications in <a href="https://www.ietf.org/rfc/rfc1779.txt">RFC 1779</a> except for the deviations described in the following list.
     * 
     * <ul>
     * <li>Names that contain quotes are enclosed within double quotation marks.</li>
     * <li>Empty strings are enclosed within double quotation marks.</li>
     * <li>Strings that contain consecutive spaces are not enclosed within quotation marks.</li>
     * <li>Relative Distinguished Name (RDN) values of type <b>CERT_RDN_ENCODED_BLOB</b> or <b>CERT_RDN_OCTET_STRING</b> are formatted in hexadecimal.</li>
     * <li>If an OID does not have a corresponding X.500 name, the “OID” prefix is used before OID.</li>
     * <li>RDN values are enclosed with double quotation marks (instead of "\") if they contain  leading white space, trailing white space, or one of the following characters:<ul>
     * <li>Comma (,)</li>
     * <li>Plus sign (+)</li>
     * <li>Equal sign (=)</li>
     * <li>Inch mark (")</li>
     * <li>Backslash (/)</li>
     * <li>Less than sign (&lt;)</li>
     * <li>Greater than sign (&gt;)</li>
     * <li>Number sign (#)</li>
     * <li>Semicolon (;)</li>
     * </ul>
     * </li>
     * <li>The X.500 key name  for stateOrProvinceName (2.5.4.8) OID is "S". This value is different from the RFC 1779 X.500 key name ("ST").</li>
     * </ul>
     * In addition, the following X.500 key names are not mentioned in RFC 1779, but may be returned by this API:
     * 
     * <table>
     * <tr>
     * <th>Key</th>
     * <th>Object identifier string</th>
     * </tr>
     * <tr>
     * <td>
     * E
     * 
     * </td>
     * <td>
     * 1.2.840.113549.1.9.1
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * T
     * 
     * </td>
     * <td>
     * 2.5.4.12
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * G
     * 
     * </td>
     * <td>
     * 2.5.4.42
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * I
     * 
     * </td>
     * <td>
     * 2.5.4.43
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SN
     * 
     * </td>
     * <td>
     * 2.5.4.4
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwCertEncodingType The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a>   that was used to encode the name. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> identifier, contained in the high <b>WORD</b> of this value, is ignored by this function.
     * 
     * 
     * This parameter can be the following currently defined certificate encoding type.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies X.509 certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pName A pointer to the 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CERT_NAME_BLOB</a> structure to be converted.
     * @param {Integer} dwStrType This parameter specifies the format of the output string. This parameter also specifies other options for the contents of the string.
     * @param {Pointer<PWSTR>} psz A pointer to a character buffer that receives the returned string. The size of this buffer is specified in the <i>csz</i> parameter.
     * @param {Integer} csz The size, in characters, of the <i>psz</i> buffer. The size must include the terminating null character.
     * @returns {Integer} Returns the number of characters converted, including the terminating null character. 
     * 
     * If <i>psz</i> is <b>NULL</b> or <i>csz</i> is zero, returns the required size of the destination string.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certnametostrw
     * @since windows5.1.2600
     */
    static CertNameToStrW(dwCertEncodingType, pName, dwStrType, psz, csz) {
        result := DllCall("CRYPT32.dll\CertNameToStrW", "uint", dwCertEncodingType, "ptr", pName, "uint", dwStrType, "ptr", psz, "uint", csz, "uint")
        return result
    }

    /**
     * Converts a null-terminated X.500 string to an encoded certificate name. (ANSI)
     * @remarks
     * The following table contains the supported X.500 keys, their corresponding object identifier string, string identifier (from Wincrypt.h), and value types.
     * 
     * <table>
     * <tr>
     * <th>Key</th>
     * <th>Object identifier string</th>
     * <th>String identifier</th>
     * <th>RDN value types</th>
     * </tr>
     * <tr>
     * <td>
     * CN
     * 
     * </td>
     * <td>
     * 2.5.4.3
     * 
     * </td>
     * <td>
     * szOID_COMMON_NAME
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * L
     * 
     * </td>
     * <td>
     * 2.5.4.7
     * 
     * </td>
     * <td>
     * szOID_LOCALITY_NAME
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * O
     * 
     * </td>
     * <td>
     * 2.5.4.10
     * 
     * </td>
     * <td>
     * szOID_ORGANIZATION_NAME
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * OU
     * 
     * </td>
     * <td>
     * 2.5.4.11
     * 
     * </td>
     * <td>
     * szOID_ORGANIZATIONAL_UNIT_NAME
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * E
     * 
     * Email
     * 
     * </td>
     * <td>
     * 1.2.840.113549.1.9.1
     * 
     * </td>
     * <td>
     * szOID_RSA_emailAddr
     * 
     * </td>
     * <td>
     * IA5
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * C
     * 
     * </td>
     * <td>
     * 2.5.4.6
     * 
     * </td>
     * <td>
     * szOID_COUNTRY_NAME
     * 
     * </td>
     * <td>
     * Printable
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * S
     * 
     * ST
     * 
     * </td>
     * <td>
     * 2.5.4.8
     * 
     * </td>
     * <td>
     * szOID_STATE_OR_PROVINCE_NAME
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * STREET
     * 
     * </td>
     * <td>
     * 2.5.4.9
     * 
     * </td>
     * <td>
     * szOID_STREET_ADDRESS
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * T
     * 
     * Title
     * 
     * </td>
     * <td>
     * 2.5.4.12
     * 
     * </td>
     * <td>
     * szOID_TITLE
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * G
     * 
     * GivenName
     * 
     * </td>
     * <td>
     * 2.5.4.42
     * 
     * </td>
     * <td>
     * szOID_GIVEN_NAME
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * I
     * 
     * Initials
     * 
     * </td>
     * <td>
     * 2.5.4.43
     * 
     * </td>
     * <td>
     * szOID_INITIALS
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SN
     * 
     * </td>
     * <td>
     * 2.5.4.4
     * 
     * </td>
     * <td>
     * szOID_SUR_NAME
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DC
     * 
     * </td>
     * <td>
     * 0.9.2342.19200300.100.1.25
     * 
     * </td>
     * <td>
     * szOID_DOMAIN_COMPONENT
     * 
     * </td>
     * <td>
     * IA5
     * 
     * UTF8
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * If either Printable or T61 is allowed as the RDN value type for the key, Printable is automatically selected if the name string component is a member of the following character sets:
     * 
     * <ul>
     * <li>A, B, …, Z</li>
     * <li>a, b, …, z</li>
     * <li>0, 1, …, 9</li>
     * <li>(space) ' ( ) + , - . / : = ?</li>
     * </ul>
     * 
     * 
     * The T61 types are UTF8 encoded.
     * @param {Integer} dwCertEncodingType The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a>   that was used to encode the string. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> identifier, contained in the high <b>WORD</b> of this value, is ignored by this function.
     * 
     * 
     * This parameter can be the following currently defined certificate encoding type.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies <a href="https://docs.microsoft.com/windows/desktop/SecGloss/x-gly">X.509</a> certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PSTR>} pszX500 A pointer to the null-terminated X.500 string to be converted. The format of this string is specified by the <i>dwStrType</i> parameter.
     * 
     * This string is expected to be formatted the same as the output from 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certnametostra">CertNameToStr</a> function.
     * @param {Integer} dwStrType This parameter specifies the type of the string. This parameter also specifies other options for the contents of the string. 
     * 
     * If no flags are combined with the string type specifier, the string can contain a comma (,) or a semicolon (;) as separators in the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">relative distinguished name</a> (RDN) and a plus sign (+) as the separator in multiple RDN values.
     * 
     * Quotation marks ("") are supported. A quotation can be included in a quoted value by using two sets of quotation marks, for example, CN="User ""one""". 
     * 
     * A value that starts with a number sign (#) is treated as <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">ASCII</a> hexadecimal and converted to a <b>CERT_RDN_OCTET_STRING</b>. Embedded white space is ignored. For example, 1.2.3 = # AB CD 01 is the same as 1.2.3=#ABCD01.
     * 
     * White space that surrounds the keys, object identifiers, and values is ignored.
     * @param {Pointer<Byte>} pbEncoded A pointer to a buffer that receives the encoded structure. 
     * 
     * 
     * The size of this buffer is specified in the <i>pcbEncoded</i> parameter.
     * 
     * This parameter can be <b>NULL</b> to obtain the required size of the buffer for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbEncoded A pointer to a <b>DWORD</b> that, before calling the function, contains the size, in bytes, of the buffer pointed to by the <i>pbEncoded</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer.
     * 
     * If <i>pbEncoded</i> is <b>NULL</b>, the <b>DWORD</b> receives the size, in bytes, required for the buffer.
     * @param {Pointer<PSTR>} ppszError A pointer to a string pointer that receives additional error information about an input string that is not valid. 
     * 
     * 
     * If the <i>pszX500</i> string is not valid, <i>ppszError</i> is updated by this function to point to the beginning of the character sequence that is not valid. If no errors are detected in the input string, <i>ppszError</i> is set to <b>NULL</b>.
     * 						
     * 
     * If this information is not required, pass <b>NULL</b> for this parameter.
     * 
     * 
     * This parameter is updated for the following error codes returned from <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * <a id="CRYPT_E_INVALID_X500_STRING"></a>
     * <a id="crypt_e_invalid_x500_string"></a>
     * @returns {Integer} Returns nonzero if successful or zero otherwise.
     * 						
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certstrtonamea
     * @since windows5.1.2600
     */
    static CertStrToNameA(dwCertEncodingType, pszX500, dwStrType, pbEncoded, pcbEncoded, ppszError) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertStrToNameA", "uint", dwCertEncodingType, "ptr", pszX500, "uint", dwStrType, "ptr", pvReserved, "ptr", pbEncoded, "ptr", pcbEncoded, "ptr", ppszError, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts a null-terminated X.500 string to an encoded certificate name. (Unicode)
     * @remarks
     * The following table contains the supported X.500 keys, their corresponding object identifier string, string identifier (from Wincrypt.h), and value types.
     * 
     * <table>
     * <tr>
     * <th>Key</th>
     * <th>Object identifier string</th>
     * <th>String identifier</th>
     * <th>RDN value types</th>
     * </tr>
     * <tr>
     * <td>
     * CN
     * 
     * </td>
     * <td>
     * 2.5.4.3
     * 
     * </td>
     * <td>
     * szOID_COMMON_NAME
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * L
     * 
     * </td>
     * <td>
     * 2.5.4.7
     * 
     * </td>
     * <td>
     * szOID_LOCALITY_NAME
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * O
     * 
     * </td>
     * <td>
     * 2.5.4.10
     * 
     * </td>
     * <td>
     * szOID_ORGANIZATION_NAME
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * OU
     * 
     * </td>
     * <td>
     * 2.5.4.11
     * 
     * </td>
     * <td>
     * szOID_ORGANIZATIONAL_UNIT_NAME
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * E
     * 
     * Email
     * 
     * </td>
     * <td>
     * 1.2.840.113549.1.9.1
     * 
     * </td>
     * <td>
     * szOID_RSA_emailAddr
     * 
     * </td>
     * <td>
     * IA5
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * C
     * 
     * </td>
     * <td>
     * 2.5.4.6
     * 
     * </td>
     * <td>
     * szOID_COUNTRY_NAME
     * 
     * </td>
     * <td>
     * Printable
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * S
     * 
     * ST
     * 
     * </td>
     * <td>
     * 2.5.4.8
     * 
     * </td>
     * <td>
     * szOID_STATE_OR_PROVINCE_NAME
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * STREET
     * 
     * </td>
     * <td>
     * 2.5.4.9
     * 
     * </td>
     * <td>
     * szOID_STREET_ADDRESS
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * T
     * 
     * Title
     * 
     * </td>
     * <td>
     * 2.5.4.12
     * 
     * </td>
     * <td>
     * szOID_TITLE
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * G
     * 
     * GivenName
     * 
     * </td>
     * <td>
     * 2.5.4.42
     * 
     * </td>
     * <td>
     * szOID_GIVEN_NAME
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * I
     * 
     * Initials
     * 
     * </td>
     * <td>
     * 2.5.4.43
     * 
     * </td>
     * <td>
     * szOID_INITIALS
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SN
     * 
     * </td>
     * <td>
     * 2.5.4.4
     * 
     * </td>
     * <td>
     * szOID_SUR_NAME
     * 
     * </td>
     * <td>
     * Printable
     * 
     * T61
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * DC
     * 
     * </td>
     * <td>
     * 0.9.2342.19200300.100.1.25
     * 
     * </td>
     * <td>
     * szOID_DOMAIN_COMPONENT
     * 
     * </td>
     * <td>
     * IA5
     * 
     * UTF8
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * If either Printable or T61 is allowed as the RDN value type for the key, Printable is automatically selected if the name string component is a member of the following character sets:
     * 
     * <ul>
     * <li>A, B, …, Z</li>
     * <li>a, b, …, z</li>
     * <li>0, 1, …, 9</li>
     * <li>(space) ' ( ) + , - . / : = ?</li>
     * </ul>
     * 
     * 
     * The T61 types are UTF8 encoded.
     * @param {Integer} dwCertEncodingType The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a>   that was used to encode the string. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> identifier, contained in the high <b>WORD</b> of this value, is ignored by this function.
     * 
     * 
     * This parameter can be the following currently defined certificate encoding type.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies <a href="https://docs.microsoft.com/windows/desktop/SecGloss/x-gly">X.509</a> certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} pszX500 A pointer to the null-terminated X.500 string to be converted. The format of this string is specified by the <i>dwStrType</i> parameter.
     * 
     * This string is expected to be formatted the same as the output from 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certnametostra">CertNameToStr</a> function.
     * @param {Integer} dwStrType This parameter specifies the type of the string. This parameter also specifies other options for the contents of the string. 
     * 
     * If no flags are combined with the string type specifier, the string can contain a comma (,) or a semicolon (;) as separators in the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">relative distinguished name</a> (RDN) and a plus sign (+) as the separator in multiple RDN values.
     * 
     * Quotation marks ("") are supported. A quotation can be included in a quoted value by using two sets of quotation marks, for example, CN="User ""one""". 
     * 
     * A value that starts with a number sign (#) is treated as <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">ASCII</a> hexadecimal and converted to a <b>CERT_RDN_OCTET_STRING</b>. Embedded white space is ignored. For example, 1.2.3 = # AB CD 01 is the same as 1.2.3=#ABCD01.
     * 
     * White space that surrounds the keys, object identifiers, and values is ignored.
     * @param {Pointer<Byte>} pbEncoded A pointer to a buffer that receives the encoded structure. 
     * 
     * 
     * The size of this buffer is specified in the <i>pcbEncoded</i> parameter.
     * 
     * This parameter can be <b>NULL</b> to obtain the required size of the buffer for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbEncoded A pointer to a <b>DWORD</b> that, before calling the function, contains the size, in bytes, of the buffer pointed to by the <i>pbEncoded</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer.
     * 
     * If <i>pbEncoded</i> is <b>NULL</b>, the <b>DWORD</b> receives the size, in bytes, required for the buffer.
     * @param {Pointer<PWSTR>} ppszError A pointer to a string pointer that receives additional error information about an input string that is not valid. 
     * 
     * 
     * If the <i>pszX500</i> string is not valid, <i>ppszError</i> is updated by this function to point to the beginning of the character sequence that is not valid. If no errors are detected in the input string, <i>ppszError</i> is set to <b>NULL</b>.
     * 						
     * 
     * If this information is not required, pass <b>NULL</b> for this parameter.
     * 
     * 
     * This parameter is updated for the following error codes returned from <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * <a id="CRYPT_E_INVALID_X500_STRING"></a>
     * <a id="crypt_e_invalid_x500_string"></a>
     * @returns {Integer} Returns nonzero if successful or zero otherwise.
     * 						
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certstrtonamew
     * @since windows5.1.2600
     */
    static CertStrToNameW(dwCertEncodingType, pszX500, dwStrType, pbEncoded, pcbEncoded, ppszError) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertStrToNameW", "uint", dwCertEncodingType, "ptr", pszX500, "uint", dwStrType, "ptr", pvReserved, "ptr", pbEncoded, "ptr", pcbEncoded, "ptr", ppszError, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Obtains the subject or issuer name from a certificate CERT_CONTEXT structure and converts it to a null-terminated character string. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The wincrypt.h header defines CertGetNameString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> certificate context that includes a subject and issuer name to be converted.
     * @param {Integer} dwType <b>DWORD</b> indicating how the name is to be found and how the output is to be formatted.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_EMAIL_TYPE"></a><a id="cert_name_email_type"></a><dl>
     * <dt><b>CERT_NAME_EMAIL_TYPE</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate has a Subject Alternative Name extension or Issuer Alternative Name, uses the first rfc822Name choice. If no rfc822Name choice is found in the extension, uses the Subject Name field for the Email OID. If either rfc822Name or the Email OID is found, uses the string. Otherwise, returns an empty string (returned character count is 1). <i>pvTypePara</i> is not used and is set to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_RDN_TYPE"></a><a id="cert_name_rdn_type"></a><dl>
     * <dt><b>CERT_NAME_RDN_TYPE</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Converts the Subject Name BLOB by calling <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certnametostra">CertNameToStr</a>. <i>pvTypePara</i> points to a <b>DWORD</b> containing the <i>dwStrType</i> passed to <b>CertNameToStr</b>. If the Subject Name field is empty and the certificate has a Subject Alternative Name extension, uses the first directory Name choice from <b>CertNameToStr</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_ATTR_TYPE"></a><a id="cert_name_attr_type"></a><dl>
     * <dt><b>CERT_NAME_ATTR_TYPE</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvTypePara</i> points to an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) specifying the name attribute to be returned. For example, if <i>pvTypePara</i> is szOID_COMMON_NAME, uses the Subject Name member. If the Subject Name member is empty and the certificate has a Subject Alternative Name extension, uses the first directoryName choice.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_SIMPLE_DISPLAY_TYPE"></a><a id="cert_name_simple_display_type"></a><dl>
     * <dt><b>CERT_NAME_SIMPLE_DISPLAY_TYPE</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Iterates through the following list of name attributes and uses the Subject Name or the Subject Alternative Name extension for the first occurrence of: szOID_COMMON_NAME, szOID_ORGANIZATIONAL_UNIT_NAME, szOID_ORGANIZATION_NAME, or szOID_RSA_emailAddr. 
     * 
     * 
     * 
     * 
     * If one of these attributes is not found, uses the Subject Alternative Name extension for a rfc822Name choice. If there is still no match, uses the first attribute.
     * 
     * <i>pvTypePara</i> is not used and is set to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_FRIENDLY_DISPLAY_TYPE"></a><a id="cert_name_friendly_display_type"></a><dl>
     * <dt><b>CERT_NAME_FRIENDLY_DISPLAY_TYPE</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Checks the certificate for a CERT_FRIENDLY_NAME_PROP_ID property. If the certificate has this property, it is returned. If the certificate does not have the property, the CERT_NAME_SIMPLE_DISPLAY_TYPE is returned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_DNS_TYPE"></a><a id="cert_name_dns_type"></a><dl>
     * <dt><b>CERT_NAME_DNS_TYPE</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate has a Subject Alternative Name extension for issuer, Issuer Alternative Name, search for first DNSName choice. 
     * 
     * 
     * 
     * 
     * If the DNSName choice is not found in the extension, search the Subject Name field for the CN OID, "2.5.4.3".
     * 
     * If the DNSName or CN OID is found, return the string. Otherwise, return an empty string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_URL_TYPE"></a><a id="cert_name_url_type"></a><dl>
     * <dt><b>CERT_NAME_URL_TYPE</b></dt>
     * <dt>7</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate has a Subject Alternative Name extension for issuer, Issuer Alternative Name, search for first URL choice. If the URL choice is found, return the string. Otherwise, return an empty string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_UPN_TYPE"></a><a id="cert_name_upn_type"></a><dl>
     * <dt><b>CERT_NAME_UPN_TYPE</b></dt>
     * <dt>8</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate has a Subject Alternative Name extension, search the OtherName choices looking for a pszObjId == szOID_NT_PRINCIPAL_NAME, ("1.3.6.1.4.1.311.20.2.3"). 
     * 
     * 
     * 
     * 
     * If the UPN OID is found, decode the BLOB as a X509_UNICODE_ANY_STRING and return the decoded string. Otherwise, return an empty string.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags Indicates the type of processing needed. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_ISSUER_FLAG"></a><a id="cert_name_issuer_flag"></a><dl>
     * <dt><b>CERT_NAME_ISSUER_FLAG</b></dt>
     * <dt>0x1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Acquires the issuer's name. If not set, acquires the subject's name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_DISABLE_IE4_UTF8_FLAG"></a><a id="cert_name_disable_ie4_utf8_flag"></a><dl>
     * <dt><b>CERT_NAME_DISABLE_IE4_UTF8_FLAG</b></dt>
     * <dt>0x00010000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Skips the default initial attempt to decode the value as UTF8 and decodes as 8-bit characters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_SEARCH_ALL_NAMES_FLAG"></a><a id="cert_name_search_all_names_flag"></a><dl>
     * <dt><b>CERT_NAME_SEARCH_ALL_NAMES_FLAG</b></dt>
     * <dt>0x2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the <i>dwType</i> parameter is set to <b>CERT_NAME_DNS_TYPE</b>, all applicable names are returned for the specified DNS value. If there is no DNS name but there is a CN component in the subject, the CN is returned instead. If there is a CN and a DNS name, only the DNS names are returned. This mimics the SSL chain building policy. If you set this flag for a name type other than <b>CERT_NAME_DNS_TYPE</b>, this function returns a null-terminated empty string.
     * 
     * <b>Windows 8 and Windows Server 2012:  </b>Support for this flag begins.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_STR_ENABLE_PUNYCODE_FLAG"></a><a id="cert_name_str_enable_punycode_flag"></a><dl>
     * <dt><b>CERT_NAME_STR_ENABLE_PUNYCODE_FLAG</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag enables decoding of  <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> strings to Unicode string values based on the <i>dwType</i> parameter value as defined below:
     * 
     * <ul>
     * <li>CERT_NAME_EMAIL_TYPE: If the host name portion of the email address contains a Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> component, it is converted to the Unicode equivalent.</li>
     * <li>CERT_NAME_SIMPLE_DISPLAY_TYPE: If a Subject Name of szOID_RSA_emailAddr or the rfc822Name from the Subject Alternative Name is returned from the certificate, and the host name portion of the email address a contains Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> component, it is converted to the Unicode equivalent.</li>
     * <li>CERT_NAME_DNS_TYPE: If the certificate has an Issuer Alternative Name, with a DNSName choice, and the host name portion of the email address a contains Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> component, it is converted to the Unicode equivalent.</li>
     * <li>CERT_NAME_URL_TYPE: The URI is decoded and unescaped. If the server host name of the URI contains a Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> component, the host name string is converted to the Unicode equivalent.</li>
     * </ul>
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvTypePara A pointer to either a <b>DWORD</b> containing the <i>dwStrType</i> or an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) specifying the name attribute. The type pointed to is determined by the value of <i>dwType</i>.
     * @param {Pointer<PSTR>} pszNameString A pointer to an allocated buffer to receive the returned string. If <i>pszNameString</i> is not <b>NULL</b> and <i>cchNameString</i> is not zero, <i>pszNameString</i> is a <b>null</b>-terminated string.
     * 
     * If <b>CERT_NAME_SEARCH_ALL_NAMES_FLAG</b> is specified in the <i>dwFlags</i> parameter and <b>CERT_NAME_DNS_TYPE</b> is set in the <i>dwType</i> parameter, the returned string will contain all of the DNS names that apply. Each string in the output string is null-terminated and the last string will be double null-terminated. If no DNS names are found, a single null-terminated empty string is returned.
     * @param {Integer} cchNameString Size, in characters, allocated for the returned string. The size must include the terminating <b>NULL</b> character.
     * @returns {Integer} Returns the number of characters converted, including the terminating zero character. If <i>pszNameString</i> is <b>NULL</b> or <i>cchNameString</i> is zero, returns the required size of the destination string (including the terminating <b>NULL</b> character). If the specified name type is not found, returns a <b>null</b>-terminated empty string with a returned character count of 1.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certgetnamestringa
     * @since windows5.1.2600
     */
    static CertGetNameStringA(pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString) {
        result := DllCall("CRYPT32.dll\CertGetNameStringA", "ptr", pCertContext, "uint", dwType, "uint", dwFlags, "ptr", pvTypePara, "ptr", pszNameString, "uint", cchNameString, "uint")
        return result
    }

    /**
     * Obtains the subject or issuer name from a certificate CERT_CONTEXT structure and converts it to a null-terminated character string. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The wincrypt.h header defines CertGetNameString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> certificate context that includes a subject and issuer name to be converted.
     * @param {Integer} dwType <b>DWORD</b> indicating how the name is to be found and how the output is to be formatted.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_EMAIL_TYPE"></a><a id="cert_name_email_type"></a><dl>
     * <dt><b>CERT_NAME_EMAIL_TYPE</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate has a Subject Alternative Name extension or Issuer Alternative Name, uses the first rfc822Name choice. If no rfc822Name choice is found in the extension, uses the Subject Name field for the Email OID. If either rfc822Name or the Email OID is found, uses the string. Otherwise, returns an empty string (returned character count is 1). <i>pvTypePara</i> is not used and is set to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_RDN_TYPE"></a><a id="cert_name_rdn_type"></a><dl>
     * <dt><b>CERT_NAME_RDN_TYPE</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Converts the Subject Name BLOB by calling <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certnametostra">CertNameToStr</a>. <i>pvTypePara</i> points to a <b>DWORD</b> containing the <i>dwStrType</i> passed to <b>CertNameToStr</b>. If the Subject Name field is empty and the certificate has a Subject Alternative Name extension, uses the first directory Name choice from <b>CertNameToStr</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_ATTR_TYPE"></a><a id="cert_name_attr_type"></a><dl>
     * <dt><b>CERT_NAME_ATTR_TYPE</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pvTypePara</i> points to an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) specifying the name attribute to be returned. For example, if <i>pvTypePara</i> is szOID_COMMON_NAME, uses the Subject Name member. If the Subject Name member is empty and the certificate has a Subject Alternative Name extension, uses the first directoryName choice.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_SIMPLE_DISPLAY_TYPE"></a><a id="cert_name_simple_display_type"></a><dl>
     * <dt><b>CERT_NAME_SIMPLE_DISPLAY_TYPE</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Iterates through the following list of name attributes and uses the Subject Name or the Subject Alternative Name extension for the first occurrence of: szOID_COMMON_NAME, szOID_ORGANIZATIONAL_UNIT_NAME, szOID_ORGANIZATION_NAME, or szOID_RSA_emailAddr. 
     * 
     * 
     * 
     * 
     * If one of these attributes is not found, uses the Subject Alternative Name extension for a rfc822Name choice. If there is still no match, uses the first attribute.
     * 
     * <i>pvTypePara</i> is not used and is set to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_FRIENDLY_DISPLAY_TYPE"></a><a id="cert_name_friendly_display_type"></a><dl>
     * <dt><b>CERT_NAME_FRIENDLY_DISPLAY_TYPE</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Checks the certificate for a CERT_FRIENDLY_NAME_PROP_ID property. If the certificate has this property, it is returned. If the certificate does not have the property, the CERT_NAME_SIMPLE_DISPLAY_TYPE is returned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_DNS_TYPE"></a><a id="cert_name_dns_type"></a><dl>
     * <dt><b>CERT_NAME_DNS_TYPE</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate has a Subject Alternative Name extension for issuer, Issuer Alternative Name, search for first DNSName choice. 
     * 
     * 
     * 
     * 
     * If the DNSName choice is not found in the extension, search the Subject Name field for the CN OID, "2.5.4.3".
     * 
     * If the DNSName or CN OID is found, return the string. Otherwise, return an empty string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_URL_TYPE"></a><a id="cert_name_url_type"></a><dl>
     * <dt><b>CERT_NAME_URL_TYPE</b></dt>
     * <dt>7</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate has a Subject Alternative Name extension for issuer, Issuer Alternative Name, search for first URL choice. If the URL choice is found, return the string. Otherwise, return an empty string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_UPN_TYPE"></a><a id="cert_name_upn_type"></a><dl>
     * <dt><b>CERT_NAME_UPN_TYPE</b></dt>
     * <dt>8</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the certificate has a Subject Alternative Name extension, search the OtherName choices looking for a pszObjId == szOID_NT_PRINCIPAL_NAME, ("1.3.6.1.4.1.311.20.2.3"). 
     * 
     * 
     * 
     * 
     * If the UPN OID is found, decode the BLOB as a X509_UNICODE_ANY_STRING and return the decoded string. Otherwise, return an empty string.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFlags Indicates the type of processing needed. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_ISSUER_FLAG"></a><a id="cert_name_issuer_flag"></a><dl>
     * <dt><b>CERT_NAME_ISSUER_FLAG</b></dt>
     * <dt>0x1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Acquires the issuer's name. If not set, acquires the subject's name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_DISABLE_IE4_UTF8_FLAG"></a><a id="cert_name_disable_ie4_utf8_flag"></a><dl>
     * <dt><b>CERT_NAME_DISABLE_IE4_UTF8_FLAG</b></dt>
     * <dt>0x00010000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Skips the default initial attempt to decode the value as UTF8 and decodes as 8-bit characters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_SEARCH_ALL_NAMES_FLAG"></a><a id="cert_name_search_all_names_flag"></a><dl>
     * <dt><b>CERT_NAME_SEARCH_ALL_NAMES_FLAG</b></dt>
     * <dt>0x2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the <i>dwType</i> parameter is set to <b>CERT_NAME_DNS_TYPE</b>, all applicable names are returned for the specified DNS value. If there is no DNS name but there is a CN component in the subject, the CN is returned instead. If there is a CN and a DNS name, only the DNS names are returned. This mimics the SSL chain building policy. If you set this flag for a name type other than <b>CERT_NAME_DNS_TYPE</b>, this function returns a null-terminated empty string.
     * 
     * <b>Windows 8 and Windows Server 2012:  </b>Support for this flag begins.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_NAME_STR_ENABLE_PUNYCODE_FLAG"></a><a id="cert_name_str_enable_punycode_flag"></a><dl>
     * <dt><b>CERT_NAME_STR_ENABLE_PUNYCODE_FLAG</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag enables decoding of  <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> strings to Unicode string values based on the <i>dwType</i> parameter value as defined below:
     * 
     * <ul>
     * <li>CERT_NAME_EMAIL_TYPE: If the host name portion of the email address contains a Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> component, it is converted to the Unicode equivalent.</li>
     * <li>CERT_NAME_SIMPLE_DISPLAY_TYPE: If a Subject Name of szOID_RSA_emailAddr or the rfc822Name from the Subject Alternative Name is returned from the certificate, and the host name portion of the email address a contains Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> component, it is converted to the Unicode equivalent.</li>
     * <li>CERT_NAME_DNS_TYPE: If the certificate has an Issuer Alternative Name, with a DNSName choice, and the host name portion of the email address a contains Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> component, it is converted to the Unicode equivalent.</li>
     * <li>CERT_NAME_URL_TYPE: The URI is decoded and unescaped. If the server host name of the URI contains a Punycode encoded <a href="https://docs.microsoft.com/windows/desktop/SecCertEnroll/about-ia5string">IA5String</a> component, the host name string is converted to the Unicode equivalent.</li>
     * </ul>
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvTypePara A pointer to either a <b>DWORD</b> containing the <i>dwStrType</i> or an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) specifying the name attribute. The type pointed to is determined by the value of <i>dwType</i>.
     * @param {Pointer<PWSTR>} pszNameString A pointer to an allocated buffer to receive the returned string. If <i>pszNameString</i> is not <b>NULL</b> and <i>cchNameString</i> is not zero, <i>pszNameString</i> is a <b>null</b>-terminated string.
     * 
     * If <b>CERT_NAME_SEARCH_ALL_NAMES_FLAG</b> is specified in the <i>dwFlags</i> parameter and <b>CERT_NAME_DNS_TYPE</b> is set in the <i>dwType</i> parameter, the returned string will contain all of the DNS names that apply. Each string in the output string is null-terminated and the last string will be double null-terminated. If no DNS names are found, a single null-terminated empty string is returned.
     * @param {Integer} cchNameString Size, in characters, allocated for the returned string. The size must include the terminating <b>NULL</b> character.
     * @returns {Integer} Returns the number of characters converted, including the terminating zero character. If <i>pszNameString</i> is <b>NULL</b> or <i>cchNameString</i> is zero, returns the required size of the destination string (including the terminating <b>NULL</b> character). If the specified name type is not found, returns a <b>null</b>-terminated empty string with a returned character count of 1.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certgetnamestringw
     * @since windows5.1.2600
     */
    static CertGetNameStringW(pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString) {
        result := DllCall("CRYPT32.dll\CertGetNameStringW", "ptr", pCertContext, "uint", dwType, "uint", dwFlags, "ptr", pvTypePara, "ptr", pszNameString, "uint", cchNameString, "uint")
        return result
    }

    /**
     * The CryptSignMessage function creates a hash of the specified content, signs the hash, and then encodes both the original message content and the signed hash.
     * @param {Pointer<CRYPT_SIGN_MESSAGE_PARA>} pSignPara A pointer to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_sign_message_para">CRYPT_SIGN_MESSAGE_PARA</a> structure containing the signature parameters.
     * @param {Integer} fDetachedSignature <b>TRUE</b> if this is to be a detached signature. Otherwise, <b>FALSE</b>. If this parameter is set to <b>TRUE</b>, only the signed hash is encoded in <i>pbSignedBlob</i>. Otherwise, both <i>rgpbToBeSigned</i> and the signed hash are encoded.
     * @param {Integer} cToBeSigned Count of the number of array elements in <i>rgpbToBeSigned</i> and <i>rgcbToBeSigned</i>. This parameter must be set to one unless <i>fDetachedSignature</i> is set to <b>TRUE</b>.
     * @param {Pointer<Byte>} rgpbToBeSigned Array of pointers to buffers that contain the contents to be signed.
     * @param {Pointer<UInt32>} rgcbToBeSigned Array of sizes, in bytes, of the content buffers pointed to in <i>rgpbToBeSigned</i>.
     * @param {Pointer<Byte>} pbSignedBlob A pointer to a buffer to receive the encoded signed hash, if <i>fDetachedSignature</i> is <b>TRUE</b>, or to both the encoded content and signed hash if <i>fDetachedSignature</i> is <b>FALSE</b>. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbSignedBlob A pointer to a <b>DWORD</b> specifying the size, in bytes, of the <i>pbSignedBlob</i> buffer. When the function returns, this variable contains the size, in bytes, of the signed and encoded message. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * The following lists the error codes most commonly returned by the 
     * 		       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbSignedBlob</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbSignedBlob</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> is not valid. Currently only PKCS_7_ASN_ENCODING is supported. The <b>cbSize</b> in *<i>pSignPara</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_KEY_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pSigningCert</i> in *<i>pSignPara</i> does not have a CERT_KEY_PROV_INFO_PROP_ID or CERT_KEY_CONTEXT_PROP_ID property.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha">CryptSignHash</a> might be propagated to this function.</div>
     * <div> </div>
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptsignmessage
     * @since windows5.1.2600
     */
    static CryptSignMessage(pSignPara, fDetachedSignature, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, pbSignedBlob, pcbSignedBlob) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptSignMessage", "ptr", pSignPara, "int", fDetachedSignature, "uint", cToBeSigned, "ptr", rgpbToBeSigned, "ptr", rgcbToBeSigned, "ptr", pbSignedBlob, "ptr", pcbSignedBlob, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Verifies a signed message's signature.
     * @remarks
     * For a verified signer and message, <i>ppSignerCert</i> is updated with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> of the signer. It must be freed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a>. Otherwise, <i>ppSignerCert</i> is set to <b>NULL</b>.
     * 
     * For a message that contains only certificates and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">CRLs</a>, <i>pcbDecoded</i> is set to <b>NULL</b>.
     * @param {Pointer<CRYPT_VERIFY_MESSAGE_PARA>} pVerifyPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_verify_message_para">CRYPT_VERIFY_MESSAGE_PARA</a> structure that contains verification parameters.
     * @param {Integer} dwSignerIndex The index of the desired signature. There can be more than one signature. <b>CryptVerifyMessageSignature</b> can be called repeatedly, incrementing <i>dwSignerIndex</i> each time. Set this parameter to zero for the first signer, or if there is only one signer. If the function returns <b>FALSE</b>, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns CRYPT_E_NO_SIGNER, the previous call processed the last signer of the message.
     * @param {Pointer<Byte>} pbSignedBlob A pointer to a buffer that contains the signed message.
     * @param {Integer} cbSignedBlob The size, in bytes, of the signed message buffer.
     * @param {Pointer<Byte>} pbDecoded A pointer to a buffer to receive the decoded message. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the decoded message is not needed for additional processing or to set the size of the message for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbDecoded A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the <i>pbDecoded</i> buffer. When the function returns, this <b>DWORD</b> contains the size, in bytes, of the decoded message. The decoded message will not be returned if this parameter is <b>NULL</b>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @param {Pointer<CERT_CONTEXT>} ppSignerCert The address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure pointer that receives the certificate of the signer. When you have finished using this structure, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function. This parameter can be <b>NULL</b> if the signer's certificate is not needed.
     * @returns {Integer} If the function succeeds, the function returns nonzero. This does not necessarily mean that the signature was verified. In the case of a detached message, the variable pointed to by <i>pcbDecoded</i> will contain zero. In this case, this function will return nonzero, but the signature is not verified. To verify the signature of a detached message, use the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifydetachedmessagesignature">CryptVerifyDetachedMessageSignature</a> function.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table shows the error codes most commonly returned by the 
     * 		       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbDecoded</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbDecoded</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid message and certificate encoding types. Currently only PKCS_7_ASN_ENCODING and X509_ASN_ENCODING_TYPE are supported. Invalid <b>cbSize</b> in *<i>pVerifyPara</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not a signed cryptographic message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_SIGNER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message does not have any signers or a signer for the specified <i>dwSignerIndex</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message was hashed and signed by using an unknown or unsupported algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message's signature was not verified.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea">CryptVerifySignature</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a> can be propagated to this function. <p class="note">If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>. 
     * 
     * </div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptverifymessagesignature
     * @since windows5.1.2600
     */
    static CryptVerifyMessageSignature(pVerifyPara, dwSignerIndex, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded, ppSignerCert) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptVerifyMessageSignature", "ptr", pVerifyPara, "uint", dwSignerIndex, "ptr", pbSignedBlob, "uint", cbSignedBlob, "ptr", pbDecoded, "ptr", pcbDecoded, "ptr", ppSignerCert, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptGetMessageSignerCount function returns the number of signers of a signed message.
     * @param {Integer} dwMsgEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<Byte>} pbSignedBlob A pointer to a buffer containing the signed message.
     * @param {Integer} cbSignedBlob The size, in bytes, of the signed message.
     * @returns {Integer} Returns the number of signers of a signed message, zero when there are no signers, and minus one (–1) for an error.
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following  error code is most commonly returned.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a>. Currently only PKCS_7_ASN_ENCODING is supported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptgetmessagesignercount
     * @since windows5.1.2600
     */
    static CryptGetMessageSignerCount(dwMsgEncodingType, pbSignedBlob, cbSignedBlob) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptGetMessageSignerCount", "uint", dwMsgEncodingType, "ptr", pbSignedBlob, "uint", cbSignedBlob, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptGetMessageCertificates function returns the handle of an open certificate store containing the message's certificates and CRLs. This function calls CertOpenStore using provider type CERT_STORE_PROV_PKCS7 as its lpszStoreProvider parameter.
     * @remarks
     * Use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to determine the reason for any errors.
     * @param {Integer} dwMsgAndCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer} hCryptProv This parameter is not used and should be set to <b>NULL</b>.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>Handle of the CSP passed to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenstore">CertOpenStore</a>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenstore">CertOpenStore</a>.Unless there is a strong reason for passing a specific cryptographic provider in <i>hCryptProv</i>, pass zero to cause the default RSA or DSS provider to be acquired.
     * 
     * This parameter's data type is <b>HCRYPTPROV</b>.
     * @param {Integer} dwFlags Flags passed to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenstore">CertOpenStore</a>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenstore">CertOpenStore</a>.
     * @param {Pointer<Byte>} pbSignedBlob A pointer to a buffered 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_INTEGER_BLOB</a> structure that contains the signed message.
     * @param {Integer} cbSignedBlob The size, in bytes, of the signed message.
     * @returns {Pointer<HCERTSTORE>} Returns the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate store</a> containing the message's certificates and CRLs. For an error, <b>NULL</b> is returned.
     * 
     * The following lists the error code most commonly returned by the 
     * 		       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid message and certificate encoding types. Currently only PKCS_7_ASN_ENCODING and X509_ASN_ENCODING are supported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptgetmessagecertificates
     * @since windows5.1.2600
     */
    static CryptGetMessageCertificates(dwMsgAndCertEncodingType, hCryptProv, dwFlags, pbSignedBlob, cbSignedBlob) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptGetMessageCertificates", "uint", dwMsgAndCertEncodingType, "ptr", hCryptProv, "uint", dwFlags, "ptr", pbSignedBlob, "uint", cbSignedBlob, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptVerifyDetachedMessageSignature function verifies a signed message containing a detached signature or signatures.
     * @param {Pointer<CRYPT_VERIFY_MESSAGE_PARA>} pVerifyPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_verify_message_para">CRYPT_VERIFY_MESSAGE_PARA</a> structure containing the verification parameters.
     * @param {Integer} dwSignerIndex Index of the signature to be verified. A message might have several signers and this function can be called repeatedly, changing <i>dwSignerIndex</i> to verify other signatures. If the function returns FALSE, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns CRYPT_E_NO_SIGNER, the previous call received the last signer of the message.
     * @param {Pointer<Byte>} pbDetachedSignBlob A pointer to a BLOB containing the encoded message signatures.
     * @param {Integer} cbDetachedSignBlob The size, in bytes, of the detached signature.
     * @param {Integer} cToBeSigned Number of array elements in <i>rgpbToBeSigned</i> and <i>rgcbToBeSigned</i>.
     * @param {Pointer<Byte>} rgpbToBeSigned Array of pointers to buffers containing the contents to be <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hashed</a>.
     * @param {Pointer<UInt32>} rgcbToBeSigned Array of sizes, in bytes, for the content buffers pointed to in <i>rgpbToBeSigned</i>.
     * @param {Pointer<CERT_CONTEXT>} ppSignerCert A pointer to a 
     * pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure of a signer certificate. When you have finished using the certificate context, free it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function. A pointer to a <b>CERT_CONTEXT</b> structure will not be returned if this parameter is <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following lists the error codes most commonly returned by the 
     * 		       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid message and certificate encoding types. Currently only PKCS_7_ASN_ENCODING and X509_ASN_ENCODING_TYPE are supported. Invalid <b>cbSize</b> in *<i>pVerifyPara</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not a signed cryptographic message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_SIGNER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message does not have any signers or a signer for the specified <i>dwSignerIndex</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message was hashed and signed by using an unknown or unsupported algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message's signature was not verified.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea">CryptVerifySignature</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a> might be propagated to this function.<p class="note">If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>. 
     * 
     * </div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptverifydetachedmessagesignature
     * @since windows5.1.2600
     */
    static CryptVerifyDetachedMessageSignature(pVerifyPara, dwSignerIndex, pbDetachedSignBlob, cbDetachedSignBlob, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, ppSignerCert) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptVerifyDetachedMessageSignature", "ptr", pVerifyPara, "uint", dwSignerIndex, "ptr", pbDetachedSignBlob, "uint", cbDetachedSignBlob, "uint", cToBeSigned, "ptr", rgpbToBeSigned, "ptr", rgcbToBeSigned, "ptr", ppSignerCert, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptEncryptMessage function encrypts and encodes a message.
     * @param {Pointer<CRYPT_ENCRYPT_MESSAGE_PARA>} pEncryptPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_encrypt_message_para">CRYPT_ENCRYPT_MESSAGE_PARA</a> structure that contains the encryption parameters.
     * 
     * The <b>CryptEncryptMessage</b> function does not support the SHA2 OIDs, <b>szOID_DH_SINGLE_PASS_STDDH_SHA256_KDF</b> and  <b>szOID_DH_SINGLE_PASS_STDDH_SHA384_KDF</b>.
     * @param {Integer} cRecipientCert Number of elements in the <i>rgpRecipientCert</i> array.
     * @param {Pointer<CERT_CONTEXT>} rgpRecipientCert Array of pointers to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structures that contain the certificates of intended recipients of the message.
     * @param {Pointer<Byte>} pbToBeEncrypted A pointer to a buffer that contains the message that is to be encrypted.
     * @param {Integer} cbToBeEncrypted The size, in bytes, of the message that is to be encrypted.
     * @param {Pointer<Byte>} pbEncryptedBlob A pointer to <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a> that contains a buffer that receives the encrypted and encoded message. 
     * 
     * 
     * 
     * 
     * To set the size of this information for memory allocation purposes, this parameter can be <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbEncryptedBlob A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pbEncryptedBlob</i> parameter. When the function returns, this variable contains the size, in bytes, of the encrypted and encoded message copied to <i>pbEncryptedBlob</i>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer of the <i>pbEncryptedBlob</i>, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  Errors from calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey">CryptGenKey</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencrypt">CryptEncrypt</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptexportkey">CryptExportKey</a> can be propagated to this function.</div>
     * <div> </div>
     * The <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the following error codes most often.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbEncryptedBlob</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbEncryptedBlob</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> is not valid. Currently only PKCS_7_ASN_ENCODING is supported. The <b>cbSize</b> in *<i>pEncryptPara</i> is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptencryptmessage
     * @since windows5.1.2600
     */
    static CryptEncryptMessage(pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeEncrypted, cbToBeEncrypted, pbEncryptedBlob, pcbEncryptedBlob) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptEncryptMessage", "ptr", pEncryptPara, "uint", cRecipientCert, "ptr", rgpRecipientCert, "ptr", pbToBeEncrypted, "uint", cbToBeEncrypted, "ptr", pbEncryptedBlob, "ptr", pcbEncryptedBlob, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptDecryptMessage function decodes and decrypts a message.
     * @remarks
     * When <b>NULL</b> is passed for <i>pbDecrypted</i>, and <i>pcbDecrypted</i> is not <b>NULL</b>, <b>NULL</b> is returned for the address passed in <i>ppXchgCert</i>; otherwise, a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> is returned. For a successfully decrypted message, this pointer to a <b>CERT_CONTEXT</b> points to the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a> used to decrypt the message. It must be freed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a>. If the function fails, the value at <i>ppXchgCert</i> is set to <b>NULL</b>.
     * @param {Pointer<CRYPT_DECRYPT_MESSAGE_PARA>} pDecryptPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_decrypt_message_para">CRYPT_DECRYPT_MESSAGE_PARA</a> structure that contains decryption parameters.
     * @param {Pointer<Byte>} pbEncryptedBlob A pointer to a buffer that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">encoded</a> and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">encrypted</a> message to be decrypted.
     * @param {Integer} cbEncryptedBlob The size, in bytes, of the encoded and encrypted message.
     * @param {Pointer<Byte>} pbDecrypted A pointer to a buffer that receives the decrypted message. 
     * 
     * 
     * 
     * 
     * To set the size of this information for memory allocation purposes, this parameter can be <b>NULL</b>. A decrypted message will not be returned if this parameter is <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbDecrypted A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pbDecrypted</i> parameter. When the function returns, this variable contains the size, in bytes, of the decrypted message copied to <i>pbDecrypted</i>.
     * 						
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the <i>pbDecrypted</i> buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified in <i>pcbDecrypted</i> on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer. On output, the <b>DWORD</b> is updated to the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @param {Pointer<CERT_CONTEXT>} ppXchgCert A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a> that corresponds to the private <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">exchange key</a> needed to decrypt the message. To indicate that the function should not return the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a> used to decrypt, set this parameter to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  Errors from calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey">CryptImportKey</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdecrypt">CryptDecrypt</a> might be propagated to this function.</div>
     * <div> </div>
     * The <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the following error codes most often.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbDecrypted</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbDecrypted</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid message and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding types</a>. Currently only PKCS_7_ASN_ENCODING and X509_ASN_ENCODING_TYPE are supported. Invalid <b>cbSize</b> in *<i>pDecryptPara</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">enveloped</a> cryptographic message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message was encrypted by using an unknown or unsupported algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_DECRYPT_CERT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No certificate was found having a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key</a> property to use for decrypting.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptdecryptmessage
     * @since windows5.1.2600
     */
    static CryptDecryptMessage(pDecryptPara, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptDecryptMessage", "ptr", pDecryptPara, "ptr", pbEncryptedBlob, "uint", cbEncryptedBlob, "ptr", pbDecrypted, "ptr", pcbDecrypted, "ptr", ppXchgCert, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptSignAndEncryptMessage function creates a hash of the specified content, signs the hash, encrypts the content, hashes the encrypted contents and the signed hash, and then encodes both the encrypted content and the signed hash.
     * @param {Pointer<CRYPT_SIGN_MESSAGE_PARA>} pSignPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_sign_message_para">CRYPT_SIGN_MESSAGE_PARA</a> structure that contains the signature parameters.
     * @param {Pointer<CRYPT_ENCRYPT_MESSAGE_PARA>} pEncryptPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_encrypt_message_para">CRYPT_ENCRYPT_MESSAGE_PARA</a> structure containing encryption parameters.
     * @param {Integer} cRecipientCert Number of array elements in <i>rgpRecipientCert</i>.
     * @param {Pointer<CERT_CONTEXT>} rgpRecipientCert Array of pointers to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structures. Each structure is the certificate of an intended recipients of the message.
     * @param {Pointer<Byte>} pbToBeSignedAndEncrypted A pointer to a buffer containing the content to be signed and encrypted.
     * @param {Integer} cbToBeSignedAndEncrypted The size, in bytes, of the <i>pbToBeSignedAndEncrypted</i> buffer.
     * @param {Pointer<Byte>} pbSignedAndEncryptedBlob A pointer to a buffer to receive the encrypted and encoded message. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbSignedAndEncryptedBlob A pointer to <b>DWORD</b> specifying the size, in bytes, of the buffer pointed to by <i>pbSignedAndEncryptedBlob</i>. When the function returns, this variable contains the size, in bytes, of the signed and encrypted message copied to *<i>pbSignedAndEncryptedBlob</i>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE).
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * The following lists the error code most commonly returned by the 
     * 		       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbSignedAndEncryptedBlob</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbSignedAndEncryptedBlob</i>.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignmessage">CryptSignMessage</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencryptmessage">CryptEncryptMessage</a> might be propagated to this function.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptsignandencryptmessage
     * @since windows5.1.2600
     */
    static CryptSignAndEncryptMessage(pSignPara, pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeSignedAndEncrypted, cbToBeSignedAndEncrypted, pbSignedAndEncryptedBlob, pcbSignedAndEncryptedBlob) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptSignAndEncryptMessage", "ptr", pSignPara, "ptr", pEncryptPara, "uint", cRecipientCert, "ptr", rgpRecipientCert, "ptr", pbToBeSignedAndEncrypted, "uint", cbToBeSignedAndEncrypted, "ptr", pbSignedAndEncryptedBlob, "ptr", pcbSignedAndEncryptedBlob, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptDecryptAndVerifyMessageSignature function decrypts a message and verifies its signature.
     * @remarks
     * For a successfully <a href="https://docs.microsoft.com/windows/desktop/SecGloss/d-gly">decrypted</a> and verified message, the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a> pointers pointed to by <i>ppXchgCert</i> and <i>ppSignerCert</i> are updated. They must be freed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a>. If the function fails, they are set to <b>NULL</b>.
     * 
     * To indicate that the caller is not interested in the exchange certificate or the signer <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a>, set the <i>ppXchgCert</i> and <i>ppSignerCert</i> parameters to <b>NULL</b>.
     * @param {Pointer<CRYPT_DECRYPT_MESSAGE_PARA>} pDecryptPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_decrypt_message_para">CRYPT_DECRYPT_MESSAGE_PARA</a> structure that contains decryption parameters.
     * @param {Pointer<CRYPT_VERIFY_MESSAGE_PARA>} pVerifyPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_verify_message_para">CRYPT_VERIFY_MESSAGE_PARA</a> structure that contains  verification parameters.
     * @param {Integer} dwSignerIndex Identifies a particular signer of the message. A message can be signed by more than one signer and this function can be called multiple times changing this parameter to check for several signers. It is set to zero for the first signer. If the function returns <b>FALSE</b>, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns CRYPT_E_NO_SIGNER, the previous call received the last signer of the message.
     * @param {Pointer<Byte>} pbEncryptedBlob A pointer to the signed, encoded, and encrypted message to be decrypted and verified.
     * @param {Integer} cbEncryptedBlob The size, in bytes, of the encrypted message.
     * @param {Pointer<Byte>} pbDecrypted A pointer to a buffer to receive the decrypted message. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the decrypted message is not required or to set the size of the decrypted message for memory allocation purposes. A decrypted message will not be returned if this parameter is <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbDecrypted A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pbDecrypted</i> parameter. When the function returns, it contains the size of the decrypted message copied to <i>pbDecrypted</i>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the <i>pbDecrypted</i> buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified in <i>pcbDecrypted</i> on input. On output, the variable pointed to by this parameter is set to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @param {Pointer<CERT_CONTEXT>} ppXchgCert A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate</a> that corresponds to the private <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">exchange key</a> needed to decrypt the message.
     * @param {Pointer<CERT_CONTEXT>} ppSignerCert A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure of the certificate of the signer.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdecryptmessage">CryptDecryptMessage</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifymessagesignature">CryptVerifyMessageSignature</a> might be propagated to this function.</div>
     * <div> </div>
     * The <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the following error code most often.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbDecrypted</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbDecrypted</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptdecryptandverifymessagesignature
     * @since windows5.1.2600
     */
    static CryptDecryptAndVerifyMessageSignature(pDecryptPara, pVerifyPara, dwSignerIndex, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert, ppSignerCert) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptDecryptAndVerifyMessageSignature", "ptr", pDecryptPara, "ptr", pVerifyPara, "uint", dwSignerIndex, "ptr", pbEncryptedBlob, "uint", cbEncryptedBlob, "ptr", pbDecrypted, "ptr", pcbDecrypted, "ptr", ppXchgCert, "ptr", ppSignerCert, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Decodes, decrypts, and verifies a cryptographic message.
     * @remarks
     * The <i>dwMsgTypeFlags</i> parameter specifies the set of allowable messages. For example, to decode either SIGNED or ENVELOPED messages, set <i>dwMsgTypeFlags</i> to CMSG_SIGNED_FLAG | CMSG_ENVELOPED_FLAG. Either or both of the <i>pDecryptPara</i> or <i>pVerifyPara</i> parameters must be specified.
     * 
     * For a successfully decoded or verified message, the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a> pointers pointed to by <i>ppXchgCert</i> and <i>ppSignerCert</i> are updated. They must be freed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a>. If the function fails, they are set to <b>NULL</b>.
     * 
     * The <i>ppXchgCert</i> or <i>ppSignerCert</i> parameters can be set to <b>NULL</b> before the function is called, which indicates that the caller is not interested in getting the exchange certificate or the signer <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a>.
     * @param {Integer} dwMsgTypeFlags Indicates the message type. Message types can be combined with the bitwise-<b>OR</b> operator. This parameter can be one of the following message types:
     * 
     * <ul>
     * <li>CMSG_DATA_FLAG</li>
     * <li>CMSG_SIGNED_FLAG</li>
     * <li>CMSG_ENVELOPED_FLAG</li>
     * <li>CMSG_SIGNED_AND_ENVELOPED_FLAG</li>
     * <li>CMSG_HASHED_FLAG</li>
     * </ul>
     * <div class="alert"><b>Note</b>  After return, the <b>DWORD</b> pointed to by <i>pdwMsgType</i> is set with the type of the message.</div>
     * <div> </div>
     * @param {Pointer<CRYPT_DECRYPT_MESSAGE_PARA>} pDecryptPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_decrypt_message_para">CRYPT_DECRYPT_MESSAGE_PARA</a> structure that contains  decryption parameters.
     * @param {Pointer<CRYPT_VERIFY_MESSAGE_PARA>} pVerifyPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_verify_message_para">CRYPT_VERIFY_MESSAGE_PARA</a> structure that contains   verification parameters.
     * @param {Integer} dwSignerIndex Indicates which signer, among the possible many signers of a message, is to be verified. This index can be changed in multiple calls to the function to verify additional signers. 
     * 
     * 
     * 
     * 
     * <i>dwSignerIndex</i> is set to zero for the first signer. If the function returns <b>FALSE</b>, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns CRYPT_E_NO_SIGNER, the previous call returned the last signer of the message. This parameter is used only with messages of types CMSG_SIGNED_AND_ENVELOPED or CMSG_SIGNED. For all other message types, it should be set to zero.
     * @param {Pointer<Byte>} pbEncodedBlob A pointer to the encoded <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a> that is to be decoded.
     * @param {Integer} cbEncodedBlob The size, in bytes, of the encoded BLOB.
     * @param {Integer} dwPrevInnerContentType Only applicable when processing nested cryptographic messages. When processing an outer cryptographic message, it must be set to zero. When decoding a nested cryptographic message, it is set to the value returned at <i>pdwInnerContentType</i> by a previous calling of 
     * <b>CryptDecodeMessage</b> for the outer message. It can be any of the CMSG types listed in <i>pdwMsgType</i>. For backward compatibility, set <i>dwPrevInnerContentType</i> to zero.
     * @param {Pointer<UInt32>} pdwMsgType A pointer to a <b>DWORD</b> that specifies the message type returned. This parameter can be one of the following message types:
     * 
     * <ul>
     * <li>CMSG_DATA</li>
     * <li>CMSG_SIGNED</li>
     * <li>CMSG_ENVELOPED</li>
     * <li>CMSG_SIGNED_AND_ENVELOPED</li>
     * <li>CMSG_HASHED</li>
     * </ul>
     * @param {Pointer<UInt32>} pdwInnerContentType A pointer to a <b>DWORD</b> that specifies the type of an inner message. The message type codes used for <i>pdwMsgType</i> are used here, also. 
     * 
     * 
     * 
     * 
     * If there is no cryptographic nesting, CMSG_DATA is returned.
     * @param {Pointer<Byte>} pbDecoded A pointer to a buffer to receive the decoded message. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the decoded message is not required or to set the size of the decoded message for memory allocation purposes. A decoded message will not be returned if this parameter is <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbDecoded A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>pbDecoded</i> parameter. When the function returns, this variable contains the size of the decoded message. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @param {Pointer<CERT_CONTEXT>} ppXchgCert A pointer to a 
     * pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure with a certificate that corresponds to the private <a href="https://docs.microsoft.com/windows/desktop/SecGloss/e-gly">exchange key</a> needed to decode the message. This parameter is only set for message types CMSG_ENVELOPED and CMSG_SIGNED_AND_ENVELOPED.
     * @param {Pointer<CERT_CONTEXT>} ppSignerCert A pointer to a 
     * pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a> of the signer. This parameter is only set for message types CMSG_SIGNED and CMSG_SIGNED_AND_ENVELOPED.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdecryptmessage">CryptDecryptMessage</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifymessagesignature">CryptVerifyMessageSignature</a>, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifymessagehash">CryptVerifyMessageHash</a> functions can be propagated to this function.
     * 
     * The following error code is most commonly returned by the 
     * 		       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbDecoded</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbDecoded</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptdecodemessage
     * @since windows5.1.2600
     */
    static CryptDecodeMessage(dwMsgTypeFlags, pDecryptPara, pVerifyPara, dwSignerIndex, pbEncodedBlob, cbEncodedBlob, dwPrevInnerContentType, pdwMsgType, pdwInnerContentType, pbDecoded, pcbDecoded, ppXchgCert, ppSignerCert) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptDecodeMessage", "uint", dwMsgTypeFlags, "ptr", pDecryptPara, "ptr", pVerifyPara, "uint", dwSignerIndex, "ptr", pbEncodedBlob, "uint", cbEncodedBlob, "uint", dwPrevInnerContentType, "ptr", pdwMsgType, "ptr", pdwInnerContentType, "ptr", pbDecoded, "ptr", pcbDecoded, "ptr", ppXchgCert, "ptr", ppSignerCert, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a hash of the message.
     * @param {Pointer<CRYPT_HASH_MESSAGE_PARA>} pHashPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_hash_message_para">CRYPT_HASH_MESSAGE_PARA</a> structure that contains the hash parameters.
     * @param {Integer} fDetachedHash If this parameter is set to <b>TRUE</b>, only <i>pbComputedHash</i> is encoded in <i>pbHashedBlob</i>. Otherwise, both <i>rgpbToBeHashed</i> and <i>pbComputedHash</i> are encoded.
     * @param {Integer} cToBeHashed The number of array elements in <i>rgpbToBeHashed</i> and <i>rgcbToBeHashed</i>. This parameter can only be one unless <i>fDetachedHash</i> is set to <b>TRUE</b>.
     * @param {Pointer<Byte>} rgpbToBeHashed An array of pointers to buffers that contain the contents to be hashed.
     * @param {Pointer<UInt32>} rgcbToBeHashed An array of sizes, in bytes, of the buffers pointed to by <i>rgpbToBeHashed</i>.
     * @param {Pointer<Byte>} pbHashedBlob A pointer to a buffer to receive the hashed message encoded for transmission. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the hashed message is not needed for additional processing or to set the size of the hashed message for memory allocation purposes. A hashed message will not be returned if this parameter is <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbHashedBlob A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pbHashedBlob</i> parameter. When the function returns, this variable contains the size, in bytes, of the decrypted message copied to <i>pbHashedBlob</i>. This parameter must be the address of a <b>DWORD</b> and not <b>NULL</b> or the length of the buffer will not be returned. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @param {Pointer<Byte>} pbComputedHash A pointer to a buffer to receive the newly created hash value. This parameter can be <b>NULL</b> if the newly created hash is not needed for additional processing, or to set the size of the hash for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbComputedHash A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pbComputedHash</i> parameter. When the function returns, this <b>DWORD</b> contains the size, in bytes, of the newly created hash that was copied to <i>pbComputedHash</i>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a> might be propagated to this function.</div>
     * <div> </div>
     * The <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the following error codes most often.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> is not valid. Currently only PKCS_7_ASN_ENCODING is supported. The <b>cbSize</b> in *<i>pHashPara</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbHashedBlob</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, into the variable pointed to by <i>pbHashedBlob</i>.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-crypthashmessage
     * @since windows5.1.2600
     */
    static CryptHashMessage(pHashPara, fDetachedHash, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbHashedBlob, pcbHashedBlob, pbComputedHash, pcbComputedHash) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptHashMessage", "ptr", pHashPara, "int", fDetachedHash, "uint", cToBeHashed, "ptr", rgpbToBeHashed, "ptr", rgcbToBeHashed, "ptr", pbHashedBlob, "ptr", pcbHashedBlob, "ptr", pbComputedHash, "ptr", pcbComputedHash, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptVerifyMessageHash function verifies the hash of specified content.
     * @param {Pointer<CRYPT_HASH_MESSAGE_PARA>} pHashPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_hash_message_para">CRYPT_HASH_MESSAGE_PARA</a> structure containing hash parameters.
     * @param {Pointer<Byte>} pbHashedBlob A pointer to a buffer containing original content and its hash.
     * @param {Integer} cbHashedBlob The size, in bytes, of the original hash buffer.
     * @param {Pointer<Byte>} pbToBeHashed A pointer to a buffer to receive the original content that was hashed. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the original content is not needed for additional processing, or to set the size of the original content for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbToBeHashed A pointer to a <b>DWORD</b> specifying the size, in bytes, of the <i>pbToBeHashed</i> buffer. When the function returns, this variable contains the size, in bytes, of the original content copied to <i>pbToBeHashed</i>. The original content will not be returned if this parameter is <b>NULL</b>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @param {Pointer<Byte>} pbComputedHash A pointer to a buffer to receive the computed hash. This parameter can be <b>NULL</b> if the created hash is not needed for additional processing, or to set the size of the original content for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbComputedHash A pointer to a <b>DWORD</b> specifying the size, in bytes, of the <i>pbComputedHash</i> buffer. When the function returns, this variable contains the size, in bytes, of the created hash. The hash is not returned if this parameter is <b>NULL</b>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE).
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following lists the error codes most commonly returned by the 
     * 		       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not a hashed cryptographic message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> is not valid. Currently only PKCS_7_ASN_ENCODING is supported. The <b>cbSize</b> in *<i>pHashPara</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbToBeHashed</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbToBeHashed</i>.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a> might be propagated to this function. <p class="note">If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>. 
     * 
     * </div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptverifymessagehash
     * @since windows5.1.2600
     */
    static CryptVerifyMessageHash(pHashPara, pbHashedBlob, cbHashedBlob, pbToBeHashed, pcbToBeHashed, pbComputedHash, pcbComputedHash) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptVerifyMessageHash", "ptr", pHashPara, "ptr", pbHashedBlob, "uint", cbHashedBlob, "ptr", pbToBeHashed, "ptr", pcbToBeHashed, "ptr", pbComputedHash, "ptr", pcbComputedHash, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptVerifyDetachedMessageHash function verifies a detached hash.
     * @param {Pointer<CRYPT_HASH_MESSAGE_PARA>} pHashPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_hash_message_para">CRYPT_HASH_MESSAGE_PARA</a> structure containing the hash parameters.
     * @param {Pointer<Byte>} pbDetachedHashBlob A pointer to the encoded, detached hash.
     * @param {Integer} cbDetachedHashBlob The size, in bytes, of the detached hash.
     * @param {Integer} cToBeHashed Number of elements in the <i>rgpbToBeHashed</i> and <i>rgcbToBeHashed</i> arrays.
     * @param {Pointer<Byte>} rgpbToBeHashed Array of pointers to content buffers to be hashed.
     * @param {Pointer<UInt32>} rgcbToBeHashed Array of sizes, in bytes, for the content buffers pointed to by the elements of the <i>rgcbToBeHashed</i> array.
     * @param {Pointer<Byte>} pbComputedHash A pointer to a buffer to receive the computed hash. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the newly created hash is not needed for additional processing, or to set the size of the hash for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbComputedHash A pointer to a <b>DWORD</b> specifying the size, in bytes, of the <i>pbComputedHash</i> buffer. When the function returns, this <b>DWORD</b> contains the size, in bytes, of the created hash. The hash will not be returned if this parameter is <b>NULL</b>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned , applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE).
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following lists the error codes most commonly returned by the 
     * 		       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not a hashed cryptographic message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> is not valid. Currently only PKCS_7_ASN_ENCODING is supported. The <b>cbSize</b> in *<i>pHashPara</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbComputedHash</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbComputedHash</i>.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  Errors from the called functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash">CryptCreateHash</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-crypthashdata">CryptHashData</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam">CryptGetHashParam</a> might be propagated to this function. <p class="note">If the function fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> may return an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/a-gly">Abstract Syntax Notation One</a> (ASN.1) encoding/decoding error. For information about these errors, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/asn-1-encoding-decoding-return-values">ASN.1 Encoding/Decoding Return Values</a>. 
     * 
     * </div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptverifydetachedmessagehash
     * @since windows5.1.2600
     */
    static CryptVerifyDetachedMessageHash(pHashPara, pbDetachedHashBlob, cbDetachedHashBlob, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbComputedHash, pcbComputedHash) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptVerifyDetachedMessageHash", "ptr", pHashPara, "ptr", pbDetachedHashBlob, "uint", cbDetachedHashBlob, "uint", cToBeHashed, "ptr", rgpbToBeHashed, "ptr", rgcbToBeHashed, "ptr", pbComputedHash, "ptr", pcbComputedHash, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Signs a message by using a CSP's private key specified in the parameters.
     * @param {Pointer<CRYPT_KEY_SIGN_MESSAGE_PARA>} pSignPara A pointer to 
     * a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_sign_message_para">CRYPT_KEY_SIGN_MESSAGE_PARA</a> structure that contains the signature parameters.
     * @param {Pointer<Byte>} pbToBeSigned A pointer to a buffer array that contains the message to be signed.
     * @param {Integer} cbToBeSigned The number of array elements in the <i>pbToBeSigned</i> buffer array.
     * @param {Pointer<Byte>} pbSignedBlob A pointer to a buffer to receive the encoded signed message. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> to set the size of this information for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbSignedBlob A pointer to a <b>DWORD</b> value that indicates the size, in bytes, of the <i>pbSignedBlob</i> buffer. When the function returns, this variable contains the size, in bytes, of the signed and encoded message. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (FALSE).
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * The following lists the error codes most commonly returned by the 
     * 		       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbSignedBlob</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code and stores the required buffer size, in bytes, into the variable pointed to by <i>pcbSignedBlob</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> is not valid. Currently only PKCS_7_ASN_ENCODING is supported. The <b>cbSize</b> in *<i>pSignPara</i> is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_KEY_PROPERTY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pSigningCert</i> in *<i>pSignPara</i> does not have a CERT_KEY_PROV_INFO_PROP_ID or CERT_KEY_CONTEXT_PROP_ID property.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptsignmessagewithkey
     * @since windows5.1.2600
     */
    static CryptSignMessageWithKey(pSignPara, pbToBeSigned, cbToBeSigned, pbSignedBlob, pcbSignedBlob) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptSignMessageWithKey", "ptr", pSignPara, "ptr", pbToBeSigned, "uint", cbToBeSigned, "ptr", pbSignedBlob, "ptr", pcbSignedBlob, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Verifies a signed message's signature by using specified public key information.
     * @param {Pointer<CRYPT_KEY_VERIFY_MESSAGE_PARA>} pVerifyPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_verify_message_para">CRYPT_KEY_VERIFY_MESSAGE_PARA</a> structure that contains verification parameters.
     * @param {Pointer<CERT_PUBLIC_KEY_INFO>} pPublicKeyInfo A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_public_key_info">CERT_PUBLIC_KEY_INFO</a> structure that contains the public key that is used to verify the signed
     * message. If <b>NULL</b>, the signature is not verified.
     * @param {Pointer<Byte>} pbSignedBlob A pointer to a buffer that contains the signed message.
     * @param {Integer} cbSignedBlob The size, in bytes, of the signed message buffer.
     * @param {Pointer<Byte>} pbDecoded A pointer to a buffer to receive the decoded message. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the decoded message is not needed for additional processing or to set the size of the message for memory allocation purposes. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbDecoded A pointer to a <b>DWORD</b> value that specifies the size, in bytes, of the <i>pbDecoded</i> buffer. When the function returns, this <b>DWORD</b> contains the size, in bytes, of the decoded message. The decoded message will not be returned if this parameter is <b>NULL</b>. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. (On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer.) On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following table shows the error codes most commonly returned by the 
     * 		       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the buffer specified by the <i>pbDecoded</i> parameter is not large enough to hold the returned data, the function sets the ERROR_MORE_DATA code, and stores the required buffer size, in bytes, in the variable pointed to by <i>pcbDecoded</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid message and certificate encoding types. Currently only PKCS_7_ASN_ENCODING and X509_ASN_ENCODING_TYPE are supported. Invalid <b>cbSize</b> in *<i>pVerifyPara</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_UNEXPECTED_MSG_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not a signed cryptographic message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NO_SIGNER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message does not have any signers or a signer for the specified <i>dwSignerIndex</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message was hashed and signed by using an unknown or unsupported algorithm.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message's signature was not verified.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptverifymessagesignaturewithkey
     * @since windows5.1.2600
     */
    static CryptVerifyMessageSignatureWithKey(pVerifyPara, pPublicKeyInfo, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptVerifyMessageSignatureWithKey", "ptr", pVerifyPara, "ptr", pPublicKeyInfo, "ptr", pbSignedBlob, "uint", cbSignedBlob, "ptr", pbDecoded, "ptr", pcbDecoded, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Opens the most common system certificate store. To open certificate stores with more complex requirements, such as file-based or memory-based stores, use CertOpenStore. (ANSI)
     * @remarks
     * Only current user certificates are accessible using this method, not the local machine store.
     * 
     * After the system store is opened, all the standard certificate store functions can be used to manipulate the certificates.
     * 
     * After use, the store should be closed by using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a>.
     * 
     * For more information about the stores that are automatically migrated, see <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/certificate-store-migration">Certificate Store Migration</a>.
     * @param {Pointer} hProv This parameter is not used and should be set to <b>0</b>.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>A handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP). Set <i>hProv</i> to <b>0</b> to use the default CSP. If <i>hProv</i> is not <b>0</b>, it must be a CSP handle created by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function.This parameter's data type is <b>HCRYPTPROV</b>.
     * @param {Pointer<PSTR>} szSubsystemProtocol A string that names a system store. If the system store name provided in this parameter is not the name of an existing system store, a new system store will be created and used. <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certenumsystemstore">CertEnumSystemStore</a> can be used to list the names of existing system stores. Some example system stores are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CA"></a><a id="ca"></a><dl>
     * <dt><b>CA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">Certification authority</a> certificates.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MY"></a><a id="my"></a><dl>
     * <dt><b>MY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A certificate store that holds certificates with associated private keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ROOT"></a><a id="root"></a><dl>
     * <dt><b>ROOT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">Root certificates</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPC"></a><a id="spc"></a><dl>
     * <dt><b>SPC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">Software Publisher Certificate</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Pointer<HCERTSTORE>} If the function succeeds, the function returns a handle to the certificate store.
     * 
     * If the function fails, it returns <b>NULL</b>. For extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  Errors from the called function <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenstore">CertOpenStore</a> are propagated to this function.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certopensystemstorea
     * @since windows5.1.2600
     */
    static CertOpenSystemStoreA(hProv, szSubsystemProtocol) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertOpenSystemStoreA", "ptr", hProv, "ptr", szSubsystemProtocol, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Opens the most common system certificate store. To open certificate stores with more complex requirements, such as file-based or memory-based stores, use CertOpenStore. (Unicode)
     * @remarks
     * Only current user certificates are accessible using this method, not the local machine store.
     * 
     * After the system store is opened, all the standard certificate store functions can be used to manipulate the certificates.
     * 
     * After use, the store should be closed by using <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a>.
     * 
     * For more information about the stores that are automatically migrated, see <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/certificate-store-migration">Certificate Store Migration</a>.
     * @param {Pointer} hProv This parameter is not used and should be set to <b>0</b>.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>A handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP). Set <i>hProv</i> to <b>0</b> to use the default CSP. If <i>hProv</i> is not <b>0</b>, it must be a CSP handle created by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function.This parameter's data type is <b>HCRYPTPROV</b>.
     * @param {Pointer<PWSTR>} szSubsystemProtocol A string that names a system store. If the system store name provided in this parameter is not the name of an existing system store, a new system store will be created and used. <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certenumsystemstore">CertEnumSystemStore</a> can be used to list the names of existing system stores. Some example system stores are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CA"></a><a id="ca"></a><dl>
     * <dt><b>CA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">Certification authority</a> certificates.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MY"></a><a id="my"></a><dl>
     * <dt><b>MY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A certificate store that holds certificates with associated private keys.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ROOT"></a><a id="root"></a><dl>
     * <dt><b>ROOT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">Root certificates</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPC"></a><a id="spc"></a><dl>
     * <dt><b>SPC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">Software Publisher Certificate</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Pointer<HCERTSTORE>} If the function succeeds, the function returns a handle to the certificate store.
     * 
     * If the function fails, it returns <b>NULL</b>. For extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  Errors from the called function <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenstore">CertOpenStore</a> are propagated to this function.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certopensystemstorew
     * @since windows5.1.2600
     */
    static CertOpenSystemStoreW(hProv, szSubsystemProtocol) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertOpenSystemStoreW", "ptr", hProv, "ptr", szSubsystemProtocol, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Opens the specified system store and adds the encoded certificate to it. (ANSI)
     * @remarks
     * Internally, <b>CertAddEncodedCertificateToSystemStore</b> calls <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopensystemstorea">CertOpenSystemStore</a> and <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddencodedcertificatetostore">CertAddEncodedCertificateToStore</a> with the following parameters.
     * 
     * 
     * <table>
     * <tr>
     * <th>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopensystemstorea">CertOpenSystemStore</a> Parameter</th>
     * <th>Value</th>
     * </tr>
     * <tr>
     * <td><i>szSubsystemProtocol</i></td>
     * <td><i>szCertStoreName</i></td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * If <b>CertAddEncodedCertificateToSystemStore</b> obtains a handle to the specified system store, it calls <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a> to close the handle before it returns.
     * 
     * 
     * <table>
     * <tr>
     * <th>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddencodedcertificatetostore">CertAddEncodedCertificateToStore</a> Parameter</th>
     * <th>Value</th>
     * </tr>
     * <tr>
     * <td><i>dwCertEncodingType</i></td>
     * <td><b>X509_ASN_ENCODING</b></td>
     * </tr>
     * <tr>
     * <td><i>dwAddDisposition</i></td>
     * <td><b>CERT_STORE_ADD_USE_EXISTING</b></td>
     * </tr>
     * <tr>
     * <td><i>ppCertContext</i></td>
     * <td><b>NULL</b></td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The wincrypt.h header defines CertAddEncodedCertificateToSystemStore as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} szCertStoreName A null-terminated string that contains the name of the system store for the encoded certificate.
     * @param {Pointer<Byte>} pbCertEncoded A pointer to a buffer that contains the encoded certificate to add.
     * @param {Integer} cbCertEncoded The size, in bytes, of the <i>pbCertEncoded</i> buffer.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. <b>CertAddEncodedCertificateToSystemStore</b> depends on the functions listed in the following remarks for error handling. Refer to those function topics for their respective error handling behaviors. For extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certaddencodedcertificatetosystemstorea
     * @since windows5.1.2600
     */
    static CertAddEncodedCertificateToSystemStoreA(szCertStoreName, pbCertEncoded, cbCertEncoded) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddEncodedCertificateToSystemStoreA", "ptr", szCertStoreName, "ptr", pbCertEncoded, "uint", cbCertEncoded, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Opens the specified system store and adds the encoded certificate to it. (Unicode)
     * @remarks
     * Internally, <b>CertAddEncodedCertificateToSystemStore</b> calls <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopensystemstorea">CertOpenSystemStore</a> and <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddencodedcertificatetostore">CertAddEncodedCertificateToStore</a> with the following parameters.
     * 
     * 
     * <table>
     * <tr>
     * <th>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopensystemstorea">CertOpenSystemStore</a> Parameter</th>
     * <th>Value</th>
     * </tr>
     * <tr>
     * <td><i>szSubsystemProtocol</i></td>
     * <td><i>szCertStoreName</i></td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * If <b>CertAddEncodedCertificateToSystemStore</b> obtains a handle to the specified system store, it calls <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a> to close the handle before it returns.
     * 
     * 
     * <table>
     * <tr>
     * <th>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddencodedcertificatetostore">CertAddEncodedCertificateToStore</a> Parameter</th>
     * <th>Value</th>
     * </tr>
     * <tr>
     * <td><i>dwCertEncodingType</i></td>
     * <td><b>X509_ASN_ENCODING</b></td>
     * </tr>
     * <tr>
     * <td><i>dwAddDisposition</i></td>
     * <td><b>CERT_STORE_ADD_USE_EXISTING</b></td>
     * </tr>
     * <tr>
     * <td><i>ppCertContext</i></td>
     * <td><b>NULL</b></td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The wincrypt.h header defines CertAddEncodedCertificateToSystemStore as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} szCertStoreName A null-terminated string that contains the name of the system store for the encoded certificate.
     * @param {Pointer<Byte>} pbCertEncoded A pointer to a buffer that contains the encoded certificate to add.
     * @param {Integer} cbCertEncoded The size, in bytes, of the <i>pbCertEncoded</i> buffer.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. <b>CertAddEncodedCertificateToSystemStore</b> depends on the functions listed in the following remarks for error handling. Refer to those function topics for their respective error handling behaviors. For extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certaddencodedcertificatetosystemstorew
     * @since windows5.1.2600
     */
    static CertAddEncodedCertificateToSystemStoreW(szCertStoreName, pbCertEncoded, cbCertEncoded) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertAddEncodedCertificateToSystemStoreW", "ptr", szCertStoreName, "ptr", pbCertEncoded, "uint", cbCertEncoded, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Pointer<CERT_CHAIN>} pCertChains 
     * @param {Pointer<UInt32>} pcbCertChains 
     * @param {Pointer<UInt32>} pcCertChains 
     * @param {Pointer<Byte>} pbEncodedIssuerName 
     * @param {Integer} cbEncodedIssuerName 
     * @param {Pointer<PWSTR>} pwszPurpose 
     * @param {Integer} dwKeySpec 
     * @returns {Integer} 
     */
    static FindCertsByIssuer(pCertChains, pcbCertChains, pcCertChains, pbEncodedIssuerName, cbEncodedIssuerName, pwszPurpose, dwKeySpec) {
        result := DllCall("WINTRUST.dll\FindCertsByIssuer", "ptr", pCertChains, "ptr", pcbCertChains, "ptr", pcCertChains, "ptr", pbEncodedIssuerName, "uint", cbEncodedIssuerName, "ptr", pwszPurpose, "uint", dwKeySpec, "int")
        return result
    }

    /**
     * Retrieves information about the contents of a cryptography API object, such as a certificate, a certificate revocation list, or a certificate trust list.
     * @param {Integer} dwObjectType 
     * @param {Pointer<Void>} pvObject A pointer to the object to be queried. 
     * 					The type of data pointer depends on the contents of the <i>dwObjectType</i> parameter.
     * 
     * <table>
     * <tr>
     * <th><i>dwObjectType</i> value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_QUERY_OBJECT_BLOB"></a><a id="cert_query_object_blob"></a><dl>
     * <dt><b>CERT_QUERY_OBJECT_BLOB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is a pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CERT_BLOB</a>, or similar, structure that contains the object to query.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_QUERY_OBJECT_FILE"></a><a id="cert_query_object_file"></a><dl>
     * <dt><b>CERT_QUERY_OBJECT_FILE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is a pointer to a null-terminated Unicode string that contains the path and name of the file to query.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwExpectedContentTypeFlags 
     * @param {Integer} dwExpectedFormatTypeFlags 
     * @param {Integer} dwFlags This parameter is reserved for future use and must be set to zero.
     * @param {Pointer<UInt32>} pdwMsgAndCertEncodingType A pointer to a <b>DWORD</b> value that receives the type of encoding used in the message. If this information is not needed, set this parameter to <b>NULL</b>.
     * @param {Pointer<UInt32>} pdwContentType 
     * @param {Pointer<UInt32>} pdwFormatType 
     * @param {Pointer<HCERTSTORE>} phCertStore A pointer to an <b>HCERTSTORE</b> value that receives a handle to a certificate store that includes all of the certificates, CRLs, and CTLs in the object.
     * @param {Pointer<Void>} phMsg A pointer to an <b>HCRYPTMSG</b> value that receives the handle of an opened message.
     * @param {Pointer<Void>} ppvContext A pointer to a pointer that receives additional information about the object.
     * 
     * 
     * The format of this data depends on the value received by the <i>dwContentType</i> parameter. The following table lists the format of the data for the specified <i>dwContentType</i> value.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th><i>dwContentType</i> value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_QUERY_CONTENT_CERT"></a><a id="cert_query_content_cert"></a><dl>
     * <dt><b>CERT_QUERY_CONTENT_CERT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter receives a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure. When you have finished using the structure, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_QUERY_CONTENT_CRL"></a><a id="cert_query_content_crl"></a><dl>
     * <dt><b>CERT_QUERY_CONTENT_CRL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter receives a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure. When you have finished using the structure, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_QUERY_CONTENT_CTL"></a><a id="cert_query_content_ctl"></a><dl>
     * <dt><b>CERT_QUERY_CONTENT_CTL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter receives a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure. When you have finished using the structure, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreectlcontext">CertFreeCTLContext</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_QUERY_CONTENT_SERIALIZED_CERT"></a><a id="cert_query_content_serialized_cert"></a><dl>
     * <dt><b>CERT_QUERY_CONTENT_SERIALIZED_CERT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter receives a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure. When you have finished using the structure, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_QUERY_CONTENT_SERIALIZED_CRL"></a><a id="cert_query_content_serialized_crl"></a><dl>
     * <dt><b>CERT_QUERY_CONTENT_SERIALIZED_CRL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter receives a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crl_context">CRL_CONTEXT</a> structure. When you have finished using the structure, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecrlcontext">CertFreeCRLContext</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_QUERY_CONTENT_SERIALIZED_CTL"></a><a id="cert_query_content_serialized_ctl"></a><dl>
     * <dt><b>CERT_QUERY_CONTENT_SERIALIZED_CTL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter receives a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-ctl_context">CTL_CONTEXT</a> structure. When you have finished using the structure, free it by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreectlcontext">CertFreeCTLContext</a> function.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If this information is not needed, set this parameter to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptqueryobject
     * @since windows5.1.2600
     */
    static CryptQueryObject(dwObjectType, pvObject, dwExpectedContentTypeFlags, dwExpectedFormatTypeFlags, dwFlags, pdwMsgAndCertEncodingType, pdwContentType, pdwFormatType, phCertStore, phMsg, ppvContext) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptQueryObject", "uint", dwObjectType, "ptr", pvObject, "uint", dwExpectedContentTypeFlags, "uint", dwExpectedFormatTypeFlags, "uint", dwFlags, "ptr", pdwMsgAndCertEncodingType, "ptr", pdwContentType, "ptr", pdwFormatType, "ptr", phCertStore, "ptr", phMsg, "ptr", ppvContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptMemAlloc function allocates memory for a buffer. It is used by all Crypt32.lib functions that return allocated buffers.
     * @param {Integer} cbSize Number of bytes to be allocated.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmemalloc
     * @since windows5.1.2600
     */
    static CryptMemAlloc(cbSize) {
        DllCall("CRYPT32.dll\CryptMemAlloc", "uint", cbSize)
    }

    /**
     * The CryptMemRealloc function frees the memory currently allocated for a buffer and allocates memory for a new buffer.
     * @param {Pointer<Void>} pv A pointer to a currently allocated buffer.
     * @param {Integer} cbSize Number of bytes to be allocated.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmemrealloc
     * @since windows5.1.2600
     */
    static CryptMemRealloc(pv, cbSize) {
        DllCall("CRYPT32.dll\CryptMemRealloc", "ptr", pv, "uint", cbSize)
    }

    /**
     * The CryptMemFree function frees memory allocated by CryptMemAlloc or CryptMemRealloc.
     * @param {Pointer<Void>} pv A pointer to the buffer to be freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptmemfree
     * @since windows5.1.2600
     */
    static CryptMemFree(pv) {
        DllCall("CRYPT32.dll\CryptMemFree", "ptr", pv)
    }

    /**
     * The CryptCreateAsyncHandle function (wincrypt.h) creates an async handle.
     * @param {Integer} dwFlags Handle creation flags.
     * @param {Pointer<IntPtr>} phAsync Receives a pointer to the created async handle.
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptcreateasynchandle
     */
    static CryptCreateAsyncHandle(dwFlags, phAsync) {
        result := DllCall("CRYPT32.dll\CryptCreateAsyncHandle", "uint", dwFlags, "ptr", phAsync, "int")
        return result
    }

    /**
     * The CryptSetAsyncParam function (wincrypt.h) sets an async parameter.
     * @param {Pointer} hAsync An async handle.
     * @param {Pointer<PSTR>} pszParamOid The parameter ID.
     * @param {Pointer<Void>} pvParam The parameter value.
     * @param {Pointer<PFN_CRYPT_ASYNC_PARAM_FREE_FUNC>} pfnFree A callback function called when the parameter is freed.
     * @returns {Integer} S_OK on success.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptsetasyncparam
     */
    static CryptSetAsyncParam(hAsync, pszParamOid, pvParam, pfnFree) {
        result := DllCall("CRYPT32.dll\CryptSetAsyncParam", "ptr", hAsync, "ptr", pszParamOid, "ptr", pvParam, "ptr", pfnFree, "int")
        return result
    }

    /**
     * The CryptGetAsyncParam function (wincrypt.h) sets an async parameter value.
     * @param {Pointer} hAsync An async handle.
     * @param {Pointer<PSTR>} pszParamOid The parameter ID.
     * @param {Pointer<Void>} ppvParam Receives the parameter value.
     * @param {Pointer<PFN_CRYPT_ASYNC_PARAM_FREE_FUNC>} ppfnFree A callback function called when the parameter is freed.
     * @returns {Integer} S_OK on success.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptgetasyncparam
     */
    static CryptGetAsyncParam(hAsync, pszParamOid, ppvParam, ppfnFree) {
        result := DllCall("CRYPT32.dll\CryptGetAsyncParam", "ptr", hAsync, "ptr", pszParamOid, "ptr", ppvParam, "ptr", ppfnFree, "int")
        return result
    }

    /**
     * The CryptCloseAsyncHandle function (wincrypt.h) closes an async handle.
     * @param {Pointer} hAsync The async handle to close.
     * @returns {Integer} Returns S_OK on success.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptcloseasynchandle
     */
    static CryptCloseAsyncHandle(hAsync) {
        result := DllCall("CRYPT32.dll\CryptCloseAsyncHandle", "ptr", hAsync, "int")
        return result
    }

    /**
     * Retrieves the public key infrastructure (PKI) object from a location specified by a URL. (ANSI)
     * @remarks
     * The remote object retrieval manager exposes two provider models. One is the Scheme Provider model that allows for installable protocol providers as defined by the URL scheme, that is, ldap, http, ftp, or file. The scheme provider entry point is the same as the <b>CryptRetrieveObjectByUrl</b> function; however, the *<i>ppvObject</i> returned is always a counted array of encoded bits (one per object retrieved).
     * 
     * The second provider model is the Context Provider model that allows for installable creators of the context handles (objects) based on the retrieved encoded bits. These are dispatched based on the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) specified in the call to <b>CryptRetrieveObjectByUrl</b>.
     * 
     * Individual PKI objects such as certificates, trusts lists, revocation lists, PKCS #7 messages, and multiple homogeneous objects can be retrieved. Starting with Windows Vista with Service Pack 1 (SP1) and Windows Server 2008, security of "http:" and "ldap:" retrievals have been hardened.
     * This function supports "http:" and "ldap:" URL schemes as well as newly defined schemes.
     * 
     * <b>Windows XP:  </b>"ftp:" is not supported for network retrieval.
     * 
     * <div class="alert"><b>Note</b>  By default, "file:" is not supported for network retrieval.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The wincrypt.h header defines CryptRetrieveObjectByUrl as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} pszUrl The address of a PKI object to be retrieved. The following schemes are supported:
     * 
     * <ul>
     * <li>ldap (<a href="https://docs.microsoft.com/windows/desktop/SecGloss/l-gly">Lightweight Directory Access Protocol</a>)</li>
     * <li>http</li>
     * <li>https (<a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate revocation list</a> (CRL) or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">online certificate status protocol</a> (OCSP) retrievals only)</li>
     * <li>file</li>
     * </ul>
     * @param {Pointer<PSTR>} pszObjectOid 
     * @param {Integer} dwRetrievalFlags Determines whether to use the cached URL or a URL retrieved from the wire URL. The form in which objects are returned is determined by the value of <i>pszObjectOid</i>.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_AIA_RETRIEVAL"></a><a id="crypt_aia_retrieval"></a><dl>
     * <dt><b>CRYPT_AIA_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Validates the content retrieved by a wire URL before writing the URL  to the cache.
     * 
     * The default provider does not support the HTTPS protocol for AIA retrievals.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_ASYNC_RETRIEVAL"></a><a id="crypt_async_retrieval"></a><dl>
     * <dt><b>CRYPT_ASYNC_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_CACHE_ONLY_RETRIEVAL"></a><a id="crypt_cache_only_retrieval"></a><dl>
     * <dt><b>CRYPT_CACHE_ONLY_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the encoded bits from the URL cache only. Do not use the wire to retrieve the URL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DONT_CACHE_RESULT"></a><a id="crypt_dont_cache_result"></a><dl>
     * <dt><b>CRYPT_DONT_CACHE_RESULT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Does not store the retrieved encoded bits to the URL cache. If this flag is not set, the retrieved URL is cached.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_HTTP_POST_RETRIEVAL"></a><a id="crypt_http_post_retrieval"></a><dl>
     * <dt><b>CRYPT_HTTP_POST_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uses the POST method instead of the default GET method for HTTP retrievals.
     * 
     * In a POST URL, additional binary data and header strings are appended to the base URL in the following format:
     * 
     * <i>BaseURL</i><b>/</b><i>OptionalURLEscaped&amp;Base64EncodedAdditionalData</i><b>?</b><i>OptionalAdditionalHTTPHeaders</i>
     * 
     * The following example shows the additional binary data delimited by the last slash mark (/) and  a Content-Type header delimited by a question mark (?) appended to a base URL.
     * 
     * <c>http://ocsp.openvalidation.org/MEIwQDA%2BMDwwOjAJBgUrDgMCGgUABBQdKNEwjytjKBQADcgM61jfflNpyQQUv1NDgnjQnsOA5RtnygUA37lIg6UCAQI%3D?Content-Type: application/ocsp-request</c>
     * 
     * When this flag is set, the <b>CryptRetrieveObjectByUrl</b> function parses the URL by using the last slash mark (/) and question mark (?) delimiters. The string, which is delimited by a slash mark (/), contains an unescaped URL (that is, a plain text URL without escape characters or escape sequences) and Base64 data decoded into binary form before being passed to the <a href="https://docs.microsoft.com/windows/desktop/api/winhttp/nf-winhttp-winhttpsendrequest">WinHttpSendRequest</a> function as the <i>lpOptional</i> parameter. The string delimited by a question mark (?) is passed to the <b>WinHttpSendRequest</b> function as the <i>pwszHeaders</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL"></a><a id="crypt_ldap_arec_exclusive_retrieval"></a><dl>
     * <dt><b>CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Performs A-Record-only DNS lookup on the supplied host string, preventing the generation of false DNS queries when resolving host names. This flag should be used when passing a host name as opposed to a domain name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE"></a><a id="crypt_ldap_insert_entry_attribute"></a><dl>
     * <dt><b>CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the entry index and attribute name for each LDAP object. The beginning of each returned BLOB contains the following ANSI string:
     * 
     * "<i>entry index in decimal</i>\0<i>attribute name</i>\0"
     * 
     * When this flag is set, <i>pszObjectOid</i> must be <b>NULL</b> so that a BLOB is returned. This flag only applies to the ldap scheme.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL"></a><a id="crypt_ldap_scope_base_only_retrieval"></a><dl>
     * <dt><b>CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Fails if the LDAP search scope is not set to base in the URL. Use with LDAP only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LDAP_SIGN_RETRIEVAL"></a><a id="crypt_ldap_sign_retrieval"></a><dl>
     * <dt><b>CRYPT_LDAP_SIGN_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Digitally signs all of the LDAP traffic to and from a server by using the Kerberos authentication protocol. This feature provides integrity required by some applications.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NO_AUTH_RETRIEVAL"></a><a id="crypt_no_auth_retrieval"></a><dl>
     * <dt><b>CRYPT_NO_AUTH_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Inhibits automatic authentication handling.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NOT_MODIFIED_RETRIEVAL"></a><a id="crypt_not_modified_retrieval"></a><dl>
     * <dt><b>CRYPT_NOT_MODIFIED_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables a conditional HTTP URL retrieval. When this flag is set, for a conditional retrieval that returns <b>HTTP_STATUS_NOT_MODIFIED</b>, <b>CryptRetrieveObjectByUrl</b> returns <b>TRUE</b> and <i>ppvObject</i> is set to <b>NULL</b>. If <i>pAuxInfo</i> is not <b>NULL</b>, <b>dwHttpStatusCode</b> is set to <b>HTTP_STATUS_NOT_MODIFIED</b>. Otherwise, <i>ppvObject</i> is updated for a successful retrieval.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_OFFLINE_CHECK_RETRIEVAL"></a><a id="crypt_offline_check_retrieval"></a><dl>
     * <dt><b>CRYPT_OFFLINE_CHECK_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Keeps track of offline failures and delays before hitting the wire on subsequent retrievals. This value is for wire retrieval only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_PROXY_CACHE_RETRIEVAL"></a><a id="crypt_proxy_cache_retrieval"></a><dl>
     * <dt><b>CRYPT_PROXY_CACHE_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables proxy cache retrieval of an object. If a proxy cache was not explicitly bypassed, <b>fProxyCacheRetrieval</b> is set to <b>TRUE</b> in <i>pAuxInfo</i>. This value only applies to HTTP URL retrievals.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_RETRIEVE_MULTIPLE_OBJECTS"></a><a id="crypt_retrieve_multiple_objects"></a><dl>
     * <dt><b>CRYPT_RETRIEVE_MULTIPLE_OBJECTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves multiple objects if available. All objects must be of a homogeneous object type as determined by the value of <i>pszObjectOid</i>, unless the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) value is CONTEXT_OID_CAPI2_ANY.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_STICKY_CACHE_RETRIEVAL"></a><a id="crypt_sticky_cache_retrieval"></a><dl>
     * <dt><b>CRYPT_STICKY_CACHE_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Tags the URL as exempt from being flushed from the cache. For more information, see STICKY_CACHE_ENTRY in INTERNET_CACHE_ENTRY_INFO.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CONTEXT_SIGNATURE"></a><a id="crypt_verify_context_signature"></a><dl>
     * <dt><b>CRYPT_VERIFY_CONTEXT_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Acquires signature verification on the context created. In this case <i>pszObjectOid</i> must be non-<b>NULL</b> and <i>pvVerify</i> points to the signer certificate context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_DATA_HASH"></a><a id="crypt_verify_data_hash"></a><dl>
     * <dt><b>CRYPT_VERIFY_DATA_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not implemented. Do not use it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_WIRE_ONLY_RETRIEVAL"></a><a id="crypt_wire_only_retrieval"></a><dl>
     * <dt><b>CRYPT_WIRE_ONLY_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the encoded bits from the wire only. Does not use the URL cache.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwTimeout Specifies the maximum number of milliseconds to wait for retrieval. If a value of zero is specified, this function does not time out. This parameter is not used if the URL scheme is file:///.
     * @param {Pointer<Void>} ppvObject The address of a pointer to the returned object. The return type can be one of the supported types shown in <i>pszObjectOid</i>.
     * @param {Pointer} hAsyncRetrieve This parameter is reserved and must be set to <b>NULL</b>.
     * @param {Pointer<CRYPT_CREDENTIALS>} pCredentials This parameter is not used.
     * @param {Pointer<Void>} pvVerify A pointer to a verification object. This object is a function of the <i>dwRetrievalFlags</i> parameter. It can be <b>NULL</b> to indicate that the caller is not interested in getting the certificate context or index of the signer if <i>dwRetrievalFlags</i> is CRYPT_VERIFY_CONTEXT_SIGNATURE.
     * @param {Pointer<CRYPT_RETRIEVE_AUX_INFO>} pAuxInfo An optional pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_retrieve_aux_info">CRYPT_RETRIEVE_AUX_INFO</a> structure. If not <b>NULL</b> and if the <b>cbSize</b> member of the structure is set, this parameter returns the time of the last successful wire retrieval.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptretrieveobjectbyurla
     * @since windows5.1.2600
     */
    static CryptRetrieveObjectByUrlA(pszUrl, pszObjectOid, dwRetrievalFlags, dwTimeout, ppvObject, hAsyncRetrieve, pCredentials, pvVerify, pAuxInfo) {
        result := DllCall("CRYPTNET.dll\CryptRetrieveObjectByUrlA", "ptr", pszUrl, "ptr", pszObjectOid, "uint", dwRetrievalFlags, "uint", dwTimeout, "ptr", ppvObject, "ptr", hAsyncRetrieve, "ptr", pCredentials, "ptr", pvVerify, "ptr", pAuxInfo, "int")
        return result
    }

    /**
     * Retrieves the public key infrastructure (PKI) object from a location specified by a URL. (Unicode)
     * @remarks
     * The remote object retrieval manager exposes two provider models. One is the Scheme Provider model that allows for installable protocol providers as defined by the URL scheme, that is, ldap, http, ftp, or file. The scheme provider entry point is the same as the <b>CryptRetrieveObjectByUrl</b> function; however, the *<i>ppvObject</i> returned is always a counted array of encoded bits (one per object retrieved).
     * 
     * The second provider model is the Context Provider model that allows for installable creators of the context handles (objects) based on the retrieved encoded bits. These are dispatched based on the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) specified in the call to <b>CryptRetrieveObjectByUrl</b>.
     * 
     * Individual PKI objects such as certificates, trusts lists, revocation lists, PKCS #7 messages, and multiple homogeneous objects can be retrieved. Starting with Windows Vista with Service Pack 1 (SP1) and Windows Server 2008, security of "http:" and "ldap:" retrievals have been hardened.
     * 
     * This function supports "http:" and "ldap:" URL schemes as well as newly defined schemes.
     * 
     * <b>Windows XP:  </b>"ftp:" is not supported for network retrieval. 
     * 
     * <div class="alert"><b>Note</b>  By default, "file:" is not supported for network retrieval.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The wincrypt.h header defines CryptRetrieveObjectByUrl as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} pszUrl The address of a PKI object to be retrieved. The following schemes are supported:
     * 
     * <ul>
     * <li>ldap (<a href="https://docs.microsoft.com/windows/desktop/SecGloss/l-gly">Lightweight Directory Access Protocol</a>)</li>
     * <li>http</li>
     * <li>https (<a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate revocation list</a> (CRL) or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">online certificate status protocol</a> (OCSP) retrievals only)</li>
     * <li>file</li>
     * </ul>
     * @param {Pointer<PSTR>} pszObjectOid 
     * @param {Integer} dwRetrievalFlags Determines whether to use the cached URL or a URL retrieved from the wire URL. The form in which objects are returned is determined by the value of <i>pszObjectOid</i>.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_AIA_RETRIEVAL"></a><a id="crypt_aia_retrieval"></a><dl>
     * <dt><b>CRYPT_AIA_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Validates the content retrieved by a wire URL before writing the URL  to the cache.
     * 
     * The default provider does not support the HTTPS protocol for AIA retrievals.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_ASYNC_RETRIEVAL"></a><a id="crypt_async_retrieval"></a><dl>
     * <dt><b>CRYPT_ASYNC_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_CACHE_ONLY_RETRIEVAL"></a><a id="crypt_cache_only_retrieval"></a><dl>
     * <dt><b>CRYPT_CACHE_ONLY_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the encoded bits from the URL cache only. Do not use the wire to retrieve the URL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_DONT_CACHE_RESULT"></a><a id="crypt_dont_cache_result"></a><dl>
     * <dt><b>CRYPT_DONT_CACHE_RESULT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Does not store the retrieved encoded bits to the URL cache. If this flag is not set, the retrieved URL is cached.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_HTTP_POST_RETRIEVAL"></a><a id="crypt_http_post_retrieval"></a><dl>
     * <dt><b>CRYPT_HTTP_POST_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uses the POST method instead of the default GET method for HTTP retrievals.
     * 
     * In a POST URL, additional binary data and header strings are appended to the base URL in the following format:
     * 
     * <i>BaseURL</i><b>/</b><i>OptionalURLEscaped&amp;Base64EncodedAdditionalData</i><b>?</b><i>OptionalAdditionalHTTPHeaders</i>
     * 
     * The following example shows the additional binary data delimited by the last slash mark (/) and  a Content-Type header delimited by a question mark (?) appended to a base URL.
     * 
     * <c>http://ocsp.openvalidation.org/MEIwQDA%2BMDwwOjAJBgUrDgMCGgUABBQdKNEwjytjKBQADcgM61jfflNpyQQUv1NDgnjQnsOA5RtnygUA37lIg6UCAQI%3D?Content-Type: application/ocsp-request</c>
     * 
     * When this flag is set, the <b>CryptRetrieveObjectByUrl</b> function parses the URL by using the last slash mark (/) and question mark (?) delimiters. The string, which is delimited by a slash mark (/), contains an unescaped URL (that is, a plain text URL without escape characters or escape sequences) and Base64 data decoded into binary form before being passed to the <a href="https://docs.microsoft.com/windows/desktop/api/winhttp/nf-winhttp-winhttpsendrequest">WinHttpSendRequest</a> function as the <i>lpOptional</i> parameter. The string delimited by a question mark (?) is passed to the <b>WinHttpSendRequest</b> function as the <i>pwszHeaders</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL"></a><a id="crypt_ldap_arec_exclusive_retrieval"></a><dl>
     * <dt><b>CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Performs A-Record-only DNS lookup on the supplied host string, preventing the generation of false DNS queries when resolving host names. This flag should be used when passing a host name as opposed to a domain name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE"></a><a id="crypt_ldap_insert_entry_attribute"></a><dl>
     * <dt><b>CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the entry index and attribute name for each LDAP object. The beginning of each returned BLOB contains the following ANSI string:
     * 
     * "<i>entry index in decimal</i>\0<i>attribute name</i>\0"
     * 
     * When this flag is set, <i>pszObjectOid</i> must be <b>NULL</b> so that a BLOB is returned. This flag only applies to the ldap scheme.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL"></a><a id="crypt_ldap_scope_base_only_retrieval"></a><dl>
     * <dt><b>CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Fails if the LDAP search scope is not set to base in the URL. Use with LDAP only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_LDAP_SIGN_RETRIEVAL"></a><a id="crypt_ldap_sign_retrieval"></a><dl>
     * <dt><b>CRYPT_LDAP_SIGN_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Digitally signs all of the LDAP traffic to and from a server by using the Kerberos authentication protocol. This feature provides integrity required by some applications.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NO_AUTH_RETRIEVAL"></a><a id="crypt_no_auth_retrieval"></a><dl>
     * <dt><b>CRYPT_NO_AUTH_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Inhibits automatic authentication handling.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_NOT_MODIFIED_RETRIEVAL"></a><a id="crypt_not_modified_retrieval"></a><dl>
     * <dt><b>CRYPT_NOT_MODIFIED_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables a conditional HTTP URL retrieval. When this flag is set, for a conditional retrieval that returns <b>HTTP_STATUS_NOT_MODIFIED</b>, <b>CryptRetrieveObjectByUrl</b> returns <b>TRUE</b> and <i>ppvObject</i> is set to <b>NULL</b>. If <i>pAuxInfo</i> is not <b>NULL</b>, <b>dwHttpStatusCode</b> is set to <b>HTTP_STATUS_NOT_MODIFIED</b>. Otherwise, <i>ppvObject</i> is updated for a successful retrieval.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_OFFLINE_CHECK_RETRIEVAL"></a><a id="crypt_offline_check_retrieval"></a><dl>
     * <dt><b>CRYPT_OFFLINE_CHECK_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Keeps track of offline failures and delays before hitting the wire on subsequent retrievals. This value is for wire retrieval only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_PROXY_CACHE_RETRIEVAL"></a><a id="crypt_proxy_cache_retrieval"></a><dl>
     * <dt><b>CRYPT_PROXY_CACHE_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables proxy cache retrieval of an object. If a proxy cache was not explicitly bypassed, <b>fProxyCacheRetrieval</b> is set to <b>TRUE</b> in <i>pAuxInfo</i>. This value only applies to HTTP URL retrievals.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_RETRIEVE_MULTIPLE_OBJECTS"></a><a id="crypt_retrieve_multiple_objects"></a><dl>
     * <dt><b>CRYPT_RETRIEVE_MULTIPLE_OBJECTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves multiple objects if available. All objects must be of a homogeneous object type as determined by the value of <i>pszObjectOid</i>, unless the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) value is CONTEXT_OID_CAPI2_ANY.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_STICKY_CACHE_RETRIEVAL"></a><a id="crypt_sticky_cache_retrieval"></a><dl>
     * <dt><b>CRYPT_STICKY_CACHE_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Tags the URL as exempt from being flushed from the cache. For more information, see STICKY_CACHE_ENTRY in INTERNET_CACHE_ENTRY_INFO.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_CONTEXT_SIGNATURE"></a><a id="crypt_verify_context_signature"></a><dl>
     * <dt><b>CRYPT_VERIFY_CONTEXT_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Acquires signature verification on the context created. In this case <i>pszObjectOid</i> must be non-<b>NULL</b> and <i>pvVerify</i> points to the signer certificate context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_VERIFY_DATA_HASH"></a><a id="crypt_verify_data_hash"></a><dl>
     * <dt><b>CRYPT_VERIFY_DATA_HASH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not implemented. Do not use it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_WIRE_ONLY_RETRIEVAL"></a><a id="crypt_wire_only_retrieval"></a><dl>
     * <dt><b>CRYPT_WIRE_ONLY_RETRIEVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the encoded bits from the wire only. Does not use the URL cache.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwTimeout Specifies the maximum number of milliseconds to wait for retrieval. If a value of zero is specified, this function does not time out. This parameter is not used if the URL scheme is file:///.
     * @param {Pointer<Void>} ppvObject The address of a pointer to the returned object. The return type can be one of the supported types shown in <i>pszObjectOid</i>.
     * @param {Pointer} hAsyncRetrieve This parameter is reserved and must be set to <b>NULL</b>.
     * @param {Pointer<CRYPT_CREDENTIALS>} pCredentials This parameter is not used.
     * @param {Pointer<Void>} pvVerify A pointer to a verification object. This object is a function of the <i>dwRetrievalFlags</i> parameter. It can be <b>NULL</b> to indicate that the caller is not interested in getting the certificate context or index of the signer if <i>dwRetrievalFlags</i> is CRYPT_VERIFY_CONTEXT_SIGNATURE.
     * @param {Pointer<CRYPT_RETRIEVE_AUX_INFO>} pAuxInfo An optional pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_retrieve_aux_info">CRYPT_RETRIEVE_AUX_INFO</a> structure. If not <b>NULL</b> and if the <b>cbSize</b> member of the structure is set, this parameter returns the time of the last successful wire retrieval.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptretrieveobjectbyurlw
     * @since windows5.1.2600
     */
    static CryptRetrieveObjectByUrlW(pszUrl, pszObjectOid, dwRetrievalFlags, dwTimeout, ppvObject, hAsyncRetrieve, pCredentials, pvVerify, pAuxInfo) {
        result := DllCall("CRYPTNET.dll\CryptRetrieveObjectByUrlW", "ptr", pszUrl, "ptr", pszObjectOid, "uint", dwRetrievalFlags, "uint", dwTimeout, "ptr", ppvObject, "ptr", hAsyncRetrieve, "ptr", pCredentials, "ptr", pvVerify, "ptr", pAuxInfo, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<PFN_CRYPT_CANCEL_RETRIEVAL>} pfnCancel 
     * @param {Pointer<Void>} pvArg 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static CryptInstallCancelRetrieval(pfnCancel, pvArg, dwFlags) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("CRYPTNET.dll\CryptInstallCancelRetrieval", "ptr", pfnCancel, "ptr", pvArg, "uint", dwFlags, "ptr", pvReserved, "int")
        return result
    }

    /**
     * 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static CryptUninstallCancelRetrieval(dwFlags) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("CRYPTNET.dll\CryptUninstallCancelRetrieval", "uint", dwFlags, "ptr", pvReserved, "int")
        return result
    }

    /**
     * Acquires the URL of the remote object from a certificate, certificate trust list (CTL), or certificate revocation list (CRL).
     * @param {Pointer<PSTR>} pszUrlOid A pointer to an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) that identifies the URL being requested. If the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a> of the <i>pszUrlOid</i> parameter is zero, the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> specifies the integer identifier for the type of the specified structure.
     * @param {Pointer<Void>} pvPara A structure determined by the value of <i>pszUrlOid</i>. For details, see the description for the <i>pszUrlOid</i> parameter.
     * @param {Integer} dwFlags 
     * @param {Pointer<CRYPT_URL_ARRAY>} pUrlArray A pointer to a buffer to receive the data for the value entry. This parameter can be <b>NULL</b> to find the length of the buffer required to hold the data. 
     * 
     * 
     * For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbUrlArray A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pUrlArray</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer. This parameter can be <b>NULL</b> only if <i>pUrlArray</i> is <b>NULL</b>.
     * @param {Pointer<CRYPT_URL_INFO>} pUrlInfo An optional pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_url_info">CRYPT_URL_INFO</a> structure that receives the data for the value entry.
     * @param {Pointer<UInt32>} pcbUrlInfo A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pUrlArray</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications must use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data will fit in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptgetobjecturl
     * @since windows5.1.2600
     */
    static CryptGetObjectUrl(pszUrlOid, pvPara, dwFlags, pUrlArray, pcbUrlArray, pUrlInfo, pcbUrlInfo) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPTNET.dll\CryptGetObjectUrl", "ptr", pszUrlOid, "ptr", pvPara, "uint", dwFlags, "ptr", pUrlArray, "ptr", pcbUrlArray, "ptr", pUrlInfo, "ptr", pcbUrlInfo, "ptr", pvReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Builds a self-signed certificate and returns a pointer to a CERT_CONTEXT structure that represents the certificate.
     * @remarks
     * As the pEndTime must be a valid date, and is automatically generated if it is not supplied by the user, unexpected failures may easily be caused when this API is called on a leap day without accompanying app logic to compensate. For more information, please see [leap year readiness](https://techcommunity.microsoft.com/t5/azure-developer-community-blog/it-s-2020-is-your-code-ready-for-leap-day/ba-p/1157279).
     * @param {Pointer} hCryptProvOrNCryptKey A handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic provider</a> used to sign the certificate created. If <b>NULL</b>, information from the <i>pKeyProvInfo</i> parameter is used to acquire the needed handle. If <i>pKeyProvInfo</i> is also <b>NULL</b>, the default provider type, PROV_RSA_FULL provider type, the default key specification, AT_SIGNATURE, and a newly created <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a> with a unique container name are used.
     * 
     * This handle must be an <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/hcryptprov">HCRYPTPROV</a> handle that has been created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a> function or an <b>NCRYPT_KEY_HANDLE</b> handle that has been created by using the <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/nf-ncrypt-ncryptopenkey">NCryptOpenKey</a> function. New applications should always pass in the <b>NCRYPT_KEY_HANDLE</b> handle of a CNG <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cryptographic service provider</a> (CSP).
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pSubjectIssuerBlob A pointer to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a> that contains the distinguished name (DN) for the certificate subject. This parameter cannot be <b>NULL</b>. Minimally, a pointer to an empty DN must be provided. This BLOB is normally created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certstrtonamea">CertStrToName</a> function. It can also be created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptencodeobject">CryptEncodeObject</a> function and specifying either the X509_NAME or X509_UNICODE_NAME <i>StructType</i>.
     * @param {Integer} dwFlags 
     * @param {Pointer<CRYPT_KEY_PROV_INFO>} pKeyProvInfo A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a> structure. Before a certificate is created, the CSP is queried for the key provider, key provider type, and the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/k-gly">key container</a> name. If the CSP queried does not support these queries, the function fails. If the default provider does not support these queries, a <i>pKeyProvInfo</i> value must be specified. The RSA BASE does support these queries.
     * 
     * If the <i>pKeyProvInfo</i> parameter is not <b>NULL</b>, the corresponding values are set in the <b>CERT_KEY_PROV_INFO_PROP_ID</b> value of the generated certificate. You must ensure that all parameters of the supplied structure are correctly specified.
     * @param {Pointer<CRYPT_ALGORITHM_IDENTIFIER>} pSignatureAlgorithm A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_algorithm_identifier">CRYPT_ALGORITHM_IDENTIFIER</a> structure. If <b>NULL</b>, the default algorithm, SHA1RSA, is used.
     * @param {Pointer<SYSTEMTIME>} pStartTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure. If <b>NULL</b>, the system current time is used by default.
     * @param {Pointer<SYSTEMTIME>} pEndTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-systemtime">SYSTEMTIME</a> structure. If <b>NULL</b>, the <i>pStartTime</i> value plus one year will be used by default.
     * @param {Pointer<CERT_EXTENSIONS>} pExtensions A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_extensions">CERT_EXTENSIONS</a> array of <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_extension">CERT_EXTENSION</a> structures. By default, the array is empty. An alternate subject name, if desired, can be specified as one of these extensions.
     * @returns {Pointer<CERT_CONTEXT>} If the function succeeds, a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">PCCERT_CONTEXT</a> variable that points to the created certificate is returned. If the function fails, it returns <b>NULL</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certcreateselfsigncertificate
     * @since windows5.1.2600
     */
    static CertCreateSelfSignCertificate(hCryptProvOrNCryptKey, pSubjectIssuerBlob, dwFlags, pKeyProvInfo, pSignatureAlgorithm, pStartTime, pEndTime, pExtensions) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertCreateSelfSignCertificate", "ptr", hCryptProvOrNCryptKey, "ptr", pSubjectIssuerBlob, "uint", dwFlags, "ptr", pKeyProvInfo, "ptr", pSignatureAlgorithm, "ptr", pStartTime, "ptr", pEndTime, "ptr", pExtensions, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptGetKeyIdentifierProperty acquires a specific property from a specified key identifier.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pKeyIdentifier A pointer to the 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a> that contains the key identifier.
     * @param {Integer} dwPropId Identifies the property to retrieve. The value of <i>dwPropId</i> determines the type and content of the <i>pvData</i> parameter. Any certificate property ID can be used.
     * @param {Integer} dwFlags The following flags can be used. They can be combined with a bitwise-<b>OR</b> operation. 
     * 
     * 
     * 
     * 
     * 					
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_KEYID_MACHINE_FLAG"></a><a id="crypt_keyid_machine_flag"></a><dl>
     * <dt><b>CRYPT_KEYID_MACHINE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Search the list of key identifiers of the LocalMachine (if <i>pwszComputerName</i> is <b>NULL</b>) or remote computer (if <i>pwszComputerName</i> is not <b>NULL</b>). For more information, see <i>pwszComputerName</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_KEYID_ALLOC_FLAG"></a><a id="crypt_keyid_alloc_flag"></a><dl>
     * <dt><b>CRYPT_KEYID_ALLOC_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>LocalAlloc()</b> function is called to allocate memory for <i>pvData</i>. *<i>pvData</i> is updated with a pointer to the allocated memory. <b>LocalFree()</b> must be called to free the allocated memory.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} pwszComputerName A pointer to the name of a remote computer to be searched. If CRYPT_KEYID_MACHINE_FLAG flag is set, searches the remote computer for a list of key identifiers. If the local computer is to be searched and not a remote computer, set <i>pwszComputerName</i> to <b>NULL</b>.
     * @param {Pointer<Void>} pvData A pointer to a buffer to receive the data as determined by <i>dwPropId</i>. Elements pointed to by fields in the <i>pvData</i> structure follow the structure. Therefore, the size contained in <i>pcbData</i> can exceed the size of the structure. 
     * 
     * 
     * 
     * 
     * If <i>dwPropId</i> is CERT_KEY_PROV_INFO_PROP_ID, <i>pvData</i> points to a CRYPT_KEY_PROV_INFO structure that contains the property of the key identifier.
     * 
     * If <i>dwPropId</i> is not CERT_KEY_PROV_INFO_PROP_ID, <i>pvData</i> points to an array of bytes that contains the property of the key identifier.
     * 
     * To get the size of this information for memory allocation purposes, this parameter can be <b>NULL</b> when the CRYPT_KEYID_ALLOC_FLAG is not set. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * 
     * When the CRYPT_KEYID_ALLOC_FLAG is set, <i>pvData</i> is the address of a pointer to the buffer that will be updated. Because memory is allocated and its pointer is stored at *<i>pvData</i>, <i>pvData</i> must not be <b>NULL</b>.
     * @param {Pointer<UInt32>} pcbData A pointer to a <b>DWORD</b> that contains the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer. The size contained in the variable pointed to by <i>pcbData</i> can indicate a size larger than the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a> structure because the structure can contain pointers to auxiliary data. This size is the sum of the size needed by the structure and all auxiliary data. 
     * 
     * 
     * 
     * 
     * When the CRYPT_KEYID_ALLOC_FLAG is set, <i>pcbData</i> is the address of a pointer to the <b>DWORD</b> that will be updated.
     * 
     * <div class="alert"><b>Note</b>  When processing the data returned in the buffer, applications need to use the actual size of the data returned. The actual size can be slightly smaller than the size of the buffer specified on input. On input, buffer sizes are usually specified large enough to ensure that the largest possible output data fits in the buffer. On output, the variable pointed to by this parameter is updated to reflect the actual size of the data copied to the buffer.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptgetkeyidentifierproperty
     * @since windows5.1.2600
     */
    static CryptGetKeyIdentifierProperty(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvData, pcbData) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptGetKeyIdentifierProperty", "ptr", pKeyIdentifier, "uint", dwPropId, "uint", dwFlags, "ptr", pwszComputerName, "ptr", pvReserved, "ptr", pvData, "ptr", pcbData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptSetKeyIdentifierProperty function sets the property of a specified key identifier. This function can set the property on the computer identified in pwszComputerName.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pKeyIdentifier A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a> containing the key identifier.
     * @param {Integer} dwPropId Identifies the property to be set. The value of <i>dwPropId</i> determines the type and content of the <i>pvData</i> parameter. Any certificate property ID can be used. CERT_KEY_PROV_INFO_PROP_ID is the property of most interest.
     * @param {Integer} dwFlags The following flags can be set. They can be combined with a bitwise-<b>OR</b> operation.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_KEYID_MACHINE_FLAG"></a><a id="crypt_keyid_machine_flag"></a><dl>
     * <dt><b>CRYPT_KEYID_MACHINE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the property of the LocalMachine (if <i>pwszComputerName</i> is <b>NULL</b>) or remote computer (if <i>pwszComputerName</i> is not <b>NULL</b>). For more information, see <i>pwszComputerName</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_KEYID_DELETE_FLAG"></a><a id="crypt_keyid_delete_flag"></a><dl>
     * <dt><b>CRYPT_KEYID_DELETE_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The key identifier and all of its properties are deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_KEYID_SET_NEW_FLAG"></a><a id="crypt_keyid_set_new_flag"></a><dl>
     * <dt><b>CRYPT_KEYID_SET_NEW_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets a new key identifier property. If the property already exists, the attempt fails, and <b>FALSE</b> is returned with the last error code set to CRYPT_E_EXISTS.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} pwszComputerName A pointer to a <b>null</b>-terminated string that contains the name of a remote computer that has the key identifier where the properties are set. If CRYPT_KEYID_MACHINE_FLAG flag is set, searches the remote computer for a list of key identifiers. If the local computer is to be set and not a remote computer, set <i>pwszComputerName</i> to <b>NULL</b>.
     * @param {Pointer<Void>} pvData If <i>dwPropId</i> is CERT_KEY_PROV_INFO_PROP_ID, <i>pvData</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_key_prov_info">CRYPT_KEY_PROV_INFO</a> structure containing the property of the key identifier. 
     * 
     * 
     * 
     * 
     * If <i>dwPropId</i> is not CERT_KEY_PROV_INFO_PROP_ID, <i>pvData</i> points to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure containing the property of the key identifier.
     * 
     * Setting <i>pvData</i> to <b>NULL</b> deletes the property.
     * @returns {Integer} If the function succeeds, the return value is nonzero (TRUE).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  If CRYPT_KEYID_SET_NEW_FLAG is set and the property already exists, <b>FALSE</b> is returned with the last error code set to CRYPT_E_EXISTS.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptsetkeyidentifierproperty
     * @since windows5.1.2600
     */
    static CryptSetKeyIdentifierProperty(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvData) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptSetKeyIdentifierProperty", "ptr", pKeyIdentifier, "uint", dwPropId, "uint", dwFlags, "ptr", pwszComputerName, "ptr", pvReserved, "ptr", pvData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CryptEnumKeyIdentifierProperties function enumerates key identifiers and their properties.
     * @remarks
     * A key identifier can have the same properties as a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate context</a>.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pKeyIdentifier A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_HASH_BLOB</a> structure that contains the key identifier. 
     * 
     * 
     * 
     * 
     * If <i>pKeyIdentifier</i> is <b>NULL</b>, the function enumerates all key identifiers.
     * 
     * If <i>pKeyIdentifier</i> is not <b>NULL</b>, the callback function <i>pfnEnum</i> is only called for the specified key identifier.
     * @param {Integer} dwPropId Indicates the property identifier to be listed. 
     * 
     * 
     * 
     * 
     * If <i>dwPropId</i> is set to zero, this function calls the callback function with all the properties.
     * 
     * If <i>dwPropId</i> is not zero and <i>pKeyIdentifier</i> is <b>NULL</b>, the callback function is called only for those key identifiers that have the specified property (sets the <i>cProp</i> parameter of <i>pfnEnum</i> to one). All key identifiers that do not have the property are skipped.
     * 
     * Any certificate property identifier can be used.
     * @param {Integer} dwFlags By default, the list of key identifiers for the CurrentUser is searched. If CRYPT_KEYID_MACHINE_FLAG is set, the list of key identifiers of the LocalMachine (if <i>pwszComputerName</i> is <b>NULL</b>) or of a remote computer (if <i>pwszComputerName</i> is not <b>NULL</b>) is searched. For more information, see <i>pwszComputerName</i>.
     * @param {Pointer<PWSTR>} pwszComputerName A pointer to the name of a remote computer to be searched. If CRYPT_KEYID_MACHINE_FLAG is set in <i>dwFlags</i>, the remote computer is searched for a list of key identifiers. If the local computer is to be searched and not a remote computer, <i>pwszComputerName</i> is set to <b>NULL</b>.
     * @param {Pointer<Void>} pvArg A pointer to data to be passed to the callback function. The type is a void that allows the application to declare, define, and initialize a structure or argument to hold any information.
     * @param {Pointer<PFN_CRYPT_ENUM_KEYID_PROP>} pfnEnum A pointer to an application-defined callback function that is executed for each key identifier entry that matches the input parameters. For details about the callback functions parameters, see <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nc-wincrypt-pfn_crypt_enum_keyid_prop">CRYPT_ENUM_KEYID_PROP</a>.
     * @returns {Integer} The <b>CryptEnumKeyIdentifierProperties</b> function repeatedly calls the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nc-wincrypt-pfn_crypt_enum_keyid_prop">CRYPT_ENUM_KEYID_PROP</a> callback function until the last key identifier is enumerated or the callback function returns <b>FALSE</b>.
     * 
     * If the main function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * To continue enumeration, the function returns <b>TRUE</b>.
     * 
     * To stop enumeration, the function returns <b>FALSE</b> and sets the last error code.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptenumkeyidentifierproperties
     * @since windows5.1.2600
     */
    static CryptEnumKeyIdentifierProperties(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvArg, pfnEnum) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptEnumKeyIdentifierProperties", "ptr", pKeyIdentifier, "uint", dwPropId, "uint", dwFlags, "ptr", pwszComputerName, "ptr", pvReserved, "ptr", pvArg, "ptr", pfnEnum, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Important  This API is deprecated. (CryptCreateKeyIdentifierFromCSP)
     * @param {Integer} dwCertEncodingType Specifies the encoding type used. It is always acceptable to specify both the certificate and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding types</a> by combining them with a bitwise-<b>OR</b> operation as shown in the following example:
     * 
     * X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
     * 
     * Currently defined encoding types are:
     * 
     * <ul>
     * <li>X509_ASN_ENCODING</li>
     * <li>PKCS_7_ASN_ENCODING</li>
     * </ul>
     * @param {Pointer<PSTR>} pszPubKeyOID A pointer to the public key <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID). A value that is not <b>NULL</b> overrides the default OID obtained from the <b>aiKeyAlg</b> member of the structure pointed to by <i>pPubKeyStruc</i>. To use the default OID, set <i>pszPubKeyOID</i> to <b>NULL</b>.
     * @param {Pointer<PUBLICKEYSTRUC>} pPubKeyStruc A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-publickeystruc">PUBLICKEYSTRUC</a> structure. In the default case, the <b>aiKeyAlg</b> member of the structure pointed to by <i>pPubKeyStruc</i> is used to find the public key OID. When the value of <i>pszPubKeyOID</i> is not <b>NULL</b>, it overrides the default.
     * @param {Integer} cbPubKeyStruc The size, in bytes, of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-publickeystruc">PUBLICKEYSTRUC</a>.
     * @param {Integer} dwFlags Reserved for future use and must be zero.
     * @param {Pointer<Byte>} pbHash A pointer to a buffer to receive the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> of the public key and the key identifier.
     * 
     * To get the size of this information for memory allocation purposes, set this parameter to <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/retrieving-data-of-unknown-length">Retrieving Data of Unknown Length</a>.
     * @param {Pointer<UInt32>} pcbHash A pointer to a <b>DWORD</b> that specifies the size, in bytes, of the buffer pointed to by the <i>pbHash</i> parameter. When the function returns, the <b>DWORD</b> contains the number of bytes stored in the buffer. Using SHA1 hashing, the length of the required buffer is twenty.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptcreatekeyidentifierfromcsp
     * @since windows5.1.2600
     */
    static CryptCreateKeyIdentifierFromCSP(dwCertEncodingType, pszPubKeyOID, pPubKeyStruc, cbPubKeyStruc, dwFlags, pbHash, pcbHash) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptCreateKeyIdentifierFromCSP", "uint", dwCertEncodingType, "ptr", pszPubKeyOID, "ptr", pPubKeyStruc, "uint", cbPubKeyStruc, "uint", dwFlags, "ptr", pvReserved, "ptr", pbHash, "ptr", pcbHash, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertCreateCertificateChainEngine function creates a new, nondefault chain engine for an application.
     * @param {Pointer<CERT_CHAIN_ENGINE_CONFIG>} pConfig A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_engine_config">CERT_CHAIN_ENGINE_CONFIG</a> data structure that specifies the parameters for the chain engine.
     * @param {Pointer<HCERTCHAINENGINE>} phChainEngine A pointer to the handle of the chain engine created. When you have finished using the chain engine, release the chain engine by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatechainengine">CertFreeCertificateChainEngine</a> function.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The <i>phChainEngine</i> parameter returns the chain engine handle.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certcreatecertificatechainengine
     * @since windows5.1.2600
     */
    static CertCreateCertificateChainEngine(pConfig, phChainEngine) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertCreateCertificateChainEngine", "ptr", pConfig, "ptr", phChainEngine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertFreeCertificateChainEngine function frees a certificate trust engine.
     * @param {Pointer<HCERTCHAINENGINE>} hChainEngine Handle of the chain engine to be freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certfreecertificatechainengine
     * @since windows5.1.2600
     */
    static CertFreeCertificateChainEngine(hChainEngine) {
        DllCall("CRYPT32.dll\CertFreeCertificateChainEngine", "ptr", hChainEngine)
    }

    /**
     * Resyncs the certificate chain engine, which resynchronizes the stores the store's engine and updates the engine caches.
     * @param {Pointer<HCERTCHAINENGINE>} hChainEngine The chain engine to resynchronize.
     * @returns {Integer} If the function succeeds, the function returns nonzero.
     * 
     * If the function fails, it returns zero. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certresynccertificatechainengine
     * @since windows10.0.10240
     */
    static CertResyncCertificateChainEngine(hChainEngine) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertResyncCertificateChainEngine", "ptr", hChainEngine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Builds a certificate chain context starting from an end certificate and going back, if possible, to a trusted root certificate.
     * @remarks
     * When an application requests a certificate chain, the structure returned is in the form of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a>. This context contains an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_simple_chain">CERT_SIMPLE_CHAIN</a> structures where each simple chain goes from an end certificate to a self-signed certificate. The chain context connects simple chains through trust lists. Each simple chain contains the chain of certificates, summary trust information about the chain, and trust information about each certificate element in the chain.
     * 
     * The following remarks apply to strong signature checking:<ul>
     * <li>
     * You can enable strong signature checking for this function by setting the <b>pStrongSignPara</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_para">CERT_CHAIN_PARA</a> structure that is pointed to by the  <i>pChainPara</i> parameter.
     * 
     * </li>
     * <li>
     * If a certificate without a strong signature is found in the chain, the <b>CERT_TRUST_HAS_WEAK_SIGNATURE</b> and <b>CERT_TRUST_IS_NOT_SIGNATURE_VALID</b> errors are set in the <b>dwErrorStatus</b> field of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_trust_status">CERT_TRUST_STATUS</a> structure. The <i>ppChainContext</i> parameter points to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> structure which, in turn, points to the  <b>CERT_TRUST_STATUS</b> structure.
     * 
     * </li>
     * <li>
     * If the chain is strong signed, the public key in the end certificate is checked to determine whether it  satisfies the minimum public key length requirements for a strong signature.  If the condition is not satisfied, the <b>CERT_TRUST_HAS_WEAK_SIGNATURE</b> and <b>CERT_TRUST_IS_NOT_SIGNATURE_VALID</b> errors are set in the <b>dwErrorStatus</b> field of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_trust_status">CERT_TRUST_STATUS</a> structure. To disable checking the key length, set the <b>CERT_CHAIN_STRONG_SIGN_DISABLE_END_CHECK_FLAG</b> value in the <b>dwStrongSignFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_para">CERT_CHAIN_PARA</a> structure pointed to by the  <i>pChainPara</i> parameter.
     * 
     * </li>
     * <li>
     * If the <b>CERT_STRONG_SIGN_ENABLE_CRL_CHECK</b> or <b>CERT_STRONG_SIGN_ENABLE_OCSP_CHECK</b> flags are set in the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_strong_sign_serialized_info">CERT_STRONG_SIGN_SERIALIZED_INFO</a> structure and a CRL or OCSP response is found without a strong signature, the CRL or OCSP response will be treated as being offline. That is, the <b>CERT_TRUST_IS_OFFLINE_REVOCATION</b> and <b>CERT_TRUST_REVOCATION_STATUS_UNKNOWN</b> errors are set in the <b>dwErrorStatus</b> field of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_trust_status">CERT_TRUST_STATUS</a> structure. Also, the <b>dwRevocationResult</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_revocation_info">CERT_REVOCATION_INFO</a> structure is set to <b>NTE_BAD_ALGID</b>.  
     * 
     * </li>
     * </ul>
     * @param {Pointer<HCERTCHAINENGINE>} hChainEngine A handle of the chain engine (namespace and cache) to be used. If <i>hChainEngine</i> is <b>NULL</b>, the default chain engine, HCCE_CURRENT_USER, is used. This parameter can be set to HCCE_LOCAL_MACHINE.
     * @param {Pointer<CERT_CONTEXT>} pCertContext A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> of the end certificate, the certificate for which a chain is being built. This certificate context will be the zero-index element in the first simple chain.
     * @param {Pointer<FILETIME>} pTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> variable that indicates the time for which the chain is to be validated. Note that the time does not affect trust list, revocation, or root store checking. The current system time is used if <b>NULL</b> is passed to this parameter. Trust in a particular certificate being a trusted root is based on the current <a href="https://docs.microsoft.com/windows/desktop/SecGloss/s-gly">state</a> of the root store and not the state of the root store at a time passed in by this parameter. For revocation, a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate revocation list</a> (CRL), itself, must be valid at the current time. The value of this parameter is used to determine whether a certificate listed in a CRL has been revoked.
     * @param {Pointer<HCERTSTORE>} hAdditionalStore A handle to any additional store to search for supporting certificates and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate trust lists</a> (CTLs). This parameter can be <b>NULL</b> if no additional store is to be searched.
     * @param {Pointer<CERT_CHAIN_PARA>} pChainPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_para">CERT_CHAIN_PARA</a> structure that includes chain-building parameters.
     * @param {Integer} dwFlags Flag values that indicate special processing. This parameter can be a combination of one or more of the  following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_CACHE_END_CERT"></a><a id="cert_chain_cache_end_cert"></a><dl>
     * <dt><b>CERT_CHAIN_CACHE_END_CERT</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When this flag is set, the end certificate is cached, which might speed up the chain-building process. By default, the end certificate is not cached, and it would need to be verified each time a chain is built for it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY"></a><a id="cert_chain_revocation_check_cache_only"></a><dl>
     * <dt><b>CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY</b></dt>
     * <dt>0x80000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Revocation checking only accesses cached URLs.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_REVOCATION_CHECK_OCSP_CERT"></a><a id="cert_chain_revocation_check_ocsp_cert"></a><dl>
     * <dt><b>CERT_CHAIN_REVOCATION_CHECK_OCSP_CERT</b></dt>
     * <dt>0x04000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is used internally during chain building for an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">online certificate status protocol</a> (OCSP) signer certificate to prevent cyclic revocation checks. During chain building, if the OCSP response is signed by an independent OCSP signer, then, in addition to the original chain build, there is a second chain built for the OCSP signer certificate itself. This flag is used during this second chain build to inhibit a recursive independent OCSP signer certificate. If the signer certificate contains the
     * <b>szOID_PKIX_OCSP_NOCHECK</b> extension, revocation checking is skipped
     * for the leaf signer certificate. Both OCSP and CRL checking are allowed.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL"></a><a id="cert_chain_cache_only_url_retrieval"></a><dl>
     * <dt><b>CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uses only cached URLs in building a certificate chain. The Internet and intranet are not searched for URL-based objects. 
     * 
     * <b>Note</b>  This flag is not applicable to revocation checking. Set CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY to use only cached URLs for revocation checking.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING"></a><a id="cert_chain_disable_pass1_quality_filtering"></a><dl>
     * <dt><b>CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING</b></dt>
     * <dt>0x00000040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For performance reasons, the second pass of chain building only considers potential chain paths that have quality greater than or equal to the highest quality determined during the first pass. The first pass only considers valid signature, complete chain, and trusted roots to calculate chain quality. This flag can be set to disable this optimization and consider all potential chain paths during the second pass.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_DISABLE_MY_PEER_TRUST"></a><a id="cert_chain_disable_my_peer_trust"></a><dl>
     * <dt><b>CERT_CHAIN_DISABLE_MY_PEER_TRUST</b></dt>
     * <dt>0x00000800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is not supported. Certificates in the "My" store are never considered for peer trust.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_ENABLE_PEER_TRUST"></a><a id="cert_chain_enable_peer_trust"></a><dl>
     * <dt><b>CERT_CHAIN_ENABLE_PEER_TRUST</b></dt>
     * <dt>0x00000400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * End entity certificates in the "TrustedPeople" store are trusted without performing any chain building. This function does not set the <b>CERT_TRUST_IS_PARTIAL_CHAIN</b> or <b>CERT_TRUST_IS_UNTRUSTED_ROOT</b> <b>dwErrorStatus</b> member bits of the  <i>ppChainContext</i> parameter.
     * 
     * <b>
     *                     Windows Server 2003
     *                     Windows XP
     *                   :  </b>This flag is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_OPT_IN_WEAK_SIGNATURE"></a><a id="cert_chain_opt_in_weak_signature"></a><dl>
     * <dt><b>CERT_CHAIN_OPT_IN_WEAK_SIGNATURE</b></dt>
     * <dt>0x00010000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Setting this flag indicates the caller wishes to opt into weak signature checks.
     * 
     * This flag is available in the rollup update for each OS starting with Windows 7 and Windows Server 2008 R2.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS"></a><a id="cert_chain_return_lower_quality_contexts"></a><dl>
     * <dt><b>CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS</b></dt>
     * <dt>0x00000080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The default is to return only the highest quality chain path. Setting this flag will return the lower quality chains. These are returned in the <b>cLowerQualityChainContext</b> and <b>rgpLowerQualityChainContext</b> fields of the chain context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE"></a><a id="cert_chain_disable_auth_root_auto_update"></a><dl>
     * <dt><b>CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE</b></dt>
     * <dt>0x00000100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Setting this flag inhibits the auto update of third-party roots from the Windows Update Web Server.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT"></a><a id="cert_chain_revocation_accumulative_timeout"></a><dl>
     * <dt><b>CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT</b></dt>
     * <dt>0x08000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When you set CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT and you also specify a value for the <i>dwUrlRetrievalTimeout</i> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_para">CERT_CHAIN_PARA</a> structure, the value you specify in <i>dwUrlRetrievalTimeout</i> represents the cumulative timeout across all revocation URL retrievals.
     * 
     * If you set CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT but do not specify a <i>dwUrlRetrievalTimeout</i> value, the maximum cumulative timeout is set, by default, to 20 seconds. Each URL tested will timeout after half of the remaining cumulative balance has passed. That is, the first URL times out after 10 seconds, the second after 5 seconds, the third after 2.5 seconds and so on until a URL succeeds, 20 seconds has passed, or there are no more URLs to test.
     * 
     * If you do not set CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT, each revocation URL in the chain is assigned a maximum timeout equal to the value specified in <i>dwUrlRetrievalTimeout</i>. If you do not specify a value for the <i>dwUrlRetrievalTimeout</i> member, each revocation URL is assigned a maximum default timeout of 15 seconds.  If no URL succeeds, the maximum cumulative timeout value is 15 seconds multiplied by the number of URLs in the chain.
     * 
     * You can set the default values by using Group Policy.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_TIMESTAMP_TIME"></a><a id="cert_chain_timestamp_time"></a><dl>
     * <dt><b>CERT_CHAIN_TIMESTAMP_TIME</b></dt>
     * <dt>0x00000200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When this flag is set, <i>pTime</i> is used as the time stamp time to determine whether the end certificate was time valid. Current time can also be used to determine whether the end certificate remains time valid. All other <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certification authority</a> (CA) and root certificates in the chain are checked by using current time and not <i>pTime</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_DISABLE_AIA"></a><a id="cert_chain_disable_aia"></a><dl>
     * <dt><b>CERT_CHAIN_DISABLE_AIA</b></dt>
     * <dt>0x00002000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Setting this flag explicitly turns off  Authority Information Access (AIA) retrievals.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * You can also set the following revocation flags, but only one flag from this group may be set at a time.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_REVOCATION_CHECK_END_CERT"></a><a id="cert_chain_revocation_check_end_cert"></a><dl>
     * <dt><b>CERT_CHAIN_REVOCATION_CHECK_END_CERT</b></dt>
     * <dt>0x10000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Revocation checking is done on the end certificate and only the end certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_REVOCATION_CHECK_CHAIN"></a><a id="cert_chain_revocation_check_chain"></a><dl>
     * <dt><b>CERT_CHAIN_REVOCATION_CHECK_CHAIN</b></dt>
     * <dt>0x20000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Revocation checking is done on all of the certificates in every chain.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT"></a><a id="cert_chain_revocation_check_chain_exclude_root"></a><dl>
     * <dt><b>CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT</b></dt>
     * <dt>0x40000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Revocation checking is done on all certificates in all of the chains except the root certificate.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CERT_CHAIN_CONTEXT>} ppChainContext The address of a pointer to the chain context created. When you have finished using the chain context, release the chain by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatechain">CertFreeCertificateChain</a> function.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns  zero (<b>FALSE</b>). For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certgetcertificatechain
     * @since windows5.1.2600
     */
    static CertGetCertificateChain(hChainEngine, pCertContext, pTime, hAdditionalStore, pChainPara, dwFlags, ppChainContext) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertGetCertificateChain", "ptr", hChainEngine, "ptr", pCertContext, "ptr", pTime, "ptr", hAdditionalStore, "ptr", pChainPara, "uint", dwFlags, "ptr", pvReserved, "ptr", ppChainContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CertFreeCertificateChain function frees a certificate chain by reducing its reference count. If the reference count becomes zero, memory allocated for the chain is released.
     * @param {Pointer<CERT_CHAIN_CONTEXT>} pChainContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> certificate chain context to be freed. If the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/r-gly">reference count</a> on the context reaches zero, the storage allocated for the context is freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certfreecertificatechain
     * @since windows5.1.2600
     */
    static CertFreeCertificateChain(pChainContext) {
        DllCall("CRYPT32.dll\CertFreeCertificateChain", "ptr", pChainContext)
    }

    /**
     * The CertDuplicateCertificateChain function duplicates a pointer to a certificate chain by incrementing the chain's reference count.
     * @param {Pointer<CERT_CHAIN_CONTEXT>} pChainContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> chain context to be duplicated.
     * @returns {Pointer<CERT_CHAIN_CONTEXT>} If the function succeeds, a pointer is returned to the chain context. This pointer has the same value as the <i>pChainContext</i> passed into the function. When you have finished using the chain context, release the chain context by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatechain">CertFreeCertificateChain</a> function.
     * 
     * If the function fails, <b>NULL</b> is returned.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certduplicatecertificatechain
     * @since windows5.1.2600
     */
    static CertDuplicateCertificateChain(pChainContext) {
        result := DllCall("CRYPT32.dll\CertDuplicateCertificateChain", "ptr", pChainContext, "ptr")
        return result
    }

    /**
     * Finds the first or next certificate in a store that meets the specified criteria.
     * @remarks
     * The <i>pPrevChainContext</i> parameter must be <b>NULL</b> on the first call to build the chain context. To build the next chain context, the <i>pPrevChainContext</i> is set to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> structure returned by a previous call. If <i>pPrevChainContext</i> is not <b>NULL</b>, the structure is always freed by this function by using the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatechain">CertFreeCertificateChain</a> function, even if an error occurs.
     * @param {Pointer<HCERTSTORE>} hCertStore The handle of the store to be searched for a certificate upon which a chain is built. This handle is passed as an additional store to 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatechain">CertGetCertificateChain</a> function as the chain is built.
     * @param {Integer} dwCertEncodingType The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate encoding type</a>   that was used to encode the store. The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">message encoding type</a> identifier, contained in the high <b>WORD</b> of this value, is ignored by this function.
     * 
     * 
     * This parameter can be the following currently defined certificate encoding type.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="X509_ASN_ENCODING"></a><a id="x509_asn_encoding"></a><dl>
     * <dt><b>X509_ASN_ENCODING</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies X.509 certificate encoding.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwFindFlags Contains additional options for the search. The possible values for this parameter depend on the value of the <i>dwFindType</i> parameter.
     * @param {Integer} dwFindType Determines what criteria to use to find a certificate in the store.
     * 
     * 
     * This parameter can be the following currently defined value.
     * @param {Pointer<Void>} pvFindPara A pointer that contains additional search criteria. The type and format of the data this parameter points to depends on the value of the <i>dwFindType</i> parameter.
     * @param {Pointer<CERT_CHAIN_CONTEXT>} pPrevChainContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> structure returned from a previous call to this function. The search is begun from this certificate. For the first call to this function, this parameter must be <b>NULL</b>. In subsequent calls, it is the pointer returned by the previous call to the function.  If this parameter is not <b>NULL</b>, this function will free this structure.
     * @returns {Pointer<CERT_CHAIN_CONTEXT>} If the first or next chain context is not built, <b>NULL</b> is returned. Otherwise, a pointer to a read-only <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> structure is returned. The <b>CERT_CHAIN_CONTEXT</b> structure is freed when passed as the <i>pPrevChainContext</i> parameter on a subsequent call to this function. Otherwise, the <b>CERT_CHAIN_CONTEXT</b> structure must be freed explicitly by calling 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatechain">CertFreeCertificateChain</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certfindchaininstore
     * @since windows5.1.2600
     */
    static CertFindChainInStore(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevChainContext) {
        result := DllCall("CRYPT32.dll\CertFindChainInStore", "ptr", hCertStore, "uint", dwCertEncodingType, "uint", dwFindFlags, "uint", dwFindType, "ptr", pvFindPara, "ptr", pPrevChainContext, "ptr")
        return result
    }

    /**
     * Checks a certificate chain to verify its validity, including its compliance with any specified validity policy criteria.
     * @remarks
     * A <b>dwError</b> member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_policy_status">CERT_CHAIN_POLICY_STATUS</a> structure pointed to by <i>pPolicyStatus</i> can apply to a single chain element, to a simple chain, or to an entire chain context. If <b>dwError</b> applies to the entire chain context, both the <b>lChainIndex</b> and the <b>lElementIndex</b> members of the <b>CERT_CHAIN_POLICY_STATUS</b> structure are set to –1. If <b>dwError</b> applies to a complete simple chain, <b>lElementIndex</b> is set to –1 and <b>lChainIndex</b> is set to the index of the first chain that has an error. If <b>dwError</b> applies to a single certificate element, <b>lChainIndex</b> and <b>lElementIndex</b> index the first certificate that has the error. 
     * 
     * To get the certificate element use this syntax: 
     * 
     * <c>pChainContext-&gt;rgpChain[lChainIndex]-&gt;rgpElement[lElementIndex];</c>
     * 
     * Use the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatechain">CertGetCertificateChain</a> function to enable and perform certificate revocation checking.  The <b>CertVerifyCertificateChainPolicy</b> function does not check if certificates in the certificate chain are revoked.
     * @param {Pointer<PSTR>} pszPolicyOID Current predefined verify chain policy structures are listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_BASE"></a><a id="cert_chain_policy_base"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_BASE</b></dt>
     * <dt>(LPCSTR) 1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Implements the base chain policy verification checks. The <b>dwFlags</b> member of the structure pointed to by <i>pPolicyPara</i> can be set to alter the default policy checking behavior.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_AUTHENTICODE"></a><a id="cert_chain_policy_authenticode"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_AUTHENTICODE</b></dt>
     * <dt>(LPCSTR) 2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Implements the Authenticode chain policy verification checks. The <b>pvExtraPolicyPara</b> member of the structure pointed to by <i>pPolicyPara</i> can be set to point to an 
     * <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-authenticode_extra_cert_chain_policy_para">AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA</a> structure.
     * 
     * The <b>pvExtraPolicyStatus</b> member of the structure pointed to by <i>pPolicyStatus</i> can be set to point to an <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-authenticode_extra_cert_chain_policy_status">AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_AUTHENTICODE_TS"></a><a id="cert_chain_policy_authenticode_ts"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_AUTHENTICODE_TS</b></dt>
     * <dt>(LPCSTR) 3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Implements Authenticode Time Stamp chain policy verification checks. The <b>pvExtraPolicyPara</b> member of the data structure pointed to by <i>pPolicyPara</i> can be set to point to an <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-authenticode_ts_extra_cert_chain_policy_para">AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA</a> structure.
     * 
     * The <b>pvExtraPolicyStatus</b> member of the data structure pointed to by <i>pPolicyStatus</i> is not used and must be set to <b>NULL</b>
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_SSL"></a><a id="cert_chain_policy_ssl"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_SSL</b></dt>
     * <dt>(LPCSTR) 4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Implements the SSL client/server chain policy verification checks. The <b>pvExtraPolicyPara</b> member in the data structure pointed to by <i>pPolicyPara</i> can be set to point to an <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-httpspolicycallbackdata">SSL_EXTRA_CERT_CHAIN_POLICY_PARA</a> structure initialized with additional policy criteria.
     * 
     * <div class="alert"><b>Note</b>  To differentiate between server and client authorization certificates,  the call to the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetcertificatechain">CertGetCertificateChain</a> function to get the chain context should specify the  certificate type by setting the expected usage. Set the expected usage by setting the <b>RequestedUsage</b> member of the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_para">CERT_CHAIN_PARA</a> structure passed in the <i>pChainPara</i> input parameter of the <b>CertGetCertificateChain</b> function.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_BASIC_CONSTRAINTS"></a><a id="cert_chain_policy_basic_constraints"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_BASIC_CONSTRAINTS</b></dt>
     * <dt>(LPCSTR) 5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Implements the basic constraints chain policy. Iterates through all the certificates in the chain checking for either a szOID_BASIC_CONSTRAINTS or a szOID_BASIC_CONSTRAINTS2 extension. If neither extension is present, the certificate is assumed to have valid policy. Otherwise, for the first certificate element, checks if it matches the expected CA_FLAG or END_ENTITY_FLAG specified in the <b>dwFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_policy_para">CERT_CHAIN_POLICY_PARA</a> structure pointed to by the <i>pPolicyPara</i> parameter. If neither or both flags are set, then, the first element can be either a CA or END_ENTITY. All other elements must be a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certification authority</a> (CA). If the PathLenConstraint is present in the extension, it is checked.
     * 
     * The first elements in the remaining simple chains (that is, the certificates used to sign the CTL) are checked to be an END_ENTITY. If this verification fails, <b>dwError</b> will be set to TRUST_E_BASIC_CONSTRAINTS.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_NT_AUTH"></a><a id="cert_chain_policy_nt_auth"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_NT_AUTH</b></dt>
     * <dt>(LPCSTR) 6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Implements the Windows NT Authentication chain policy, which consists of three distinct chain verifications in the following order: 
     * 
     * 
     * 
     * 
     * <ol>
     * <li>CERT_CHAIN_POLICY_BASE—Implements the base chain policy verification checks. The LOWORD of <i>dwFlags</i> can be set in <i>pPolicyPara</i> to alter the default policy checking behavior. For more information, see CERT_CHAIN_POLICY_BASE.</li>
     * <li>CERT_CHAIN_POLICY_BASIC_CONSTRAINTS—Implements the basic constraints chain policy. The HIWORD of <i>dwFlags</i> can be set to specify if the first element must be either a CA or END_ENTITY. For more information, see CERT_CHAIN_POLICY_BASIC_CONSTRAINTS.</li>
     * <li>Checks if the second element in the chain, the CA that issued the end certificate, is a trusted CA for Windows NT Authentication. A CA is considered to be trusted if it exists in the "NTAuth" system registry store found in the CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE store location. If this verification fails, the CA is untrusted, and <i>dwError</i> is set to CERT_E_UNTRUSTEDCA.If CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG is set in the <b>Flags</b> value of the <b>HKEY_LOCAL_MACHINE</b> policy <b>ProtectedRoots</b> subkey, defined by CERT_PROT_ROOT_FLAGS_REGPATH and the above check fails, the chain is checked for CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS set in <i>dwInfoStatus</i>. This is set if there was a valid name constraint for all namespaces including UPN. If the chain does not have this info status set, <i>dwError</i> is set to CERT_E_UNTRUSTEDCA.
     * 
     * </li>
     * </ol>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_MICROSOFT_ROOT"></a><a id="cert_chain_policy_microsoft_root"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_MICROSOFT_ROOT</b></dt>
     * <dt>(LPCSTR) 7</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Checks the last element of the first simple chain for a Microsoft root public key. If that element does not contain a Microsoft root public key, the <b>dwError</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_policy_status">CERT_CHAIN_POLICY_STATUS</a> structure pointed to by the <i>pPolicyStatus</i> parameter is set to <b>CERT_E_UNTRUSTEDROOT</b>.
     * 
     * The <b>dwFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_policy_para">CERT_CHAIN_POLICY_PARA</a> structure pointed to by the <i>pPolicyStatus</i> parameter can contain the <b>MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG</b> flag, which causes this function to instead check for the Microsoft application root "Microsoft Root Certificate Authority 2011".
     * 
     * The <b>dwFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_policy_para">CERT_CHAIN_POLICY_PARA</a> structure pointed to by the <i>pPolicyPara</i> parameter can contain the <b>MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG</b> flag, which causes this function to also check for the Microsoft test roots.
     * 
     * <div class="alert"><b>Note</b>  This policy <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) does not perform any policy verification checks by itself, it is meant to be used in conjunction with other policies.
     * </div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_EV"></a><a id="cert_chain_policy_ev"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_EV</b></dt>
     * <dt>(LPCSTR) 8</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies that extended validation of certificates is performed.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_CHAIN_POLICY_SSL_F12"></a><a id="cert_chain_policy_ssl_f12"></a><dl>
     * <dt><b>CERT_CHAIN_POLICY_SSL_F12</b></dt>
     * <dt>(LPCSTR) 9</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Checks if any certificates in the chain have weak crypto or if third party root certificate compliance and provide an error string. The <b>pvExtraPolicyStatus</b> member of the CERT_CHAIN_POLICY_STATUS structure pointed to by the <i>pPolicyStatus</i> parameter must point to <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-ssl_f12_extra_cert_chain_policy_status">SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS</a>, which is updated with the results of the weak crypto and root program compliance checks.
     * 
     * Before calling, the <b>cbSize</b> member of the 	CERT_CHAIN_POLICY_STATUS structure pointed to by the <i>pPolicyStatus</i> parameter must be set to a value greater than or equal to sizeof(SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS).
     * 
     * The <b>dwError</b> member in CERT_CHAIN_POLICY_STATUS structure pointed to by the <i>pPolicyStatus</i> parameter will be set to <b>TRUST_E_CERT_SIGNATURE</b> for potential weak crypto and set to <b>CERT_E_UNTRUSTEDROOT</b> for Third Party Roots not in compliance with the Microsoft Root Program. 
     * 
     * <b>Windows 10, version 1607, Windows Server 2016, Windows 10, version 1511 with KB3172985, Windows 10 RTM with KB3163912, Windows 8.1 and Windows Server 2012 R2 with KB3163912, and Windows 7 with SP1 and Windows Server 2008 R2 SP1 with KB3161029</b>
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CERT_CHAIN_CONTEXT>} pChainContext A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> structure that contains a chain to be verified.
     * @param {Pointer<CERT_CHAIN_POLICY_PARA>} pPolicyPara A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_policy_para">CERT_CHAIN_POLICY_PARA</a> structure that provides the policy verification criteria for the chain. The <b>dwFlags</b> member of that structure can be set to change the default policy checking behavior. 
     * 
     * 
     * 
     * 
     * In addition, policy-specific parameters can also be passed in the <b>pvExtraPolicyPara</b> member of the structure.
     * @param {Pointer<CERT_CHAIN_POLICY_STATUS>} pPolicyStatus A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_policy_status">CERT_CHAIN_POLICY_STATUS</a> structure where status information on the chain is returned. OID-specific extra status can be returned in the <b>pvExtraPolicyStatus</b> member of this structure.
     * @returns {Integer} The return value indicates whether the function was able to check for the policy, it does not indicate whether the policy check failed or passed. 
     * 
     * If the chain can be verified for the specified policy, <b>TRUE</b> is returned and the <b>dwError</b> member of the <i>pPolicyStatus</i> is updated. A <b>dwError</b> of 0 (ERROR_SUCCESS or S_OK) indicates the chain satisfies the specified policy.
     * 
     * If the chain cannot be validated, the return value is  <b>TRUE</b> and you need to verify the <i>pPolicyStatus</i> parameter for the actual error.
     * 
     * A value of <b>FALSE</b>  indicates that the function wasn't able to check for the policy.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certverifycertificatechainpolicy
     * @since windows5.1.2600
     */
    static CertVerifyCertificateChainPolicy(pszPolicyOID, pChainContext, pPolicyPara, pPolicyStatus) {
        result := DllCall("CRYPT32.dll\CertVerifyCertificateChainPolicy", "ptr", pszPolicyOID, "ptr", pChainContext, "ptr", pPolicyPara, "ptr", pPolicyStatus, "int")
        return result
    }

    /**
     * Converts a formatted string into an array of bytes. (ANSI)
     * @remarks
     * The
     * <b>CRYPT_STRING_BASE64HEADER</b>,
     * <b>CRYPT_STRING_BASE64REQUESTHEADER</b>,
     * and
     * <b>CRYPT_STRING_BASE64X509CRLHEADER</b>
     * flags are all treated identically by this function:
     * They attempt to parse the first block of
     * base64-encoded data between lines of the form
     * `-----BEGIN ...-----` and `-----END ...-----`.
     * The `...` portions are ignored, and they need not match.
     * If parsing is successful, the value passed in the <i>dwFlags</i> parameter
     * is returned in the <b>DWORD</b> pointed to by the <i>pdwFlags</i> parameter.
     * Note that a value of
     * <b>CRYPT_STRING_BASE64REQUESTHEADER</b>
     * or
     * <b>CRYPT_STRING_BASE64X509CRLHEADER</b>
     * does not mean that a request header or
     * <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly#_SECURITY_X.509_GLY">X.509</a>
     * <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly#_security_certificate_revocation_list_gly">certificate revocation list</a> (CRL)
     * was found.
     * 
     * > [!NOTE]
     * > The wincrypt.h header defines CryptStringToBinary as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} pszString A pointer to a string that contains the formatted string to be converted.
     * @param {Integer} cchString The number of characters of the formatted string to be converted, not including the terminating <b>NULL</b> character. If this parameter is zero,  <i>pszString</i> is considered to be a null-terminated string.
     * @param {Integer} dwFlags 
     * @param {Pointer<Byte>} pbBinary A pointer to a buffer that receives the returned sequence of bytes. If this parameter is <b>NULL</b>, the function calculates the length of the buffer needed and returns the size, in bytes, of required memory in the <b>DWORD</b> pointed to by <i>pcbBinary</i>.
     * @param {Pointer<UInt32>} pcbBinary A pointer to a <b>DWORD</b> variable that, on entry, contains the size, in bytes, of the <i>pbBinary</i> buffer. After the function returns, this variable contains the number of bytes copied to the buffer. If this value is not large enough to contain all of the data, the function fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_MORE_DATA</b>.
     * 
     * If <i>pbBinary</i> is <b>NULL</b>, the <b>DWORD</b> pointed to by <i>pcbBinary</i> is ignored.
     * @param {Pointer<UInt32>} pdwSkip A pointer to a <b>DWORD</b> value that receives the number of characters skipped to reach the beginning of the
     * `-----BEGIN ...-----` header.
     * If no header is present, then the <b>DWORD</b> is set to zero.
     * This parameter is optional and can be <b>NULL</b> if it is not needed.
     * @param {Pointer<UInt32>} pdwFlags A pointer to a <b>DWORD</b> value that receives the flags actually used in the conversion. These are the same flags used for the <i>dwFlags</i> parameter. In many cases, these will be the same flags that were passed in the <i>dwFlags</i> parameter. If <i>dwFlags</i> contains one of the following flags, this value will receive a flag that indicates the actual format of the string. This parameter is optional and can be <b>NULL</b> if it is not needed.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_STRING_ANY"></a><a id="crypt_string_any"></a><dl>
     * <dt><b>CRYPT_STRING_ANY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptstringtobinarya
     * @since windows5.1.2600
     */
    static CryptStringToBinaryA(pszString, cchString, dwFlags, pbBinary, pcbBinary, pdwSkip, pdwFlags) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptStringToBinaryA", "ptr", pszString, "uint", cchString, "uint", dwFlags, "ptr", pbBinary, "ptr", pcbBinary, "ptr", pdwSkip, "ptr", pdwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts a formatted string into an array of bytes. (Unicode)
     * @remarks
     * The
     * <b>CRYPT_STRING_BASE64HEADER</b>,
     * <b>CRYPT_STRING_BASE64REQUESTHEADER</b>,
     * and
     * <b>CRYPT_STRING_BASE64X509CRLHEADER</b>
     * flags are all treated identically by this function:
     * They attempt to parse the first block of
     * base64-encoded data between lines of the form
     * `-----BEGIN ...-----` and `-----END ...-----`.
     * The `...` portions are ignored, and they need not match.
     * If parsing is successful, the value passed in the <i>dwFlags</i> parameter
     * is returned in the <b>DWORD</b> pointed to by the <i>pdwFlags</i> parameter.
     * Note that a value of
     * <b>CRYPT_STRING_BASE64REQUESTHEADER</b>
     * or
     * <b>CRYPT_STRING_BASE64X509CRLHEADER</b>
     * does not mean that a request header or
     * <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly#_SECURITY_X.509_GLY">X.509</a>
     * <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly#_security_certificate_revocation_list_gly">certificate revocation list</a> (CRL)
     * was found.
     * 
     * > [!NOTE]
     * > The wincrypt.h header defines CryptStringToBinary as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} pszString A pointer to a string that contains the formatted string to be converted.
     * @param {Integer} cchString The number of characters of the formatted string to be converted, not including the terminating <b>NULL</b> character. If this parameter is zero,  <i>pszString</i> is considered to be a null-terminated string.
     * @param {Integer} dwFlags 
     * @param {Pointer<Byte>} pbBinary A pointer to a buffer that receives the returned sequence of bytes. If this parameter is <b>NULL</b>, the function calculates the length of the buffer needed and returns the size, in bytes, of required memory in the <b>DWORD</b> pointed to by <i>pcbBinary</i>.
     * @param {Pointer<UInt32>} pcbBinary A pointer to a <b>DWORD</b> variable that, on entry, contains the size, in bytes, of the <i>pbBinary</i> buffer. After the function returns, this variable contains the number of bytes copied to the buffer. If this value is not large enough to contain all of the data, the function fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_MORE_DATA</b>.
     * 
     * If <i>pbBinary</i> is <b>NULL</b>, the <b>DWORD</b> pointed to by <i>pcbBinary</i> is ignored.
     * @param {Pointer<UInt32>} pdwSkip A pointer to a <b>DWORD</b> value that receives the number of characters skipped to reach the beginning of the
     * `-----BEGIN ...-----` header.
     * If no header is present, then the <b>DWORD</b> is set to zero.
     * This parameter is optional and can be <b>NULL</b> if it is not needed.
     * @param {Pointer<UInt32>} pdwFlags A pointer to a <b>DWORD</b> value that receives the flags actually used in the conversion. These are the same flags used for the <i>dwFlags</i> parameter. In many cases, these will be the same flags that were passed in the <i>dwFlags</i> parameter. If <i>dwFlags</i> contains one of the following flags, this value will receive a flag that indicates the actual format of the string. This parameter is optional and can be <b>NULL</b> if it is not needed.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_STRING_ANY"></a><a id="crypt_string_any"></a><dl>
     * <dt><b>CRYPT_STRING_ANY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptstringtobinaryw
     * @since windows5.1.2600
     */
    static CryptStringToBinaryW(pszString, cchString, dwFlags, pbBinary, pcbBinary, pdwSkip, pdwFlags) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptStringToBinaryW", "ptr", pszString, "uint", cchString, "uint", dwFlags, "ptr", pbBinary, "ptr", pcbBinary, "ptr", pdwSkip, "ptr", pdwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts an array of bytes into a formatted string. (ANSI)
     * @remarks
     * With the exception of when <b>CRYPT_STRING_BINARY</b> encoding is used, all strings are appended with a new line sequence. By default, the new line sequence is a CR/LF pair (0x0D/0x0A). If the <i>dwFlags</i> parameter contains the <b>CRYPT_STRING_NOCR</b> flag, then the new line sequence is a LF character (0x0A). If the <i>dwFlags</i> parameter contains the <b>CRYPT_STRING_NOCRLF</b> flag, then no new line sequence is appended to the string.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The wincrypt.h header defines CryptBinaryToString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pbBinary A pointer to the array of bytes to be converted into a string.
     * @param {Integer} cbBinary The number of elements in the <i>pbBinary</i> array.
     * @param {Integer} dwFlags 
     * @param {Pointer<PSTR>} pszString A pointer to a buffer that receives the converted string. To calculate the number of characters that must be allocated to hold the returned string, set this parameter to <b>NULL</b>. The function will place the required number of characters, including the terminating <b>NULL</b> character, in the value pointed to by <i>pcchString</i>.
     * @param {Pointer<UInt32>} pcchString A pointer to a <b>DWORD</b> variable that contains the size, in <b>TCHAR</b>s, of the <i>pszString</i> buffer. If <i>pszString</i> is <b>NULL</b>, the function calculates the length of the return string (including the terminating null character) in <b>TCHAR</b>s and returns it in this parameter. If <i>pszString</i> is not <b>NULL</b> and big enough, the function converts the binary data into a specified string format including the terminating null character, but <i>pcchString</i> receives the length in <b>TCHAR</b>s, not including the terminating null character.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptbinarytostringa
     * @since windows5.1.2600
     */
    static CryptBinaryToStringA(pbBinary, cbBinary, dwFlags, pszString, pcchString) {
        result := DllCall("CRYPT32.dll\CryptBinaryToStringA", "ptr", pbBinary, "uint", cbBinary, "uint", dwFlags, "ptr", pszString, "ptr", pcchString, "int")
        return result
    }

    /**
     * Converts an array of bytes into a formatted string. (Unicode)
     * @remarks
     * With the exception of when <b>CRYPT_STRING_BINARY</b> encoding is used, all strings are appended with a new line sequence. By default, the new line sequence is a CR/LF pair (0x0D/0x0A). If the <i>dwFlags</i> parameter contains the <b>CRYPT_STRING_NOCR</b> flag, then the new line sequence is a LF character (0x0A). If the <i>dwFlags</i> parameter contains the <b>CRYPT_STRING_NOCRLF</b> flag, then no new line sequence is appended to the string.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The wincrypt.h header defines CryptBinaryToString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pbBinary A pointer to the array of bytes to be converted into a string.
     * @param {Integer} cbBinary The number of elements in the <i>pbBinary</i> array.
     * @param {Integer} dwFlags 
     * @param {Pointer<PWSTR>} pszString A pointer to a buffer that receives the converted string. To calculate the number of characters that must be allocated to hold the returned string, set this parameter to <b>NULL</b>. The function will place the required number of characters, including the terminating <b>NULL</b> character, in the value pointed to by <i>pcchString</i>.
     * @param {Pointer<UInt32>} pcchString A pointer to a <b>DWORD</b> variable that contains the size, in <b>TCHAR</b>s, of the <i>pszString</i> buffer. If <i>pszString</i> is <b>NULL</b>, the function calculates the length of the return string (including the terminating null character) in <b>TCHAR</b>s and returns it in this parameter. If <i>pszString</i> is not <b>NULL</b> and big enough, the function converts the binary data into a specified string format including the terminating null character, but <i>pcchString</i> receives the length in <b>TCHAR</b>s, not including the terminating null character.
     * @returns {Integer} If the function succeeds, the function returns nonzero (<b>TRUE</b>).
     * 
     * If the function fails, it returns zero (<b>FALSE</b>).
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptbinarytostringw
     * @since windows5.1.2600
     */
    static CryptBinaryToStringW(pbBinary, cbBinary, dwFlags, pszString, pcchString) {
        result := DllCall("CRYPT32.dll\CryptBinaryToStringW", "ptr", pbBinary, "uint", cbBinary, "uint", dwFlags, "ptr", pszString, "ptr", pcchString, "int")
        return result
    }

    /**
     * Imports a PFX BLOB and returns the handle of a store that contains certificates and any associated private keys.
     * @remarks
     * The **PFXImportCertStore** function opens a temporary store. If the function succeeds, you should close the handle to the store by calling the [CertCloseStore](nf-wincrypt-certclosestore.md) function.
     * 
     * When you import a certificate from the PFX packet, the CSP/KSP container name is determined by using the AttributeId with OID 1.3.6.1.4.1.311.17.1 of the PKCS8ShroudedKeyBag SafeBag [bagId: 1.2.840.113549.1.12.10.1.2] (see [PKCS #12](https://www.rfc-editor.org/rfc/rfc7292) for details about the ASN.1 structure of this).
     * 
     * * **AttributeId:** 1.3.6.1.4.1.311.17.1
     * * **Value:** The KSP name or CSP name
     * 
     * If the AttributeId is not present and the PREFER_CNG flag is passed, MS_KEY_STORAGE_PROVIDER is picked. If the AttributeId is not present and the PREFER_CNG flag is not passed, the provider name is determined based on the public key algorithm (that is, the public key algorithm is determined by the AlgorithmIdentifier in PKCS #8):
     * 
     * * **RSA:** MS_ENHANCED_PROV_W
     * * **DSA:** MS_DEF_DSS_DH_PROV_W
     * 
     * Similarly, the key specification is determined by using the AttributeId with OID 2.5.29.15 (szOID_KEY_USAGE) as follows:
     * 
     * **If a CAPI key is used:**
     * 
     * * If KEY_ENCIPHERMENT or DATA_ENCIPHERMENT is set, then the key specification is set to AT_KEYEXCHANGE.
     * * If DIGITAL_SIGNATURE or CERT_SIGN or CRL_SIGN is set, then the key specification is set to AT_SIGNATURE.
     * 
     * **If a CNG key is used:**
     * 
     * * If KEY_ENCIPHERMENT or DATA_ENCIPHERMENT or ENCIPHER_ONLY or DECIPHER_ONLY is set, then ncrypt key usage is set to ALLOW_DECRYPT.
     * * If DIGITAL_SIGNATURE or CERT_SIGN  or CRL_SIGN is set, ncrypt key usage is set to ALLOW_SIGN.
     * * If KEY_AGREEMENT is set, then ncrypt key usage is set to ALLOW_KEY_AGREEMENT.
     * 
     * If the AttributeId is not present, then the CAPI key value is set to AT_KEYEXCHANGE for RSA or DH and the algorithm is determined by the AlgorithmIdentifier in PKCS #8; otherwise, the algorithm is set to AT_SIGNATURE. For the CNG key value, all ncrypt key usage is set.
     * 
     * >[!NOTE]
     * >If an invalid provider name is present in the PFX packet, or the base or enhanced cryptography provider is not present in this registry key: **HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider**, then a provider lookup is performed by the provider type using this registry subkey: **HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider Types**.
     * 
     * Microsoft only supports two encryption/hash algorithms for importing a PFX:
     * 
     * * TripleDES-SHA1
     * * AES256-SHA256
     * 
     * For either of the above algorithms, encryption of the certificates is optional.
     * 
     * Microsoft can export a PFX from a certificate store via the `All Tasks` \> `Yes, export the private key` selection. There you can select the encryption/hash algorithm to match one of these two choices.
     * 
     * You can use PowerShell to export a PFX via the following:
     * 
     * ```powershell
     * Export-PfxCertificate
     * [-CryptoAlgorithmOption <CryptoAlgorithmOptions>]
     * ```
     * 
     * `-CryptoAlgorithmOption` specifies the algorithm for encrypting private keys within the PFX file. If this parameter is not specified, the default is `TripleDES_SHA1`. The acceptable values for this parameter are:
     * 
     * | Value | Description |
     * |--------|--------|
     * | `TripleDES_SHA1` | Private keys will be encrypted in the PFX file using Triple DES encryption. |
     * | `AES256_SHA256` | Private keys will be encrypted in the PFX file using AES-256 encryption. |
     * 
     * OpenSSL supports the above two algorithms via the following commands:
     * 
     * * `openssl pkcs12 -keypbe PBE-SHA1-3DES -certpbe PBE-SHA1-3DES -in in.pem -export -out out.pfx -password file:password.txt -passin file:password.txt`
     * * `openssl pkcs12 -keypbe AES-256-CBC -certpbe AES-256-CBC -macalg sha256 -in in.pem -export -out out.pfx -password file:password.txt -passin file:password.txt`
     * 
     * The following commands are equivalent to the previous two, but they do not encrypt the certificates:
     * 
     * * `openssl pkcs12 -keypbe PBE-SHA1-3DES -certpbe NONE -in in.pem -export -out out.pfx -password file:password.txt -passin file:password.txt`
     * * `openssl pkcs12 -keypbe AES-256-CBC -certpbe NONE -macalg sha256 -in in.pem -export -out out.pfx -password file:password.txt -passin file:password.txt`
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pPFX A pointer to a [CRYPT_DATA_BLOB](/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)) structure that contains a PFX packet with the exported and encrypted certificates and keys.
     * @param {Pointer<PWSTR>} szPassword A string password used to decrypt and verify the PFX packet. Whether set to a string of length greater than zero or set to an empty string or to **NULL**,  this value must be exactly the same as the value that was used to encrypt the packet.
     * 
     * Beginning with Windows 8 and Windows Server 2012, if the PFX packet was created in the [PFXExportCertStoreEx](nf-wincrypt-pfxexportcertstoreex.md) function by using the **PKCS12_PROTECT_TO_DOMAIN_SIDS** flag, the **PFXImportCertStore** function attempts to decrypt the password by using the Active Directory (AD) principal that was used to encrypt it. The AD principal is specified in the *pvPara* parameter. If the *szPassword* parameter in the **PFXExportCertStoreEx** function was an empty string or **NULL** and the *dwFlags* parameter was set to **PKCS12_PROTECT_TO_DOMAIN_SIDS**, that function randomly generated a password and encrypted it to the AD principal specified in the *pvPara* parameter. In that case you should set the password to the value, empty string or **NULL**, that was used when the PFX packet was created. The **PFXImportCertStore** function will use the AD principal to decrypt the random password, and the randomly generated password will be used to decrypt the PFX certificate.
     * 
     * When you have finished using the password, clear it from memory by calling the [SecureZeroMemory](/previous-versions/windows/desktop/legacy/aa366877(v=vs.85)) function. For more information about protecting passwords, see [Handling Passwords](/windows/win32/SecBP/handling-passwords).
     * @param {Integer} dwFlags 
     * @returns {Pointer<HCERTSTORE>} If the function succeeds, the function returns a handle to a certificate store that contains the imported certificates, including available private keys.
     * 
     * If the function fails, that is, if the password parameter does not contain an exact match with the password used to encrypt the exported packet or if there were any other problems decoding the PFX BLOB, the function returns **NULL**, and an error code can be found by calling the [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) function.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-pfximportcertstore
     * @since windows5.1.2600
     */
    static PFXImportCertStore(pPFX, szPassword, dwFlags) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\PFXImportCertStore", "ptr", pPFX, "ptr", szPassword, "uint", dwFlags, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The PFXIsPFXBlob function attempts to decode the outer layer of a BLOB as a PFX packet.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pPFX A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure that the function will attempt to decode as a PFX packet.
     * @returns {Integer} The function returns <b>TRUE</b> if the BLOB can be decoded as a PFX packet. If the outer layer of the BLOB cannot be decoded as a PFX packet, the function returns <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-pfxispfxblob
     * @since windows5.1.2600
     */
    static PFXIsPFXBlob(pPFX) {
        result := DllCall("CRYPT32.dll\PFXIsPFXBlob", "ptr", pPFX, "int")
        return result
    }

    /**
     * The PFXVerifyPassword function attempts to decode the outer layer of a BLOB as a Personal Information Exchange (PFX) packet and to decrypt it with the given password. No data from the BLOB is imported.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pPFX A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure that the function will attempt to decode as a PFX packet.
     * @param {Pointer<PWSTR>} szPassword String password to be checked. For this function to succeed, this password must be exactly the same as the password used to encrypt the packet.
     * 
     * If you set this value to an empty string or <b>NULL</b>, this function typically attempts to decrypt the password embedded in the PFX BLOB by using the empty string or <b>NULL</b>.
     * 
     * However, beginning with Windows 8 and Windows Server 2012, if a <b>NULL</b> or empty password was specified when the PFX BLOB was created and the application also specified  that the password should be protected to an Active Directory (AD) principal, the Cryptography API (CAPI) randomly generates a password, encrypts it to the AD principal and embeds it in the PFX BLOB. The <b>PFXVerifyPassword</b> function will then try to use the specified AD principal (current user, computer, or AD group member) to decrypt the password. For more information about protecting PFX to an AD principal, see the <i>pvPara</i> parameter and the <b>PKCS12_PROTECT_TO_DOMAIN_SIDS</b> flag of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-pfxexportcertstoreex">PFXExportCertStoreEx</a> function.
     * 
     * When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com/windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.
     * @param {Integer} dwFlags Reserved for future use.
     * @returns {Integer} The function return <b>TRUE</b> if the password appears correct; otherwise, it returns <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-pfxverifypassword
     * @since windows5.1.2600
     */
    static PFXVerifyPassword(pPFX, szPassword, dwFlags) {
        result := DllCall("CRYPT32.dll\PFXVerifyPassword", "ptr", pPFX, "ptr", szPassword, "uint", dwFlags, "int")
        return result
    }

    /**
     * Exports the certificates and, if available, their associated private keys from the referenced certificate store.
     * @remarks
     * Beginning with Windows 8 and Windows Server 2012, you can protect the PFX password to an Active Directory user, computer, or group. If you choose to do so but do not create a password, a temporary password will be randomly selected. The password is encrypted by using the Active Directory principal and then embedded in the PFX BLOB. For more information, see the <i>pvPara</i> parameter and the <b>PKCS12_PROTECT_TO_DOMAIN_SIDS</b> flag.
     * 
     * Beginning with Windows 10 1709 (Fall Creators update) and Windows Server 2019, you can control the number of iterations of the hash function over the password done by the <b>PFXExportCertStoreEx</b> function using the following registry key. The value in this key is of type <b>REG_DWORD</b>.
     * 
     * <b>HKEY_LOCAL_MACHINE</b>&#92;<b>Software</b>&#92;<b>Microsoft</b>&#92;<b>Windows</b>&#92;<b>CurrentVersion</b>&#92;<b>PFX</b>&#92;<b>PasswordIterationCount</b>
     * @param {Pointer<HCERTSTORE>} hStore Handle of the certificate store containing the certificates to be exported.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pPFX A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure to contain the PFX packet with the exported certificates and keys. If <i>pPFX</i>-&gt;<i>pbData</i> is <b>NULL</b>, the function calculates the number of bytes needed for the encoded BLOB and returns this in <i>pPFX</i>-&gt;<i>cbData</i>. When the function is called with <i>pPFX</i>-&gt;<i>pbData</i> pointing to an allocated buffer of the needed size, the function copies the encoded bytes into the buffer and updates <i>pPFX</i>-&gt;<i>cbData</i> with the encode byte length.
     * @param {Pointer<PWSTR>} szPassword String password used to encrypt and verify the PFX packet. When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com/windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.
     * @param {Pointer<Void>} pvPara This parameter must be <b>NULL</b> if the <i>dwFlags</i> parameter does not contain <b>PKCS12_PROTECT_TO_DOMAIN_SIDS</b> or <b>PKCS12_EXPORT_PBES2_PARAMS</b>. Prior to Windows 8 and Windows Server 2012, therefore, this parameter must be <b>NULL</b>.
     * 
     * Beginning with Windows 8 and Windows Server 2012, if the <i>dwFlags</i> parameter contains <b>PKCS12_PROTECT_TO_DOMAIN_SIDS</b>, you can set the <i>pvPara</i> parameter to point to an <b>NCRYPT_DESCRIPTOR_HANDLE</b> value to identify which Active Directory principal the PFX password will be protected to inside of the PFX BLOB. Currently, the password can be protected to an Active Directory user, computer, or group. For more information about protection descriptors, see <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptcreateprotectiondescriptor">NCryptCreateProtectionDescriptor</a>.
     * 
     * Beginning with Windows 10 1709 (Fall Creators update) and Windows Server 2019, if the <i>dwFlags</i> parameter contains <b>PKCS12_EXPORT_PBES2_PARAMS</b>, you should set the <i>pvPara</i> to an <b><a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-pkcs12_pbes2_export_params">PKCS12_EXPORT_PBES2_PARAMS</a></b> value to select the password-based encryption algorithm to use.
     * @param {Integer} dwFlags Flag values can be set to any combination of the following.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="EXPORT_PRIVATE_KEYS"></a><a id="export_private_keys"></a><dl>
     * <dt><b>EXPORT_PRIVATE_KEYS</b></dt>
     * <dt>0x0004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Private keys are exported as well as the certificates.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="REPORT_NO_PRIVATE_KEY"></a><a id="report_no_private_key"></a><dl>
     * <dt><b>REPORT_NO_PRIVATE_KEY</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a certificate is encountered that has no associated private key, the function returns FALSE with the last error set to either CRYPT_E_NOT_FOUND or NTE_NO_KEY.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY"></a><a id="report_not_able_to_export_private_key"></a><dl>
     * <dt><b>REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a certificate is encountered that has a non-exportable private key, the function returns FALSE and the last error set to NTE_BAD_KEY, NTE_BAD_KEY_STATE, or NTE_PERM.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PKCS12_INCLUDE_EXTENDED_PROPERTIES"></a><a id="pkcs12_include_extended_properties"></a><dl>
     * <dt><b>PKCS12_INCLUDE_EXTENDED_PROPERTIES</b></dt>
     * <dt>0x0010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Export all extended
     * properties on the certificate.
     * 
     *  
     * 
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PKCS12_PROTECT_TO_DOMAIN_SIDS"></a><a id="pkcs12_protect_to_domain_sids"></a><dl>
     * <dt><b>PKCS12_PROTECT_TO_DOMAIN_SIDS</b></dt>
     * <dt>0x0020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The PFX BLOB contains an embedded password that will be protected to the Active Directory (AD) protection descriptor pointed to by the <i>pvPara</i> parameter. If the <i>szPassword</i> parameter is not  <b>NULL</b> or empty, the specified password is protected. If, however,  the <i>szPassword</i> parameter is <b>NULL</b> or an empty string, a random forty (40)  character password is created and protected.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-pfximportcertstore">PFXImportCertStore</a> uses the specified protection descriptor to decrypt the embedded password, whether specified by the user or randomly generated, and then uses the password to decrypt the PFX BLOB.
     * 
     * <b>Windows 8 and Windows Server 2012:  </b>Support for this flag begins.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PKCS12_EXPORT_PBES2_PARAMS"></a><a id="pkcs12_export_pbes2_params"></a><dl>
     * <dt><b>PKCS12_EXPORT_PBES2_PARAMS</b></dt>
     * <dt>0x0080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Export using the passowrd-based encryption algorithm specified by the <b><a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-pkcs12_pbes2_export_params">PKCS12_EXPORT_PBES2_PARAMS</a></b> value passed as <i>pvPara</i>.
     * 
     * <b>Windows 10 1709 (Fall Creators update) and Windows Server 2019:  </b>Support for this flag begins.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns <b>TRUE</b> (nonzero) if the function succeeds, and <b>FALSE</b> (zero) if the function fails. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-pfxexportcertstoreex
     * @since windows5.1.2600
     */
    static PFXExportCertStoreEx(hStore, pPFX, szPassword, pvPara, dwFlags) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\PFXExportCertStoreEx", "ptr", hStore, "ptr", pPFX, "ptr", szPassword, "ptr", pvPara, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Exports the certificates and, if available, the associated private keys from the referenced certificate store.
     * @param {Pointer<HCERTSTORE>} hStore Handle of the certificate store containing the certificates to be exported.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pPFX A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">CRYPT_DATA_BLOB</a> structure to contain the PFX packet with the exported certificates and keys. If <i>pPFX</i>-&gt;<i>pbData</i> is <b>NULL</b>, the function calculates the number of bytes needed for the encoded BLOB and returns this in <i>pPFX</i>-&gt;<i>cbData</i>. When the function is called with <i>pPFX</i>-&gt;<i>pbData</i> pointing to an allocated buffer of the needed size, the function copies the encoded bytes into the buffer and updates <i>pPFX</i>-&gt;<i>cbData</i> with the encode byte length.
     * @param {Pointer<PWSTR>} szPassword String password used to encrypt and verify the PFX packet. When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com/windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.
     * @param {Integer} dwFlags Flag values can be set to any combination of the following.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="EXPORT_PRIVATE_KEYS"></a><a id="export_private_keys"></a><dl>
     * <dt><b>EXPORT_PRIVATE_KEYS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Private keys are exported as well as the certificates.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="REPORT_NO_PRIVATE_KEY"></a><a id="report_no_private_key"></a><dl>
     * <dt><b>REPORT_NO_PRIVATE_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a certificate is encountered that has no associated private key, the function returns <b>FALSE</b> with the last error set to either CRYPT_E_NOT_FOUND or NTE_NO_KEY.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY"></a><a id="report_not_able_to_export_private_key"></a><dl>
     * <dt><b>REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If a certificate is encountered that has a non-exportable private key, the function returns <b>FALSE</b> and the last error set to NTE_BAD_KEY, NTE_BAD_KEY_STATE, or NTE_PERM.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns <b>TRUE</b> (nonzero) if the function succeeds, and <b>FALSE</b> (zero) if the function fails. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-pfxexportcertstore
     * @since windows5.1.2600
     */
    static PFXExportCertStore(hStore, pPFX, szPassword, dwFlags) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\PFXExportCertStore", "ptr", hStore, "ptr", pPFX, "ptr", szPassword, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Opens a handle to an online certificate status protocol (OCSP) response associated with a server certificate chain.
     * @remarks
     * The <b>CertOpenServerOcspResponse</b> function tries to retrieve an initial OCSP response before it returns.
     * It blocks its process thread during the retrieval. The <b>CertOpenServerOcspResponse</b> function creates a background thread that prefetches time-valid OCSP responses.
     * 
     * The <b>CertOpenServerOcspResponse</b> function increments the reference count for the chain context represented by the <i>pChainContext</i> parameter. When you have finished using the chain context, close the returned handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certcloseserverocspresponse">CertCloseServerOcspResponse</a> function.
     * 
     * The <b>CertOpenServerOcspResponse</b> function initializes configuration settings used by the following functions:
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddrefserverocspresponse">CertAddRefServerOcspResponse</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certcloseserverocspresponse">CertCloseServerOcspResponse</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetserverocspresponsecontext">CertGetServerOcspResponseContext</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddrefserverocspresponsecontext">CertAddRefServerOcspResponseContext</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreeserverocspresponsecontext">CertFreeServerOcspResponseContext</a>
     * </li>
     * </ul>
     * First, the <b>CertOpenServerOcspResponse</b> function initializes the settings based on default values in Wincrypt.h. If the function subsequently finds the registry key defined in <b>CERT_CHAIN_CONFIG_REGPATH</b>, it updates the previously initialized values with the registry values.
     * 
     * The following configuration setting names and default values are initialized by this function:
     * 
     * <ul>
     * <li>
     * <b>CERT_SRV_OCSP_RESP_MIN_VALIDITY_SECONDS_VALUE_NAME</b>
     * 
     * L"SrvOcspRespMinValiditySeconds"
     * 
     * The minimum time validity of the server OCSP response to be returned by <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetserverocspresponsecontext">CertGetServerOcspResponseContext</a>. The OCSP
     * response validity must be sufficiently long that the client treats it as time valid.
     * 
     * </li>
     * <li>
     * <b>CERT_SRV_OCSP_RESP_MIN_VALIDITY_SECONDS_DEFAULT</b>
     * 
     * (10 × 60)
     * 
     * 10 minutes.
     * 
     * </li>
     * <li>
     * <b>CERT_SRV_OCSP_RESP_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_VALUE_NAME</b>
     * 
     * L"SrvOcspRespUrlRetrievalTimeoutMilliseconds"
     * 
     * This is the maximum time before an OCSP response prefetch wire URL retrieval times out.
     * 
     * </li>
     * <li>
     * <b>CERT_SRV_OCSP_RESP_URL_RETRIEVAL_TIMEOUT_MILLISECONDS_DEFAULT</b>
     * 
     * (15 × 1000)
     * 
     * 15 seconds.
     * 
     * </li>
     * <li>
     * <b>CERT_SRV_OCSP_RESP_MAX_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME</b>
     * 
     * L"SrvOcspRespMaxBeforeNextUpdateSeconds"
     * 
     * This is the maximum number of seconds to perform a server OCSP response
     * prefetch retrieval before the NextUpdate date of an OCSP response. The
     * server OCSP response thread waits until the current time is greater than or equal to the NextUpdate date minus this number of seconds to perform a prefetch retrieval.
     * 
     * </li>
     * <li>
     * <b>CERT_SRV_OCSP_RESP_MAX_BEFORE_NEXT_UPDATE_SECONDS_DEFAULT</b>
     * 
     * (4 ×60 × 60)
     * 
     * 4 hours.
     * 
     * </li>
     * <li>
     * <b>CERT_SRV_OCSP_RESP_MIN_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME</b>
     * 
     * L"SrvOcspRespMinBeforeNextUpdateSeconds"
     * 
     * This is the minimum number of seconds to perform a server OCSP response
     * prefetch retrieval before the NextUpdate date of an OCSP response. If the current time is greater than or equal to the NextUpdate date minus this number of seconds, the server OCSP response thread waits until
     * after the NextUpdate date plus the  <b>CERT_SRV_OCSP_RESP_MIN_AFTER_NEXT_UPDATE_SECONDS_VALUE_NAME</b> number of seconds before it performs a prefetch retrieval.
     * 
     * </li>
     * <li>
     * <b>CERT_SRV_OCSP_RESP_MIN_BEFORE_NEXT_UPDATE_SECONDS_DEFAULT</b>
     * 
     * (2 × 60)
     * 
     * 2 minutes.
     * 
     * </li>
     * <li>
     * <b>CERT_SRV_OCSP_RESP_MIN_AFTER_NEXT_UPDATE_SECONDS_VALUE_NAME</b>
     * 
     * L"SrvOcspRespMinAfterNextUpdateSeconds"
     * 
     * This is the minimum number of seconds to perform a server OCSP response
     * prefetch retrieval after the NextUpdate date of an OCSP response. When the current time is greater than the NextUpdate date minus the <b>CERT_SRV_OCSP_RESP_MIN_BEFORE_NEXT_UPDATE_SECONDS_VALUE_NAME</b> number of seconds but less than the NextUpdate date, the server OCSP response thread waits this number of seconds after the NextUpdate date to perform a prefetch retrieval.
     * 
     * </li>
     * <li>
     * <b>CERT_SRV_OCSP_RESP_MIN_AFTER_NEXT_UPDATE_SECONDS_DEFAULT</b>
     * 
     * (1 × 60)
     * 
     * 1 minute.
     * 
     * </li>
     * </ul>
     * @param {Pointer<CERT_CHAIN_CONTEXT>} pChainContext The address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> structure that contains the certificate chain.
     * @param {Integer} dwFlags This parameter is not used and must be zero.
     * @param {Pointer<CERT_SERVER_OCSP_RESPONSE_OPEN_PARA>} pOpenPara This parameter is not used and must be <b>NULL</b>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certopenserverocspresponse
     * @since windows6.0.6000
     */
    static CertOpenServerOcspResponse(pChainContext, dwFlags, pOpenPara) {
        A_LastError := 0

        DllCall("CRYPT32.dll\CertOpenServerOcspResponse", "ptr", pChainContext, "uint", dwFlags, "ptr", pOpenPara)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Increments the reference count for an HCERT_SERVER_OCSP_RESPONSE handle.
     * @remarks
     * Each <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenserverocspresponse">CertOpenServerOcspResponse</a> and <b>CertAddRefServerOcspResponse</b> requires a corresponding <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certcloseserverocspresponse">CertCloseServerOcspResponse</a>.
     * @param {Pointer<Void>} hServerOcspResponse A handle to an <b>HCERT_SERVER_OCSP_RESPONSE</b> returned by <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenserverocspresponse">CertOpenServerOcspResponse</a>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certaddrefserverocspresponse
     * @since windows6.0.6000
     */
    static CertAddRefServerOcspResponse(hServerOcspResponse) {
        DllCall("CRYPT32.dll\CertAddRefServerOcspResponse", "ptr", hServerOcspResponse)
    }

    /**
     * Closes an online certificate status protocol (OCSP) server response handle.
     * @remarks
     * The <b>CertCloseServerOcspResponse</b> function closes a handle returned by either the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenserverocspresponse">CertOpenServerOcspResponse</a> or <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certaddrefserverocspresponse">CertAddRefServerOcspResponse</a> function.
     * @param {Pointer<Void>} hServerOcspResponse The handle to close for an OCSP server response.
     * @param {Integer} dwFlags This parameter is not used and must be zero.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certcloseserverocspresponse
     * @since windows6.0.6000
     */
    static CertCloseServerOcspResponse(hServerOcspResponse, dwFlags) {
        DllCall("CRYPT32.dll\CertCloseServerOcspResponse", "ptr", hServerOcspResponse, "uint", dwFlags)
    }

    /**
     * Retrieves a non-blocking, time valid online certificate status protocol (OCSP) response context for the specified handle.
     * @remarks
     * If you use the <b>CertGetServerOcspResponseContext</b> function to create multiple references to an OCSP response context, you must call <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-cert_server_ocsp_response_context">CertAddRefServerOcspResponseContext</a> to increment the reference count for the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_server_ocsp_response_context">CERT_SERVER_OCSP_RESPONSE_CONTEXT</a> structure. When you have finished using the structure, you must free it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreeserverocspresponsecontext">CertFreeServerOcspResponseContext</a> function.
     * @param {Pointer<Void>} hServerOcspResponse The OCSP server response handle for which to retrieve a response context. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certopenserverocspresponse">CertOpenServerOcspResponse</a> function.
     * @param {Integer} dwFlags This parameter is reserved for future use and must be zero.
     * @returns {Pointer<CERT_SERVER_OCSP_RESPONSE_CONTEXT>} If the function succeeds, it returns a pointer to a <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-cert_server_ocsp_response_context">CERT_SERVER_OCSP_RESPONSE_CONTEXT</a> structure.
     * 
     * For a response to be time valid, the current time on the system hosting this function call must be less than the next update time for the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate revocation list</a> (CRL) context. When a time valid OCSP response
     * is not available, this function returns <b>NULL</b> with the last error set to
     * CRYPT_E_REVOCATION_OFFLINE.
     * 
     * If the certificate is unknown by the OCSP responder, this function returns <b>NULL</b> with the last error set to CRYPT_E_REVOCATION_OFFLINE.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certgetserverocspresponsecontext
     * @since windows6.0.6000
     */
    static CertGetServerOcspResponseContext(hServerOcspResponse, dwFlags) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("CRYPT32.dll\CertGetServerOcspResponseContext", "ptr", hServerOcspResponse, "uint", dwFlags, "ptr", pvReserved, "ptr")
        return result
    }

    /**
     * Increments the reference count for a CERT_SERVER_OCSP_RESPONSE_CONTEXT structure.
     * @remarks
     * Each call to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetserverocspresponsecontext">CertGetServerOcspResponseContext</a> and <b>CertAddRefServerOcspResponseContext</b> requires a corresponding call to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreeserverocspresponsecontext">CertFreeServerOcspResponseContext</a>.
     * @param {Pointer<CERT_SERVER_OCSP_RESPONSE_CONTEXT>} pServerOcspResponseContext A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-cert_server_ocsp_response_context">CERT_SERVER_OCSP_RESPONSE_CONTEXT</a> returned by <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetserverocspresponsecontext">CertGetServerOcspResponseContext</a>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certaddrefserverocspresponsecontext
     * @since windows6.0.6000
     */
    static CertAddRefServerOcspResponseContext(pServerOcspResponseContext) {
        DllCall("CRYPT32.dll\CertAddRefServerOcspResponseContext", "ptr", pServerOcspResponseContext)
    }

    /**
     * Decrements the reference count for a CERT_SERVER_OCSP_RESPONSE_CONTEXT structure.
     * @param {Pointer<CERT_SERVER_OCSP_RESPONSE_CONTEXT>} pServerOcspResponseContext A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/wincrypt/ns-wincrypt-cert_server_ocsp_response_context">CERT_SERVER_OCSP_RESPONSE_CONTEXT</a> structure that contains a value returned by the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certgetserverocspresponsecontext">CertGetServerOcspResponseContext</a> function.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certfreeserverocspresponsecontext
     * @since windows6.0.6000
     */
    static CertFreeServerOcspResponseContext(pServerOcspResponseContext) {
        DllCall("CRYPT32.dll\CertFreeServerOcspResponseContext", "ptr", pServerOcspResponseContext)
    }

    /**
     * Performs a URL retrieval of logo or biometric information specified in either the szOID_LOGOTYPE_EXT or szOID_BIOMETRIC_EXT certificate extension.
     * @param {Pointer<CERT_CONTEXT>} pCertContext The address of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">CERT_CONTEXT</a> structure that contains the certificate.
     * @param {Pointer<PSTR>} lpszLogoOrBiometricType The address of a null-terminated ANSI string that contains an <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID) string that identifies the type of information to retrieve.
     * 
     * 
     * This parameter may also contain one of the following predefined values.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_RETRIEVE_ISSUER_LOGO"></a><a id="cert_retrieve_issuer_logo"></a><dl>
     * <dt><b>CERT_RETRIEVE_ISSUER_LOGO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the certificate issuer logotype.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_RETRIEVE_SUBJECT_LOGO"></a><a id="cert_retrieve_subject_logo"></a><dl>
     * <dt><b>CERT_RETRIEVE_SUBJECT_LOGO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the certificate subject logotype.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_RETRIEVE_COMMUNITY_LOGO"></a><a id="cert_retrieve_community_logo"></a><dl>
     * <dt><b>CERT_RETRIEVE_COMMUNITY_LOGO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the certificate community logotype.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_RETRIEVE_BIOMETRIC_PICTURE_TYPE"></a><a id="cert_retrieve_biometric_picture_type"></a><dl>
     * <dt><b>CERT_RETRIEVE_BIOMETRIC_PICTURE_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the picture associated with the certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_RETRIEVE_BIOMETRIC_SIGNATURE_TYPE"></a><a id="cert_retrieve_biometric_signature_type"></a><dl>
     * <dt><b>CERT_RETRIEVE_BIOMETRIC_SIGNATURE_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieve the signature associated with the certificate.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwRetrievalFlags A set of flags that specify how the information should be retrieved. This parameter is passed as the <i>dwRetrievalFlags</i> in the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptretrieveobjectbyurla">CryptRetrieveObjectByUrl</a> function.
     * @param {Integer} dwTimeout The maximum amount of time, in milliseconds, to wait for the retrieval.
     * @param {Integer} dwFlags This parameter is not used and must be zero.
     * @param {Pointer<Byte>} ppbData The address of a <b>BYTE</b> pointer that receives the logotype or biometric data. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmemfree">CryptMemFree</a> function.
     * @param {Pointer<UInt32>} pcbData The address of a <b>DWORD</b> variable that receives the number of bytes in the <i>ppbData</i> buffer.
     * @param {Pointer<PWSTR>} ppwszMimeType The address of a pointer to a null-terminated Unicode string that receives the Multipurpose Internet Mail Extensions (MIME) type of the data. This parameter can be <b>NULL</b> if this information is not needed. This memory must be freed when it is no longer needed by passing this pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmemfree">CryptMemFree</a> function.
     * 
     * This address always receives <b>NULL</b> for biometric types. You must always ensure that this parameter contains a valid memory address before attempting to access the memory.
     * @returns {Integer} Returns nonzero if successful or zero otherwise.
     * 
     * For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes returned by the 
     * 		       <b>GetLastError</b> function include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b> CRYPT_E_HASH_VALUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The computed hash value does not match the hash value in the certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>CRYPT_E_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The certificate does not contain the <b>szOID_LOGOTYPE_EXT</b> or <b>szOID_BIOMETRIC_EXT</b> extension, or the specified <i>lpszLogoOrBiometricType</i> was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters are not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b> ERROR_INVALID_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No data could be retrieved from the URL specified by the certificate extension.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b> ERROR_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The certificate does not support the required extension.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b> NTE_BAD_ALGID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The hash algorithm OID is unknown.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certretrievelogoorbiometricinfo
     * @since windows6.0.6000
     */
    static CertRetrieveLogoOrBiometricInfo(pCertContext, lpszLogoOrBiometricType, dwRetrievalFlags, dwTimeout, dwFlags, ppbData, pcbData, ppwszMimeType) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertRetrieveLogoOrBiometricInfo", "ptr", pCertContext, "ptr", lpszLogoOrBiometricType, "uint", dwRetrievalFlags, "uint", dwTimeout, "uint", dwFlags, "ptr", pvReserved, "ptr", ppbData, "ptr", pcbData, "ptr", ppwszMimeType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves certificate chains based on specified selection criteria.
     * @remarks
     * Selection criteria can  be specified through either the  <i>dwFlags</i>  parameter, through the <i>rgpCriteria</i> parameter, or through both parameters. If no selection criteria are specified, the function  succeeds and returns certificate chains for all certificates in the store specified by the <i>hStore</i> parameter.
     * 
     * 
     * Certificate chains that are selected are ordered based on the following preference logic:
     * 
     * <ul>
     * <li>Prefer certificates that are smart card certificates over certificates that are not smart-card based.</li>
     * <li>Prefer certificates that have a longer validity period (the expiration date is later.)</li>
     * <li>If multiple certificates have same expiration date, prefer certificates that were issued more recently.</li>
     * <li>If there is a tie, prefer shorter chains.</li>
     * </ul>
     * Certain selection criteria require that a certificate chain be built before you can select that criteria for use. If the intermediate certificates required to build the chain are not available locally, a network retrieval is performed for the issuer certificates. This network retrieval is performed if the <b>CERT_SELECT_TRUSTED_ROOT</b> flag is set or for the following criteria:
     * 
     * <ul>
     * <li><b>CERT_SELECT_BY_ISSUER_NAME</b></li>
     * <li><b>CERT_SELECT_BY_ISSUER_ATTR</b></li>
     * <li><b>CERT_SELECT_BY_POLICY_OID</b></li>
     * </ul>
     * Perform the following actions to enable strong signature checking:<ul>
     * <li>Create a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_strong_sign_para">CERT_STRONG_SIGN_PARA</a> structure, specify the required strong signing parameters, and set a pointer to the structure in the <b>pStrongSignPara</b> member of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_para">CERT_CHAIN_PARA</a> structure.</li>
     * <li>Set a pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_para">CERT_CHAIN_PARA</a> structure in the <b>pChainPara</b> member of a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_select_chain_para">CERT_SELECT_CHAIN_PARA</a> structure.</li>
     * <li>Set  a pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_select_chain_para">CERT_SELECT_CHAIN_PARA</a> structure in the <i>pChainParameters</i> parameter of this (<b>CertSelectCertificateChains</b>)function.</li>
     * </ul>
     * 
     * 
     * When you enable strong signature checking, any certificate chain that returns a <b>CERT_TRUST_IS_NOT_SIGNATURE_VALID</b> error in the <b>dwErrorStatus</b> field of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_trust_status">CERT_TRUST_STATUS</a> structure will be skipped. (The <i>pprgpSelection</i> parameter points to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> structure which, in turn, points to the  <b>CERT_TRUST_STATUS</b> structure.) The <b>CERT_TRUST_HAS_WEAK_SIGNATURE</b> value is also set for a weak signature.
     * @param {Pointer<Guid>} pSelectionContext A pointer to the GUID of the certificate selection scenario to use for this call.
     * @param {Integer} dwFlags Flags for controlling the certificate selection process. This parameter can be a combination of zero or more of the following flags:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SELECT_ALLOW_EXPIRED"></a><a id="cert_select_allow_expired"></a><dl>
     * <dt><b>CERT_SELECT_ALLOW_EXPIRED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Select expired certificates that meet selection criteria. By default expired certificates are rejected from selection.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SELECT_TRUSTED_ROOT"></a><a id="cert_select_trusted_root"></a><dl>
     * <dt><b>CERT_SELECT_TRUSTED_ROOT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Select certificates on which the error bit in the certificate chain trust status is not set to <b>CERT_TRUST_IS_UNTRUSTED_ROOT</b>, <b>CERT_TRUST_IS_PARTIAL_CHAIN</b>, or <b>CERT_TRUST_IS_NOT_TIME_VALID</b>. 
     * 
     * In addition, certificates that have one of the following invalid constraint errors are not selected:
     * 
     * <ul>
     * <li><b>CERT_TRUST_INVALID_POLICY_CONSTRAINTS</b></li>
     * <li><b>CERT_TRUST_INVALID_BASIC_CONSTRAINTS</b></li>
     * <li><b>CERT_TRUST_INVALID_NAME_CONSTRAINTS</b></li>
     * </ul>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SELECT_DISALLOW_SELFSIGNED"></a><a id="cert_select_disallow_selfsigned"></a><dl>
     * <dt><b>CERT_SELECT_DISALLOW_SELFSIGNED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Select certificates that are not self-issued and self-signed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SELECT_HAS_PRIVATE_KEY"></a><a id="cert_select_has_private_key"></a><dl>
     * <dt><b>CERT_SELECT_HAS_PRIVATE_KEY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Select  certificates that have a value set for the <b>CERT_KEY_PROV_INFO_PROP_ID</b>  property of the certificate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SELECT_HAS_KEY_FOR_SIGNATURE"></a><a id="cert_select_has_key_for_signature"></a><dl>
     * <dt><b>CERT_SELECT_HAS_KEY_FOR_SIGNATURE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Select certificates on which the value of the <b>dwKeySpec</b> member of  the  <b>CERT_KEY_PROV_INFO_PROP_ID</b> property is set to <b>AT_SIGNATURE</b>. 
     * 
     * If this function is being called as part of  a CNG enabled application and the <b>dwKeySpec</b> member of  the  <b>CERT_KEY_PROV_INFO_PROP_ID</b> property is set to -1, select certificates on which the value of the <b>NCRYPT_KEY_USAGE_PROPERTY</b> property of the associated private key has the <b>NCRYPT_ALLOW_SIGNING_FLAG</b> set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SELECT_HAS_KEY_FOR_KEY_EXCHANGE"></a><a id="cert_select_has_key_for_key_exchange"></a><dl>
     * <dt><b>CERT_SELECT_HAS_KEY_FOR_KEY_EXCHANGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Select certificates on which the value of the <b>dwKeySpec</b> member of  the  <b>CERT_KEY_PROV_INFO_PROP_ID</b> property is set to <b>AT_KEYEXCHANGE</b>. 
     * 
     * If this function is being called as part of  a CNG enabled application and the <b>dwKeySpec</b> member of  the  <b>CERT_KEY_PROV_INFO_PROP_ID</b> property is set to -1, select certificates on which either <b>NCRYPT_ALLOW_DECRYPT_FLAG</b> or <b>NCRYPT_ALLOW_KEY_AGREEMENT_FLAG</b> is set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SELECT_HARDWARE_ONLY"></a><a id="cert_select_hardware_only"></a><dl>
     * <dt><b>CERT_SELECT_HARDWARE_ONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Select certificates on which the value of the <b>PP_IMPTYPE</b> property of the associated private key provider is set to either <b>  CRYPT_IMPL_HARDWARE</b> or <b>CRYPT_IMPL_REMOVABLE</b>. (For CNG providers, NCRYPT_IMPL_TYPE_PROPERTY property value MUST have either the NCRYPT_IMPL_HARDWARE_FLAG or NCRYPT_IMPL_REMOVABLE_FLAG bit set).
     * 
     * If this function is being called as part of  a CNG enabled application, select certificates on which the <b>NCRYPT_IMPL_TYPE_PROPERTY</b> property is set to <b> NCRYPT_IMPL_HARDWARE_FLAG</b> or <b>NCRYPT_IMPL_REMOVABLE_FLAG</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CERT_SELECT_ALLOW_DUPLICATES"></a><a id="cert_select_allow_duplicates"></a><dl>
     * <dt><b>CERT_SELECT_ALLOW_DUPLICATES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Allow the selection of certificates on which the Subject and Subject Alt Name contain the same information  and the certificate template extension value is equivalent.  By default when certificates match this criteria, only the most recent certificate is selected.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CERT_SELECT_CHAIN_PARA>} pChainParameters A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_select_chain_para">CERT_SELECT_CHAIN_PARA</a> structure to specify parameters for chain building. If <b>NULL</b>, default parameters will be used.
     * 
     * The <b>pChainPara</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_select_chain_para">CERT_SELECT_CHAIN_PARA</a> structure points to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_para">CERT_CHAIN_PARA</a> structure that can be used to enable strong signing.
     * @param {Integer} cCriteria The number of elements in the array pointed to by the <i>rgpCriteria</i> array.
     * @param {Pointer<CERT_SELECT_CRITERIA>} rgpCriteria A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_select_criteria">CERT_SELECT_CRITERIA</a> structures that define the selection criteria. If this parameter is set to <b>NULL</b>, the value of the <i>cCriteria</i> parameter must be zero.
     * @param {Pointer<HCERTSTORE>} hStore The handle to a store from which to select the certificates.
     * @param {Pointer<UInt32>} pcSelection A pointer to a <b>DWORD</b> value to receive the number of elements in the array pointed to by the <i>pprgpSelection</i> parameter.
     * @param {Pointer<CERT_CHAIN_CONTEXT>} pprgpSelection A pointer to a pointer to a location to receive an array of <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">CERT_CHAIN_CONTEXT</a> structure. The <b>CertSelectCertificateChains</b> function only returns certificate chains that match all the selection criteria. The entries in the array are ordered by quality, i.e. the chain with the highest quality is the first entry. 
     * 
     * Storage for the array is allocated by the <b>CertSelectCertificateChains</b> function. To free the allocated memory you must first release each individual chain context in the array by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatechain">CertFreeCertificateChain</a> function. Then you must  free the memory by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatechainlist">CertFreeCertificateChainList</a> function.
     * @returns {Integer} If the function succeeds, the function returns <b>TRUE</b>. 
     * 
     * If the function fails, it returns zero (FALSE). For extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * <div class="alert"><b>Note</b>  If the selection does not yield any results, the <b>CertSelectCertificateChains</b> function returns <b>TRUE</b>, but the value pointed to by <i>pcSelection</i> parameter is set to zero.
     * </div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certselectcertificatechains
     * @since windows6.1
     */
    static CertSelectCertificateChains(pSelectionContext, dwFlags, pChainParameters, cCriteria, rgpCriteria, hStore, pcSelection, pprgpSelection) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CertSelectCertificateChains", "ptr", pSelectionContext, "uint", dwFlags, "ptr", pChainParameters, "uint", cCriteria, "ptr", rgpCriteria, "ptr", hStore, "ptr", pcSelection, "ptr", pprgpSelection, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Frees the array of pointers to chain contexts.
     * @remarks
     * Before calling the <b>CertFreeCertificateChainList</b> function, you must call the  <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatechain">CertFreeCertificateChain</a> function on each chain context within the array pointed to by the <i>prgpSelection</i> parameter.
     * @param {Pointer<CERT_CHAIN_CONTEXT>} prgpSelection A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_chain_context">PCCERT_CHAIN_CONTEXT</a> structure returned by the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certselectcertificatechains">CertSelectCertificateChains</a> function.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certfreecertificatechainlist
     * @since windows6.1
     */
    static CertFreeCertificateChainList(prgpSelection) {
        DllCall("CRYPT32.dll\CertFreeCertificateChainList", "ptr", prgpSelection)
    }

    /**
     * Encodes a time stamp request and retrieves the time stamp token from a location specified by a URL to a Time Stamping Authority (TSA).
     * @param {Pointer<PWSTR>} wszUrl A pointer to a null-terminated wide character string that contains the URL of the TSA to which to send the request.
     * @param {Integer} dwRetrievalFlags A set of flags that specify how the time stamp is retrieved.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TIMESTAMP_DONT_HASH_DATA"></a><a id="timestamp_dont_hash_data"></a><dl>
     * <dt><b>TIMESTAMP_DONT_HASH_DATA</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Inhibit hash calculation on the array of bytes pointed to by the <i>pbData</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TIMESTAMP_VERIFY_CONTEXT_SIGNATURE"></a><a id="timestamp_verify_context_signature"></a><dl>
     * <dt><b>TIMESTAMP_VERIFY_CONTEXT_SIGNATURE</b></dt>
     * <dt>0x00000020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enforce signature validation on the retrieved time stamp.
     * 
     * 
     * <div class="alert"><b>Note</b>  The <b>TIMESTAMP_VERIFY_CONTEXT_SIGNATURE</b> flag is valid only      if the <b>fRequestCerts</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_timestamp_para">CRYPT_TIMESTAMP_PARA</a> pointed to by the <i>pPara</i> parameter is set to <b>TRUE</b>.</div>
     * <div> </div>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TIMESTAMP_NO_AUTH_RETRIEVAL"></a><a id="timestamp_no_auth_retrieval"></a><dl>
     * <dt><b>TIMESTAMP_NO_AUTH_RETRIEVAL</b></dt>
     * <dt>0x00020000 </dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Set this flag to inhibit automatic authentication handling.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwTimeout A <b>DWORD</b> value that specifies the maximum number of milliseconds to wait for retrieval. If this parameter is set to zero, this function does not time out.
     * @param {Pointer<PSTR>} pszHashId A pointer to a null-terminated character string that contains the hash algorithm <a href="https://docs.microsoft.com/windows/desktop/SecGloss/o-gly">object identifier</a> (OID).
     * @param {Pointer<CRYPT_TIMESTAMP_PARA>} pPara A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_timestamp_para">CRYPT_TIMESTAMP_PARA</a> structure that contains additional parameters for the request.
     * @param {Pointer<Byte>} pbData A pointer to an array of bytes to be time stamped.
     * @param {Integer} cbData The size, in bytes, of the array pointed to by the <i>pbData</i> parameter.
     * @param {Pointer<CRYPT_TIMESTAMP_CONTEXT>} ppTsContext A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_timestamp_context">PCRYPT_TIMESTAMP_CONTEXT</a> structure. When you have finished using the context, you must free it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmemfree">CryptMemFree</a> function.
     * @param {Pointer<CERT_CONTEXT>} ppTsSigner A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">PCERT_CONTEXT</a> that
     * receives the certificate of the signer.
     *      When you have finished using this structure, you must free it by passing this
     * pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function.
     * 
     * 
     * Set this parameter to <b>NULL</b> if the TSA signer's certificate is not needed.
     * @param {Pointer<HCERTSTORE>} phStore The handle of a certificate store initialized with certificates from the time stamp response. This store can be used for validating the signer certificate of the time stamp response.
     * 
     * This parameter can be <b>NULL</b> if the TSA supporting certificates are not needed. When you have finished using this handle,  release it by passing it to  the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a> function.
     * @returns {Integer} If the function is unable to retrieve, decode, and validate the time stamp context, it returns <b>FALSE</b>. For extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptretrievetimestamp
     * @since windows6.1
     */
    static CryptRetrieveTimeStamp(wszUrl, dwRetrievalFlags, dwTimeout, pszHashId, pPara, pbData, cbData, ppTsContext, ppTsSigner, phStore) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptRetrieveTimeStamp", "ptr", wszUrl, "uint", dwRetrievalFlags, "uint", dwTimeout, "ptr", pszHashId, "ptr", pPara, "ptr", pbData, "uint", cbData, "ptr", ppTsContext, "ptr", ppTsSigner, "ptr", phStore, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Validates the time stamp signature on a specified array of bytes.
     * @remarks
     * The caller should validate the <b>pszTSAPolicyId</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_timestamp_info">CRYPT_TIMESTAMP_INFO</a> structure when it is returned by the   <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptretrievetimestamp">CryptRetrieveTimeStamp</a> function. If a TSA policy was specified in the request 
     *      and the <b>ftTime</b> member contains a valid value, the caller should build a certificate context chain with which to populate the <i>ppTsSigner</i> parameter and validate the trust.
     * @param {Pointer<Byte>} pbTSContentInfo A pointer to a buffer that contains time stamp content.
     * @param {Integer} cbTSContentInfo The size, in bytes, of the buffer pointed to by the <i>pbTSContentInfo</i> parameter.
     * @param {Pointer<Byte>} pbData A pointer to an array of bytes on which to validate the time stamp signature.
     * @param {Integer} cbData The size, in bytes, of the array pointed to by the <i>pbData</i> parameter.
     * @param {Pointer<HCERTSTORE>} hAdditionalStore The handle of an additional store to search for supporting
     * Time Stamping Authority (TSA) signing certificates and <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">certificate trust lists</a> (CTLs).
     *     This parameter can be <b>NULL</b> if no additional store is to be searched.
     * @param {Pointer<CRYPT_TIMESTAMP_CONTEXT>} ppTsContext A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-crypt_timestamp_context">PCRYPT_TIMESTAMP_CONTEXT</a> structure. When you have finished using the context, you must free it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptmemfree">CryptMemFree</a> function.
     * @param {Pointer<CERT_CONTEXT>} ppTsSigner A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/ns-wincrypt-cert_context">PCERT_CONTEXT</a> that
     * receives the certificate of the signer.
     *      When you have finished using this structure, you must free it by passing this
     * pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certfreecertificatecontext">CertFreeCertificateContext</a> function.
     * 
     * Set this parameter to <b>NULL</b> if the TSA signer's certificate is not needed.
     * @param {Pointer<HCERTSTORE>} phStore A pointer to a handle that receives the certificate store opened  on CMS to search for supporting certificates.
     * 
     * This parameter can be <b>NULL</b> if the TSA supporting certificates are not needed. When you have finished using this handle,  you  must release it by passing it to  the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-certclosestore">CertCloseStore</a> function.
     * @returns {Integer} If the function succeeds, the function returns <b>TRUE</b>. For extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-cryptverifytimestampsignature
     * @since windows6.1
     */
    static CryptVerifyTimeStampSignature(pbTSContentInfo, cbTSContentInfo, pbData, cbData, hAdditionalStore, ppTsContext, ppTsSigner, phStore) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptVerifyTimeStampSignature", "ptr", pbTSContentInfo, "uint", cbTSContentInfo, "ptr", pbData, "uint", cbData, "ptr", hAdditionalStore, "ptr", ppTsContext, "ptr", ppTsSigner, "ptr", phStore, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Integer} dwHashUseType 
     * @param {Pointer<PWSTR>} pwszCNGHashAlgid 
     * @param {Integer} dwChainFlags 
     * @param {Pointer<CERT_CHAIN_CONTEXT>} pSignerChainContext 
     * @param {Pointer<FILETIME>} pTimeStamp 
     * @param {Pointer<PWSTR>} pwszFileName 
     * @returns {Integer} 
     */
    static CertIsWeakHash(dwHashUseType, pwszCNGHashAlgid, dwChainFlags, pSignerChainContext, pTimeStamp, pwszFileName) {
        result := DllCall("CRYPT32.dll\CertIsWeakHash", "uint", dwHashUseType, "ptr", pwszCNGHashAlgid, "uint", dwChainFlags, "ptr", pSignerChainContext, "ptr", pTimeStamp, "ptr", pwszFileName, "int")
        return result
    }

    /**
     * Performs encryption on the data in a DATA_BLOB structure.
     * @remarks
     * Typically, only a user with logon <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">credentials</a> that match those of the user who encrypted the data can decrypt the data. In addition, decryption usually can only be done on the computer where the data was encrypted. However, a user with a roaming profile can decrypt the data from another computer on the network.
     * 
     * If the CRYPTPROTECT_LOCAL_MACHINE flag is set when the data is encrypted, any user on the computer where the encryption was done can decrypt the data.
     * 
     * The function creates a session key to perform the encryption. The session key is derived again when the data is to be decrypted.
     * 
     * The function also adds a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">Message Authentication Code</a> (MAC) (keyed integrity check) to the encrypted data to guard against data tampering.
     * 
     * To encrypt memory for temporary use in the same process or across processes, call the <a href="https://docs.microsoft.com/windows/desktop/api/dpapi/nf-dpapi-cryptprotectmemory">CryptProtectMemory</a> function.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pDataIn A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">DATA_BLOB</a> structure that contains the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">plaintext</a> to be encrypted.
     * @param {Pointer<PWSTR>} szDataDescr A string with a readable description of the data to be encrypted. This description string is included with the encrypted data. This parameter is optional and can be set to <b>NULL</b>.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pOptionalEntropy A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">DATA_BLOB</a> structure that contains a password or other additional entropy used to encrypt the data. The <b>DATA_BLOB</b> structure used in the encryption phase must also be used in the decryption phase. This parameter can be set to <b>NULL</b> for no additional entropy. For information about protecting passwords, see <a href="https://docs.microsoft.com/windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.
     * @param {Pointer<CRYPTPROTECT_PROMPTSTRUCT>} pPromptStruct A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/dpapi/ns-dpapi-cryptprotect_promptstruct">CRYPTPROTECT_PROMPTSTRUCT</a> structure that provides information about where and when prompts are to be displayed and what the content of those prompts should be. This parameter can be set to <b>NULL</b> in both the encryption and decryption phases.
     * @param {Integer} dwFlags This parameter can be one of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECT_LOCAL_MACHINE"></a><a id="cryptprotect_local_machine"></a><dl>
     * <dt><b>CRYPTPROTECT_LOCAL_MACHINE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When this flag is set, it associates the data encrypted with the current computer instead of with an individual user. Any user on the computer on which <b>CryptProtectData</b> is called can use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/dpapi/nf-dpapi-cryptunprotectdata">CryptUnprotectData</a> to decrypt the data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECT_UI_FORBIDDEN"></a><a id="cryptprotect_ui_forbidden"></a><dl>
     * <dt><b>CRYPTPROTECT_UI_FORBIDDEN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is used for remote situations where presenting a user interface (UI) is not an option. When this flag is set and a UI is specified for either the protect or unprotect operation, the operation fails and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the ERROR_PASSWORD_RESTRICTION code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECT_AUDIT"></a><a id="cryptprotect_audit"></a><dl>
     * <dt><b>CRYPTPROTECT_AUDIT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag generates an audit on protect and unprotect operations. Audit log entries are recorded only if szDataDescr is not <b>NULL</b> and not empty.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pDataOut A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">DATA_BLOB</a> structure that receives the encrypted data. When you have finished using the <b>DATA_BLOB</b> structure, free its <b>pbData</b> member by calling the   <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> function.
     * @returns {Integer} If the function succeeds, the function returns <b>TRUE</b>.
     * 						
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/dpapi/nf-dpapi-cryptprotectdata
     * @since windows5.1.2600
     */
    static CryptProtectData(pDataIn, szDataDescr, pOptionalEntropy, pPromptStruct, dwFlags, pDataOut) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptProtectData", "ptr", pDataIn, "ptr", szDataDescr, "ptr", pOptionalEntropy, "ptr", pvReserved, "ptr", pPromptStruct, "uint", dwFlags, "ptr", pDataOut, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Decrypts and does an integrity check of the data in a DATA_BLOB structure.
     * @remarks
     * The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/dpapi/nf-dpapi-cryptprotectdata">CryptProtectData</a> function creates a session key when the data is encrypted. That key is derived again and used to decrypt the data <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a>.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">Message Authentication Code</a> (MAC) <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">hash</a> added to the encrypted data can be used to determine whether the encrypted data was altered in any way. Any tampering results in the return of the ERROR_INVALID_DATA code.
     * 
     * When you have finished using the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">DATA_BLOB</a> structure, free its <b>pbData</b> member by calling the  <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> function. Any <i>ppszDataDescr</i> that is not <b>NULL</b> must also be freed by using <b>LocalFree</b>.
     * 
     *  When you have finished using sensitive information, clear it from memory by calling the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pDataIn A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">DATA_BLOB</a> structure that holds the encrypted data. The <b>DATA_BLOB</b> structure's <b>cbData</b> member holds the length of the <b>pbData</b> member's byte string that contains the text to be encrypted.
     * @param {Pointer<PWSTR>} ppszDataDescr A pointer to a string-readable description of the encrypted data included with the encrypted data. This parameter can be set to <b>NULL</b>.  When you have finished using <i>ppszDataDescr</i>, free it by calling the  <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> function.
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pOptionalEntropy A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">DATA_BLOB</a> structure that contains a password or other additional entropy used when the data was encrypted. This parameter can be set to <b>NULL</b>; however, if an optional entropy <b>DATA_BLOB</b> structure was used in the encryption phase, that same <b>DATA_BLOB</b> structure must be used for the decryption phase. For information about protecting passwords, see <a href="https://docs.microsoft.com/windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.
     * @param {Pointer<CRYPTPROTECT_PROMPTSTRUCT>} pPromptStruct A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/dpapi/ns-dpapi-cryptprotect_promptstruct">CRYPTPROTECT_PROMPTSTRUCT</a> structure that provides information about where and when prompts are to be displayed and what the content of those prompts should be. This parameter can be set to <b>NULL</b>.
     * @param {Integer} dwFlags A <b>DWORD</b> value that specifies options for this function. This parameter can be zero, in which case no option is set, or the following flag.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECT_UI_FORBIDDEN"></a><a id="cryptprotect_ui_forbidden"></a><dl>
     * <dt><b>CRYPTPROTECT_UI_FORBIDDEN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is used for remote situations where the user interface (UI) is not an option. When this flag is set and UI is specified for either the protect or unprotect operation, the operation fails and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns the ERROR_PASSWORD_RESTRICTION code.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECT_VERIFY_PROTECTION"></a><a id="cryptprotect_verify_protection"></a><dl>
     * <dt><b>CRYPTPROTECT_VERIFY_PROTECTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag verifies the protection of a protected <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">BLOB</a>. If the default protection level configured of the host is higher than the current protection level for the BLOB, the function returns <b>CRYPT_I_NEW_PROTECTION_REQUIRED</b> to advise the caller to again protect the plaintext contained in the BLOB.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CRYPT_INTEGER_BLOB>} pDataOut A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)">DATA_BLOB</a> structure where the function stores the decrypted data. When you have finished using the <b>DATA_BLOB</b> structure, free its <b>pbData</b> member by calling the  <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> function.
     * @returns {Integer} If the function succeeds, the function returns  <b>TRUE</b>.
     * 
     * If the function fails, it returns  <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/dpapi/nf-dpapi-cryptunprotectdata
     * @since windows5.1.2600
     */
    static CryptUnprotectData(pDataIn, ppszDataDescr, pOptionalEntropy, pPromptStruct, dwFlags, pDataOut) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptUnprotectData", "ptr", pDataIn, "ptr", ppszDataDescr, "ptr", pOptionalEntropy, "ptr", pvReserved, "ptr", pPromptStruct, "uint", dwFlags, "ptr", pDataOut, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Migrates the current user's master keys after the user's security identifier (SID) has changed.
     * @remarks
     * This function decrypts all of the user's master keys in the old master key directory, using the previous password, and stores them in the user's current master key directory, encrypted with the user's current password.
     * 
     *  This function must be called from the user account that the keys are being migrated to.
     * 
     * If this function is able to successfully migrate an old master key, it will automatically delete the old master key. 
     * Master keys that cannot be decrypted are not deleted.
     * @param {Pointer<PSID>} pOldSid The address of a <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-sid">SID</a> structure that contains the user's previous SID. This SID is used to locate the old master keys. If this parameter is <b>NULL</b>, the master keys for the current user SID are migrated.
     * 
     * Either this parameter or the <i>pwszOldPassword</i> parameter may be <b>NULL</b>, but not both.
     * @param {Pointer<PWSTR>} pwszOldPassword A pointer to a null-terminated Unicode string that contains the user's password before the SID was changed. This password is used to decrypt the old master keys. If this parameter is <b>NULL</b>, the password of the current user will be used.
     * 
     * Either this parameter or the <i>pOldSid</i> parameter may be <b>NULL</b>, but not both.
     * @param {Integer} dwFlags Not used. Must be zero.
     * @param {Pointer<UInt32>} pdwSuccessCount The address of a <b>DWORD</b> variable that receives the number of master keys that were successfully migrated.
     * @param {Pointer<UInt32>} pdwFailureCount The address of a <b>DWORD</b> variable that receives the number of master keys that could not be decrypted.
     * 
     * It is not necessarily an error if one or more master keys cannot be decrypted. Some users may possess master keys that are stagnant and could not have been decrypted for a long time. One way that this can happen is when the password of a local user has been administratively reset.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Some possible error codes include the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters contains a value that is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_OUTOFMEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ENCRYPTION_FAILED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The old password could not be encrypted.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/dpapi/nf-dpapi-cryptupdateprotectedstate
     * @since windows6.0.6000
     */
    static CryptUpdateProtectedState(pOldSid, pwszOldPassword, dwFlags, pdwSuccessCount, pdwFailureCount) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptUpdateProtectedState", "ptr", pOldSid, "ptr", pwszOldPassword, "uint", dwFlags, "ptr", pdwSuccessCount, "ptr", pdwFailureCount, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * encrypts memory to prevent others from viewing sensitive information in your process.
     * @remarks
     * Using  <a href="https://docs.microsoft.com/windows/desktop/api/dpapi/nf-dpapi-cryptprotectmemory">CryptProtectMemory</a> and <a href="https://docs.microsoft.com/windows/desktop/api/dpapi/nf-dpapi-cryptunprotectmemory">CryptUnprotectMemory</a> for password encryption is not secure because the data exists as plaintext in memory before it is encrypted and at any time the caller decrypts it for use.
     * 
     * Typically, you use the <b>CryptProtectMemory</b> function to encrypt sensitive information that you are going to decrypt while your process is running.  Do not use this function to save data that you want to decrypt later; you will not be able to decrypt the data if the computer is restarted. To save encrypted data to a file to decrypt later, use the <a href="https://docs.microsoft.com/windows/desktop/api/dpapi/nf-dpapi-cryptprotectdata">CryptProtectData</a> function.  
     * 
     * Call the <a href="https://docs.microsoft.com/windows/desktop/api/dpapi/nf-dpapi-cryptunprotectmemory">CryptUnprotectMemory</a> function to decrypt memory encrypted with the <b>CryptProtectMemory</b> function.  When you have finished using the sensitive information, clear it from memory by calling the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. 
     * 
     * Use the CRYPTPROTECTMEMORY_CROSS_PROCESS or CRYPTPROTECTMEMORY_SAME_LOGON flag if you use RPC or LRPC to pass encrypted data to another process. The receiving process must specify the same flag to decrypt the data. Also, use these flags if you use shared memory.
     * 
     * If the client uses the CRYPTPROTECTMEMORY_SAME_LOGON flag, the server must impersonate the client (<a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcimpersonateclient">RpcImpersonateClient</a>) before decrypting the memory.
     * @param {Pointer<Void>} pDataIn A pointer to the block of memory to encrypt. The <i>cbDataIn</i> parameter specifies the number of bytes that will be encrypted. If the data contained in the memory space is smaller than the number of bytes specified, data outside of the intended block will be encrypted. If it is larger than <i>cbDataIn</i> bytes, then only the first <i>cbDataIn</i> bytes will be encrypted.
     * @param {Integer} cbDataIn Number of bytes of memory pointed to by the <i>pData</i> parameter to encrypt. The number of bytes must be a multiple of the <b>CRYPTPROTECTMEMORY_BLOCK_SIZE</b> constant defined in Wincrypt.h.
     * @param {Integer} dwFlags This parameter can be one of the following flags. You must specify the same flag when encrypting and decrypting the memory.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECTMEMORY_SAME_PROCESS"></a><a id="cryptprotectmemory_same_process"></a><dl>
     * <dt><b>CRYPTPROTECTMEMORY_SAME_PROCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encrypt and decrypt memory in the same process. An application running in a different process will not be able to decrypt the data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECTMEMORY_CROSS_PROCESS"></a><a id="cryptprotectmemory_cross_process"></a><dl>
     * <dt><b>CRYPTPROTECTMEMORY_CROSS_PROCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encrypt and decrypt memory in different processes. An application running in a different process will be able to decrypt the data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECTMEMORY_SAME_LOGON"></a><a id="cryptprotectmemory_same_logon"></a><dl>
     * <dt><b>CRYPTPROTECTMEMORY_SAME_LOGON</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the same logon credentials to encrypt and decrypt memory in different processes. An application running in a different process will be able to decrypt the data. However, the process must run as the same user that encrypted the data and in the same logon session. 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/dpapi/nf-dpapi-cryptprotectmemory
     * @since windows6.0.6000
     */
    static CryptProtectMemory(pDataIn, cbDataIn, dwFlags) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptProtectMemory", "ptr", pDataIn, "uint", cbDataIn, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Decrypts memory that was encrypted using the CryptProtectMemory function.
     * @remarks
     * Using  <a href="https://docs.microsoft.com/windows/desktop/api/dpapi/nf-dpapi-cryptprotectmemory">CryptProtectMemory</a> and <a href="https://docs.microsoft.com/windows/desktop/api/dpapi/nf-dpapi-cryptunprotectmemory">CryptUnprotectMemory</a> for password encryption is not secure because the data exists as plaintext in memory before it is encrypted and at any time the caller decrypts it for use.
     * 
     *  You must encrypt and decrypt the memory during the same boot session. If the computer is restarted before you call the <b>CryptUnprotectMemory</b> function, you will not be able to decrypt the data.
     * 
     * You must pass the same flag to <b>CryptUnprotectMemory</b> and <a href="https://docs.microsoft.com/windows/desktop/api/dpapi/nf-dpapi-cryptprotectmemory">CryptProtectMemory</a>. If you pass different flags, the <b>CryptUnprotectMemory</b> function succeeds; however, the result is unpredictable.
     * 
     *  When you have finished using the sensitive information, clear it from memory by calling the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function.
     * @param {Pointer<Void>} pDataIn A pointer to the block of memory to decrypt. The <i>cbData</i> parameter specifies the number of bytes that the function will attempt to decrypt. If the data contained in the memory space is smaller than the number of bytes specified, the function will attempt to decrypt data outside of the intended block. If it is larger than <i>cbData</i> bytes, then only the first <i>cbData</i> bytes will be decrypted.
     * @param {Integer} cbDataIn Number of bytes of memory pointed to by the <i>pData</i> parameter to decrypt. The number of bytes must be a multiple of the <b>CRYPTPROTECTMEMORY_BLOCK_SIZE</b> constant defined in Wincrypt.h.
     * @param {Integer} dwFlags This parameter can be one of the following flags. You must specify the same flag when encrypting and decrypting the memory.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECTMEMORY_SAME_PROCESS"></a><a id="cryptprotectmemory_same_process"></a><dl>
     * <dt><b>CRYPTPROTECTMEMORY_SAME_PROCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encrypt and decrypt memory in the same process. An application running in a different process will not be able to decrypt the data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECTMEMORY_CROSS_PROCESS"></a><a id="cryptprotectmemory_cross_process"></a><dl>
     * <dt><b>CRYPTPROTECTMEMORY_CROSS_PROCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Encrypt and decrypt memory in different processes. An application running in a different process will be able to decrypt the data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPTPROTECTMEMORY_SAME_LOGON"></a><a id="cryptprotectmemory_same_logon"></a><dl>
     * <dt><b>CRYPTPROTECTMEMORY_SAME_LOGON</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use the same logon credentials to encrypt and decrypt memory in different processes. An application running in a different process will be able to decrypt the data. However, the process must run as the same user that encrypted the data and in the same logon session.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the function returns <b>TRUE</b>.
     * 
     * If the function fails, it returns <b>FALSE</b>. For extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/dpapi/nf-dpapi-cryptunprotectmemory
     * @since windows6.0.6000
     */
    static CryptUnprotectMemory(pDataIn, cbDataIn, dwFlags) {
        A_LastError := 0

        result := DllCall("CRYPT32.dll\CryptUnprotectMemory", "ptr", pDataIn, "uint", cbDataIn, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Registers the display name and the associated rule string for a protection descriptor.
     * @remarks
     * The registry key created by using this function is not volatile. The information is stored in a file and preserved when the computer shuts down.
     * @param {Pointer<PWSTR>} pwszName Pointer to a null-terminated Unicode string that contains the display name of the descriptor to be registered.
     * @param {Pointer<PWSTR>} pwszDescriptorString Pointer to a null-terminated Unicode string that contains a protection descriptor rule. If this parameter is <b>NULL</b> or the string is empty, the registry value previously created for the <i>pwszName</i> parameter will be deleted.
     * @param {Integer} dwFlags A constant that indicates the registry hive under which to register the new entry. If this value is zero (0), the registry root is <b>HKEY_CURRENT_USER</b>. If this value is <b>NCRYPT_MACHINE_KEY_FLAG</b>, the root is <b>HKEY_LOCAL_MACHINE</b>.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pwszName</i> parameter cannot be <b>NULL</b>, and the value pointed to by the parameter cannot be an empty string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter must be zero or <b>NCRYPT_MACHINE_KEY_FLAG</b>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptregisterprotectiondescriptorname
     * @since windows8.0
     */
    static NCryptRegisterProtectionDescriptorName(pwszName, pwszDescriptorString, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptRegisterProtectionDescriptorName", "ptr", pwszName, "ptr", pwszDescriptorString, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves the protection descriptor rule string associated with a registered descriptor display name.
     * @remarks
     * To retrieve a protection descriptor rule string, you must call this function twice. The first time you call, set the <i>pwszDescriptorString</i> argument to <b>NULL</b> and the value pointed to by the <i>pcDescriptorString</i> argument to zero. Your first call retrieves the number of characters in the descriptor string. Use this number to allocate memory for the string and retrieve a pointer to the allocated buffer. To retrieve the string, call the function again using the pointer.
     * @param {Pointer<PWSTR>} pwszName The registered display name for the protection descriptor. Register a name by calling the <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptregisterprotectiondescriptorname">NCryptRegisterProtectionDescriptorName</a> function.
     * @param {Pointer<PWSTR>} pwszDescriptorString A null-terminated Unicode string that contains the protection descriptor rule. Set this value to <b>NULL</b> and set the size of the descriptor string pointed to by <i>pcDescriptorString</i> argument to zero on your initial call to this function. For more information, see Remarks.
     * @param {Pointer<UIntPtr>} pcDescriptorString Pointer to a variable that contains the number  of characters in the string retrieved in the <i>pwszDescriptorString</i> parameter. Set the variable to zero on your initial call to this function. For more information, see Remarks.
     * @param {Integer} dwFlags Flag that specifies which registry hive to query for the registered name. This can be zero to look in the <b>HKEY_CURRENT_USER</b> hive or you can specify <b>NCRYPT_MACHINE_KEY_FLAG</b> to query the <b>HKEY_LOCAL_MACHINE</b> hive.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pwszName</i> parameter cannot be <b>NULL</b>, and the value pointed to by the parameter cannot be an empty string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwFlags</i> parameter must be zero or <b>NCRYPT_MACHINE_KEY_FLAG</b>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptqueryprotectiondescriptorname
     * @since windows8.0
     */
    static NCryptQueryProtectionDescriptorName(pwszName, pwszDescriptorString, pcDescriptorString, dwFlags) {
        result := DllCall("ncrypt.dll\NCryptQueryProtectionDescriptorName", "ptr", pwszName, "ptr", pwszDescriptorString, "ptr", pcDescriptorString, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves a handle to a protection descriptor object.
     * @remarks
     * The protection descriptor object created by this function is an internal data structure that contains information about the descriptor. You cannot use it directly. Your application can, however, use the returned handle in the following functions:
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptcloseprotectiondescriptor">NCryptCloseProtectionDescriptor</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptgetprotectiondescriptorinfo">NCryptGetProtectionDescriptorInfo</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptprotectsecret">NCryptProtectSecret</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptprotectsecret">NCryptProtectSecret</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptunprotectsecret">NCryptUnprotectSecret</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamopentoprotect">NCryptStreamOpenToProtect</a>
     * </li>
     * </ul>
     * The following examples show protection descriptor rule strings:
     * 
     * <ul>
     * <li>"SID=S-1-5-21-4392301 AND SID=S-1-5-21-3101812"</li>
     * <li>"SDDL=O:S-1-5-5-0-290724G:SYD:(A;;CCDC;;;S-1-5-5-0-290724)(A;;DC;;;WD)"</li>
     * <li>"LOCAL=user"</li>
     * <li>"LOCAL=machine"</li>
     * <li>"WEBCREDENTIALS=MyPasswordName"</li>
     * <li>"WEBCREDENTIALS=MyPasswordName,myweb.com"</li>
     * </ul>
     * You can use the <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptregisterprotectiondescriptorname">NCryptRegisterProtectionDescriptorName</a> function to associate a display name with a rule string and save both in the registry.
     * @param {Pointer<PWSTR>} pwszDescriptorString Null-terminated Unicode string that contains a protection descriptor rule string or a registered display name for the rule.
     * 
     * If you specify the display name and you want this function to look in the registry for the associated protection descriptor rule string, you must set the <i>dwFlags</i> parameter to <b>NCRYPT_NAMED_DESCRIPTOR_FLAG</b>.
     * @param {Integer} dwFlags Flag that specifies whether the string in <i>pwszDescriptorString</i> represents the display name of a  protection descriptor and, if so, where in the registry the function should search for the associated protection rule string. The following value combinations can be set:
     * 
     * <ul>
     * <li>To indicate that the value set in the <i>pwszDescriptorString</i> parameter is a complete protection descriptor rule string rather than a display name, set the <i>dwFlags</i> parameter to zero (0).</li>
     * <li>To indicate that the string is a display name and that it is saved, along with its associated descriptor rule string, in the <b>HKEY_LOCAL_MACHINE</b> registry hive, bitwise-OR  the <b>NCRYPT_NAMED_DESCRIPTOR_FLAG</b> value and the <b>NCRYPT_MACHINE_KEY_FLAG</b> value.</li>
     * <li>To indicate that the string is a display name and that it is saved, along with its associated descriptor string rule, in the <b>HKEY_CURRENT_USER</b> registry hive, set only the <b>NCRYPT_NAMED_DESCRIPTOR_FLAG</b> value. That is, there is no unique  flag to specify the current user registry hive.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  To associate a descriptor rule with a display name and save both in the registry, call the <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptregisterprotectiondescriptorname">NCryptRegisterProtectionDescriptorName</a> function.</div>
     * <div> </div>
     * @param {Pointer<NCRYPT_DESCRIPTOR_HANDLE>} phDescriptor Pointer to a protection descriptor object handle.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>phDescriptor</i> parameter cannot be <b>NULL</b>.
     * 
     * The <i>pwszDescriptorString</i> parameter cannot be <b>NULL</b> and it cannot be an empty sting.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The dwFlags parameter must be <b>NCRYPT_MACHINE_KEY_FLAG</b> or <b>NCRYPT_NAMED_DESCRIPTOR_FLAG</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Memory could not be allocated to retrieve the registered protection descriptor string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protection descriptor name specified in the <i>pwszDescriptorString</i> parameter could not be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptcreateprotectiondescriptor
     * @since windows8.0
     */
    static NCryptCreateProtectionDescriptor(pwszDescriptorString, dwFlags, phDescriptor) {
        result := DllCall("ncrypt.dll\NCryptCreateProtectionDescriptor", "ptr", pwszDescriptorString, "uint", dwFlags, "ptr", phDescriptor, "int")
        return result
    }

    /**
     * Zeros and frees a protection descriptor object and releases its handle.
     * @param {Pointer<NCRYPT_DESCRIPTOR_HANDLE>} hDescriptor Handle of a protection descriptor created by calling <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptcreateprotectiondescriptor">NCryptCreateProtectionDescriptor</a>.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle specified by the <i>hDescriptor</i> parameter cannot be <b>NULL</b> and it must represent a valid descriptor.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptcloseprotectiondescriptor
     * @since windows8.0
     */
    static NCryptCloseProtectionDescriptor(hDescriptor) {
        result := DllCall("ncrypt.dll\NCryptCloseProtectionDescriptor", "ptr", hDescriptor, "int")
        return result
    }

    /**
     * Retrieves a protection descriptor rule string.
     * @param {Pointer<NCRYPT_DESCRIPTOR_HANDLE>} hDescriptor Protection descriptor handle created by calling <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptcreateprotectiondescriptor">NCryptCreateProtectionDescriptor</a>.
     * @param {Pointer<NCRYPT_ALLOC_PARA>} pMemPara Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/ns-ncrypt-ncrypt_alloc_para">NCRYPT_ALLOC_PARA</a> structure that you can use to specify custom memory management functions. If you set this argument to <b>NULL</b>, the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> function is used internally to allocate memory and your application must call <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> to release memory pointed to by the <i>ppvInfo</i> parameter.
     * @param {Integer} dwInfoType Specifies how to return descriptor information to the  <i>ppvInfo</i> parameter. This can be the following value:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_PROTECTION_INFO_TYPE_DESCRIPTOR_STRING"></a><a id="ncrypt_protection_info_type_descriptor_string"></a><dl>
     * <dt><b>NCRYPT_PROTECTION_INFO_TYPE_DESCRIPTOR_STRING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>ppvInfo</i> argument returns the descriptor rule string.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} ppvInfo Pointer to the descriptor information.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>ppvInfo</i> parameter cannot be <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unsupported value was specified in the <i>dwInfoType</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle specified by the <i>hDescriptor</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptgetprotectiondescriptorinfo
     * @since windows8.0
     */
    static NCryptGetProtectionDescriptorInfo(hDescriptor, pMemPara, dwInfoType, ppvInfo) {
        result := DllCall("ncrypt.dll\NCryptGetProtectionDescriptorInfo", "ptr", hDescriptor, "ptr", pMemPara, "uint", dwInfoType, "ptr", ppvInfo, "int")
        return result
    }

    /**
     * Encrypts data to a specified protection descriptor.
     * @remarks
     * Use the <b>NCryptProtectSecret</b> function to protect keys, key material, and passwords. Use the <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamopentoprotect">NCryptStreamOpenToProtect</a> and the <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamupdate">NCryptStreamUpdate</a> functions to encrypt larger messages.
     * @param {Pointer<NCRYPT_DESCRIPTOR_HANDLE>} hDescriptor Handle of the protection descriptor object. Create the handle by calling <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptcreateprotectiondescriptor">NCryptCreateProtectionDescriptor</a>.
     * @param {Integer} dwFlags The flag can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider not display a user interface.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} pbData Pointer to the byte array to be protected.
     * @param {Integer} cbData Number of bytes in the binary array specified by the <i>pbData</i> parameter.
     * @param {Pointer<NCRYPT_ALLOC_PARA>} pMemPara Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/ns-ncrypt-ncrypt_alloc_para">NCRYPT_ALLOC_PARA</a> structure that you can use to specify custom memory management functions. If you set this argument to <b>NULL</b>, the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> function is used internally to allocate memory and your application must call <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> to release memory pointed to by the <i>ppbProtectedBlob</i> parameter.
     * @param {Pointer<HWND>} hWnd Handle to the parent window of the user interface, if any, to be displayed.
     * @param {Pointer<Byte>} ppbProtectedBlob Address of a variable that receives a pointer to the encrypted data.
     * @param {Pointer<UInt32>} pcbProtectedBlob Pointer to a <b>ULONG</b> variable that contains the size, in bytes, of the encrypted data pointed to by the <i>ppbProtectedBlob</i> variable.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pbData</i>, <i>ppbProtectedBlob</i>, and <i>pcbProtectedBlob</i> parameters cannot be <b>NULL</b>.
     * 
     * The <i>cbData</i> parameter cannot be less than one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory exists to allocate the content encryption key.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle specified by the <i>hDescriptor</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptprotectsecret
     * @since windows8.0
     */
    static NCryptProtectSecret(hDescriptor, dwFlags, pbData, cbData, pMemPara, hWnd, ppbProtectedBlob, pcbProtectedBlob) {
        result := DllCall("ncrypt.dll\NCryptProtectSecret", "ptr", hDescriptor, "uint", dwFlags, "ptr", pbData, "uint", cbData, "ptr", pMemPara, "ptr", hWnd, "ptr", ppbProtectedBlob, "ptr", pcbProtectedBlob, "int")
        return result
    }

    /**
     * Decrypts data to a specified protection descriptor.
     * @remarks
     * Use the <b>NCryptUnprotectSecret</b> function to decrypt keys, key material, and passwords. Use the <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamopentounprotect">NCryptStreamOpenToUnprotect</a>  and the <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamupdate">NCryptStreamUpdate</a> functions to decrypt larger messages.
     * @param {Pointer<NCRYPT_DESCRIPTOR_HANDLE>} phDescriptor Pointer to the protection descriptor handle.
     * @param {Integer} dwFlags 
     * @param {Pointer<Byte>} pbProtectedBlob Pointer to an array of bytes that contains the data to decrypt.
     * @param {Integer} cbProtectedBlob The number of bytes in the array pointed to by the <i>pbProtectedBlob</i> parameter.
     * @param {Pointer<NCRYPT_ALLOC_PARA>} pMemPara Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/ncrypt/ns-ncrypt-ncrypt_alloc_para">NCRYPT_ALLOC_PARA</a> structure that you can use to specify custom memory management functions. If you set this argument to <b>NULL</b>, the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> function is used internally to allocate memory and your application must call <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> to release memory pointed to by the <i>ppbData</i> parameter.
     * @param {Pointer<HWND>} hWnd Handle to the parent window of the user interface, if any, to be displayed.
     * @param {Pointer<Byte>} ppbData Address of a variable that receives a pointer to the decrypted data.
     * @param {Pointer<UInt32>} pcbData Pointer to a <b>ULONG</b> variable that contains the size, in bytes, of the decrypted data pointed to by the <i>ppbData</i> variable.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The dwFlags parameter can only contain <b>NCRYPT_SILENT_FLAG</b> or <b>NCRYPT_UNPROTECT_NO_DECRYPT</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pbProtectedBlob</i>, <i>ppbData</i>, and <i>pcbData</i> parameters cannot be <b>NULL</b>.
     * 
     * The <i>cbData</i> parameter cannot be less than one.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptunprotectsecret
     * @since windows8.0
     */
    static NCryptUnprotectSecret(phDescriptor, dwFlags, pbProtectedBlob, cbProtectedBlob, pMemPara, hWnd, ppbData, pcbData) {
        result := DllCall("ncrypt.dll\NCryptUnprotectSecret", "ptr", phDescriptor, "uint", dwFlags, "ptr", pbProtectedBlob, "uint", cbProtectedBlob, "ptr", pMemPara, "ptr", hWnd, "ptr", ppbData, "ptr", pcbData, "int")
        return result
    }

    /**
     * Opens a stream object that can be used to encrypt large amounts of data to a given protection descriptor.
     * @remarks
     * The <b>NCryptStreamOpenToProtect</b> function creates an internal stream object that can be used to encrypt large messages. You cannot use the object directly. Instead, you must use the object handle returned by this function.
     * 
     * Call this function before calling the <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamupdate">NCryptStreamUpdate</a> function. If you are encrypting a large file, use <b>NCryptStreamUpdate</b> in a loop that advances through the file block by block, encrypting each block as it advances and notifying your callback when each block is finished. For more information, see <b>NCryptStreamUpdate</b>.
     * 
     * The <b>NCryptStreamOpenToProtect</b> function writes the unencrypted protection descriptor rule string to the stream object header so that <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamopentounprotect">NCryptStreamOpenToUnprotect</a> will be able to start the decrypting the stream by using the same protector used during encryption.
     * @param {Pointer<NCRYPT_DESCRIPTOR_HANDLE>} hDescriptor Handle of the protection descriptor. Create the handle by calling <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptcreateprotectiondescriptor">NCryptCreateProtectionDescriptor</a>.
     * @param {Integer} dwFlags The flag can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider not display a user interface.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<HWND>} hWnd Handle to the parent window of the user interface, if any, to be displayed.
     * @param {Pointer<NCRYPT_PROTECT_STREAM_INFO>} pStreamInfo Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/ns-ncryptprotect-ncrypt_protect_stream_info">NCRYPT_PROTECT_STREAM_INFO</a> structure that contains the address of a user defined callback function to receive the encrypted data and a pointer to user-defined context data.
     * @param {Pointer<NCRYPT_STREAM_HANDLE>} phStream Pointer to the stream object handle.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The dwFlags parameter must contain zero (0), <b>NCRYPT_MACHINE_KEY_FLAG</b>, or <b>NCRYPT_SILENT_FLAG</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle specified by the <i>hDescriptor</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>phStream</i> and <i>pStreamInfo</i> parameters cannot be <b>NULL</b>.
     * 
     * The callback function pointed to by the <b>pfnStreamOutput</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/ns-ncryptprotect-ncrypt_protect_stream_info">NCRYPT_PROTECT_STREAM_INFO</a> structure pointed to by the <i>pStreamInfo</i> parameter cannot be <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to allocate a data stream.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptstreamopentoprotect
     * @since windows8.0
     */
    static NCryptStreamOpenToProtect(hDescriptor, dwFlags, hWnd, pStreamInfo, phStream) {
        result := DllCall("ncrypt.dll\NCryptStreamOpenToProtect", "ptr", hDescriptor, "uint", dwFlags, "ptr", hWnd, "ptr", pStreamInfo, "ptr", phStream, "int")
        return result
    }

    /**
     * Opens a stream object that can be used to decrypt large amounts of data to the same protection descriptor used for encryption. (NCryptStreamOpenToUnprotect)
     * @remarks
     * The <b>NCryptStreamOpenToUnprotect</b> function  creates an internal stream object that can be used to encrypt large messages. You cannot use the object directly. Instead, you must use the object handle returned by this function.
     * 
     * Call this function before calling the <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamupdate">NCryptStreamUpdate</a> function. If you are encrypting a large file, use <b>NCryptStreamUpdate</b> in a loop that advances through the file block by block, encrypting each block as it advances and notifying your callback when each block is finished. For more information, see <b>NCryptStreamUpdate</b>.
     * 
     * The <b>NCryptStreamOpenToUnprotect</b> function retrieves the unencrypted protection descriptor rule string from the stream header. The rule string is placed in the header by the <b>NCryptStreamOpenToUnprotect</b> function.
     * @param {Pointer<NCRYPT_PROTECT_STREAM_INFO>} pStreamInfo Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/ns-ncryptprotect-ncrypt_protect_stream_info">NCRYPT_PROTECT_STREAM_INFO</a> structure that contains the address of a user defined callback function to receive the decrypted data and a pointer to user-defined context data.
     * @param {Integer} dwFlags A flag that specifies additional information for the key service provider. This can be zero or the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NCRYPT_SILENT_FLAG"></a><a id="ncrypt_silent_flag"></a><dl>
     * <dt><b>NCRYPT_SILENT_FLAG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Requests that the key service provider not display a user interface.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<HWND>} hWnd Handle to the parent window of the user interface, if any, to be displayed.
     * @param {Pointer<NCRYPT_STREAM_HANDLE>} phStream Pointer to the handle of the decrypted stream of data.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_FLAGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The dwFlags parameter must contain zero (0) or <b>NCRYPT_SILENT_FLAG</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>phStream</i> and <i>pStreamInfo</i> parameters cannot be <b>NULL</b>.
     * 
     * The callback function pointed to by the <b>pfnStreamOutput</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/ns-ncryptprotect-ncrypt_protect_stream_info">NCRYPT_PROTECT_STREAM_INFO</a> structure pointed to by the <i>pStreamInfo</i> parameter cannot be <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to allocate a data stream.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptstreamopentounprotect
     * @since windows8.0
     */
    static NCryptStreamOpenToUnprotect(pStreamInfo, dwFlags, hWnd, phStream) {
        result := DllCall("ncrypt.dll\NCryptStreamOpenToUnprotect", "ptr", pStreamInfo, "uint", dwFlags, "ptr", hWnd, "ptr", phStream, "int")
        return result
    }

    /**
     * Opens a stream object that can be used to decrypt large amounts of data to the same protection descriptor used for encryption. (NCryptStreamOpenToUnprotectEx)
     * @param {Pointer<NCRYPT_PROTECT_STREAM_INFO_EX>} pStreamInfo A pointer to NCRYPT_PROTECT_STREAM_INFO_EX.
     * @param {Integer} dwFlags Only the NCRYPT_SILENT_FLAG is supported.
     * @param {Pointer<HWND>} hWnd A window handle to be used as the parent of any user
     *         interface that is displayed.
     * @param {Pointer<NCRYPT_STREAM_HANDLE>} phStream Receives a pointer to a stream handle.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function.
     *         Possible return codes include, but are not limited to:
     * 
     * <ul>
     * <li>ERROR_SUCCESS</li>
     * <li>NTE_INVALID_PARAMETER</li>
     * <li>NTE_BAD_FLAGS</li>
     * <li>NTE_BAD_DATA</li>
     * <li>NTE_NO_MEMORY</li>
     * <li>NTE_NOT_FOUND</li>
     * <li>NTE_NOT_SUPPORTED</li>
     * <li>NTE_INVALID_HANDLE</li>
     * <li>NTE_BAD_KEY</li>
     * <li>NTE_BAD_PROVIDER</li>
     * <li>NTE_BAD_TYPE</li>
     * <li>NTE_DECRYPTION_FAILURE</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptstreamopentounprotectex
     */
    static NCryptStreamOpenToUnprotectEx(pStreamInfo, dwFlags, hWnd, phStream) {
        result := DllCall("ncrypt.dll\NCryptStreamOpenToUnprotectEx", "ptr", pStreamInfo, "uint", dwFlags, "ptr", hWnd, "ptr", phStream, "int")
        return result
    }

    /**
     * Encrypts and decrypts blocks of data.
     * @remarks
     * You must call <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamopentoprotect">NCryptStreamOpenToProtect</a> or <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamopentounprotect">NCryptStreamOpenToUnprotect</a> to open a stream before calling <b>NCryptStreamUpdate</b>
     * 
     * Messages can be so large that processing them all at once by storing the entire message in memory can be difficult. It is possible, however,  to process large messages by partitioning the data to be processed into manageable blocks.
     * 
     * To do this, use <b>NCryptStreamUpdate</b> in a loop that advances through the file block by block. As the streamed message is processed, the resulting output data is passed back to your application by using a callback function that you specify. This is shown by the following example. For more information about the callback function, see  <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nc-ncryptprotect-pfncryptstreamoutputcallback">PFNCryptStreamOutputCallback</a>.
     * 
     * <div class="alert"><b>Note</b>  We recommend against using too small of a block size. Small blocks require more calls and therefore more calling overhead. Further, the streaming APIs are optimized for larger blocks. You should experiment to find the best block size for the data  you must process.</div>
     * <div> </div>
     * 
     * ```cpp
     * BOOL                        fFinal = FALSE;
     * PBYTE                       pbBuf = NULL;
     * 
     * // Determine the number of bytes to read.
     * DWORD cbData = GetFileSize( hFileIn, NULL );
     * 
     * // Call NCryptStreamUpdate while there is data left to read.
     * while(FALSE == fFinal)
     * {
     *     // Read dwBlockSize bytes from the file.
     *     if(dwBlockSize > 1)
     *     {
     *         if( !ReadFile(hFileIn, pbBuf, dwBlockSize, &cbResult, NULL) )
     *         {
     *             hr = HRESULT_FROM_WIN32(hr);            
     *             goto CleanUp;
     *         }
     *     }
     * 
     *     // Decrement the number of bytes to read by the current amount read.
     *     cbData -= cbResult;
     * 
     *     // Set fFinal if there are no bytes left to read.
     *     if (cbData <= 0) fFinal = TRUE;
     * 
     *     // Encrypt (or decrypt) the bytes pointed to by pbBuf
     *     hr = NCryptStreamUpdate(hStream, pbBuf, cbResult, fFinal); 
     *     if( FAILED(hr) )
     *     {            
     *         goto CleanUp;
     *     }         
     * }      
     * 
     * CleanUp:
     *     if( NULL != hStream )
     *     {
     *         NCryptStreamClose(hStream);
     *     }
     *     if( NULL != hDescriptor )
     *     {
     *         NCryptCloseProtectionDescriptor( hDescriptor );
     *     }
     *     if(NULL != pbBuf)
     *     {
     *         LocalFree(pbBuf);
     *         pbBuf = NULL;
     *     }
     * ```
     * @param {Pointer<NCRYPT_STREAM_HANDLE>} hStream Handle to the stream object created by calling <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamopentoprotect">NCryptStreamOpenToProtect</a> or <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamopentounprotect">NCryptStreamOpenToUnprotect</a>.
     * @param {Pointer<Byte>} pbData Pointer to the byte array to be processed.
     * @param {Pointer} cbData Number of bytes in the binary array specified by the <i>pbData</i> parameter.
     * @param {Integer} fFinal A Boolean value that specifies whether the last block of data has been processed.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_BAD_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The content could not be decoded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The stream handle pointed to by the <i>hStream</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_NO_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory available to process the content.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptstreamupdate
     * @since windows8.0
     */
    static NCryptStreamUpdate(hStream, pbData, cbData, fFinal) {
        result := DllCall("ncrypt.dll\NCryptStreamUpdate", "ptr", hStream, "ptr", pbData, "ptr", cbData, "int", fFinal, "int")
        return result
    }

    /**
     * Closes a data protection stream object opened by using the NCryptStreamOpenToProtect or NCryptStreamOpenToUnprotect functions.
     * @param {Pointer<NCRYPT_STREAM_HANDLE>} hStream Data stream handle returned by <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamopentoprotect">NCryptStreamOpenToProtect</a> or <a href="https://docs.microsoft.com/windows/desktop/api/ncryptprotect/nf-ncryptprotect-ncryptstreamopentounprotect">NCryptStreamOpenToUnprotect</a>.
     * @returns {Integer} Returns a status code that indicates the success or failure of the function. Possible return codes include, but are not limited to, the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NTE_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle specified by the <i>hStream</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ncryptprotect/nf-ncryptprotect-ncryptstreamclose
     * @since windows8.0
     */
    static NCryptStreamClose(hStream) {
        result := DllCall("ncrypt.dll\NCryptStreamClose", "ptr", hStream, "int")
        return result
    }

    /**
     * Calls the GetLastError function and converts the return code to an HRESULT.
     * @returns {Integer} This function has no parameters.
     * 
     * 
     * If the method succeeds, it returns **S\_OK**.
     * 
     * If the method fails, it returns an **HRESULT** value that indicates the error. For a list of common error codes, see [Common HRESULT Values](common-hresult-values.md).
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signerror
     */
    static SignError() {
        result := DllCall("Mssign32.dll\SignError", "int")
        return result
    }

    /**
     * Frees a SIGNER\_CONTEXT structure allocated by a previous call to the SignerSignEx function.
     * @param {Pointer<SIGNER_CONTEXT>} pSignerContext A pointer to the [**SIGNER\_CONTEXT**](signer-context.md) structure to free.
     * @returns {Integer} If the function succeeds, the function returns S\_OK.
     * 
     * If the function fails, it returns an **HRESULT** value that indicates the error. For a list of common error codes, see [Common HRESULT Values](common-hresult-values.md).
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signerfreesignercontext
     */
    static SignerFreeSignerContext(pSignerContext) {
        result := DllCall("Mssign32.dll\SignerFreeSignerContext", "ptr", pSignerContext, "int")
        return result
    }

    /**
     * Signs the specified file.
     * @param {Pointer<SIGNER_SUBJECT_INFO>} pSubjectInfo A pointer to a [**SIGNER\_SUBJECT\_INFO**](signer-subject-info.md) structure that specifies the subject to sign.
     * @param {Pointer<SIGNER_CERT>} pSignerCert A pointer to a [**SIGNER\_CERT**](signer-cert.md) structure that specifies the certificate to use to create the digital signature.
     * @param {Pointer<SIGNER_SIGNATURE_INFO>} pSignatureInfo A pointer to a [**SIGNER\_SIGNATURE\_INFO**](signer-signature-info.md) structure that contains information about the digital signature.
     * @param {Pointer<SIGNER_PROVIDER_INFO>} pProviderInfo A pointer to a [**SIGNER\_PROVIDER\_INFO**](signer-provider-info.md) structure that specifies the [*cryptographic service provider*](../secgloss/c-gly.md) (CSP) and [*private key*](../secgloss/p-gly.md) information used to create the digital signature.
     * 
     * If the value of this parameter is **NULL**, the value of the *pSignerCert* parameter must specify a certificate that is associated with a CSP.
     * @param {Pointer<PWSTR>} pwszHttpTimeStamp The URL of a time stamp server.
     * @param {Pointer<CRYPT_ATTRIBUTES>} psRequest A pointer to an array of [**CRYPT\_ATTRIBUTE**](/windows/desktop/api/Wincrypt/ns-wincrypt-crypt_attribute) structures that are added to a sign request. This parameter is ignored if the *pwszHttpTimeStamp* parameter does not contain a valid value that is not **NULL**.
     * @param {Pointer<Void>} pSipData A 32-bit value that is passed as additional data to SIP functions. The format and content of this is defined by the SIP provider.
     * @returns {Integer} If the function succeeds, the function returns S\_OK.
     * 
     * If the function fails, it returns an **HRESULT** value that indicates the error. For a list of common error codes, see [Common HRESULT Values](common-hresult-values.md).
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signersign
     */
    static SignerSign(pSubjectInfo, pSignerCert, pSignatureInfo, pProviderInfo, pwszHttpTimeStamp, psRequest, pSipData) {
        result := DllCall("Mssign32.dll\SignerSign", "ptr", pSubjectInfo, "ptr", pSignerCert, "ptr", pSignatureInfo, "ptr", pProviderInfo, "ptr", pwszHttpTimeStamp, "ptr", psRequest, "ptr", pSipData, "int")
        return result
    }

    /**
     * Signs the specified file and returns a pointer to the signed data.
     * @param {Integer} dwFlags Modifies the behavior of this function.
     * 
     * If the file to be signed is a portable executable (PE) file, this can be zero or a combination of one or more of the following values. These identifiers are defined in Mssip.h.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                                                                                                    | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="SPC_EXC_PE_PAGE_HASHES_FLAG"></span><span id="spc_exc_pe_page_hashes_flag"></span><dl> <dt>**SPC\_EXC\_PE\_PAGE\_HASHES\_FLAG**</dt> <dt>0x10</dt> </dl>                    | Exclude page hashes when creating SIP indirect data for the PE file. This flag takes precedence over the **SPC\_INC\_PE\_PAGE\_HASHES\_FLAG** flag.<br/> If neither the **SPC\_EXC\_PE\_PAGE\_HASHES\_FLAG** or the **SPC\_INC\_PE\_PAGE\_HASHES\_FLAG** flag is specified, the value set with the [**WintrustSetDefaultIncludePEPageHashes**](/windows/desktop/api/Wintrust/nf-wintrust-wintrustsetdefaultincludepepagehashes) function is used for this setting. The default for this setting is to exclude page hashes when creating SIP indirect data for PE files.<br/> **Windows Server 2003 and Windows XP:** This value is not supported.<br/> |
     * | <span id="SPC_INC_PE_IMPORT_ADDR_TABLE_FLAG"></span><span id="spc_inc_pe_import_addr_table_flag"></span><dl> <dt>**SPC\_INC\_PE\_IMPORT\_ADDR\_TABLE\_FLAG**</dt> <dt>0x20</dt> </dl> | This value is not supported.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="SPC_INC_PE_DEBUG_INFO_FLAG"></span><span id="spc_inc_pe_debug_info_flag"></span><dl> <dt>**SPC\_INC\_PE\_DEBUG\_INFO\_FLAG**</dt> <dt>0x40</dt> </dl>                       | This value is not supported.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="SPC_INC_PE_RESOURCES_FLAG"></span><span id="spc_inc_pe_resources_flag"></span><dl> <dt>**SPC\_INC\_PE\_RESOURCES\_FLAG**</dt> <dt>0x80</dt> </dl>                           | This value is not supported.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="SPC_INC_PE_PAGE_HASHES_FLAG"></span><span id="spc_inc_pe_page_hashes_flag"></span><dl> <dt>**SPC\_INC\_PE\_PAGE\_HASHES\_FLAG**</dt> <dt>0x100</dt> </dl>                   | Include page hashes when creating SIP indirect data for the PE file.<br/> **Windows Server 2003 and Windows XP:** This value is not supported.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
     * @param {Pointer<SIGNER_SUBJECT_INFO>} pSubjectInfo A pointer to a [**SIGNER\_SUBJECT\_INFO**](signer-subject-info.md) structure that specifies the subject to sign.
     * @param {Pointer<SIGNER_CERT>} pSignerCert A pointer to a [**SIGNER\_CERT**](signer-cert.md) structure that specifies the certificate to use to create the digital signature.
     * @param {Pointer<SIGNER_SIGNATURE_INFO>} pSignatureInfo A pointer to a [**SIGNER\_SIGNATURE\_INFO**](signer-signature-info.md) structure that contains information about the digital signature.
     * @param {Pointer<SIGNER_PROVIDER_INFO>} pProviderInfo A pointer to a [**SIGNER\_PROVIDER\_INFO**](signer-provider-info.md) structure that specifies the [*cryptographic service provider*](../secgloss/c-gly.md) (CSP) and private key information used to create the digital signature.
     * 
     * If the value of this parameter is **NULL**, the value of the *pSignerCert* parameter must specify a certificate that is associated with a CSP.
     * @param {Pointer<PWSTR>} pwszHttpTimeStamp The URL of a time stamp server.
     * @param {Pointer<CRYPT_ATTRIBUTES>} psRequest A pointer to an array of [**CRYPT\_ATTRIBUTE**](/windows/desktop/api/Wincrypt/ns-wincrypt-crypt_attribute) structures that are added to a sign request. This parameter is ignored if the *pwszHttpTimeStamp* parameter does not contain a valid value that is not **NULL**.
     * @param {Pointer<Void>} pSipData A 32-bit value that is passed as additional data to SIP functions. The format and content of this is defined by the SIP provider.
     * @param {Pointer<SIGNER_CONTEXT>} ppSignerContext The address of a pointer to the [**SIGNER\_CONTEXT**](signer-context.md) structure that contains the signed [*BLOB*](../secgloss/b-gly.md). When you have finished using the **SIGNER\_CONTEXT** structure, free the **SIGNER\_CONTEXT** structure by calling the [**SignerFreeSignerContext**](signerfreesignercontext.md) function.
     * @returns {Integer} If the function succeeds, the function returns S\_OK.
     * 
     * If the function fails, it returns an **HRESULT** value that indicates the error. For a list of common error codes, see [Common HRESULT Values](common-hresult-values.md).
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signersignex
     */
    static SignerSignEx(dwFlags, pSubjectInfo, pSignerCert, pSignatureInfo, pProviderInfo, pwszHttpTimeStamp, psRequest, pSipData, ppSignerContext) {
        result := DllCall("Mssign32.dll\SignerSignEx", "uint", dwFlags, "ptr", pSubjectInfo, "ptr", pSignerCert, "ptr", pSignatureInfo, "ptr", pProviderInfo, "ptr", pwszHttpTimeStamp, "ptr", psRequest, "ptr", pSipData, "ptr", ppSignerContext, "int")
        return result
    }

    /**
     * Signs and time stamps the specified file, allowing multiple nested signatures.
     * @param {Integer} dwFlags Modifies the behavior of this function.
     * 
     * If the file to be signed is a portable executable (PE) file, this can be zero or a combination of one or more of the following values.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                                                                                                    | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="SPC_EXC_PE_PAGE_HASHES_FLAG"></span><span id="spc_exc_pe_page_hashes_flag"></span><dl> <dt>**SPC\_EXC\_PE\_PAGE\_HASHES\_FLAG**</dt> <dt>0x10</dt> </dl>                    | Exclude page hashes when creating SIP indirect data for the PE file. This flag takes precedence over the **SPC\_INC\_PE\_PAGE\_HASHES\_FLAG** flag.<br/> If neither the **SPC\_EXC\_PE\_PAGE\_HASHES\_FLAG** or the **SPC\_INC\_PE\_PAGE\_HASHES\_FLAG** flag is specified, the value set with the [**WintrustSetDefaultIncludePEPageHashes**](/windows/desktop/api/Wintrust/nf-wintrust-wintrustsetdefaultincludepepagehashes) function is used for this setting. The default for this setting is to exclude page hashes when creating SIP indirect data for PE files.<br/> This value is defined in the Mssip.h header file.<br/> **Windows Server 2003 and Windows XP:** This value is not supported.<br/> |
     * | <span id="SPC_INC_PE_IMPORT_ADDR_TABLE_FLAG"></span><span id="spc_inc_pe_import_addr_table_flag"></span><dl> <dt>**SPC\_INC\_PE\_IMPORT\_ADDR\_TABLE\_FLAG**</dt> <dt>0x20</dt> </dl> | This value is not supported.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
     * | <span id="SPC_INC_PE_DEBUG_INFO_FLAG"></span><span id="spc_inc_pe_debug_info_flag"></span><dl> <dt>**SPC\_INC\_PE\_DEBUG\_INFO\_FLAG**</dt> <dt>0x40</dt> </dl>                       | This value is not supported.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
     * | <span id="SPC_INC_PE_RESOURCES_FLAG"></span><span id="spc_inc_pe_resources_flag"></span><dl> <dt>**SPC\_INC\_PE\_RESOURCES\_FLAG**</dt> <dt>0x80</dt> </dl>                           | This value is not supported.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
     * | <span id="SPC_INC_PE_PAGE_HASHES_FLAG"></span><span id="spc_inc_pe_page_hashes_flag"></span><dl> <dt>**SPC\_INC\_PE\_PAGE\_HASHES\_FLAG**</dt> <dt>0x100</dt> </dl>                   | Include page hashes when creating SIP indirect data for the PE file.<br/> **Windows Server 2003 and Windows XP:** This value is not supported.<br/> This value is defined in the Mssip.h header file.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
     * | <span id="SIG_APPEND"></span><span id="sig_append"></span><dl> <dt>**SIG\_APPEND**</dt> <dt>0x1000</dt> </dl>                                                                         | The signature will be nested. If you set this flag before any signature has been added, the generated signature will be added as the outer signature. If you do not set this flag, the generated signature replaces the outer signature, deleting all inner signatures.<br/>                                                                                                                                                                                                                                                                                                                                                                                                              |
     * @param {Pointer<SIGNER_SUBJECT_INFO>} pSubjectInfo Pointer to a [**SIGNER\_SUBJECT\_INFO**](signer-subject-info.md) structure that specifies the subject to sign.
     * @param {Pointer<SIGNER_CERT>} pSignerCert Pointer to a [**SIGNER\_CERT**](signer-cert.md) structure that specifies the certificate to use to create the digital signature.
     * @param {Pointer<SIGNER_SIGNATURE_INFO>} pSignatureInfo A pointer to a [**SIGNER\_SIGNATURE\_INFO**](signer-signature-info.md) structure that contains information about the digital signature.
     * @param {Pointer<SIGNER_PROVIDER_INFO>} pProviderInfo Pointer to a [**SIGNER\_PROVIDER\_INFO**](signer-provider-info.md) structure that specifies the [*cryptographic service provider*](../secgloss/c-gly.md) (CSP) and private key information used to create the digital signature.
     * 
     * If the value of this parameter is **NULL**, the *pSignerCert* parameter must specify a certificate that is associated with a CSP.
     * @param {Integer} dwTimestampFlags Flags that will be passed to [**SignerTimeStampEx3**](signertimestampex3.md) if the *pwszHttpTimeStamp* parameter is not **NULL**. This can be one of the following values.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                          | Meaning                                                        |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------|
     * | <span id="SIGNER_TIMESTAMP_AUTHENTICODE"></span><span id="signer_timestamp_authenticode"></span><dl> <dt>**SIGNER\_TIMESTAMP\_AUTHENTICODE**</dt> </dl> | Default value. Specifies an Authenticode timestamp.<br/> |
     * | <span id="SIGNER_TIMESTAMP_RFC3161"></span><span id="signer_timestamp_rfc3161"></span><dl> <dt>**SIGNER\_TIMESTAMP\_RFC3161**</dt> </dl>                | Specifies an RFC 3161 timestamp.<br/>                    |
     * 
     * 
     * 
     *  
     * 
     * This parameter is ignored if the *pwszHttpTimeStamp* parameter is **NULL**.
     * @param {Pointer<PSTR>} pszTimestampAlgorithmOid Object identifier of the algorithm to be used for creating an RFC 3161 timestamp. This parameter is ignored for Authenticode time stamps.
     * @param {Pointer<PWSTR>} pwszHttpTimeStamp URL of the time stamp server.
     * @param {Pointer<CRYPT_ATTRIBUTES>} psRequest Pointer to an array of [**CRYPT\_ATTRIBUTE**](/windows/desktop/api/Wincrypt/ns-wincrypt-crypt_attribute) structures that are added to a sign request. This parameter is ignored if the *pwszHttpTimeStamp* parameter does not contain a valid value or is **NULL**.
     * @param {Pointer<Void>} pSipData A 32-bit value that is passed as additional data to SIP functions. The format and content of this is defined by the SIP provider.
     * @param {Pointer<SIGNER_CONTEXT>} ppSignerContext The address of a pointer to the [**SIGNER\_CONTEXT**](signer-context.md) structure that contains the signed [*BLOB*](../secgloss/b-gly.md). When you have finished using the **SIGNER\_CONTEXT** structure, free the **SIGNER\_CONTEXT** structure by calling the [**SignerFreeSignerContext**](signerfreesignercontext.md) function.
     * @param {Pointer<CERT_STRONG_SIGN_PARA>} pCryptoPolicy If present, a pointer to a [**CERT\_STRONG\_SIGN\_PARA**](/windows/desktop/api/Wincrypt/ns-wincrypt-cert_strong_sign_para) structure that contains the parameters used to check for strong signatures. If either a certificate or its chain does not pass, the file is not altered in any way. If a URL is passed in to specify a Time Stamping Authority (TSA), this policy is also applied to the time stamp.
     * @returns {Integer} If the function succeeds, the function returns S\_OK.
     * 
     * If the function fails, it returns an **HRESULT** value that indicates the error. Possible error codes returned by this function include, but are not limited to, the following. For a list of common error codes, see [Common HRESULT Values](common-hresult-values.md).
     * 
     * 
     * 
     * | Return code                                                                                  | Description                                                                                                                                               |
     * |----------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <dl> <dt>**E\_INVALIDARG**</dt> </dl> | If you set the *dwTimestampFlags* parameter to **SIGNER\_TIMESTAMP\_AUTHENTICODE**, you cannot set the *dwFlags* parameter to **SIG\_APPEND**.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signersignex2
     */
    static SignerSignEx2(dwFlags, pSubjectInfo, pSignerCert, pSignatureInfo, pProviderInfo, dwTimestampFlags, pszTimestampAlgorithmOid, pwszHttpTimeStamp, psRequest, pSipData, ppSignerContext, pCryptoPolicy) {
        static pReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("Mssign32.dll\SignerSignEx2", "uint", dwFlags, "ptr", pSubjectInfo, "ptr", pSignerCert, "ptr", pSignatureInfo, "ptr", pProviderInfo, "uint", dwTimestampFlags, "ptr", pszTimestampAlgorithmOid, "ptr", pwszHttpTimeStamp, "ptr", psRequest, "ptr", pSipData, "ptr", ppSignerContext, "ptr", pCryptoPolicy, "ptr", pReserved, "int")
        return result
    }

    /**
     * Signs and time stamps the specified file to allow multiple nested signatures.
     * @param {Integer} dwFlags Modifies the behavior of this function.
     * 
     * If the file to be signed is a portable executable (PE) file, this can be zero or a combination of one or more of the following values.
     * 
     * | Value                                                                                                                                                                                                                                                                                    | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="SPC_EXC_PE_PAGE_HASHES_FLAG"></span><span id="spc_exc_pe_page_hashes_flag"></span><dl> <dt>**SPC\_EXC\_PE\_PAGE\_HASHES\_FLAG**</dt> <dt>0x10</dt> </dl>                    | Exclude page hashes when creating SIP indirect data for the PE file. This flag takes precedence over the **SPC\_INC\_PE\_PAGE\_HASHES\_FLAG** flag.<br/> If neither the **SPC\_EXC\_PE\_PAGE\_HASHES\_FLAG** or the **SPC\_INC\_PE\_PAGE\_HASHES\_FLAG** flag is specified, the value set with the [**WintrustSetDefaultIncludePEPageHashes**](/windows/desktop/api/Wintrust/nf-wintrust-wintrustsetdefaultincludepepagehashes) function is used for this setting. The default for this setting is to exclude page hashes when creating SIP indirect data for PE files.<br/> This value is defined in the Mssip.h header file.<br/> **Windows Server 2003 and Windows XP:** This value is not supported.<br/> |
     * | <span id="SPC_INC_PE_IMPORT_ADDR_TABLE_FLAG"></span><span id="spc_inc_pe_import_addr_table_flag"></span><dl> <dt>**SPC\_INC\_PE\_IMPORT\_ADDR\_TABLE\_FLAG**</dt> <dt>0x20</dt> </dl> | This value is not supported.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
     * | <span id="SPC_INC_PE_DEBUG_INFO_FLAG"></span><span id="spc_inc_pe_debug_info_flag"></span><dl> <dt>**SPC\_INC\_PE\_DEBUG\_INFO\_FLAG**</dt> <dt>0x40</dt> </dl>                       | This value is not supported.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
     * | <span id="SPC_INC_PE_RESOURCES_FLAG"></span><span id="spc_inc_pe_resources_flag"></span><dl> <dt>**SPC\_INC\_PE\_RESOURCES\_FLAG**</dt> <dt>0x80</dt> </dl>                           | This value is not supported.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
     * | <span id="SPC_INC_PE_PAGE_HASHES_FLAG"></span><span id="spc_inc_pe_page_hashes_flag"></span><dl> <dt>**SPC\_INC\_PE\_PAGE\_HASHES\_FLAG**</dt> <dt>0x100</dt> </dl>                   | Include page hashes when creating SIP indirect data for the PE file.<br/> **Windows Server 2003 and Windows XP:** This value is not supported.<br/> This value is defined in the Mssip.h header file.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
     * | <span id="SPC_DIGEST_SIGN_FLAG"></span><span id="spc_digest_sign_flag"></span><dl> <dt>**SPC\_DIGEST\_SIGN\_FLAG**</dt> <dt>0x800</dt> </dl>                                          | Digest signing will be done.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
     * | <span id="SIG_APPEND"></span><span id="sig_append"></span><dl> <dt>**SIG\_APPEND**</dt> <dt>0x1000</dt> </dl>                                                                         | The signature will be nested. If you set this flag before any signature has been added, the generated signature will be added as the outer signature. If you do not set this flag, the generated signature replaces the outer signature, deleting all inner signatures.<br/>                                                                                                                                                                                                                                                                                                                                                                                                              |
     * | <span id="SPC_DIGEST_SIGN_EX_FLAG"></span><span id="spc_digest_sign_ex_flag"></span><dl> <dt>**SPC\_DIGEST\_SIGN\_EX\_FLAG**</dt> <dt>0x4000</dt> </dl>                                 | Digest signing will be done. The caller’s digest signing function will select and return the code signing certificate which performed the signing operation.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
     * @param {Pointer<SIGNER_SUBJECT_INFO>} pSubjectInfo Pointer to a [**SIGNER\_SUBJECT\_INFO**](signer-subject-info.md) structure that specifies the subject to sign.
     * @param {Pointer<SIGNER_CERT>} pSignerCert Pointer to a [**SIGNER\_CERT**](signer-cert.md) structure that specifies the certificate to use to create the digital signature.
     * @param {Pointer<SIGNER_SIGNATURE_INFO>} pSignatureInfo A pointer to a [**SIGNER\_SIGNATURE\_INFO**](signer-signature-info.md) structure that contains information about the digital signature.
     * @param {Pointer<SIGNER_PROVIDER_INFO>} pProviderInfo Pointer to a [**SIGNER\_PROVIDER\_INFO**](signer-provider-info.md) structure that specifies the [*cryptographic service provider*](../secgloss/c-gly.md) (CSP) and private key information used to create the digital signature.
     * 
     * If the value of this parameter is **NULL**, the *pSignerCert* parameter must specify a certificate that is associated with a CSP.
     * @param {Integer} dwTimestampFlags Flags that will be passed to [**SignerTimeStampEx3**](signertimestampex3.md) if the *pwszHttpTimeStamp* parameter is not **NULL**. This can be one of the following values.
     * 
     * | Value                                                                                                                                                                                                          | Meaning                                                        |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------|
     * | <span id="SIGNER_TIMESTAMP_AUTHENTICODE"></span><span id="signer_timestamp_authenticode"></span><dl> <dt>**SIGNER\_TIMESTAMP\_AUTHENTICODE**</dt> </dl> | Default value. Specifies an Authenticode timestamp.<br/> |
     * | <span id="SIGNER_TIMESTAMP_RFC3161"></span><span id="signer_timestamp_rfc3161"></span><dl> <dt>**SIGNER\_TIMESTAMP\_RFC3161**</dt> </dl>                | Specifies an RFC 3161 timestamp.<br/>                    |
     * 
     * This parameter is ignored if the *pwszHttpTimeStamp* parameter is **NULL**.
     * @param {Pointer<PSTR>} pszTimestampAlgorithmOid Object identifier of the algorithm to be used for creating an RFC 3161 timestamp. This parameter is ignored for Authenticode time stamps.
     * @param {Pointer<PWSTR>} pwszHttpTimeStamp URL of the time stamp server.
     * @param {Pointer<CRYPT_ATTRIBUTES>} psRequest Pointer to an array of [**CRYPT\_ATTRIBUTE**](/windows/desktop/api/Wincrypt/ns-wincrypt-crypt_attribute) structures that are added to a sign request. This parameter is ignored if the *pwszHttpTimeStamp* parameter does not contain a valid value or is **NULL**.
     * @param {Pointer<Void>} pSipData A 32-bit value that is passed as additional data to SIP functions. The format and content of this is defined by the SIP provider.
     * @param {Pointer<SIGNER_CONTEXT>} ppSignerContext The address of a pointer to the [**SIGNER\_CONTEXT**](signer-context.md) structure that contains the signed [*BLOB*](../secgloss/b-gly.md). When you have finished using the **SIGNER\_CONTEXT** structure, free the **SIGNER\_CONTEXT** structure by calling the [**SignerFreeSignerContext**](signerfreesignercontext.md) function.
     * @param {Pointer<CERT_STRONG_SIGN_PARA>} pCryptoPolicy If present, a pointer to a [**CERT\_STRONG\_SIGN\_PARA**](/windows/win32/api/Wincrypt/ns-wincrypt-cert_strong_sign_para) structure that contains the parameters used to check for strong signatures. If either a certificate or its chain does not pass, the file is not altered in any way. If a URL is passed in to specify a Time Stamping Authority (TSA), this policy is also applied to the time stamp.
     * @param {Pointer<SIGNER_DIGEST_SIGN_INFO>} pDigestSignInfo </dt> <dd>
     * 
     *  If present, a pointer to a [**SIGNER\_DIGEST\_SIGN\_INFO**](signer-digest-sign-info.md) structure that contains information regarding digest signing.
     * 
     *  </dd> <dt>
     * @returns {Integer} If the function succeeds, the function returns S\_OK.
     * 
     * If the function fails, it returns an **HRESULT** value that indicates the error. Possible error codes returned by this function include, but are not limited to, the following. For a list of common error codes, see [Common HRESULT Values](common-hresult-values.md).
     * 
     * | Return code                                                                                  | Description                                                                                                                                               |
     * |----------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <dl> <dt>**E\_INVALIDARG**</dt> </dl> | If you set the *dwTimestampFlags* parameter to **SIGNER\_TIMESTAMP\_AUTHENTICODE**, you cannot set the *dwFlags* parameter to **SIG\_APPEND**.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signersignex3
     */
    static SignerSignEx3(dwFlags, pSubjectInfo, pSignerCert, pSignatureInfo, pProviderInfo, dwTimestampFlags, pszTimestampAlgorithmOid, pwszHttpTimeStamp, psRequest, pSipData, ppSignerContext, pCryptoPolicy, pDigestSignInfo) {
        static pReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("Mssign32.dll\SignerSignEx3", "uint", dwFlags, "ptr", pSubjectInfo, "ptr", pSignerCert, "ptr", pSignatureInfo, "ptr", pProviderInfo, "uint", dwTimestampFlags, "ptr", pszTimestampAlgorithmOid, "ptr", pwszHttpTimeStamp, "ptr", psRequest, "ptr", pSipData, "ptr", ppSignerContext, "ptr", pCryptoPolicy, "ptr", pDigestSignInfo, "ptr", pReserved, "int")
        return result
    }

    /**
     * Time stamps the specified subject. This function supports Authenticode time stamping. To perform X.509 Public Key Infrastructure (RFC 3161) time stamping, use the SignerTimeStampEx2 function.
     * @param {Pointer<SIGNER_SUBJECT_INFO>} pSubjectInfo The address of a [**SIGNER\_SUBJECT\_INFO**](signer-subject-info.md) structure that represents the subject to be time stamped.
     * @param {Pointer<PWSTR>} pwszHttpTimeStamp The address of a null-terminated Unicode string that contains the URL of a time stamp server.
     * @param {Pointer<CRYPT_ATTRIBUTES>} psRequest The address of a [**CRYPT\_ATTRIBUTES**](/windows/desktop/api/Wincrypt/ns-wincrypt-crypt_attributes) structure that contains additional attributes that are added to the time stamp request.
     * 
     * This parameter is optional and can be **NULL** if it is not included.
     * @param {Pointer<Void>} pSipData A 32-bit value that is passed as additional data to SIP functions. The format and content of this is defined by the SIP provider.
     * 
     * This parameter is optional and can be **NULL** if it is not included.
     * @returns {Integer} If the function succeeds, the function returns S\_OK.
     * 
     * If the function fails, it returns an **HRESULT** value that indicates the error. For a list of common error codes, see [Common HRESULT Values](common-hresult-values.md).
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signertimestamp
     */
    static SignerTimeStamp(pSubjectInfo, pwszHttpTimeStamp, psRequest, pSipData) {
        result := DllCall("Mssign32.dll\SignerTimeStamp", "ptr", pSubjectInfo, "ptr", pwszHttpTimeStamp, "ptr", psRequest, "ptr", pSipData, "int")
        return result
    }

    /**
     * Time stamps the specified subject and optionally returns a pointer to a SIGNER\_CONTEXT structure that contains a pointer to a BLOB.
     * @param {Pointer<SIGNER_SUBJECT_INFO>} pSubjectInfo The address of a [**SIGNER\_SUBJECT\_INFO**](signer-subject-info.md) structure that represents the subject to be time stamped.
     * @param {Pointer<PWSTR>} pwszHttpTimeStamp The address of a null-terminated Unicode string that contains the URL of a time stamp server.
     * @param {Pointer<CRYPT_ATTRIBUTES>} psRequest Optional. The address of a [**CRYPT\_ATTRIBUTES**](/windows/desktop/api/Wincrypt/ns-wincrypt-crypt_attributes) structure that contains additional attributes that are added to the time stamp request.
     * 
     * This parameter is optional and can be **NULL** if it is not included.
     * @param {Pointer<Void>} pSipData Optional. A 32-bit value that is passed as additional data to [*subject interface package*](../secgloss/s-gly.md) (SIP) functions. The format and content of this parameter is defined by the SIP provider.
     * 
     * This parameter is optional and can be **NULL** if it is not included.
     * @param {Pointer<SIGNER_CONTEXT>} ppSignerContext Optional. The address of a pointer to the [**SIGNER\_CONTEXT**](signer-context.md) structure that contains the signed BLOB. When you have finished using the **SIGNER\_CONTEXT** structure, free it by calling the [**SignerFreeSignerContext**](signerfreesignercontext.md) function.
     * @returns {Integer} If the function succeeds, the function returns S\_OK.
     * 
     * If the function fails, it returns an **HRESULT** value that indicates the error. For a list of common error codes, see [Common HRESULT Values](common-hresult-values.md).
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signertimestampex
     */
    static SignerTimeStampEx(pSubjectInfo, pwszHttpTimeStamp, psRequest, pSipData, ppSignerContext) {
        static dwFlags := 0 ;Reserved parameters must always be NULL

        result := DllCall("Mssign32.dll\SignerTimeStampEx", "uint", dwFlags, "ptr", pSubjectInfo, "ptr", pwszHttpTimeStamp, "ptr", psRequest, "ptr", pSipData, "ptr", ppSignerContext, "int")
        return result
    }

    /**
     * Time stamps the specified subject and optionally returns a pointer to a SIGNER\_CONTEXT structure that contains a pointer to a BLOB. This function can be used to perform X.509 Public Key Infrastructure, RFC 3161&\#8211;compliant, time stamps.
     * @param {Pointer<SIGNER_SUBJECT_INFO>} pSubjectInfo The address of a [**SIGNER\_SUBJECT\_INFO**](signer-subject-info.md) structure that represents the subject to be time stamped.
     * @param {Pointer<PWSTR>} pwszHttpTimeStamp The address of a null-terminated Unicode string that contains the URL of a time stamp server.
     * @param {Integer} dwAlgId Specifies a hash algorithm to be used for performing RFC 3161–compliant time stamps. This parameter is ignored for Authenticode time stamps.
     * @param {Pointer<CRYPT_ATTRIBUTES>} psRequest Optional. The address of a [**CRYPT\_ATTRIBUTES**](/windows/desktop/api/Wincrypt/ns-wincrypt-crypt_attributes) structure that contains additional attributes that are added to the time stamp request.
     * 
     * This parameter is optional and can be **NULL** if it is not included.
     * @param {Pointer<Void>} pSipData Optional. A 32-bit value that is passed as additional data to [*subject interface package*](../secgloss/s-gly.md) (SIP) functions. The format and content of this parameter is defined by the SIP provider.
     * 
     * This parameter is optional and can be **NULL** if it is not included.
     * @param {Pointer<SIGNER_CONTEXT>} ppSignerContext Optional. The address of a pointer to the [**SIGNER\_CONTEXT**](signer-context.md) structure that contains the signed BLOB. When you have finished using the **SIGNER\_CONTEXT** structure, free it by calling the [**SignerFreeSignerContext**](signerfreesignercontext.md) function.
     * @returns {Integer} If the function succeeds, the function returns S\_OK.
     * 
     * If the function fails, it returns an **HRESULT** value that indicates the error. For a list of common error codes, see [Common HRESULT Values](common-hresult-values.md).
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signertimestampex2
     */
    static SignerTimeStampEx2(pSubjectInfo, pwszHttpTimeStamp, dwAlgId, psRequest, pSipData, ppSignerContext) {
        static dwFlags := 0 ;Reserved parameters must always be NULL

        result := DllCall("Mssign32.dll\SignerTimeStampEx2", "uint", dwFlags, "ptr", pSubjectInfo, "ptr", pwszHttpTimeStamp, "uint", dwAlgId, "ptr", psRequest, "ptr", pSipData, "ptr", ppSignerContext, "int")
        return result
    }

    /**
     * Time stamps the specified subject and supports setting time stamps on multiple signatures.
     * @param {Integer} dwFlags Flag that specifies the type of time stamp to generate. This parameter can be one of the following values. The values are mutually exclusive.
     * 
     * 
     * 
     * 
     * | Value | Meaning | 
     * |-------|---------|
     * | <span id="SIGNER_TIMESTAMP_AUTHENTICODE"></span><span id="signer_timestamp_authenticode"></span><dl><dt><strong>SIGNER_TIMESTAMP_AUTHENTICODE</strong></dt></dl> | Specifies an Authenticode time stamp.<br /><blockquote>[!Note]<br />Authenticode is no longer the preferred type of time stamp. Support for Authenticode time stamps may be removed in the future. We recommend that you use RFC 3161 instead.</blockquote><br /> | 
     * | <span id="SIGNER_TIMESTAMP_RFC3161"></span><span id="signer_timestamp_rfc3161"></span><dl><dt><strong>SIGNER_TIMESTAMP_RFC3161</strong></dt></dl> | Specifies an RFC 3161–compliant time stamp.<br /> |
     * @param {Integer} dwIndex Specifies the sequence number of the signature to which the timestamp will be added. If this value is zero (0), the outer signature will be time stamped.
     * @param {Pointer<SIGNER_SUBJECT_INFO>} pSubjectInfo The address of a [**SIGNER\_SUBJECT\_INFO**](signer-subject-info.md) structure that represents the subject to be time stamped.
     * @param {Pointer<PWSTR>} pwszHttpTimeStamp The address of a null-terminated Unicode string that contains the URL of a time stamp server.
     * @param {Pointer<PWSTR>} pszAlgorithmOid A hash algorithm to be used for performing RFC 3161–compliant time stamps. This parameter is ignored for Authenticode time stamps.
     * @param {Pointer<CRYPT_ATTRIBUTES>} psRequest Optional. The address of a [**CRYPT\_ATTRIBUTES**](/windows/desktop/api/Wincrypt/ns-wincrypt-crypt_attributes) structure that contains additional attributes that are added to the time stamp request.
     * 
     * This parameter is optional and can be **NULL** if it is not included.
     * @param {Pointer<Void>} pSipData Optional. A 32-bit value that is passed as additional data to [*subject interface package*](../secgloss/s-gly.md) (SIP) functions. The format and content of this parameter is defined by the SIP provider.
     * 
     * This parameter is optional and can be **NULL** if it is not included.
     * @param {Pointer<SIGNER_CONTEXT>} ppSignerContext Optional. The address of a pointer to the [**SIGNER\_CONTEXT**](signer-context.md) structure that contains the signed BLOB. When you have finished using the **SIGNER\_CONTEXT** structure, free it by calling the [**SignerFreeSignerContext**](signerfreesignercontext.md) function.
     * @param {Pointer<CERT_STRONG_SIGN_PARA>} pCryptoPolicy If present, a pointer to a [**CERT\_STRONG\_SIGN\_PARA**](/windows/desktop/api/Wincrypt/ns-wincrypt-cert_strong_sign_para) structure that contains the parameters used to check for strong signatures. The time stamp must pass this cryptographic policy.
     * @returns {Integer} If the function succeeds, the function returns S\_OK.
     * 
     * If the function fails, it returns an **HRESULT** value that indicates the error. Possible error codes returned by this function include, but are not limited to, the following. For a list of common error codes, see [Common HRESULT Values](common-hresult-values.md).
     * 
     * 
     * 
     * 
     * | Return code | Description | 
     * |-------------|-------------|
     * | <dl><dt><strong>E_INVALIDARG</strong></dt></dl> | This error can be returned for the following conditions:<br /><ul><li>You must set either <strong>SIGNER_TIMESTAMP_AUTHENTICODE</strong> or <strong>SIGNER_TIMESTAMP_RFC3161</strong> for the <em>dwFlags</em> parameter.</li><li>The <em>pReserved</em> parameter must be <strong>NULL</strong>.</li><li>If you set the <strong>SIGNER_TIMESTAMP_AUTHENTICODE</strong> flag in the <em>dwFlags</em> parameter, you must set the <em>dwIndex</em> parameter to zero.</li></ul> |
     * @see https://learn.microsoft.com/windows/win32/SecCrypto/signertimestampex3
     */
    static SignerTimeStampEx3(dwFlags, dwIndex, pSubjectInfo, pwszHttpTimeStamp, pszAlgorithmOid, psRequest, pSipData, ppSignerContext, pCryptoPolicy) {
        static pReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("Mssign32.dll\SignerTimeStampEx3", "uint", dwFlags, "uint", dwIndex, "ptr", pSubjectInfo, "ptr", pwszHttpTimeStamp, "ptr", pszAlgorithmOid, "ptr", psRequest, "ptr", pSipData, "ptr", ppSignerContext, "ptr", pCryptoPolicy, "ptr", pReserved, "int")
        return result
    }

    /**
     * Closes a cryptographic XML object handle.
     * @remarks
     * At each call to this function, the reference count on the handle is reduced by one. When the reference count reaches zero, an object encapsulated by the handle is fully released.
     * @param {Pointer<Void>} hCryptXml The handle of the cryptographic XML object to be closed.
     * @returns {Integer} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://learn.microsoft.com/windows/win32/api/cryptxml/nf-cryptxml-cryptxmlclose
     * @since windows6.1
     */
    static CryptXmlClose(hCryptXml) {
        result := DllCall("CRYPTXML.dll\CryptXmlClose", "ptr", hCryptXml, "int")
        return result
    }

    /**
     * Returns information about the default transform chain engine.
     * @param {Pointer<CRYPT_XML_TRANSFORM_CHAIN_CONFIG>} ppConfig A pointer to a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_transform_chain_config">CRYPT_XML_TRANSFORM_CHAIN_CONFIG</a> structure to receive the returned transform information.
     * @returns {Integer} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://learn.microsoft.com/windows/win32/api/cryptxml/nf-cryptxml-cryptxmlgettransforms
     * @since windows6.1
     */
    static CryptXmlGetTransforms(ppConfig) {
        result := DllCall("CRYPTXML.dll\CryptXmlGetTransforms", "ptr", ppConfig, "int")
        return result
    }

    /**
     * Opens an XML digital signature to encode and returns a handle of the opened Signature element. The handle encapsulates a document context with a single CRYPT_XML_SIGNATURE structure and remains open until the CryptXmlClose function is called.
     * @param {Pointer<CRYPT_XML_TRANSFORM_CHAIN_CONFIG>} pConfig The handle of the transform chain engine. If this parameter is <b>NULL</b>, then a default engine is used to apply transforms.
     * @param {Integer} dwFlags 
     * @param {Pointer<PWSTR>} wszId A pointer to a null-terminated Unicode string that contains the <b>Id</b> attribute of the <b>Signature</b> element.
     * If this parameter is <b>NULL</b>, then a new GUID is generated. If this parameter is an empty string, then no <b>Id</b> attribute is produced.
     * @param {Pointer<CRYPT_XML_PROPERTY>} rgProperty A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_property">CRYPT_XML_PROPERTY</a> structures that specify additional properties.
     * @param {Integer} cProperty The number of elements in the array pointed to by the <i>rgProperty</i> parameter.
     * @param {Pointer<CRYPT_XML_BLOB>} pEncoded A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_blob">CRYPT_XML_BLOB</a> structure that contains the signature to encode.
     * @param {Pointer<Void>} phSignature The handle to the <b>Signature</b> element.
     * @returns {Integer} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://learn.microsoft.com/windows/win32/api/cryptxml/nf-cryptxml-cryptxmlopentoencode
     * @since windows6.1
     */
    static CryptXmlOpenToEncode(pConfig, dwFlags, wszId, rgProperty, cProperty, pEncoded, phSignature) {
        result := DllCall("CRYPTXML.dll\CryptXmlOpenToEncode", "ptr", pConfig, "uint", dwFlags, "ptr", wszId, "ptr", rgProperty, "uint", cProperty, "ptr", pEncoded, "ptr", phSignature, "int")
        return result
    }

    /**
     * Opens an XML digital signature to decode and returns the handle of the document context that encapsulates a CRYPT_XML_SIGNATURE structure. The document context can include one or more Signature elements.
     * @param {Pointer<CRYPT_XML_TRANSFORM_CHAIN_CONFIG>} pConfig The handle of the transform chain engine. 
     *     If this parameter is <b>NULL</b>, then a default engine will be 
     *     used to apply transforms.
     * @param {Integer} dwFlags 
     * @param {Pointer<CRYPT_XML_PROPERTY>} rgProperty A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_property">CRYPT_XML_PROPERTY</a> structures that contain additional properties.
     * @param {Integer} cProperty The number of items in the array pointed to by the <i>rgProperty</i> parameter.
     * @param {Pointer<CRYPT_XML_BLOB>} pEncoded A pointer to <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_blob">CRYPT_XML_BLOB</a> structure that contains the signature to decode.
     * @param {Pointer<Void>} phCryptXml The handle of a Document Context object.  When you have finished using the handle, release it by passing it to the <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/nf-cryptxml-cryptxmlclose">CryptXmlClose</a> function.
     * @returns {Integer} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://learn.microsoft.com/windows/win32/api/cryptxml/nf-cryptxml-cryptxmlopentodecode
     * @since windows6.1
     */
    static CryptXmlOpenToDecode(pConfig, dwFlags, rgProperty, cProperty, pEncoded, phCryptXml) {
        result := DllCall("CRYPTXML.dll\CryptXmlOpenToDecode", "ptr", pConfig, "uint", dwFlags, "ptr", rgProperty, "uint", cProperty, "ptr", pEncoded, "ptr", phCryptXml, "int")
        return result
    }

    /**
     * Adds the Object element to the Signature in the Document Context opened for encoding.
     * @remarks
     * When the <i>hSignatureOrObject</i> parameter specifies a handle to a Reference returned 
     *     by the <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/nf-cryptxml-cryptxmlcreatereference">CryptXmlCreateReference</a> function, the <i>pEncoded</i> parameter specifies XML content that is included
     *     in the <b>Object</b> node after the optional <b>Manifest</b> element.
     *     The pointer contained in the <i>pEncoded</i>  parameter must be valid until the signature is complete. 
     *     Otherwise, use the <b>CRYPT_XML_FLAG_ADD_OBJECT_CREATE_COPY</b> flag to create an in-memory copy.
     * @param {Pointer<Void>} hSignatureOrObject The handle of a Signature returned by the <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/nf-cryptxml-cryptxmlopentoencode">CryptXmlOpenToEncode</a> function or the handle of a Reference returned by the <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/nf-cryptxml-cryptxmlcreatereference">CryptXmlCreateReference</a> function with     the <b>CRYPT_XML_FLAG_CREATE_REFERENCE_AS_OBJECT</b> flag set.
     * @param {Integer} dwFlags Specifies flags that control the manner in which the object is added.
     * 
     * 
     * Currently defined <i>dwFlags</i> values are shown in the following table .
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_XML_ADD_OBJECT_CREATE_REFERENCE"></a><a id="crypt_xml_add_object_create_reference"></a><dl>
     * <dt><b>CRYPT_XML_ADD_OBJECT_CREATE_REFERENCE</b></dt>
     * <dt></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When set, an in-memory copy of the XML part is created and included in the <b>Object</b> element.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CRYPT_XML_PROPERTY>} rgProperty A pointer to  a  <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_property">CRYPT_XML_PROPERTY</a> structure that specifies additional properties used to decode the <b>Object</b> element.
     * @param {Integer} cProperty The number of elements in the array pointed to by the <i>rgProperty</i> property.
     * @param {Pointer<CRYPT_XML_BLOB>} pEncoded A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_blob">CRYPT_XML_BLOB</a> structure that contains the <b>Object</b> element.
     * @param {Pointer<CRYPT_XML_OBJECT>} ppObject A pointer to  a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_object">CRYPT_XML_OBJECT</a> structure to receive the decoded structure.
     *     This parameter must be <b>NULL</b> when the <i>hSignatureOrObject</i> parameter contains a handle to the Object.
     * @returns {Integer} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://learn.microsoft.com/windows/win32/api/cryptxml/nf-cryptxml-cryptxmladdobject
     * @since windows6.1
     */
    static CryptXmlAddObject(hSignatureOrObject, dwFlags, rgProperty, cProperty, pEncoded, ppObject) {
        result := DllCall("CRYPTXML.dll\CryptXmlAddObject", "ptr", hSignatureOrObject, "uint", dwFlags, "ptr", rgProperty, "uint", cProperty, "ptr", pEncoded, "ptr", ppObject, "int")
        return result
    }

    /**
     * Creates a reference to an XML signature.
     * @param {Pointer<Void>} hCryptXml The handle of the XML signature.
     * @param {Integer} dwFlags Specifies flags that affect how the reference is created.
     * 
     * 
     * Currently defined <i>dwFlags</i> values are shown in the following table.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_XML_FLAG_CREATE_REFERENCE_AS_OBJECT"></a><a id="crypt_xml_flag_create_reference_as_object"></a><dl>
     * <dt><b>CRYPT_XML_FLAG_CREATE_REFERENCE_AS_OBJECT</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Set this flag to create an <b>Object</b> node and add it to the <b>Signature</b> element. A reference to the <b>Object</b>  node is created in the <b>SignedInfo</b> element.
     * 
     * The returned handle is an encapsulated <b>Object</b> node and can be used in subsequent calls to the <b>CryptXmlCreateReference</b> function to create references in the <b>Manifest</b> node.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} wszId A pointer to a <b>null</b>-terminated Unicode string that contains the value of the ID attribute of the <b>Reference</b> element of the signature.
     * 	If this parameter is <b>NULL</b>, then the <b>ID</b> attribute is not created.
     * 	If this parameter is an empty string, then the <b>ID</b> attribute with empty
     *         value is created.
     * @param {Pointer<PWSTR>} wszURI A pointer to a <b>null</b>-terminated Unicode string that contains the value of the URI attribute of the <b>Reference</b> element of the signature.
     *     If this parameter is an empty string,
     *     then the URI attribute with an empty value is created.
     * @param {Pointer<PWSTR>} wszType A pointer to a <b>null</b>-terminated Unicode string that contains the value of the Type attribute of the <b>Reference</b> element of the signature.
     *     The processing engine does not check or use this attribute.
     * @param {Pointer<CRYPT_XML_ALGORITHM>} pDigestMethod A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_algorithm">CRYPT_XML_ALGORITHM</a> structure that contains the digest method.
     * @param {Integer} cTransform The number of elements in the array pointed to by the <i>rgTransform</i> parameter.
     * @param {Pointer<CRYPT_XML_ALGORITHM>} rgTransform A pointer to an ordered array of <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_algorithm">CRYPT_XML_ALGORITHM</a> structures that contain transform algorithms to be applied to
     *     the reference data before the digest calculation.
     * @param {Pointer<Void>} phReference A pointer to a reference handle.
     * @returns {Integer} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://learn.microsoft.com/windows/win32/api/cryptxml/nf-cryptxml-cryptxmlcreatereference
     * @since windows6.1
     */
    static CryptXmlCreateReference(hCryptXml, dwFlags, wszId, wszURI, wszType, pDigestMethod, cTransform, rgTransform, phReference) {
        result := DllCall("CRYPTXML.dll\CryptXmlCreateReference", "ptr", hCryptXml, "uint", dwFlags, "ptr", wszId, "ptr", wszURI, "ptr", wszType, "ptr", pDigestMethod, "uint", cTransform, "ptr", rgTransform, "ptr", phReference, "int")
        return result
    }

    /**
     * Is used by an application to digest the resolved reference. This function applies transforms before updating the digest.
     * @remarks
     * When the <b>CRYPT_XML_REFERENCE_DATA_TRANSFORMED</b> flag is set,
     *     the processing engine adds received data directly to the digest without 
     *     applying the transform chain engine.
     * 
     * <div class="alert"><b>Note</b>  The <b>CryptXmlDigestReference</b> function always calls the function pointed to by the <b>fpnClose</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_data_provider">CRYPT_XML_DATA_PROVIDER</a> structure pointed to by the <i>pDataProviderIn</i> parameter.
     * </div>
     * <div> </div>
     * @param {Pointer<Void>} hReference The  handle of a <b>Reference</b> element.
     * @param {Integer} dwFlags Specifies values that control how the process applies transforms.
     * 
     * 
     * Currently defined <i>dwFlags</i> are shown in the following table.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CRYPT_XML_REFERENCE_DATA_TRANSFORMED"></a><a id="crypt_xml_reference_data_transformed"></a><dl>
     * <dt><b>CRYPT_XML_REFERENCE_DATA_TRANSFORMED</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies that the processing engine will create the digest without applying the transform chain engine.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CRYPT_XML_DATA_PROVIDER>} pDataProviderIn A pointer to a    <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_data_provider">CRYPT_XML_DATA_PROVIDER</a> structure that specifies the data provider. The <b>CryptXmlDigestReference</b> function always calls the <b>fpnClose</b> function on the data provider.
     * @returns {Integer} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://learn.microsoft.com/windows/win32/api/cryptxml/nf-cryptxml-cryptxmldigestreference
     * @since windows6.1
     */
    static CryptXmlDigestReference(hReference, dwFlags, pDataProviderIn) {
        result := DllCall("CRYPTXML.dll\CryptXmlDigestReference", "ptr", hReference, "uint", dwFlags, "ptr", pDataProviderIn, "int")
        return result
    }

    /**
     * Sets the HMAC secret on the handle before calling the CryptXmlSign or CryptXmlVerify function.
     * @param {Pointer<Void>} hSignature The handle of the XML <b>Signature</b> element.
     * @param {Pointer<Byte>} pbSecret A pointer to a buffer that contains a block of bytes. 
     *     The pointer must be valid during the call to the <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/nf-cryptxml-cryptxmlsign">CryptXmlSign</a> or <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/nf-cryptxml-cryptxmlverifysignature">CryptXmlVerify</a> function.
     * @param {Integer} cbSecret The size, in bytes, of the buffer pointed to by the <i>pbSecret</i> parameter.
     * @returns {Integer} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://learn.microsoft.com/windows/win32/api/cryptxml/nf-cryptxml-cryptxmlsethmacsecret
     * @since windows6.1
     */
    static CryptXmlSetHMACSecret(hSignature, pbSecret, cbSecret) {
        result := DllCall("CRYPTXML.dll\CryptXmlSetHMACSecret", "ptr", hSignature, "ptr", pbSecret, "uint", cbSecret, "int")
        return result
    }

    /**
     * Creates a cryptographic signature of a SignedInfo element.
     * @remarks
     * If a certificate cannot be found CryptXmlSign will create a UI for certificate selection. If this window is generated from a process running in [session 0](https://techcommunity.microsoft.com/t5/ask-the-performance-team/application-compatibility-session-0-isolation/ba-p/372361), the application may unexpectedly terminate.
     * @param {Pointer<Void>} hSignature The handle to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_signature">CRYPT_XML_SIGNATURE</a> structure.
     * @param {Pointer} hKey The handle of a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">private key</a> used to sign the <b>SignedInfo</b> element.
     *     This parameter must be <b>NULL</b> for HMAC-based signature algorithms.
     * @param {Integer} dwKeySpec 
     * @param {Integer} dwFlags 
     * @param {Integer} dwKeyInfoSpec The type of data structure pointed to by the <i>pvKeyInfoSpec</i> parameter. Here are some possible combinations.
     * 
     * <table>
     * <tr>
     * <th><i>dwKeyInfec</i></th>
     * <th><i>pvKeyInfoSpec</i></th>
     * </tr>
     * <tr>
     * <td>
     * <b>CRYPT_XML_KEYINFO_SPEC_NONE</b>
     * 
     * </td>
     * <td>
     * Is set to  <b>NULL</b>
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>CRYPT_XML_KEYINFO_SPEC_ENCODED</b>
     * 
     * </td>
     * <td>
     * Points to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_blob">CRYPT_XML_BLOB</a> structure
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>CRYPT_XML_KEYINFO_SPEC_PARAM</b>
     * 
     * </td>
     * <td>
     * Points to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_keyinfo_param">CRYPT_XML_KEYINFO_PARAM</a> structure
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvKeyInfoSpec A pointer to a structure, the type of which is determined by the value of the <i>dwKeyInfoSpec</i> parameter.
     * @param {Pointer<CRYPT_XML_ALGORITHM>} pSignatureMethod A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_algorithm">CRYPT_XML_ALGORITHM</a>     structure that specifies the signature method.
     * @param {Pointer<CRYPT_XML_ALGORITHM>} pCanonicalization A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_algorithm">CRYPT_XML_ALGORITHM</a>     structure that specifies the canonicalization method.
     * @returns {Integer} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://learn.microsoft.com/windows/win32/api/cryptxml/nf-cryptxml-cryptxmlsign
     * @since windows6.1
     */
    static CryptXmlSign(hSignature, hKey, dwKeySpec, dwFlags, dwKeyInfoSpec, pvKeyInfoSpec, pSignatureMethod, pCanonicalization) {
        result := DllCall("CRYPTXML.dll\CryptXmlSign", "ptr", hSignature, "ptr", hKey, "uint", dwKeySpec, "uint", dwFlags, "int", dwKeyInfoSpec, "ptr", pvKeyInfoSpec, "ptr", pSignatureMethod, "ptr", pCanonicalization, "int")
        return result
    }

    /**
     * Imports the public key specified by the supplied handle.
     * @param {Integer} dwFlags 
     * @param {Pointer<CRYPT_XML_KEY_VALUE>} pKeyValue A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_key_value">CRYPT_XML_KEY_VALUE</a> structure to receive the imported key.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} phKey A pointer to the handle of the key to import.
     * @returns {Integer} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://learn.microsoft.com/windows/win32/api/cryptxml/nf-cryptxml-cryptxmlimportpublickey
     * @since windows6.1
     */
    static CryptXmlImportPublicKey(dwFlags, pKeyValue, phKey) {
        result := DllCall("CRYPTXML.dll\CryptXmlImportPublicKey", "uint", dwFlags, "ptr", pKeyValue, "ptr", phKey, "int")
        return result
    }

    /**
     * Performs a cryptographic signature validation of a SignedInfo element.
     * @param {Pointer<Void>} hSignature The handle of a <b>Signature</b> element.
     * @param {Pointer<BCRYPT_KEY_HANDLE>} hKey The handle of the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/p-gly">public key</a> to use to verify the signature value on 
     *     the <b>SignedInfo</b> element.
     *     This parameter must be <b>NULL</b> for HMAC-based signature algorithms.
     * @param {Integer} dwFlags 
     * @returns {Integer} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://learn.microsoft.com/windows/win32/api/cryptxml/nf-cryptxml-cryptxmlverifysignature
     * @since windows6.1
     */
    static CryptXmlVerifySignature(hSignature, hKey, dwFlags) {
        result := DllCall("CRYPTXML.dll\CryptXmlVerifySignature", "ptr", hSignature, "ptr", hKey, "uint", dwFlags, "int")
        return result
    }

    /**
     * Returns the document context specified by the supplied handle.
     * @param {Pointer<Void>} hCryptXml The handle of the document context to retrieve.
     * @param {Pointer<CRYPT_XML_DOC_CTXT>} ppStruct A pointer to a pointer to a  <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_doc_ctxt">CRYPT_XML_DOC_CTXT</a> structure that contains the returned document context.
     * @returns {Integer} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://learn.microsoft.com/windows/win32/api/cryptxml/nf-cryptxml-cryptxmlgetdoccontext
     * @since windows6.1
     */
    static CryptXmlGetDocContext(hCryptXml, ppStruct) {
        result := DllCall("CRYPTXML.dll\CryptXmlGetDocContext", "ptr", hCryptXml, "ptr", ppStruct, "int")
        return result
    }

    /**
     * Returns an XML Signature element.
     * @param {Pointer<Void>} hCryptXml The handle of the <b>Signature</b> element.
     * @param {Pointer<CRYPT_XML_SIGNATURE>} ppStruct A pointer to a  pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_signature">CRYPT_XML_SIGNATURE</a> structure to receive the signature.
     * @returns {Integer} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://learn.microsoft.com/windows/win32/api/cryptxml/nf-cryptxml-cryptxmlgetsignature
     * @since windows6.1
     */
    static CryptXmlGetSignature(hCryptXml, ppStruct) {
        result := DllCall("CRYPTXML.dll\CryptXmlGetSignature", "ptr", hCryptXml, "ptr", ppStruct, "int")
        return result
    }

    /**
     * Returns the Reference element specified by the supplied handle.
     * @param {Pointer<Void>} hCryptXml The handle of the <b>Reference</b> element to retrieve.
     * @param {Pointer<CRYPT_XML_REFERENCE>} ppStruct A pointer to a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_reference">CRYPT_XML_REFERENCE</a> structure that contains the returned <b>Reference</b> element.
     * @returns {Integer} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://learn.microsoft.com/windows/win32/api/cryptxml/nf-cryptxml-cryptxmlgetreference
     * @since windows6.1
     */
    static CryptXmlGetReference(hCryptXml, ppStruct) {
        result := DllCall("CRYPTXML.dll\CryptXmlGetReference", "ptr", hCryptXml, "ptr", ppStruct, "int")
        return result
    }

    /**
     * Returns a CRYPT_XML_STATUS structure that contains status information about the object specified by the supplied handle.
     * @param {Pointer<Void>} hCryptXml A handle to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_signature">CRYPT_XML_SIGNATURE</a> structure, an array 
     * of <b>CRYPT_XML_SIGNATURE</b> structures , a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_reference">CRYPT_XML_REFERENCE</a> structure, or a  Manifest object about which to get status information.
     * @param {Pointer<CRYPT_XML_STATUS>} pStatus A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_status">CRYPT_XML_STATUS</a> structure to receive the returned status information.
     * @returns {Integer} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://learn.microsoft.com/windows/win32/api/cryptxml/nf-cryptxml-cryptxmlgetstatus
     * @since windows6.1
     */
    static CryptXmlGetStatus(hCryptXml, pStatus) {
        result := DllCall("CRYPTXML.dll\CryptXmlGetStatus", "ptr", hCryptXml, "ptr", pStatus, "int")
        return result
    }

    /**
     * Encodes signature data by using the supplied XML writer callback function.
     * @param {Pointer<Void>} hCryptXml The handle of the object to be serialized. The handle can be of <b>Signature</b>, <b>Object</b>, or <b>Reference</b> types.
     * @param {Integer} dwCharset A value of the <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ne-cryptxml-crypt_xml_charset">CRYPT_XML_CHARSET</a> enumeration that specifies the character set of the encoded XML.
     * @param {Pointer<CRYPT_XML_PROPERTY>} rgProperty A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_property">CRYPT_XML_PROPERTY</a> structures that contain additional properties.
     * @param {Integer} cProperty A <b>ULONG</b> value that specifies the number of entries in the array pointed to by the <i>rgProperty</i> parameter.
     * @param {Pointer<Void>} pvCallbackState A pointer to an application defined argument that is passed to the XML writer callback function pointed to by the <i>pfnWrite</i> parameter.
     * @param {Pointer<PFN_CRYPT_XML_WRITE_CALLBACK>} pfnWrite An XML writer callback function to receive the application defined argument pointed to by the <i>pvCallbackState</i> parameter.
     * @returns {Integer} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://learn.microsoft.com/windows/win32/api/cryptxml/nf-cryptxml-cryptxmlencode
     * @since windows6.1
     */
    static CryptXmlEncode(hCryptXml, dwCharset, rgProperty, cProperty, pvCallbackState, pfnWrite) {
        result := DllCall("CRYPTXML.dll\CryptXmlEncode", "ptr", hCryptXml, "int", dwCharset, "ptr", rgProperty, "uint", cProperty, "ptr", pvCallbackState, "ptr", pfnWrite, "int")
        return result
    }

    /**
     * Decodes the CRYPT_XML_ALGORITHM structure and returns information about the algorithm.
     * @param {Pointer<CRYPT_XML_ALGORITHM>} pXmlAlgorithm A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_algorithm">CRYPT_XML_ALGORITHM</a> structure that specifies the algorithm about which to return information.
     * @param {Integer} dwFlags 
     * @param {Pointer<CRYPT_XML_ALGORITHM_INFO>} ppAlgInfo A pointer to a pointer to a  <a href="https://docs.microsoft.com/windows/desktop/api/cryptxml/ns-cryptxml-crypt_xml_algorithm_info">CRYPT_XML_ALGORITHM_INFO</a> structure. When you have finished using the memory pointed to by the <i>ppAlgInfo</i> parameter, free it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localfree">LocalFree</a> function.
     * @returns {Integer} If the function succeeds, the function returns zero.
     * 
     * If the function fails, it returns an <b>HRESULT</b> value that indicates the error.
     * @see https://learn.microsoft.com/windows/win32/api/cryptxml/nf-cryptxml-cryptxmlgetalgorithminfo
     * @since windows6.1
     */
    static CryptXmlGetAlgorithmInfo(pXmlAlgorithm, dwFlags, ppAlgInfo) {
        result := DllCall("CRYPTXML.dll\CryptXmlGetAlgorithmInfo", "ptr", pXmlAlgorithm, "uint", dwFlags, "ptr", ppAlgInfo, "int")
        return result
    }

    /**
     * 
     * @param {Integer} dwFindByType 
     * @param {Pointer<Void>} pvFindBy 
     * @param {Integer} dwGroupId 
     * @param {Integer} dwFlags 
     * @returns {Pointer<CRYPT_XML_ALGORITHM_INFO>} 
     */
    static CryptXmlFindAlgorithmInfo(dwFindByType, pvFindBy, dwGroupId, dwFlags) {
        result := DllCall("CRYPTXML.dll\CryptXmlFindAlgorithmInfo", "uint", dwFindByType, "ptr", pvFindBy, "uint", dwGroupId, "uint", dwFlags, "ptr")
        return result
    }

    /**
     * 
     * @param {Integer} dwGroupId 
     * @param {Integer} dwFlags 
     * @param {Pointer<Void>} pvArg 
     * @param {Pointer<PFN_CRYPT_XML_ENUM_ALG_INFO>} pfnEnumAlgInfo 
     * @returns {Integer} 
     */
    static CryptXmlEnumAlgorithmInfo(dwGroupId, dwFlags, pvArg, pfnEnumAlgInfo) {
        result := DllCall("CRYPTXML.dll\CryptXmlEnumAlgorithmInfo", "uint", dwGroupId, "uint", dwFlags, "ptr", pvArg, "ptr", pfnEnumAlgInfo, "int")
        return result
    }

    /**
     * 
     * @param {Integer} cPolicyChain 
     * @param {Pointer<POLICY_ELEMENT>} pPolicyChain 
     * @param {Pointer<GENERIC_XML_TOKEN>} securityToken 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} phProofTokenCrypto 
     * @returns {Integer} 
     */
    static GetToken(cPolicyChain, pPolicyChain, securityToken, phProofTokenCrypto) {
        result := DllCall("infocardapi.dll\GetToken", "uint", cPolicyChain, "ptr", pPolicyChain, "ptr", securityToken, "ptr", phProofTokenCrypto, "int")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static ManageCardSpace() {
        result := DllCall("infocardapi.dll\ManageCardSpace", "int")
        return result
    }

    /**
     * 
     * @param {Pointer<PWSTR>} fileName 
     * @returns {Integer} 
     */
    static ImportInformationCard(fileName) {
        result := DllCall("infocardapi.dll\ImportInformationCard", "ptr", fileName, "int")
        return result
    }

    /**
     * Begins encryption of a fully decrypted volume, or resumes encryption of a partially encrypted volume.
     * @remarks
     * When you use this method without the second optional parameter (according to the Windows 7 and Windows Vista Enterprise definition), the method will always initiate full mode conversion in order to keep backward compatible behavior. This way the security expectation of existing applications and scripts will not be broken with the addition of the second optional parameter in Windows 8 and Windows Server 2012.
     * 
     * You can call [**GetConversionStatus**](getconversionstatus-win32-encryptablevolume.md) to determine whether encryption is in progress and the percentage of the volume that has been encrypted.
     * 
     * After the volume is fully encrypted and if key protectors have been added and enabled, the protection status for the volume changes to "on".
     * 
     * Managed Object Format (MOF) files contain the definitions for Windows Management Instrumentation (WMI) classes. MOF files are not installed as part of the Windows SDK. They are installed on the server when you add the associated role by using the Server Manager. For more information about MOF files, see [Managed Object Format (MOF)](../wmisdk/managed-object-format--mof-.md).
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {Integer} fOAEP 
     * @param {Integer} cbInData 
     * @param {Pointer<Byte>} pInData 
     * @param {Pointer<UInt32>} pcbOutData 
     * @param {Pointer<Byte>} ppOutData 
     * @returns {Integer} Type: **uint32**
     * 
     * This method returns one of the following codes or another error code if it fails.
     * 
     * This method returns immediately. If the volume is already fully encrypted and no other errors are returned, this method returns 0.
     * 
     * 
     * 
     * 
     * | Return code/value | Description | 
     * |-------------------|-------------|
     * | <dl><dt><strong>S_OK</strong></dt><dt>0 (0x0)</dt></dl> | The method was successful.<br /> | 
     * | <dl><dt><strong>E_INVALIDARG</strong></dt><dt>2147942487 (0x80070057)</dt></dl> | The <em>EncryptionMethod</em> parameter is provided but is not within the known range or does not match the current Group Policy setting.<br /> | 
     * | <dl><dt><strong>FVE_E_CANNOT_ENCRYPT_NO_KEY</strong></dt><dt>2150694958 (0x8031002E)</dt></dl> | No encryption key exists for the volume. Either disable key protectors by using the <a href="disablekeyprotectors-win32-encryptablevolume.md"><strong>DisableKeyProtectors</strong></a> method or use one of the following methods to specify key protectors for the volume:<br /><ul><li><a href="protectkeywithexternalkey-win32-encryptablevolume.md"><strong>ProtectKeyWithExternalKey</strong></a></li><li><a href="protectkeywithnumericalpassword-win32-encryptablevolume.md"><strong>ProtectKeyWithNumericalPassword</strong></a></li><li><a href="protectkeywithtpm-win32-encryptablevolume.md"><strong>ProtectKeyWithTPM</strong></a></li><li><a href="protectkeywithtpmandpin-win32-encryptablevolume.md"><strong>ProtectKeyWithTPMAndPIN</strong></a></li><li><a href="protectkeywithtpmandpinandstartupkey-win32-encryptablevolume.md"><strong>ProtectKeyWithTPMAndPINAndStartupKey</strong></a></li><li><a href="protectkeywithtpmandstartupkey-win32-encryptablevolume.md"><strong>ProtectKeyWithTPMAndStartupKey</strong></a></li></ul><strong>Windows Vista:</strong> When no encryption key exists for the volume, ERROR_INVALID_OPERATION is returned instead. The decimal value is 4317 and the hexadecimal value is 0x10DD.<br /> | 
     * | <dl><dt><strong>FVE_E_CANNOT_SET_FVEK_ENCRYPTED</strong></dt><dt>2150694957 (0x8031002D)</dt></dl> | The provided encryption method does not match that of the partially or fully encrypted volume. To continue encryption, leave the <em>EncryptionMethod</em> parameter blank or use a value of zero.<br /> | 
     * | <dl><dt><strong>FVE_E_CLUSTERING_NOT_SUPPORTED</strong></dt><dt>2150694942 (0x8031001E)</dt></dl> | The volume cannot be encrypted because this computer is configured to be part of a server cluster.<br /> | 
     * | <dl><dt><strong>FVE_E_LOCKED_VOLUME</strong></dt><dt>2150694912 (0x80310000)</dt></dl> | The volume is locked.<br /> | 
     * | <dl><dt><strong>FVE_E_POLICY_PASSWORD_REQUIRED</strong></dt><dt>2150694956 (0x8031002C)</dt></dl> | No key protectors of the type "Numerical Password" are specified. The Group Policy requires a backup of recovery information to Active Directory Domain Services. To add at least one key protector of that type, use the <a href="protectkeywithnumericalpassword-win32-encryptablevolume.md"><strong>ProtectKeyWithNumericalPassword</strong></a> method.<br /> |
     * @see https://learn.microsoft.com/windows/win32/SecProv/encrypt-win32-encryptablevolume
     */
    static Encrypt(hCrypto, fOAEP, cbInData, pInData, pcbOutData, ppOutData) {
        result := DllCall("infocardapi.dll\Encrypt", "ptr", hCrypto, "int", fOAEP, "uint", cbInData, "ptr", pInData, "ptr", pcbOutData, "ptr", ppOutData, "int")
        return result
    }

    /**
     * Begins decryption of a fully encrypted volume, or resumes decryption of a partially encrypted volume.
     * @remarks
     * If the volume is not already fully decrypted, running **Decrypt** causes [**GetConversionStatus**](getconversionstatus-win32-encryptablevolume.md) to indicate that decryption is progress and shows the percentage of the volume that remains encrypted.
     * 
     * If the protection status of the volume is "on" before this method is run, running this method changes the protection status to "off", since by definition a partially encrypted volume is not protected.
     * 
     * If this method is run on the currently running operating system volume and this operating system volume is being used to automatically unlock data volumes (see method [**EnableAutoUnlock**](enableautounlock-win32-encryptablevolume.md)) you must first call the method [**ClearAllAutoUnlockKeys**](clearallautounlockkeys-win32-encryptablevolume.md).
     * 
     * Managed Object Format (MOF) files contain the definitions for Windows Management Instrumentation (WMI) classes. MOF files are not installed as part of the Windows SDK. They are installed on the server when you add the associated role by using the Server Manager. For more information about MOF files, see [Managed Object Format (MOF)](../wmisdk/managed-object-format--mof-.md).
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {Integer} fOAEP 
     * @param {Integer} cbInData 
     * @param {Pointer<Byte>} pInData 
     * @param {Pointer<UInt32>} pcbOutData 
     * @param {Pointer<Byte>} ppOutData 
     * @returns {Integer} This method has no parameters.
     * 
     * 
     * Type: **uint32**
     * 
     * This method returns one of the following codes or another error code if it fails.
     * 
     * This method returns immediately. If the volume is already fully decrypted and no other errors exist, this method returns 0.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                                       | Description                                                                                                                                                                                                                             |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <dl> <dt>**S\_OK**</dt> <dt>0 (0x0)</dt> </dl>                                       | The method was successful.<br/>                                                                                                                                                                                                   |
     * | <dl> <dt>**FVE\_E\_LOCKED\_VOLUME**</dt> <dt>2150694912 (0x80310000)</dt> </dl>      | The volume is locked.<br/>                                                                                                                                                                                                        |
     * | <dl> <dt>**FVE\_E\_AUTOUNLOCK\_ENABLED**</dt> <dt>2150694953 (0x80310029)</dt> </dl> | This volume cannot be decrypted because keys used to automatically unlock data volumes are available. <br/> Use [**ClearAllAutoUnlockKeys**](clearallautounlockkeys-win32-encryptablevolume.md) to remove these keys.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecProv/decrypt-win32-encryptablevolume
     */
    static Decrypt(hCrypto, fOAEP, cbInData, pInData, pcbOutData, ppOutData) {
        result := DllCall("infocardapi.dll\Decrypt", "ptr", hCrypto, "int", fOAEP, "uint", cbInData, "ptr", pInData, "ptr", pcbOutData, "ptr", ppOutData, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {Integer} cbHash 
     * @param {Pointer<Byte>} pHash 
     * @param {Pointer<PWSTR>} hashAlgOid 
     * @param {Pointer<UInt32>} pcbSig 
     * @param {Pointer<Byte>} ppSig 
     * @returns {Integer} 
     */
    static SignHash(hCrypto, cbHash, pHash, hashAlgOid, pcbSig, ppSig) {
        result := DllCall("infocardapi.dll\SignHash", "ptr", hCrypto, "uint", cbHash, "ptr", pHash, "ptr", hashAlgOid, "ptr", pcbSig, "ptr", ppSig, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {Integer} cbHash 
     * @param {Pointer<Byte>} pHash 
     * @param {Pointer<PWSTR>} hashAlgOid 
     * @param {Integer} cbSig 
     * @param {Pointer<Byte>} pSig 
     * @param {Pointer<Int32>} pfVerified 
     * @returns {Integer} 
     */
    static VerifyHash(hCrypto, cbHash, pHash, hashAlgOid, cbSig, pSig, pfVerified) {
        result := DllCall("infocardapi.dll\VerifyHash", "ptr", hCrypto, "uint", cbHash, "ptr", pHash, "ptr", hashAlgOid, "uint", cbSig, "ptr", pSig, "ptr", pfVerified, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hSymmetricCrypto 
     * @param {Integer} mode 
     * @param {Integer} padding 
     * @param {Integer} feedbackSize 
     * @param {Integer} direction 
     * @param {Integer} cbIV 
     * @param {Pointer<Byte>} pIV 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} pphTransform 
     * @returns {Integer} 
     */
    static GetCryptoTransform(hSymmetricCrypto, mode, padding, feedbackSize, direction, cbIV, pIV, pphTransform) {
        result := DllCall("infocardapi.dll\GetCryptoTransform", "ptr", hSymmetricCrypto, "uint", mode, "int", padding, "uint", feedbackSize, "int", direction, "uint", cbIV, "ptr", pIV, "ptr", pphTransform, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hSymmetricCrypto 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} pphHash 
     * @returns {Integer} 
     */
    static GetKeyedHash(hSymmetricCrypto, pphHash) {
        result := DllCall("infocardapi.dll\GetKeyedHash", "ptr", hSymmetricCrypto, "ptr", pphHash, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {Integer} cbInData 
     * @param {Pointer<Byte>} pInData 
     * @param {Pointer<UInt32>} pcbOutData 
     * @param {Pointer<Byte>} ppOutData 
     * @returns {Integer} 
     */
    static TransformBlock(hCrypto, cbInData, pInData, pcbOutData, ppOutData) {
        result := DllCall("infocardapi.dll\TransformBlock", "ptr", hCrypto, "uint", cbInData, "ptr", pInData, "ptr", pcbOutData, "ptr", ppOutData, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {Integer} cbInData 
     * @param {Pointer<Byte>} pInData 
     * @param {Pointer<UInt32>} pcbOutData 
     * @param {Pointer<Byte>} ppOutData 
     * @returns {Integer} 
     */
    static TransformFinalBlock(hCrypto, cbInData, pInData, pcbOutData, ppOutData) {
        result := DllCall("infocardapi.dll\TransformFinalBlock", "ptr", hCrypto, "uint", cbInData, "ptr", pInData, "ptr", pcbOutData, "ptr", ppOutData, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {Integer} cbInData 
     * @param {Pointer<Byte>} pInData 
     * @returns {Integer} 
     */
    static HashCore(hCrypto, cbInData, pInData) {
        result := DllCall("infocardapi.dll\HashCore", "ptr", hCrypto, "uint", cbInData, "ptr", pInData, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {Integer} cbInData 
     * @param {Pointer<Byte>} pInData 
     * @param {Pointer<UInt32>} pcbOutData 
     * @param {Pointer<Byte>} ppOutData 
     * @returns {Integer} 
     */
    static HashFinal(hCrypto, cbInData, pInData, pcbOutData, ppOutData) {
        result := DllCall("infocardapi.dll\HashFinal", "ptr", hCrypto, "uint", cbInData, "ptr", pInData, "ptr", pcbOutData, "ptr", ppOutData, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<GENERIC_XML_TOKEN>} pAllocMemory 
     * @returns {Integer} 
     */
    static FreeToken(pAllocMemory) {
        result := DllCall("infocardapi.dll\FreeToken", "ptr", pAllocMemory, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @returns {Integer} 
     */
    static CloseCryptoHandle(hCrypto) {
        result := DllCall("infocardapi.dll\CloseCryptoHandle", "ptr", hCrypto, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<INFORMATIONCARD_CRYPTO_HANDLE>} hCrypto 
     * @param {Integer} cbLabel 
     * @param {Pointer<Byte>} pLabel 
     * @param {Integer} cbNonce 
     * @param {Pointer<Byte>} pNonce 
     * @param {Integer} derivedKeyLength 
     * @param {Integer} offset 
     * @param {Pointer<PWSTR>} algId 
     * @param {Pointer<UInt32>} pcbKey 
     * @param {Pointer<Byte>} ppKey 
     * @returns {Integer} 
     */
    static GenerateDerivedKey(hCrypto, cbLabel, pLabel, cbNonce, pNonce, derivedKeyLength, offset, algId, pcbKey, ppKey) {
        result := DllCall("infocardapi.dll\GenerateDerivedKey", "ptr", hCrypto, "uint", cbLabel, "ptr", pLabel, "uint", cbNonce, "ptr", pNonce, "uint", derivedKeyLength, "uint", offset, "ptr", algId, "ptr", pcbKey, "ptr", ppKey, "int")
        return result
    }

    /**
     * 
     * @param {Integer} dwParamType 
     * @param {Pointer<Void>} pParam 
     * @param {Pointer<UInt32>} pcbToken 
     * @param {Pointer<Byte>} ppToken 
     * @returns {Integer} 
     */
    static GetBrowserToken(dwParamType, pParam, pcbToken, ppToken) {
        result := DllCall("infocardapi.dll\GetBrowserToken", "uint", dwParamType, "ptr", pParam, "ptr", pcbToken, "ptr", ppToken, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<PWSTR>} pszProviderName 
     * @param {Pointer<PWSTR>} pszAlgId 
     * @param {Pointer<BCRYPT_CIPHER_FUNCTION_TABLE>} ppFunctionTable 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static GetCipherInterface(pszProviderName, pszAlgId, ppFunctionTable, dwFlags) {
        result := DllCall("bcryptprimitives.dll\GetCipherInterface", "ptr", pszProviderName, "ptr", pszAlgId, "ptr", ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<PWSTR>} pszProviderName 
     * @param {Pointer<PWSTR>} pszAlgId 
     * @param {Pointer<BCRYPT_HASH_FUNCTION_TABLE>} ppFunctionTable 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static GetHashInterface(pszProviderName, pszAlgId, ppFunctionTable, dwFlags) {
        result := DllCall("bcryptprimitives.dll\GetHashInterface", "ptr", pszProviderName, "ptr", pszAlgId, "ptr", ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<PWSTR>} pszProviderName 
     * @param {Pointer<PWSTR>} pszAlgId 
     * @param {Pointer<BCRYPT_ASYMMETRIC_ENCRYPTION_FUNCTION_TABLE>} ppFunctionTable 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static GetAsymmetricEncryptionInterface(pszProviderName, pszAlgId, ppFunctionTable, dwFlags) {
        result := DllCall("bcryptprimitives.dll\GetAsymmetricEncryptionInterface", "ptr", pszProviderName, "ptr", pszAlgId, "ptr", ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<PWSTR>} pszProviderName 
     * @param {Pointer<PWSTR>} pszAlgId 
     * @param {Pointer<BCRYPT_SECRET_AGREEMENT_FUNCTION_TABLE>} ppFunctionTable 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static GetSecretAgreementInterface(pszProviderName, pszAlgId, ppFunctionTable, dwFlags) {
        result := DllCall("bcryptprimitives.dll\GetSecretAgreementInterface", "ptr", pszProviderName, "ptr", pszAlgId, "ptr", ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<PWSTR>} pszProviderName 
     * @param {Pointer<PWSTR>} pszAlgId 
     * @param {Pointer<BCRYPT_SIGNATURE_FUNCTION_TABLE>} ppFunctionTable 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static GetSignatureInterface(pszProviderName, pszAlgId, ppFunctionTable, dwFlags) {
        result := DllCall("bcryptprimitives.dll\GetSignatureInterface", "ptr", pszProviderName, "ptr", pszAlgId, "ptr", ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<PWSTR>} pszProviderName 
     * @param {Pointer<BCRYPT_RNG_FUNCTION_TABLE>} ppFunctionTable 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static GetRngInterface(pszProviderName, ppFunctionTable, dwFlags) {
        result := DllCall("bcryptprimitives.dll\GetRngInterface", "ptr", pszProviderName, "ptr", ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<PWSTR>} pszProviderName 
     * @param {Pointer<PWSTR>} pszAlgId 
     * @param {Pointer<BCRYPT_KEY_DERIVATION_FUNCTION_TABLE>} ppFunctionTable 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static GetKeyDerivationInterface(pszProviderName, pszAlgId, ppFunctionTable, dwFlags) {
        result := DllCall("bcryptprimitives.dll\GetKeyDerivationInterface", "ptr", pszProviderName, "ptr", pszAlgId, "ptr", ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<PWSTR>} pszProvider 
     * @param {Integer} dwFlags 
     * @param {Pointer<CRYPT_PROVIDER_REG>} pReg 
     * @returns {Integer} 
     */
    static BCryptRegisterProvider(pszProvider, dwFlags, pReg) {
        result := DllCall("bcrypt.dll\BCryptRegisterProvider", "ptr", pszProvider, "uint", dwFlags, "ptr", pReg, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<PWSTR>} pszProvider 
     * @returns {Integer} 
     */
    static BCryptUnregisterProvider(pszProvider) {
        result := DllCall("bcrypt.dll\BCryptUnregisterProvider", "ptr", pszProvider, "int")
        return result
    }

    /**
     * 
     * @param {Integer} dwTable 
     * @param {Pointer<PWSTR>} pszContext 
     * @param {Integer} dwInterface 
     * @param {Pointer<PWSTR>} pszFunction 
     * @param {Pointer<PWSTR>} pszProvider 
     * @param {Integer} dwPosition 
     * @returns {Integer} 
     */
    static BCryptAddContextFunctionProvider(dwTable, pszContext, dwInterface, pszFunction, pszProvider, dwPosition) {
        result := DllCall("bcrypt.dll\BCryptAddContextFunctionProvider", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "ptr", pszProvider, "uint", dwPosition, "int")
        return result
    }

    /**
     * 
     * @param {Integer} dwTable 
     * @param {Pointer<PWSTR>} pszContext 
     * @param {Integer} dwInterface 
     * @param {Pointer<PWSTR>} pszFunction 
     * @param {Pointer<PWSTR>} pszProvider 
     * @returns {Integer} 
     */
    static BCryptRemoveContextFunctionProvider(dwTable, pszContext, dwInterface, pszFunction, pszProvider) {
        result := DllCall("bcrypt.dll\BCryptRemoveContextFunctionProvider", "uint", dwTable, "ptr", pszContext, "uint", dwInterface, "ptr", pszFunction, "ptr", pszProvider, "int")
        return result
    }

    /**
     * Retrieves the key storage interface for the specified provider.
     * @remarks
     * **GetKeyStorageInterface** isn't associated with a header file. You can call it by first using the [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryw) function (to load `Ncrypt.dll`), and then by calling the [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) function to retrieve the address of **GetKeyStorageInterface**.
     * @param {Pointer<PWSTR>} pszProviderName The provider name.
     * @param {Pointer<NCRYPT_KEY_STORAGE_FUNCTION_TABLE>} ppFunctionTable Used to retrieve the key storage interface.
     * @param {Integer} dwFlags Flags.
     * @returns {Integer} Type: **[HRESULT](/windows/win32/com/structure-of-com-error-codes)**
     * 
     * If the function succeeds, it returns **S_OK**. Otherwise, it returns an [HRESULT](/windows/win32/com/structure-of-com-error-codes) [error code](/windows/desktop/com/com-error-codes-10).
     * @see https://learn.microsoft.com/windows/win32/SecCNG/ncrypt/nf-ncrypt-getkeystorageinterface
     */
    static GetKeyStorageInterface(pszProviderName, ppFunctionTable, dwFlags) {
        result := DllCall("ncrypt.dll\GetKeyStorageInterface", "ptr", pszProviderName, "ptr", ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * Not implemented and cannot be used.
     * @param {Pointer<HANDLE>} hEvent This parameter is reserved for future use.
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} Returns **NTE\_NOT\_SUPPORTED**.
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslchangenotify
     */
    static SslChangeNotify(hEvent, dwFlags) {
        result := DllCall("ncrypt.dll\SslChangeNotify", "ptr", hEvent, "uint", dwFlags, "int")
        return result
    }

    /**
     * Computes a hash to use during certificate authentication.
     * @remarks
     * The **SslComputeClientAuthHash** function computes the hash that is sent in the certificate verification message of the SSL handshake. The hash value is computed by creating a hash that contains the master secret with a hash of all previous handshake messages sent or received.
     * 
     * The manner in which the hash is computed depends on the protocol and cipher suite used. In addition, the hash depends on the type of client authentication key used; the *pszAlgId* parameter indicates the type of key used for client authentication.
     * @param {Pointer} hSslProvider The handle of the [*Secure Sockets Layer protocol*](/windows/desktop/SecGloss/s-gly) (SSL) protocol provider instance.
     * @param {Pointer} hMasterKey The handle of the [*master key*](/windows/desktop/SecGloss/m-gly) object.
     * @param {Pointer} hHandshakeHash The handle of the hash of the handshake computed so far.
     * @param {Pointer<PWSTR>} pszAlgId A pointer to a null-terminated Unicode string that identifies the requested [*cryptographic algorithm*](/windows/desktop/SecGloss/c-gly). This can be one of the standard [**CNG Algorithm Identifiers**](cng-algorithm-identifiers.md) or the identifier for another registered algorithm.
     * @param {Pointer<Byte>} pbOutput The address of a buffer that receives the [*key BLOB*](/windows/desktop/SecGloss/k-gly). The *cbOutput* parameter contains the size of this buffer. If this parameter is **NULL**, this function will place the required size, in bytes, in the **DWORD** pointed to by the *pcbResult* parameter.
     * @param {Integer} cbOutput The length, in bytes, of the *pbOutput* buffer.
     * @param {Pointer<UInt32>} pcbResult A pointer to a **DWORD** value that specifies the length, in bytes, of the hash written to the *pbOutput* buffer.
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                    | Description                                          |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl> | One of the supplied handles is not valid.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslcomputeclientauthhash
     */
    static SslComputeClientAuthHash(hSslProvider, hMasterKey, hHandshakeHash, pszAlgId, pbOutput, cbOutput, pcbResult, dwFlags) {
        result := DllCall("ncrypt.dll\SslComputeClientAuthHash", "ptr", hSslProvider, "ptr", hMasterKey, "ptr", hHandshakeHash, "ptr", pszAlgId, "ptr", pbOutput, "uint", cbOutput, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Computes the key block used by the Extensible Authentication Protocol (EAP).
     * @param {Pointer} hSslProvider The handle of the [*Secure Sockets Layer protocol*](/windows/desktop/SecGloss/s-gly) (SSL) protocol provider instance.
     * @param {Pointer} hMasterKey The handle of the [*master key*](/windows/desktop/SecGloss/m-gly) object.
     * @param {Pointer<Byte>} pbRandoms A pointer to a buffer that contains a concatenation of the client\_random and server\_random values of the SSL session.
     * @param {Integer} cbRandoms The length, in bytes, of the *pbRandoms* buffer.
     * @param {Pointer<Byte>} pbOutput The address of a buffer that receives the key BLOB. The *cbOutput* parameter contains the size of this buffer. If this parameter is **NULL**, this function will place the required size, in bytes, in the **DWORD** pointed to by the *pcbResult* parameter.
     * @param {Integer} cbOutput The length, in bytes, of the *pbOutput* buffer.
     * @param {Pointer<UInt32>} pcbResult A pointer to a **DWORD** value that specifies the length, in bytes, of the hash written to the *pbOutput* buffer.
     * @param {Integer} dwFlags Set to **NCRYPT\_SSL\_SERVER\_FLAG** to indicate that this is a server call.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                    | Description                                          |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl> | One of the supplied handles is not valid.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslcomputeeapkeyblock
     */
    static SslComputeEapKeyBlock(hSslProvider, hMasterKey, pbRandoms, cbRandoms, pbOutput, cbOutput, pcbResult, dwFlags) {
        result := DllCall("ncrypt.dll\SslComputeEapKeyBlock", "ptr", hSslProvider, "ptr", hMasterKey, "ptr", pbRandoms, "uint", cbRandoms, "ptr", pbOutput, "uint", cbOutput, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Computes the hash sent in the finished message of the Secure Sockets Layer protocol (SSL) handshake.
     * @remarks
     * The **SslComputeFinishedHash** function is one of three functions used to generate a hash to use during the SSL handshake.
     * 
     * 1.  The [**SslCreateHandshakeHash**](sslcreatehandshakehash.md) function is called to obtain a hash handle.
     * 2.  The [**SslHashHandshake**](sslhashhandshake.md) function is called any number of times with the hash handle to add data to the hash.
     * 3.  The **SslComputeFinishedHash** function is called with the hash handle to obtain the digest of the hashed data.
     * 
     * The hash value is computed by hashing the master secret with a hash of all previous handshake messages sent or received.
     * 
     * The value of *cbOutput* determines the length of the hash data. When the [*Transport Layer Security protocol*](/windows/desktop/SecGloss/t-gly) (TLS) 1.0 protocol is used, this should always be 12 (bytes). For more information, see [The TLS Protocol Version 1.0](https://www.ietf.org/rfc/rfc2246.txt).
     * @param {Pointer} hSslProvider The handle of the SSL protocol provider instance.
     * @param {Pointer} hMasterKey The handle of the [*master key*](/windows/desktop/SecGloss/m-gly) object.
     * @param {Pointer} hHandshakeHash The handle of the hash of the handshake messages.
     * @param {Pointer<Byte>} pbOutput A pointer to a buffer that receives the hash for the finish message.
     * @param {Integer} cbOutput The length, in bytes, of the *pbOutput* buffer.
     * @param {Integer} dwFlags One of the following constants.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                                                                      | Meaning                                          |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------|
     * | <span id="NCRYPT_SSL_CLIENT_FLAG"></span><span id="ncrypt_ssl_client_flag"></span><dl> <dt>**NCRYPT\_SSL\_CLIENT\_FLAG**</dt> <dt>0x00000001</dt> </dl> | Specifies that this is a client call.<br/> |
     * | <span id="NCRYPT_SSL_SERVER_FLAG"></span><span id="ncrypt_ssl_server_flag"></span><dl> <dt>**NCRYPT\_SSL\_SERVER\_FLAG**</dt> <dt>0x00000002</dt> </dl> | Specifies that this is a server call.<br/> |
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                                | Description                                          |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>2148073510 (0x80090026)</dt> </dl> | One of the supplied handles is not valid.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslcomputefinishedhash
     */
    static SslComputeFinishedHash(hSslProvider, hMasterKey, hHandshakeHash, pbOutput, cbOutput, dwFlags) {
        result := DllCall("ncrypt.dll\SslComputeFinishedHash", "ptr", hSslProvider, "ptr", hMasterKey, "ptr", hHandshakeHash, "ptr", pbOutput, "uint", cbOutput, "uint", dwFlags, "int")
        return result
    }

    /**
     * Creates an ephemeral key for use during the authentication that occurs during the Secure Sockets Layer protocol (SSL) handshake.
     * @remarks
     * When using a DHE cipher suite, the internal SSL implementation passes server *p* and *g* parameters to the **SslCreateEphemeralKey** function in the *pbParams* and *cbParams* parameters.
     * 
     * The format of the data in the *pbParams* buffer is the same as that used when setting the [**BCRYPT\_DH\_PARAMETERS**](cng-property-identifiers.md) property, and it starts with a [**BCRYPT\_DH\_PARAMETER\_HEADER**](/windows/desktop/api/Bcrypt/ns-bcrypt-bcrypt_dh_parameter_header) structure.
     * @param {Pointer} hSslProvider The handle of the SSL protocol provider instance.
     * @param {Pointer<UIntPtr>} phEphemeralKey The handle of the ephemeral key.
     * @param {Integer} dwProtocol One of the [**CNG SSL Provider Protocol Identifier**](https://msdn.microsoft.com/library/Hh971257(v=VS.85).aspx) values.
     * @param {Integer} dwCipherSuite One of the [**CNG SSL Provider Cipher Suite Identifier**](https://msdn.microsoft.com/library/Hh971253(v=VS.85).aspx) values.
     * @param {Integer} dwKeyType One of the [**CNG SSL Provider Key Type Identifier**](https://msdn.microsoft.com/library/Hh971256(v=VS.85).aspx) values. Set this parameter to zero for key types that are not [*elliptic curve cryptography*](/windows/desktop/SecGloss/e-gly) (ECC).
     * @param {Integer} dwKeyBitLen The length, in bits, of the key.
     * @param {Pointer<Byte>} pbParams A pointer to a buffer to contain parameters for the key that is to be created. If a [*Diffie-Hellman (ephemeral) key-exchange algorithm*](/windows/desktop/SecGloss/d-gly) (DHE) cipher suite is not used, set the *pbParams* parameter to **NULL** and the *cbParams* parameter to zero.
     * @param {Integer} cbParams The length, in bytes, of the data in the *pbParams* buffer.
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                       | Description                                                     |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------|
     * | <dl> <dt>**NTE\_NO\_MEMORY**</dt> <dt>0x8009000EL</dt> </dl>         | There is insufficient memory to allocate the buffer.<br/> |
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl>    | The *hSslProvider* handle is not valid.<br/>              |
     * | <dl> <dt>**NTE\_INVALID\_PARAMETER**</dt> <dt>0x80090027L</dt> </dl> | One of the supplied parameters is not valid.<br/>         |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslcreateephemeralkey
     */
    static SslCreateEphemeralKey(hSslProvider, phEphemeralKey, dwProtocol, dwCipherSuite, dwKeyType, dwKeyBitLen, pbParams, cbParams, dwFlags) {
        result := DllCall("ncrypt.dll\SslCreateEphemeralKey", "ptr", hSslProvider, "ptr", phEphemeralKey, "uint", dwProtocol, "uint", dwCipherSuite, "uint", dwKeyType, "uint", dwKeyBitLen, "ptr", pbParams, "uint", cbParams, "uint", dwFlags, "int")
        return result
    }

    /**
     * Obtains a hash handle that is used to hash handshake messages.
     * @remarks
     * The **SslCreateHandshakeHash** function is one of three functions used to generate a hash to use during the SSL handshake.
     * 
     * 1.  The **SslCreateHandshakeHash** function is called to obtain a hash handle.
     * 2.  The [**SslHashHandshake**](sslhashhandshake.md) function is called any number of times with the hash handle to add data to the hash.
     * 3.  The [**SslComputeFinishedHash**](sslcomputefinishedhash.md) function is called with the hash handle to obtain the digest of the hashed data.
     * @param {Pointer} hSslProvider The handle of the [*Secure Sockets Layer protocol*](/windows/desktop/SecGloss/s-gly) (SSL) protocol provider instance.
     * @param {Pointer<UIntPtr>} phHandshakeHash A hash handle that can be passed to other SSL provider functions.
     * @param {Integer} dwProtocol One of the [**CNG SSL Provider Protocol Identifier**](https://msdn.microsoft.com/library/Hh971257(v=VS.85).aspx) values.
     * 
     * > [!Note]  
     * > This function is not used with the SSL 2.0 protocol.
     * @param {Integer} dwCipherSuite One of the [**CNG SSL Provider Cipher Suite Identifier**](https://msdn.microsoft.com/library/Hh971253(v=VS.85).aspx) values.
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                       | Description                                                          |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------|
     * | <dl> <dt>**NTE\_NO\_MEMORY**</dt> <dt>0x8009000EL</dt> </dl>         | There is insufficient memory to allocate the hash buffer.<br/> |
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl>    | The *hSslProvider* handle is not valid.<br/>                   |
     * | <dl> <dt>**NTE\_INVALID\_PARAMETER**</dt> <dt>0x80090027L</dt> </dl> | The *phHandshakeHash* is null.<br/>                            |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslcreatehandshakehash
     */
    static SslCreateHandshakeHash(hSslProvider, phHandshakeHash, dwProtocol, dwCipherSuite, dwFlags) {
        result := DllCall("ncrypt.dll\SslCreateHandshakeHash", "ptr", hSslProvider, "ptr", phHandshakeHash, "uint", dwProtocol, "uint", dwCipherSuite, "uint", dwFlags, "int")
        return result
    }

    /**
     * Decrypts a single Secure Sockets Layer protocol (SSL) packet.
     * @remarks
     * The length of the packet can be zero, such as when a "HelloRequest" message is decrypted.
     * @param {Pointer} hSslProvider The handle of the SSL protocol provider instance.
     * @param {Pointer} hKey The handle to the key that is used to decrypt the packet.
     * @param {Pointer<Byte>} pbInput A pointer to the buffer that contains the packet to be decrypted.
     * @param {Integer} cbInput The length, in bytes, of the *pbInput* buffer.
     * @param {Pointer<Byte>} pbOutput A pointer to a buffer to contain the decrypted packet.
     * @param {Integer} cbOutput The length, bytes, of the *pbOutput* buffer.
     * @param {Pointer<UInt32>} pcbResult The number of bytes written to the *pbOutput* buffer.
     * @param {Integer} SequenceNumber The sequence number that corresponds to this packet.
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                    | Description                                          |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl> | One of the provided handles is not valid.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/ssldecryptpacket
     */
    static SslDecryptPacket(hSslProvider, hKey, pbInput, cbInput, pbOutput, cbOutput, pcbResult, SequenceNumber, dwFlags) {
        result := DllCall("ncrypt.dll\SslDecryptPacket", "ptr", hSslProvider, "ptr", hKey, "ptr", pbInput, "uint", cbInput, "ptr", pbOutput, "uint", cbOutput, "ptr", pcbResult, "uint", SequenceNumber, "uint", dwFlags, "int")
        return result
    }

    /**
     * Encrypts a single Secure Sockets Layer protocol (SSL) packet.
     * @param {Pointer} hSslProvider The handle of the SSL protocol provider instance.
     * @param {Pointer} hKey The handle to the key that is used to encrypt the packet.
     * @param {Pointer<Byte>} pbInput A pointer to the buffer that contains the packet to be encrypted.
     * @param {Integer} cbInput The length, in bytes, of the *pbInput* buffer.
     * @param {Pointer<Byte>} pbOutput A pointer to a buffer to receive the encrypted packet.
     * @param {Integer} cbOutput The length, bytes, of the *pbOutput* buffer.
     * @param {Pointer<UInt32>} pcbResult The number of bytes written to the *pbOutput* buffer.
     * @param {Integer} SequenceNumber The sequence number that corresponds to this packet.
     * @param {Integer} dwContentType The content type that corresponds to this packet, which specifies the higher level protocol used to process the enclosed packet.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                                                           | Meaning                                                                          |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|
     * | <span id="CT_CHANGE_CIPHER_SPEC"></span><span id="ct_change_cipher_spec"></span><dl> <dt>**CT\_CHANGE\_CIPHER\_SPEC**</dt> <dt>20</dt> </dl> | Indicates a change in the ciphering strategy.<br/>                         |
     * | <span id="CT_ALERT"></span><span id="ct_alert"></span><dl> <dt>**CT\_ALERT**</dt> <dt>21</dt> </dl>                                          | Indicates that the enclosed packet contains an alert.<br/>                 |
     * | <span id="CT_HANDSHAKE"></span><span id="ct_handshake"></span><dl> <dt>**CT\_HANDSHAKE**</dt> <dt>22</dt> </dl>                              | Indicates that the enclosed packet is part of the handshake protocol.<br/> |
     * | <span id="CT_APPLICATIONDATA"></span><span id="ct_applicationdata"></span><dl> <dt>**CT\_APPLICATIONDATA**</dt> <dt>23</dt> </dl>            | Indicates that the packet contains application data.<br/>                  |
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                    | Description                                          |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl> | One of the provided handles is not valid.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslencryptpacket
     */
    static SslEncryptPacket(hSslProvider, hKey, pbInput, cbInput, pbOutput, cbOutput, pcbResult, SequenceNumber, dwContentType, dwFlags) {
        result := DllCall("ncrypt.dll\SslEncryptPacket", "ptr", hSslProvider, "ptr", hKey, "ptr", pbInput, "uint", cbInput, "ptr", pbOutput, "uint", cbOutput, "ptr", pcbResult, "uint", SequenceNumber, "uint", dwContentType, "uint", dwFlags, "int")
        return result
    }

    /**
     * Enumerates the cipher suites supported by a Secure Sockets Layer protocol (SSL) protocol provider.
     * @remarks
     * To enumerate all cipher suites supported by the SSL provider, call the **SslEnumCipherSuites** function in a loop until **NTE\_NO\_MORE\_ITEMS** is returned.
     * @param {Pointer} hSslProvider The handle of the SSL protocol provider instance.
     * @param {Pointer} hPrivateKey The handle of a [*private key*](/windows/desktop/SecGloss/p-gly). When a private key is specified, **SslEnumCipherSuites** enumerates the cipher suites that are compatible with the private key. For example, if the private key is a DSS key, then only the DSS\_DHE cipher suites are returned. If the private key is an RSA key, but it does not support raw decryption operations, then the SSL2 cipher suites are not returned.
     * 
     * Set this parameter to **NULL** when you are not specifying a private key.
     * 
     * > [!Note]  
     * > A *hPrivateKey* handle is obtained by calling the [**SslOpenPrivateKey**](sslopenprivatekey.md) function. Handles obtained from the [**NCryptOpenKey**](/windows/desktop/api/Ncrypt/nf-ncrypt-ncryptopenkey) function are not supported.
     * @param {Pointer<NCRYPT_SSL_CIPHER_SUITE>} ppCipherSuite A pointer to a **NCRYPT\_SSL\_CIPHER\_SUITE** structure to receive the address of the next cipher suite in the list.
     * @param {Pointer<Void>} ppEnumState A pointer to a buffer that indicates the current position in the list of cipher suites.
     * 
     * Set the pointer to **NULL** on the first call to **SslEnumCipherSuites**. On each subsequent call, pass the unmodified value back to **SslEnumCipherSuites**.
     * 
     * When there are no more cipher suites available, you should free *ppEnumState* by calling the [**SslFreeBuffer**](sslfreebuffer.md) function.
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                    | Description                                                              |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
     * | <dl> <dt>**NTE\_NO\_MEMORY**</dt> <dt>0x8009000EL</dt> </dl>      | Not enough memory is available to allocate necessary buffers.<br/> |
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl> | One of the provided handles is not valid.<br/>                     |
     * | <dl> <dt>**NTE\_NO\_MORE\_ITEMS**</dt> <dt>0x8009002AL</dt> </dl> | No additional cipher suites are supported.<br/>                    |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslenumciphersuites
     */
    static SslEnumCipherSuites(hSslProvider, hPrivateKey, ppCipherSuite, ppEnumState, dwFlags) {
        result := DllCall("ncrypt.dll\SslEnumCipherSuites", "ptr", hSslProvider, "ptr", hPrivateKey, "ptr", ppCipherSuite, "ptr", ppEnumState, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} hSslProvider 
     * @param {Pointer} hPrivateKey 
     * @param {Pointer<NCRYPT_SSL_CIPHER_SUITE_EX>} ppCipherSuite 
     * @param {Pointer<Void>} ppEnumState 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static SslEnumCipherSuitesEx(hSslProvider, hPrivateKey, ppCipherSuite, ppEnumState, dwFlags) {
        result := DllCall("ncrypt.dll\SslEnumCipherSuitesEx", "ptr", hSslProvider, "ptr", hPrivateKey, "ptr", ppCipherSuite, "ptr", ppEnumState, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} hSslProvider 
     * @param {Pointer<UInt32>} pEccCurveCount 
     * @param {Pointer<NCRYPT_SSL_ECC_CURVE>} ppEccCurve 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static SslEnumEccCurves(hSslProvider, pEccCurveCount, ppEccCurve, dwFlags) {
        result := DllCall("ncrypt.dll\SslEnumEccCurves", "ptr", hSslProvider, "ptr", pEccCurveCount, "ptr", ppEccCurve, "uint", dwFlags, "int")
        return result
    }

    /**
     * Returns an array of installed Secure Sockets Layer protocol (SSL) protocol providers.
     * @remarks
     * When you have finished using the array of [**NCryptProviderName**](/windows/desktop/api/Ncrypt/ns-ncrypt-ncryptprovidername) structures, call the [**SslFreeBuffer**](sslfreebuffer.md) function to free the array.
     * @param {Pointer<UInt32>} pdwProviderCount A pointer to a **DWORD** value to receive the number of protocol providers returned.
     * @param {Pointer<NCryptProviderName>} ppProviderList A pointer to a buffer that receives the array of [**NCryptProviderName**](/windows/desktop/api/Ncrypt/ns-ncrypt-ncryptprovidername) structures.
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                       | Description                                                                  |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------|
     * | <dl> <dt>**NTE\_BAD\_FLAGS**</dt> <dt>0x80090009L</dt> </dl>         | The *dwFlags* parameter is not zero.<br/>                              |
     * | <dl> <dt>**NTE\_NO\_MEMORY**</dt> <dt>0x8009000EL</dt> </dl>         | Not enough memory is available to allocate necessary buffers.<br/>     |
     * | <dl> <dt>**NTE\_INVALID\_PARAMETER**</dt> <dt>0x80090027L</dt> </dl> | The *pdwProviderCount* or *ppProviderList* parameter is **NULL**.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslenumprotocolproviders
     */
    static SslEnumProtocolProviders(pdwProviderCount, ppProviderList, dwFlags) {
        result := DllCall("ncrypt.dll\SslEnumProtocolProviders", "ptr", pdwProviderCount, "ptr", ppProviderList, "uint", dwFlags, "int")
        return result
    }

    /**
     * Returns an Secure Sockets Layer protocol (SSL) session key or public ephemeral key into a serialized BLOB.
     * @remarks
     * The **SslExportKey** function facilitates transporting session keys from one process to another as well as exporting the public portion an ephemeral key.
     * 
     * When exporting session keys, the BLOB type is opaque, meaning that the format of the BLOB is irrelevant as long as both the **SslExportKey** and [**SslImportKey**](sslimportkey.md) functions can interpret it.
     * 
     * When exporting the public portion of an ephemeral key the BLOB type must be the appropriate type, such as **NCRYPT\_DH\_PUBLIC\_BLOB** or **NCRYPT\_ECCPUBLIC\_BLOB**.
     * @param {Pointer} hSslProvider The handle of the SSL protocol provider instance.
     * @param {Pointer} hKey The handle of the key to export.
     * 
     * When you are not specifying a key, set this parameter to **NULL**.
     * 
     * > [!Note]  
     * > A *hKey* handle is obtained by calling the [**SslOpenPrivateKey**](sslopenprivatekey.md) function. Handles obtained from the [**NCryptOpenKey**](/windows/desktop/api/Ncrypt/nf-ncrypt-ncryptopenkey) function are not supported.
     * @param {Pointer<PWSTR>} pszBlobType A null-terminated Unicode string that contains an identifier that specifies the type of BLOB to export. This can be one of the following values.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                                                                                                                                 |
     * |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="BCRYPT_DH_PUBLIC_BLOB"></span><span id="bcrypt_dh_public_blob"></span><dl> <dt>**BCRYPT\_DH\_PUBLIC\_BLOB**</dt> </dl>    | Export a Diffie-Hellman [*public key*](/windows/desktop/SecGloss/p-gly). The *pbOutput* buffer receives a [**BCRYPT\_DH\_KEY\_BLOB**](/windows/desktop/api/Bcrypt/ns-bcrypt-bcrypt_dh_key_blob) structure immediately followed by the key data.<br/>                                                                                                               |
     * | <span id="BCRYPT_ECCPUBLIC_BLOB"></span><span id="bcrypt_eccpublic_blob"></span><dl> <dt>**BCRYPT\_ECCPUBLIC\_BLOB**</dt> </dl>     | Export an [*elliptic curve cryptography*](/windows/desktop/SecGloss/e-gly) (ECC) public key. The *pbOutput* buffer receives a [**BCRYPT\_ECCKEY\_BLOB**](/windows/desktop/api/Bcrypt/ns-bcrypt-bcrypt_ecckey_blob) structure immediately followed by the key data.<br/>                                                          |
     * | <span id="BCRYPT_OPAQUE_KEY_BLOB"></span><span id="bcrypt_opaque_key_blob"></span><dl> <dt>**BCRYPT\_OPAQUE\_KEY\_BLOB**</dt> </dl> | Export a symmetric key in a format that is specific to a single [*cryptographic service provider*](/windows/desktop/SecGloss/c-gly) (CSP). Opaque BLOBs are not transferable and must be imported by using the same *cryptographic service provider* (CSP) that generated the BLOB.<br/> |
     * | <span id="BCRYPT_RSAPUBLIC_BLOB"></span><span id="bcrypt_rsapublic_blob"></span><dl> <dt>**BCRYPT\_RSAPUBLIC\_BLOB**</dt> </dl>     | Export an RSA public key. The *pbOutput* buffer receives a [**BCRYPT\_RSAKEY\_BLOB**](/windows/desktop/api/Bcrypt/ns-bcrypt-bcrypt_rsakey_blob) structure immediately followed by the key data.<br/>                                                                                                                                                                                                |
     * @param {Pointer<Byte>} pbOutput The address of a buffer that receives the [*key BLOB*](/windows/desktop/SecGloss/k-gly). The *cbOutput* parameter contains the size of this buffer. If this parameter is **NULL**, this function will place the required size, in bytes, in the **DWORD** pointed to by the *pcbResult* parameter.
     * @param {Integer} cbOutput The size, in bytes, of the *pbOutput* buffer.
     * @param {Pointer<UInt32>} pcbResult The address of a **DWORD** variable that receives the number of bytes copied to the *pbOutput* buffer. If the *pbOutput* parameter is set to **NULL** when the function is called, the required size for the *pbOutput* buffer, in bytes, is returned in the **DWORD** pointed to by this parameter.
     * @param {Integer} dwFlags Reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                    | Description                                          |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl> | One of the provided handles is not valid.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslexportkey
     */
    static SslExportKey(hSslProvider, hKey, pszBlobType, pbOutput, cbOutput, pcbResult, dwFlags) {
        result := DllCall("ncrypt.dll\SslExportKey", "ptr", hSslProvider, "ptr", hKey, "ptr", pszBlobType, "ptr", pbOutput, "uint", cbOutput, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Used to free memory that was allocated by one of the Secure Sockets Layer protocol (SSL) provider functions.
     * @param {Pointer<Void>} pvInput A pointer to the memory buffer to be freed.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                       | Description                                                                  |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_PARAMETER**</dt> <dt>0x80090027L</dt> </dl> | The *pdwProviderCount* or *ppProviderList* parameter is **NULL**.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslfreebuffer
     */
    static SslFreeBuffer(pvInput) {
        result := DllCall("ncrypt.dll\SslFreeBuffer", "ptr", pvInput, "int")
        return result
    }

    /**
     * Frees a key, hash, or provider object.
     * @param {Pointer} hObject The handle of the object to free.
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                       | Description                                  |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl>    | An internal handle is not valid.<br/>  |
     * | <dl> <dt>**STATUS\_INVALID\_HANDLE**</dt> <dt>0xC0000008L</dt> </dl> | The provided handle is not valid.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslfreeobject
     */
    static SslFreeObject(hObject, dwFlags) {
        result := DllCall("ncrypt.dll\SslFreeObject", "ptr", hObject, "uint", dwFlags, "int")
        return result
    }

    /**
     * Computes the Secure Sockets Layer protocol (SSL) master secret key.
     * @param {Pointer} hSslProvider The handle to the SSL protocol provider instance.
     * @param {Pointer} hPrivateKey The handle to the [*private key*](/windows/desktop/SecGloss/p-gly) used in the exchange.
     * @param {Pointer} hPublicKey The handle to the [*public key*](/windows/desktop/SecGloss/p-gly) used in the exchange.
     * @param {Pointer<UIntPtr>} phMasterKey A pointer to the handle to the generated [*master key*](/windows/desktop/SecGloss/m-gly).
     * @param {Integer} dwProtocol One of the [**CNG SSL Provider Protocol Identifier**](https://msdn.microsoft.com/library/Hh971257(v=VS.85).aspx) values.
     * @param {Integer} dwCipherSuite One of the [**CNG SSL Provider Cipher Suite Identifier**](https://msdn.microsoft.com/library/Hh971253(v=VS.85).aspx) values.
     * @param {Pointer<BCryptBufferDesc>} pParameterList A pointer to an array of **NCryptBuffer** buffers that contain information used as part of the key exchange operation. The precise set of buffers is dependent on the protocol and cipher suite that is used. At the minimum, the list will contain buffers that contain the client and server supplied random values.
     * @param {Pointer<Byte>} pbOutput The address of a buffer that receives the premaster secret encrypted with the public key of the server. The *cbOutput* parameter contains the size of this buffer. If this parameter is **NULL**, this function returns the required size, in bytes, in the **DWORD** pointed to by the *pcbResult* parameter.
     * 
     * > [!Note]  
     * > This buffer is used when performing a RSA key exchange.
     * @param {Integer} cbOutput The size, in bytes, of the *pbOutput* buffer.
     * @param {Pointer<UInt32>} pcbResult A pointer to a **DWORD** value in which to place number of bytes written to the *pbOutput* buffer.
     * @param {Integer} dwFlags Specifies whether this function is being used for client-side or server-side key exchange.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                                                                      | Meaning                                          |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------|
     * | <span id="NCRYPT_SSL_CLIENT_FLAG"></span><span id="ncrypt_ssl_client_flag"></span><dl> <dt>**NCRYPT\_SSL\_CLIENT\_FLAG**</dt> <dt>0x00000001</dt> </dl> | Specifies a client-side key exchange.<br/> |
     * | <span id="NCRYPT_SSL_SERVER_FLAG"></span><span id="ncrypt_ssl_server_flag"></span><dl> <dt>**NCRYPT\_SSL\_SERVER\_FLAG**</dt> <dt>0x00000002</dt> </dl> | Specifies a server-side key exchange.<br/> |
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                       | Description                                                              |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
     * | <dl> <dt>**NTE\_NO\_MEMORY**</dt> <dt>0x8009000EL</dt> </dl>         | Not enough memory is available to allocate necessary buffers.<br/> |
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl>    | One of the provided handles is not valid.<br/>                     |
     * | <dl> <dt>**NTE\_INVALID\_PARAMETER**</dt> <dt>0x80090027L</dt> </dl> | The *phMasterKey* or *hPublicKey* parameter is not valid.<br/>     |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslgeneratemasterkey
     */
    static SslGenerateMasterKey(hSslProvider, hPrivateKey, hPublicKey, phMasterKey, dwProtocol, dwCipherSuite, pParameterList, pbOutput, cbOutput, pcbResult, dwFlags) {
        result := DllCall("ncrypt.dll\SslGenerateMasterKey", "ptr", hSslProvider, "ptr", hPrivateKey, "ptr", hPublicKey, "ptr", phMasterKey, "uint", dwProtocol, "uint", dwCipherSuite, "ptr", pParameterList, "ptr", pbOutput, "uint", cbOutput, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Generates a set of Secure Sockets Layer protocol (SSL) session keys.
     * @param {Pointer} hSslProvider The handle to the SSL protocol provider instance.
     * @param {Pointer} hMasterKey The handle to the [*master key*](/windows/desktop/SecGloss/m-gly) object.
     * @param {Pointer<UIntPtr>} phReadKey A pointer to the returned read key handle.
     * @param {Pointer<UIntPtr>} phWriteKey A pointer to the returned write key handle.
     * @param {Pointer<BCryptBufferDesc>} pParameterList A pointer to an array of **NCryptBuffer** buffers that contain information used as part of the key exchange operation. The precise set of buffers is dependent on the protocol and cipher suite that is used. At the minimum, the list will contain buffers that contain the client and server supplied random values.
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                       | Description                                                              |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
     * | <dl> <dt>**NTE\_NO\_MEMORY**</dt> <dt>0x8009000EL</dt> </dl>         | Not enough memory is available to allocate necessary buffers.<br/> |
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl>    | One of the provided handles is not valid.<br/>                     |
     * | <dl> <dt>**NTE\_INVALID\_PARAMETER**</dt> <dt>0x80090027L</dt> </dl> | The *phReadKey* or *phWriteKey* parameter is null.<br/>            |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslgeneratesessionkeys
     */
    static SslGenerateSessionKeys(hSslProvider, hMasterKey, phReadKey, phWriteKey, pParameterList, dwFlags) {
        result := DllCall("ncrypt.dll\SslGenerateSessionKeys", "ptr", hSslProvider, "ptr", hMasterKey, "ptr", phReadKey, "ptr", phWriteKey, "ptr", pParameterList, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves the value of a named property for a Secure Sockets Layer protocol (SSL) provider key object.
     * @param {Pointer} hKey The handle of the SSL provider.
     * @param {Pointer<PWSTR>} pszProperty A pointer to a null-terminated Unicode string that contains the name of the property to retrieve. This can be one of the predefined [**Key Storage Property Identifiers**](key-storage-property-identifiers.md) or a custom property identifier.
     * @param {Pointer<Byte>} ppbOutput A pointer to a buffer that receives the property value. The caller of the function must free this buffer by calling the [**SslFreeBuffer**](sslfreebuffer.md) function.
     * @param {Pointer<UInt32>} pcbOutput The size, in bytes, of the *pbOutput* buffer.
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                       | Description                                             |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl>    | One of the provided handles is not valid.<br/>    |
     * | <dl> <dt>**NTE\_INVALID\_PARAMETER**</dt> <dt>0x80090027L</dt> </dl> | One of the supplied parameters is not valid.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslgetkeyproperty
     */
    static SslGetKeyProperty(hKey, pszProperty, ppbOutput, pcbOutput, dwFlags) {
        result := DllCall("ncrypt.dll\SslGetKeyProperty", "ptr", hKey, "ptr", pszProperty, "ptr", ppbOutput, "ptr", pcbOutput, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves the value of a specified provider property.
     * @param {Pointer} hSslProvider The handle of the [*Secure Sockets Layer protocol*](/windows/desktop/SecGloss/s-gly) (SSL) provider for which to retrieve the property.
     * @param {Pointer<PWSTR>} pszProperty A pointer to a null-terminated Unicode string that contains the name of the property to retrieve.
     * @param {Pointer<Byte>} ppbOutput The address of a buffer that receives the property value.
     * 
     * The caller of the function must free this buffer by calling the [**SslFreeBuffer**](sslfreebuffer.md) function.
     * @param {Pointer<UInt32>} pcbOutput The size, in bytes, of the *pbOutput* buffer.
     * @param {Pointer<Void>} ppEnumState The address of a **VOID** pointer that receives enumeration state information that is used in subsequent calls to this function. This information only has meaning to the SSL provider and is opaque to the caller. The SSL provider uses this information to determine which item is next in the enumeration. If the variable pointed to by this parameter contains **NULL**, the enumeration is started from the beginning.
     * 
     * The caller of the function must free this memory by calling the [**SslFreeBuffer**](sslfreebuffer.md) function.
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                       | Description                                                              |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
     * | <dl> <dt>**NTE\_NO\_MEMORY**</dt> <dt>0x8009000EL</dt> </dl>         | Not enough memory is available to allocate necessary buffers.<br/> |
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl>    | The *hSslProvider* handle is not valid.<br/>                       |
     * | <dl> <dt>**NTE\_INVALID\_PARAMETER**</dt> <dt>0x80090027L</dt> </dl> | One of the supplied parameters is not valid.<br/>                  |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslgetproviderproperty
     */
    static SslGetProviderProperty(hSslProvider, pszProperty, ppbOutput, pcbOutput, ppEnumState, dwFlags) {
        result := DllCall("ncrypt.dll\SslGetProviderProperty", "ptr", hSslProvider, "ptr", pszProperty, "ptr", ppbOutput, "ptr", pcbOutput, "ptr", ppEnumState, "uint", dwFlags, "int")
        return result
    }

    /**
     * Returns a handle to the handshake hash.
     * @remarks
     * The **SslHashHandshake** function is one of three functions used to generate a hash to use during the SSL handshake.
     * 
     * 1.  The [**SslCreateHandshakeHash**](sslcreatehandshakehash.md) function is called to obtain a hash handle.
     * 2.  The **SslHashHandshake** function is called any number of times with the hash handle to add data to the hash.
     * 3.  The [**SslComputeFinishedHash**](sslcomputefinishedhash.md) function is called with the hash handle to obtain the digest of the hashed data.
     * @param {Pointer} hSslProvider The handle to the [*Secure Sockets Layer protocol*](/windows/desktop/SecGloss/s-gly) (SSL) protocol provider instance.
     * @param {Pointer} hHandshakeHash The handle to the hash object.
     * @param {Pointer<Byte>} pbInput The address of a buffer that contains the data to be hashed.
     * @param {Integer} cbInput The size, in bytes, of the *pbInput* buffer.
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslhashhandshake
     */
    static SslHashHandshake(hSslProvider, hHandshakeHash, pbInput, cbInput, dwFlags) {
        result := DllCall("ncrypt.dll\SslHashHandshake", "ptr", hSslProvider, "ptr", hHandshakeHash, "ptr", pbInput, "uint", cbInput, "uint", dwFlags, "int")
        return result
    }

    /**
     * Imports a key into the Secure Sockets Layer protocol (SSL) protocol provider.
     * @remarks
     * You can use the **SslImportKey** function to import session keys as a part of the process of transferring session keys from one process to another.
     * @param {Pointer} hSslProvider The handle to the SSL protocol provider instance.
     * @param {Pointer<UIntPtr>} phKey A pointer to the handle of the [*cryptographic key*](/windows/desktop/SecGloss/c-gly) to receive the imported key.
     * @param {Pointer<PWSTR>} pszBlobType A null-terminated Unicode string that contains an identifier that specifies the type of [*BLOB*](/windows/desktop/SecGloss/b-gly) that is contained in the *pbInput* buffer. This can be one of the following values.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                                                                                                                                                                          |
     * |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="BCRYPT_DH_PUBLIC_BLOB"></span><span id="bcrypt_dh_public_blob"></span><dl> <dt>**BCRYPT\_DH\_PUBLIC\_BLOB**</dt> </dl>    | Export a Diffie-Hellman [*public key*](/windows/desktop/SecGloss/p-gly). The *pbOutput* buffer receives a [**BCRYPT\_DH\_KEY\_BLOB**](/windows/desktop/api/Bcrypt/ns-bcrypt-bcrypt_dh_key_blob) structure immediately followed by the key data.<br/>                                                                                                                                                        |
     * | <span id="BCRYPT_ECCPUBLIC_BLOB"></span><span id="bcrypt_eccpublic_blob"></span><dl> <dt>**BCRYPT\_ECCPUBLIC\_BLOB**</dt> </dl>     | Export an [*elliptic curve cryptography*](/windows/desktop/SecGloss/e-gly) (ECC) [*public key*](/windows/desktop/SecGloss/p-gly). The *pbOutput* buffer receives a [**BCRYPT\_ECCKEY\_BLOB**](/windows/desktop/api/Bcrypt/ns-bcrypt-bcrypt_ecckey_blob) structure immediately followed by the key data.<br/>                             |
     * | <span id="BCRYPT_OPAQUE_KEY_BLOB"></span><span id="bcrypt_opaque_key_blob"></span><dl> <dt>**BCRYPT\_OPAQUE\_KEY\_BLOB**</dt> </dl> | Export a [*symmetric key*](/windows/desktop/SecGloss/s-gly) in a format that is specific to a single [*cryptographic service provider*](/windows/desktop/SecGloss/c-gly) (CSP). Opaque BLOBs are not transferable and must be imported by using the same CSP that generated the BLOB.<br/> |
     * | <span id="BCRYPT_RSAPUBLIC_BLOB"></span><span id="bcrypt_rsapublic_blob"></span><dl> <dt>**BCRYPT\_RSAPUBLIC\_BLOB**</dt> </dl>     | Export an [*RSA*](/windows/desktop/SecGloss/r-gly) public key. The *pbOutput* buffer receives a [**BCRYPT\_RSAKEY\_BLOB**](/windows/desktop/api/Bcrypt/ns-bcrypt-bcrypt_rsakey_blob) structure immediately followed by the key data.<br/>                                                                                                                                                                                 |
     * @param {Pointer<Byte>} pbKeyBlob A pointer to the buffer that contains the [*key BLOB*](/windows/desktop/SecGloss/k-gly).
     * @param {Integer} cbKeyBlob The size, in bytes, of the *pbKeyBlob* buffer.
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                       | Description                                                              |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
     * | <dl> <dt>**NTE\_NO\_MEMORY**</dt> <dt>0x8009000EL</dt> </dl>         | Not enough memory is available to allocate necessary buffers.<br/> |
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl>    | The *hSslProvider* handle is not valid.<br/>                       |
     * | <dl> <dt>**NTE\_INVALID\_PARAMETER**</dt> <dt>0x80090027L</dt> </dl> | The *phKey* parameter is **NULL**.<br/>                            |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslimportkey
     */
    static SslImportKey(hSslProvider, phKey, pszBlobType, pbKeyBlob, cbKeyBlob, dwFlags) {
        result := DllCall("ncrypt.dll\SslImportKey", "ptr", hSslProvider, "ptr", phKey, "ptr", pszBlobType, "ptr", pbKeyBlob, "uint", cbKeyBlob, "uint", dwFlags, "int")
        return result
    }

    /**
     * Performs a server-side Secure Sockets Layer protocol (SSL) key exchange operation.
     * @remarks
     * This function decrypts the premaster secret, computes the SSL master secret, and returns a handle to this object to the caller. This master key can then be used to derive the SSL session key and finish the SSL handshake.
     * 
     * > [!Note]  
     * > This function is used when the [*RSA*](/windows/desktop/SecGloss/r-gly) key exchange algorithm is being used. When [*DH*](/windows/desktop/SecGloss/d-gly) is used, then the server code calls [**SslGenerateMasterKey**](sslgeneratemasterkey.md) instead.
     * @param {Pointer} hSslProvider The handle to the SSL protocol provider instance.
     * @param {Pointer} hPrivateKey The handle to the [*private key*](/windows/desktop/SecGloss/p-gly) used in the exchange.
     * @param {Pointer<UIntPtr>} phMasterKey A pointer to the handle to receive the [*master key*](/windows/desktop/SecGloss/m-gly).
     * @param {Integer} dwProtocol One of the [**CNG SSL Provider Protocol Identifier**](https://msdn.microsoft.com/library/Hh971257(v=VS.85).aspx) values.
     * @param {Integer} dwCipherSuite One of the [**CNG SSL Provider Cipher Suite Identifiers**](https://msdn.microsoft.com/library/Hh971253(v=VS.85).aspx) values.
     * @param {Pointer<BCryptBufferDesc>} pParameterList A pointer to an array of **NCryptBuffer** buffers that contain information used as part of the key exchange operation. The precise set of buffers is dependent on the protocol and cipher suite that is used. At the minimum, the list will contain buffers that contain the client and server supplied random values.
     * @param {Pointer<Byte>} pbEncryptedKey A pointer to a buffer that contains the encrypted premaster secret key encrypted with the [*public key*](/windows/desktop/SecGloss/p-gly) of the server.
     * @param {Integer} cbEncryptedKey The size, in bytes, of the *pbEncryptedKey* buffer.
     * @param {Integer} dwFlags Set this parameter to **NCRYPT\_SSL\_SERVER\_FLAG** to indicate that this is a server call.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                       | Description                                                              |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
     * | <dl> <dt>**NTE\_NO\_MEMORY**</dt> <dt>0x8009000EL</dt> </dl>         | Not enough memory is available to allocate necessary buffers.<br/> |
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl>    | One of the provided handles is not valid.<br/>                     |
     * | <dl> <dt>**NTE\_INVALID\_PARAMETER**</dt> <dt>0x80090027L</dt> </dl> | The *phMasterKey* parameter is **NULL**.<br/>                      |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslimportmasterkey
     */
    static SslImportMasterKey(hSslProvider, hPrivateKey, phMasterKey, dwProtocol, dwCipherSuite, pParameterList, pbEncryptedKey, cbEncryptedKey, dwFlags) {
        result := DllCall("ncrypt.dll\SslImportMasterKey", "ptr", hSslProvider, "ptr", hPrivateKey, "ptr", phMasterKey, "uint", dwProtocol, "uint", dwCipherSuite, "ptr", pParameterList, "ptr", pbEncryptedKey, "uint", cbEncryptedKey, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves the cipher suite information for a specified protocol, cipher suite, and key type set.
     * @param {Pointer} hSslProvider The handle to the [*Secure Sockets Layer protocol*](/windows/desktop/SecGloss/s-gly) (SSL) protocol provider instance.
     * @param {Integer} dwProtocol One of the [**CNG SSL Provider Protocol Identifier**](https://msdn.microsoft.com/library/Hh971257(v=VS.85).aspx) values.
     * @param {Integer} dwCipherSuite One of the [**CNG SSL Provider Cipher Suite Identifiers**](https://msdn.microsoft.com/library/Hh971253(v=VS.85).aspx) values.
     * @param {Integer} dwKeyType One of the [**CNG SSL Provider Key Type Identifiers**](https://msdn.microsoft.com/library/Hh971256(v=VS.85).aspx) values.
     * @param {Pointer<NCRYPT_SSL_CIPHER_SUITE>} pCipherSuite The address of a buffer that contains a [**NCRYPT\_SSL\_CIPHER\_SUITE**](https://www.bing.com/search?q=**NCRYPT\_SSL\_CIPHER\_SUITE**) structure in which to write the cipher suite information.
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                    | Description                                        |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl> | The *hSslProvider* handle is not valid.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/ssllookupciphersuiteinfo
     */
    static SslLookupCipherSuiteInfo(hSslProvider, dwProtocol, dwCipherSuite, dwKeyType, pCipherSuite, dwFlags) {
        result := DllCall("ncrypt.dll\SslLookupCipherSuiteInfo", "ptr", hSslProvider, "uint", dwProtocol, "uint", dwCipherSuite, "uint", dwKeyType, "ptr", pCipherSuite, "uint", dwFlags, "int")
        return result
    }

    /**
     * Opens a handle to a private key.
     * @remarks
     * The private key obtained is part of a [*public/private key pair*](/windows/desktop/SecGloss/p-gly) within a [*certificate*](/windows/desktop/SecGloss/c-gly). This function merely extracts the private key from the certificate specified by the *pCertContext* parameter.
     * @param {Pointer} hSslProvider The handle to the [*Secure Sockets Layer protocol*](/windows/desktop/SecGloss/s-gly) (SSL) protocol provider instance.
     * @param {Pointer<UIntPtr>} phPrivateKey The address of a buffer in which to write the handle to the private key.
     * 
     * When you have finished using the key, you should free *phPrivateKey* by calling the [**SslFreeObject**](sslfreeobject.md) function.
     * @param {Pointer<CERT_CONTEXT>} pCertContext The address of the certificate from which to obtain the private key.
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                       | Description                                                              |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
     * | <dl> <dt>**NTE\_NO\_MEMORY**</dt> <dt>0x8009000EL</dt> </dl>         | Not enough memory is available to allocate necessary buffers.<br/> |
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl>    | The *hSslProvider* handle is not valid.<br/>                       |
     * | <dl> <dt>**NTE\_INVALID\_PARAMETER**</dt> <dt>0x80090027L</dt> </dl> | The *phPrivateKey* or *pCertContext* parameter is **NULL**.<br/>   |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslopenprivatekey
     */
    static SslOpenPrivateKey(hSslProvider, phPrivateKey, pCertContext, dwFlags) {
        result := DllCall("ncrypt.dll\SslOpenPrivateKey", "ptr", hSslProvider, "ptr", phPrivateKey, "ptr", pCertContext, "uint", dwFlags, "int")
        return result
    }

    /**
     * Opens a handle to the specified Secure Sockets Layer protocol (SSL) protocol provider.
     * @param {Pointer<UIntPtr>} phSslProvider The address of an **NCRYPT\_PROV\_HANDLE** in which to write the provider handle.
     * 
     * When you have finished using the handle, you should free it by calling the [**SslFreeObject**](sslfreeobject.md) function.
     * @param {Pointer<PWSTR>} pszProviderName A pointer to a Unicode string that contains the provider name. If the value of this parameter is **NULL**, a handle to the **MS\_SCHANNEL\_PROVIDER** is returned.
     * @param {Integer} dwFlags This parameter is reserved for future use, and it must be set to zero.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                       | Description                                                               |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl>    | One of the provided handles is not valid.<br/>                      |
     * | <dl> <dt>**NTE\_INVALID\_PARAMETER**</dt> <dt>0x80090027L</dt> </dl> | The *phSslProvider* or *ppProviderList* parameter is **NULL**.<br/> |
     * | <dl> <dt>**STATUS\_NO\_MEMORY**</dt> <dt>0xC0000017L</dt> </dl>      | Not enough memory is available to allocate necessary buffers.<br/>  |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslopenprovider
     */
    static SslOpenProvider(phSslProvider, pszProviderName, dwFlags) {
        result := DllCall("ncrypt.dll\SslOpenProvider", "ptr", phSslProvider, "ptr", pszProviderName, "uint", dwFlags, "int")
        return result
    }

    /**
     * Signs a hash by using the specified private key.
     * @param {Pointer} hSslProvider The handle to the [*Secure Sockets Layer protocol*](/windows/desktop/SecGloss/s-gly) (SSL) protocol provider instance.
     * @param {Pointer} hPrivateKey The handle to the private key to use to sign the hash.
     * @param {Pointer<Byte>} pbHashValue A pointer to a buffer that contains the hash to sign.
     * @param {Integer} cbHashValue The size, in bytes, of the *pbHashValue* buffer.
     * @param {Pointer<Byte>} pbSignature The address of a buffer that receives the signature of the hash. The *cbSignature* parameter contains the size of this buffer. To determine the required sized size of the buffer, set the *pbSignature* parameter to **NULL**. The required size of the buffer will be returned in the *pcbResult* parameter.
     * @param {Integer} cbSignature The size, in bytes, of the *pbSignature* buffer.
     * @param {Pointer<UInt32>} pcbResult A pointer to a value that, upon completion, contains the actual number of bytes written to the *pbSignature* buffer.
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                    | Description                                          |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl> | One of the provided handles is not valid.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslsignhash
     */
    static SslSignHash(hSslProvider, hPrivateKey, pbHashValue, cbHashValue, pbSignature, cbSignature, pcbResult, dwFlags) {
        result := DllCall("ncrypt.dll\SslSignHash", "ptr", hSslProvider, "ptr", hPrivateKey, "ptr", pbHashValue, "uint", cbHashValue, "ptr", pbSignature, "uint", cbSignature, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Verifies the specified signature by using the supplied hash and the public key.
     * @remarks
     * The **SslVerifySignature** function is not currently called by Windows. This function is a required part of the SSL Provider interface and should be fully implemented to ensure forward compatibility.
     * 
     * Current implementations of the server side of the [*Transport Layer Security protocol*](/windows/desktop/SecGloss/t-gly) (TLS) connection call the [**NCryptVerifySignature**](/windows/desktop/api/Ncrypt/nf-ncrypt-ncryptverifysignature) function during the client authentication to process the certificate verify message.
     * @param {Pointer} hSslProvider The handle to the [*Secure Sockets Layer protocol*](/windows/desktop/SecGloss/s-gly) (SSL) protocol provider instance.
     * @param {Pointer} hPublicKey The handle to the public key.
     * @param {Pointer<Byte>} pbHashValue A pointer to a buffer that contains the hash to use to verify the signature.
     * @param {Integer} cbHashValue The size, in bytes, of the *pbHashValue* buffer.
     * @param {Pointer<Byte>} pbSignature A pointer to a buffer that contains the signature to verify.
     * @param {Integer} cbSignature The size, in bytes, of the *pbSignature* buffer.
     * @param {Integer} dwFlags This parameter is reserved for future use.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                    | Description                                          |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl> | One of the provided handles is not valid.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslverifysignature
     */
    static SslVerifySignature(hSslProvider, hPublicKey, pbHashValue, cbHashValue, pbSignature, cbSignature, dwFlags) {
        result := DllCall("ncrypt.dll\SslVerifySignature", "ptr", hSslProvider, "ptr", hPublicKey, "ptr", pbHashValue, "uint", cbHashValue, "ptr", pbSignature, "uint", cbSignature, "uint", dwFlags, "int")
        return result
    }

    /**
     * Returns an NCRYPT\_SSL\_CIPHER\_LENGTHS structure that contains the header and trailer lengths of the input protocol, cipher suite, and key type.
     * @remarks
     * The **SslLookupCipherLengths** function is called for [*Transport Layer Security protocol*](/windows/desktop/SecGloss/t-gly) (TLS) 1.1 or later conversations to query the header and trailer lengths for the requested protocol, cipher suite, and key type.
     * @param {Pointer} hSslProvider The handle of the [*Secure Sockets Layer protocol*](/windows/desktop/SecGloss/s-gly) (SSL) protocol provider instance.
     * @param {Integer} dwProtocol One of the [**CNG SSL Provider Protocol Identifier**](https://msdn.microsoft.com/library/Hh971257(v=VS.85).aspx) values.
     * @param {Integer} dwCipherSuite One of the [**CNG SSL Provider Cipher Suite Identifier**](https://msdn.microsoft.com/library/Hh971253(v=VS.85).aspx) values.
     * @param {Integer} dwKeyType One of the [**CNG SSL Provider Key Type Identifier**](https://msdn.microsoft.com/library/Hh971256(v=VS.85).aspx) values. For key types that are not [*elliptic curve cryptography*](/windows/desktop/SecGloss/e-gly) (ECC), set this parameter to zero.
     * @param {Pointer<NCRYPT_SSL_CIPHER_LENGTHS>} pCipherLengths A pointer to a buffer to receive the [**NCRYPT\_SSL\_CIPHER\_LENGTHS**](https://www.bing.com/search?q=**NCRYPT\_SSL\_CIPHER\_LENGTHS**) structure.
     * @param {Integer} cbCipherLengths The length, in bytes, of the buffer pointed to by the *pCipherLengths* parameter.
     * @param {Integer} dwFlags This parameter is reserved for future use and must be set to zero.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                       | Description                                                                                                                        |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl>    | The *hSslProvider* parameter contains a pointer that is not valid.<br/>                                                      |
     * | <dl> <dt>**NTE\_INVALID\_PARAMETER**</dt> <dt>0x80090027L</dt> </dl> | The *pCipherLengths* parameter is set to **NULL** or the buffer length specified by the *cbCipherLengths* is too short.<br/> |
     * | <dl> <dt>**NTE\_BAD\_FLAGS**</dt> <dt>0x80090009L</dt> </dl>         | The *dwFlags* parameter must be set to zero.<br/>                                                                            |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/ssllookupcipherlengths
     */
    static SslLookupCipherLengths(hSslProvider, dwProtocol, dwCipherSuite, dwKeyType, pCipherLengths, cbCipherLengths, dwFlags) {
        result := DllCall("ncrypt.dll\SslLookupCipherLengths", "ptr", hSslProvider, "uint", dwProtocol, "uint", dwCipherSuite, "uint", dwKeyType, "ptr", pCipherLengths, "uint", cbCipherLengths, "uint", dwFlags, "int")
        return result
    }

    /**
     * Retrieves a handle to the handshake hash that is used for client authentication.
     * @remarks
     * The **SslCreateClientAuthHash** function is called for [*Transport Layer Security protocol*](/windows/desktop/SecGloss/t-gly) (TLS) 1.2 or later conversations to create hash objects that are used to hash handshake messages. It is called once for each possible [*hashing algorithm*](/windows/desktop/SecGloss/h-gly) that can be used in the client authentication signature.
     * @param {Pointer} hSslProvider The handle of the [*Secure Sockets Layer protocol*](/windows/desktop/SecGloss/s-gly) (SSL) protocol provider instance.
     * @param {Pointer<UIntPtr>} phHandshakeHash A pointer to an **NCRYPT\_HASH\_HANDLE** variable to receive the hash handle.
     * @param {Integer} dwProtocol One of the [**CNG SSL Provider Protocol Identifier**](https://msdn.microsoft.com/library/Hh971257(v=VS.85).aspx) values.
     * @param {Integer} dwCipherSuite One of the [**CNG SSL Provider Cipher Suite Identifier**](https://msdn.microsoft.com/library/Hh971253(v=VS.85).aspx) values.
     * @param {Pointer<PWSTR>} pszHashAlgId One of the [**CNG Algorithm Identifiers**](cng-algorithm-identifiers.md) values.
     * @param {Integer} dwFlags This parameter is reserved for future use and must be set to zero.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                       | Description                                                                                  |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl>    | The *hSslProvider* parameter contains a pointer that is not valid.<br/>                |
     * | <dl> <dt>**NTE\_INVALID\_PARAMETER**</dt> <dt>0x80090027L</dt> </dl> | The *phHandshakeHash* parameter is set to **NULL**.<br/>                               |
     * | <dl> <dt>**NTE\_NOT\_SUPPORTED**</dt> <dt>0x80090029L</dt> </dl>     | The selected function is not supported in the specified version of the interface.<br/> |
     * | <dl> <dt>**NTE\_NO\_MEMORY**</dt> <dt>0x8009000EL</dt> </dl>         | Insufficient memory to allocate buffers.<br/>                                          |
     * | <dl> <dt>**NTE\_BAD\_FLAGS**</dt> <dt>0x80090009L</dt> </dl>         | The *dwFlags* parameter must be set to zero.<br/>                                      |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslcreateclientauthhash
     */
    static SslCreateClientAuthHash(hSslProvider, phHandshakeHash, dwProtocol, dwCipherSuite, pszHashAlgId, dwFlags) {
        result := DllCall("ncrypt.dll\SslCreateClientAuthHash", "ptr", hSslProvider, "ptr", phHandshakeHash, "uint", dwProtocol, "uint", dwCipherSuite, "ptr", pszHashAlgId, "uint", dwFlags, "int")
        return result
    }

    /**
     * Returns the Cryptography API: Next Generation (CNG) Algorithm Identifier of the hashing algorithm that is used for the Transport Layer Security protocol (TLS) pseudo-random function (PRF) for the input protocol, cipher suite, and key type.
     * @remarks
     * This **SslGetCipherSuitePRFHashAlgorithm** function is called for TLS 1.2 or later conversations to query the hashing algorithm that will be used in the TLS PRF.
     * @param {Pointer} hSslProvider The handle of the [*Secure Sockets Layer protocol*](/windows/desktop/SecGloss/s-gly) (SSL) protocol provider instance.
     * @param {Integer} dwProtocol One of the [**CNG SSL Provider Protocol Identifier**](https://msdn.microsoft.com/library/Hh971257(v=VS.85).aspx) values.
     * @param {Integer} dwCipherSuite One of the [**CNG SSL Provider Cipher Suite Identifier**](https://msdn.microsoft.com/library/Hh971253(v=VS.85).aspx) values.
     * @param {Integer} dwKeyType One of the [**CNG SSL Provider Key Type Identifier**](https://msdn.microsoft.com/library/Hh971256(v=VS.85).aspx) values. For key types that are not [*elliptic curve cryptography*](/windows/desktop/SecGloss/e-gly) (ECC), set this parameter to zero.
     * @param {Pointer<PWSTR>} szPRFHash One of the [**CNG Algorithm Identifiers**](cng-algorithm-identifiers.md) for the hash that will be used for the TLS PRF.
     * @param {Integer} dwFlags This parameter is reserved for future use and must be set to zero.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                       | Description                                                                                  |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl>    | The *hSslProvider* parameter contains a pointer that is not valid.<br/>                |
     * | <dl> <dt>**NTE\_INVALID\_PARAMETER**</dt> <dt>0x80090027L</dt> </dl> | The *szPRFHash* parameter is set to **NULL**.<br/>                                     |
     * | <dl> <dt>**NTE\_NOT\_SUPPORTED**</dt> <dt>0x80090029L</dt> </dl>     | The selected function is not supported in the specified version of the interface.<br/> |
     * | <dl> <dt>**NTE\_BAD\_FLAGS**</dt> <dt>0x80090009L</dt> </dl>         | The *dwFlags* parameter must be set to zero.<br/>                                      |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslgetciphersuiteprfhashalgorithm
     */
    static SslGetCipherSuitePRFHashAlgorithm(hSslProvider, dwProtocol, dwCipherSuite, dwKeyType, szPRFHash, dwFlags) {
        result := DllCall("ncrypt.dll\SslGetCipherSuitePRFHashAlgorithm", "ptr", hSslProvider, "uint", dwProtocol, "uint", dwCipherSuite, "uint", dwKeyType, "ptr", szPRFHash, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} hSslProvider 
     * @param {Pointer} hHandshakeHash 
     * @param {Integer} dwProtocol 
     * @param {Pointer<Byte>} pbOutput 
     * @param {Integer} cbOutput 
     * @param {Pointer<UInt32>} pcbResult 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static SslComputeSessionHash(hSslProvider, hHandshakeHash, dwProtocol, pbOutput, cbOutput, pcbResult, dwFlags) {
        result := DllCall("ncrypt.dll\SslComputeSessionHash", "ptr", hSslProvider, "ptr", hHandshakeHash, "uint", dwProtocol, "ptr", pbOutput, "uint", cbOutput, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} hSslProvider 
     * @param {Pointer} hPublicKey 
     * @param {Pointer<UIntPtr>} phPreMasterKey 
     * @param {Integer} dwProtocol 
     * @param {Integer} dwCipherSuite 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Pointer<Byte>} pbOutput 
     * @param {Integer} cbOutput 
     * @param {Pointer<UInt32>} pcbResult 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static SslGeneratePreMasterKey(hSslProvider, hPublicKey, phPreMasterKey, dwProtocol, dwCipherSuite, pParameterList, pbOutput, cbOutput, pcbResult, dwFlags) {
        result := DllCall("ncrypt.dll\SslGeneratePreMasterKey", "ptr", hSslProvider, "ptr", hPublicKey, "ptr", phPreMasterKey, "uint", dwProtocol, "uint", dwCipherSuite, "ptr", pParameterList, "ptr", pbOutput, "uint", cbOutput, "ptr", pcbResult, "uint", dwFlags, "int")
        return result
    }

    /**
     * Exports keying material per the RFC 5705 standard.
     * @param {Pointer} hSslProvider The handle of the TLS protocol provider instance.
     * @param {Pointer} hMasterKey The handle of the master key object that will be used to create the keying material to br exported.
     * @param {Pointer<PSTR>} sLabel a NUL-terminated ASCII label string. Schannel will remove the terminating NUL character before passing it to the pseudorandom function.
     * @param {Pointer<Byte>} pbRandoms A pointer to a buffer that contains a concatenation of the *client\_random* and *server\_random* values of the TLS connection.
     * @param {Integer} cbRandoms The length, in bytes, of the *pbRandoms* buffer.
     * @param {Pointer<Byte>} pbContextValue A pointer to a buffer that contains the application context. If *pbContextValue* is **NULL**, *cbContextValue* must be zero.
     * @param {Integer} cbContextValue The length, in bytes, of the *pbContextValue* buffer.
     * @param {Pointer<Byte>} pbOutput The address of a buffer that receives the exported keying material. The *cbOutput* parameter contains the size of this buffer. This value cannot be **NULL**.
     * @param {Integer} cbOutput The length, in bytes, of the *pbOutput* buffer. Must be greater than zero.
     * @param {Integer} dwFlags Not used. Must be set to zero.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                    | Description                                          |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl> | One of the provided handles is not valid.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslexportkeyingmaterial
     */
    static SslExportKeyingMaterial(hSslProvider, hMasterKey, sLabel, pbRandoms, cbRandoms, pbContextValue, cbContextValue, pbOutput, cbOutput, dwFlags) {
        result := DllCall("ncrypt.dll\SslExportKeyingMaterial", "ptr", hSslProvider, "ptr", hMasterKey, "ptr", sLabel, "ptr", pbRandoms, "uint", cbRandoms, "ptr", pbContextValue, "ushort", cbContextValue, "ptr", pbOutput, "uint", cbOutput, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} hSslProvider 
     * @param {Pointer} hPreSharedKey 
     * @param {Pointer<UIntPtr>} phEarlyKey 
     * @param {Integer} dwProtocol 
     * @param {Integer} dwCipherSuite 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static SslExtractEarlyKey(hSslProvider, hPreSharedKey, phEarlyKey, dwProtocol, dwCipherSuite, pParameterList, dwFlags) {
        result := DllCall("ncrypt.dll\SslExtractEarlyKey", "ptr", hSslProvider, "ptr", hPreSharedKey, "ptr", phEarlyKey, "uint", dwProtocol, "uint", dwCipherSuite, "ptr", pParameterList, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} hSslProvider 
     * @param {Pointer} hPrivateKey 
     * @param {Pointer} hPublicKey 
     * @param {Pointer} hEarlyKey 
     * @param {Pointer<UIntPtr>} phHandshakeKey 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static SslExtractHandshakeKey(hSslProvider, hPrivateKey, hPublicKey, hEarlyKey, phHandshakeKey, pParameterList, dwFlags) {
        result := DllCall("ncrypt.dll\SslExtractHandshakeKey", "ptr", hSslProvider, "ptr", hPrivateKey, "ptr", hPublicKey, "ptr", hEarlyKey, "ptr", phHandshakeKey, "ptr", pParameterList, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} hSslProvider 
     * @param {Pointer} hHandshakeKey 
     * @param {Pointer<UIntPtr>} phMasterKey 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static SslExtractMasterKey(hSslProvider, hHandshakeKey, phMasterKey, pParameterList, dwFlags) {
        result := DllCall("ncrypt.dll\SslExtractMasterKey", "ptr", hSslProvider, "ptr", hHandshakeKey, "ptr", phMasterKey, "ptr", pParameterList, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} hSslProvider 
     * @param {Pointer} hBaseKey 
     * @param {Pointer} hHashValue 
     * @param {Pointer<UIntPtr>} phClientTrafficKey 
     * @param {Pointer<UIntPtr>} phServerTrafficKey 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static SslExpandTrafficKeys(hSslProvider, hBaseKey, hHashValue, phClientTrafficKey, phServerTrafficKey, pParameterList, dwFlags) {
        result := DllCall("ncrypt.dll\SslExpandTrafficKeys", "ptr", hSslProvider, "ptr", hBaseKey, "ptr", hHashValue, "ptr", phClientTrafficKey, "ptr", phServerTrafficKey, "ptr", pParameterList, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} hSslProvider 
     * @param {Pointer} hBaseTrafficKey 
     * @param {Pointer<UIntPtr>} phWriteKey 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static SslExpandWriteKey(hSslProvider, hBaseTrafficKey, phWriteKey, pParameterList, dwFlags) {
        result := DllCall("ncrypt.dll\SslExpandWriteKey", "ptr", hSslProvider, "ptr", hBaseTrafficKey, "ptr", phWriteKey, "ptr", pParameterList, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} hSslProvider 
     * @param {Pointer} hBaseKey 
     * @param {Pointer} hHashValue 
     * @param {Pointer<UIntPtr>} phExporterMasterKey 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static SslExpandExporterMasterKey(hSslProvider, hBaseKey, hHashValue, phExporterMasterKey, pParameterList, dwFlags) {
        result := DllCall("ncrypt.dll\SslExpandExporterMasterKey", "ptr", hSslProvider, "ptr", hBaseKey, "ptr", hHashValue, "ptr", phExporterMasterKey, "ptr", pParameterList, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} hSslProvider 
     * @param {Pointer} hMasterKey 
     * @param {Pointer} hHashValue 
     * @param {Pointer<UIntPtr>} phResumptionMasterKey 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static SslExpandResumptionMasterKey(hSslProvider, hMasterKey, hHashValue, phResumptionMasterKey, pParameterList, dwFlags) {
        result := DllCall("ncrypt.dll\SslExpandResumptionMasterKey", "ptr", hSslProvider, "ptr", hMasterKey, "ptr", hHashValue, "ptr", phResumptionMasterKey, "ptr", pParameterList, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} hSslProvider 
     * @param {Pointer} hTranscriptHash 
     * @param {Pointer<UIntPtr>} phTranscriptHash 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static SslDuplicateTranscriptHash(hSslProvider, hTranscriptHash, phTranscriptHash, dwFlags) {
        result := DllCall("ncrypt.dll\SslDuplicateTranscriptHash", "ptr", hSslProvider, "ptr", hTranscriptHash, "ptr", phTranscriptHash, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} hSslProvider 
     * @param {Pointer} hEarlyKey 
     * @param {Pointer<UIntPtr>} phBinderKey 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static SslExpandBinderKey(hSslProvider, hEarlyKey, phBinderKey, pParameterList, dwFlags) {
        result := DllCall("ncrypt.dll\SslExpandBinderKey", "ptr", hSslProvider, "ptr", hEarlyKey, "ptr", phBinderKey, "ptr", pParameterList, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} hSslProvider 
     * @param {Pointer} hResumptionMasterKey 
     * @param {Pointer<Byte>} pbTicketNonce 
     * @param {Integer} cbTicketNonce 
     * @param {Pointer<UIntPtr>} phPreSharedKey 
     * @param {Pointer<BCryptBufferDesc>} pParameterList 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static SslExpandPreSharedKey(hSslProvider, hResumptionMasterKey, pbTicketNonce, cbTicketNonce, phPreSharedKey, pParameterList, dwFlags) {
        result := DllCall("ncrypt.dll\SslExpandPreSharedKey", "ptr", hSslProvider, "ptr", hResumptionMasterKey, "ptr", pbTicketNonce, "uint", cbTicketNonce, "ptr", phPreSharedKey, "ptr", pParameterList, "uint", dwFlags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<PWSTR>} pszProviderName 
     * @param {Pointer<NCRYPT_SSL_FUNCTION_TABLE>} ppFunctionTable 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static GetSChannelInterface(pszProviderName, ppFunctionTable, dwFlags) {
        result := DllCall("ncrypt.dll\GetSChannelInterface", "ptr", pszProviderName, "ptr", ppFunctionTable, "uint", dwFlags, "int")
        return result
    }

    /**
     * Increments the reference count to a Secure Sockets Layer protocol (SSL) provider instance.
     * @param {Pointer} hSslProvider The handle to the SSL protocol provider instance.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                    | Description                                        |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------|
     * | <dl> <dt>**NTE\_INVALID\_HANDLE**</dt> <dt>0x80090026L</dt> </dl> | The *hSslProvider* handle is not valid.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/sslincrementproviderreferencecount
     */
    static SslIncrementProviderReferenceCount(hSslProvider) {
        result := DllCall("ncrypt.dll\SslIncrementProviderReferenceCount", "ptr", hSslProvider, "int")
        return result
    }

    /**
     * Decrements the references to the Secure Sockets Layer protocol (SSL) provider.
     * @param {Pointer} hSslProvider The handle of the SSL protocol provider instance.
     * @returns {Integer} If the function succeeds, it returns zero.
     * 
     * If the function fails, it returns a nonzero error value.
     * 
     * Possible return codes include, but are not limited to, the following.
     * 
     * 
     * 
     * | Return code/value                                                                                                                                                        | Description                                      |
     * |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------|
     * | <dl> <dt>**STATUS\_INVALID\_HANDLE** </dt> <dt>0xC0000008L</dt> </dl> | The SSL provider handle is not valid.<br/> |
     * @see https://learn.microsoft.com/windows/win32/SecCNG/ssldecrementproviderreferencecount
     */
    static SslDecrementProviderReferenceCount(hSslProvider) {
        result := DllCall("ncrypt.dll\SslDecrementProviderReferenceCount", "ptr", hSslProvider, "int")
        return result
    }

;@endregion Methods
}
