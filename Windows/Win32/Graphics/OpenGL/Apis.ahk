#Requires AutoHotkey v2.0.0 64-bit

/**
 * @namespace Windows.Win32.Graphics.OpenGL
 * @version v4.0.30319
 */
class OpenGL {

;@region Constants

    /**
     * @type {Integer (UInt32)}
     */
    static GL_VERSION_1_1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ACCUM => 256

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LOAD => 257

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RETURN => 258

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MULT => 259

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ADD => 260

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NEVER => 512

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LESS => 513

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EQUAL => 514

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LEQUAL => 515

    /**
     * @type {Integer (UInt32)}
     */
    static GL_GREATER => 516

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NOTEQUAL => 517

    /**
     * @type {Integer (UInt32)}
     */
    static GL_GEQUAL => 518

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ALWAYS => 519

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CURRENT_BIT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POINT_BIT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINE_BIT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POLYGON_BIT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POLYGON_STIPPLE_BIT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MODE_BIT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LIGHTING_BIT => 64

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FOG_BIT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DEPTH_BUFFER_BIT => 256

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ACCUM_BUFFER_BIT => 512

    /**
     * @type {Integer (UInt32)}
     */
    static GL_STENCIL_BUFFER_BIT => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static GL_VIEWPORT_BIT => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TRANSFORM_BIT => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ENABLE_BIT => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_BUFFER_BIT => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static GL_HINT_BIT => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EVAL_BIT => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LIST_BIT => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_BIT => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SCISSOR_BIT => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ALL_ATTRIB_BITS => 1048575

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POINTS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINE_LOOP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINE_STRIP => 3

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TRIANGLES => 4

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TRIANGLE_STRIP => 5

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TRIANGLE_FAN => 6

    /**
     * @type {Integer (UInt32)}
     */
    static GL_QUADS => 7

    /**
     * @type {Integer (UInt32)}
     */
    static GL_QUAD_STRIP => 8

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POLYGON => 9

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ZERO => 0

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ONE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SRC_COLOR => 768

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ONE_MINUS_SRC_COLOR => 769

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SRC_ALPHA => 770

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ONE_MINUS_SRC_ALPHA => 771

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DST_ALPHA => 772

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ONE_MINUS_DST_ALPHA => 773

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DST_COLOR => 774

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ONE_MINUS_DST_COLOR => 775

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SRC_ALPHA_SATURATE => 776

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TRUE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FALSE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CLIP_PLANE0 => 12288

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CLIP_PLANE1 => 12289

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CLIP_PLANE2 => 12290

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CLIP_PLANE3 => 12291

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CLIP_PLANE4 => 12292

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CLIP_PLANE5 => 12293

    /**
     * @type {Integer (UInt32)}
     */
    static GL_BYTE => 5120

    /**
     * @type {Integer (UInt32)}
     */
    static GL_UNSIGNED_BYTE => 5121

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SHORT => 5122

    /**
     * @type {Integer (UInt32)}
     */
    static GL_UNSIGNED_SHORT => 5123

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INT => 5124

    /**
     * @type {Integer (UInt32)}
     */
    static GL_UNSIGNED_INT => 5125

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FLOAT => 5126

    /**
     * @type {Integer (UInt32)}
     */
    static GL_2_BYTES => 5127

    /**
     * @type {Integer (UInt32)}
     */
    static GL_3_BYTES => 5128

    /**
     * @type {Integer (UInt32)}
     */
    static GL_4_BYTES => 5129

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DOUBLE => 5130

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FRONT_LEFT => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FRONT_RIGHT => 1025

    /**
     * @type {Integer (UInt32)}
     */
    static GL_BACK_LEFT => 1026

    /**
     * @type {Integer (UInt32)}
     */
    static GL_BACK_RIGHT => 1027

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FRONT => 1028

    /**
     * @type {Integer (UInt32)}
     */
    static GL_BACK => 1029

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LEFT => 1030

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RIGHT => 1031

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FRONT_AND_BACK => 1032

    /**
     * @type {Integer (UInt32)}
     */
    static GL_AUX0 => 1033

    /**
     * @type {Integer (UInt32)}
     */
    static GL_AUX1 => 1034

    /**
     * @type {Integer (UInt32)}
     */
    static GL_AUX2 => 1035

    /**
     * @type {Integer (UInt32)}
     */
    static GL_AUX3 => 1036

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NO_ERROR => 0

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INVALID_ENUM => 1280

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INVALID_VALUE => 1281

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INVALID_OPERATION => 1282

    /**
     * @type {Integer (UInt32)}
     */
    static GL_STACK_OVERFLOW => 1283

    /**
     * @type {Integer (UInt32)}
     */
    static GL_STACK_UNDERFLOW => 1284

    /**
     * @type {Integer (UInt32)}
     */
    static GL_OUT_OF_MEMORY => 1285

    /**
     * @type {Integer (UInt32)}
     */
    static GL_2D => 1536

    /**
     * @type {Integer (UInt32)}
     */
    static GL_3D => 1537

    /**
     * @type {Integer (UInt32)}
     */
    static GL_3D_COLOR => 1538

    /**
     * @type {Integer (UInt32)}
     */
    static GL_3D_COLOR_TEXTURE => 1539

    /**
     * @type {Integer (UInt32)}
     */
    static GL_4D_COLOR_TEXTURE => 1540

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PASS_THROUGH_TOKEN => 1792

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POINT_TOKEN => 1793

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINE_TOKEN => 1794

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POLYGON_TOKEN => 1795

    /**
     * @type {Integer (UInt32)}
     */
    static GL_BITMAP_TOKEN => 1796

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DRAW_PIXEL_TOKEN => 1797

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COPY_PIXEL_TOKEN => 1798

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINE_RESET_TOKEN => 1799

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EXP => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EXP2 => 2049

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CW => 2304

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CCW => 2305

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COEFF => 2560

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ORDER => 2561

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DOMAIN => 2562

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CURRENT_COLOR => 2816

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CURRENT_INDEX => 2817

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CURRENT_NORMAL => 2818

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CURRENT_TEXTURE_COORDS => 2819

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CURRENT_RASTER_COLOR => 2820

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CURRENT_RASTER_INDEX => 2821

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CURRENT_RASTER_TEXTURE_COORDS => 2822

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CURRENT_RASTER_POSITION => 2823

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CURRENT_RASTER_POSITION_VALID => 2824

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CURRENT_RASTER_DISTANCE => 2825

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POINT_SMOOTH => 2832

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POINT_SIZE => 2833

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POINT_SIZE_RANGE => 2834

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POINT_SIZE_GRANULARITY => 2835

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINE_SMOOTH => 2848

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINE_WIDTH => 2849

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINE_WIDTH_RANGE => 2850

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINE_WIDTH_GRANULARITY => 2851

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINE_STIPPLE => 2852

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINE_STIPPLE_PATTERN => 2853

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINE_STIPPLE_REPEAT => 2854

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LIST_MODE => 2864

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAX_LIST_NESTING => 2865

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LIST_BASE => 2866

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LIST_INDEX => 2867

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POLYGON_MODE => 2880

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POLYGON_SMOOTH => 2881

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POLYGON_STIPPLE => 2882

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EDGE_FLAG => 2883

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CULL_FACE => 2884

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CULL_FACE_MODE => 2885

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FRONT_FACE => 2886

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LIGHTING => 2896

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LIGHT_MODEL_LOCAL_VIEWER => 2897

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LIGHT_MODEL_TWO_SIDE => 2898

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LIGHT_MODEL_AMBIENT => 2899

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SHADE_MODEL => 2900

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_MATERIAL_FACE => 2901

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_MATERIAL_PARAMETER => 2902

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_MATERIAL => 2903

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FOG => 2912

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FOG_INDEX => 2913

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FOG_DENSITY => 2914

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FOG_START => 2915

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FOG_END => 2916

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FOG_MODE => 2917

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FOG_COLOR => 2918

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DEPTH_RANGE => 2928

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DEPTH_TEST => 2929

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DEPTH_WRITEMASK => 2930

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DEPTH_CLEAR_VALUE => 2931

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DEPTH_FUNC => 2932

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ACCUM_CLEAR_VALUE => 2944

    /**
     * @type {Integer (UInt32)}
     */
    static GL_STENCIL_TEST => 2960

    /**
     * @type {Integer (UInt32)}
     */
    static GL_STENCIL_CLEAR_VALUE => 2961

    /**
     * @type {Integer (UInt32)}
     */
    static GL_STENCIL_FUNC => 2962

    /**
     * @type {Integer (UInt32)}
     */
    static GL_STENCIL_VALUE_MASK => 2963

    /**
     * @type {Integer (UInt32)}
     */
    static GL_STENCIL_FAIL => 2964

    /**
     * @type {Integer (UInt32)}
     */
    static GL_STENCIL_PASS_DEPTH_FAIL => 2965

    /**
     * @type {Integer (UInt32)}
     */
    static GL_STENCIL_PASS_DEPTH_PASS => 2966

    /**
     * @type {Integer (UInt32)}
     */
    static GL_STENCIL_REF => 2967

    /**
     * @type {Integer (UInt32)}
     */
    static GL_STENCIL_WRITEMASK => 2968

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MATRIX_MODE => 2976

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NORMALIZE => 2977

    /**
     * @type {Integer (UInt32)}
     */
    static GL_VIEWPORT => 2978

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MODELVIEW_STACK_DEPTH => 2979

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PROJECTION_STACK_DEPTH => 2980

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_STACK_DEPTH => 2981

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MODELVIEW_MATRIX => 2982

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PROJECTION_MATRIX => 2983

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_MATRIX => 2984

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ATTRIB_STACK_DEPTH => 2992

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CLIENT_ATTRIB_STACK_DEPTH => 2993

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ALPHA_TEST => 3008

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ALPHA_TEST_FUNC => 3009

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ALPHA_TEST_REF => 3010

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DITHER => 3024

    /**
     * @type {Integer (UInt32)}
     */
    static GL_BLEND_DST => 3040

    /**
     * @type {Integer (UInt32)}
     */
    static GL_BLEND_SRC => 3041

    /**
     * @type {Integer (UInt32)}
     */
    static GL_BLEND => 3042

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LOGIC_OP_MODE => 3056

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INDEX_LOGIC_OP => 3057

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_LOGIC_OP => 3058

    /**
     * @type {Integer (UInt32)}
     */
    static GL_AUX_BUFFERS => 3072

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DRAW_BUFFER => 3073

    /**
     * @type {Integer (UInt32)}
     */
    static GL_READ_BUFFER => 3074

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SCISSOR_BOX => 3088

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SCISSOR_TEST => 3089

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INDEX_CLEAR_VALUE => 3104

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INDEX_WRITEMASK => 3105

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_CLEAR_VALUE => 3106

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_WRITEMASK => 3107

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INDEX_MODE => 3120

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RGBA_MODE => 3121

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DOUBLEBUFFER => 3122

    /**
     * @type {Integer (UInt32)}
     */
    static GL_STEREO => 3123

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RENDER_MODE => 3136

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PERSPECTIVE_CORRECTION_HINT => 3152

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POINT_SMOOTH_HINT => 3153

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINE_SMOOTH_HINT => 3154

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POLYGON_SMOOTH_HINT => 3155

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FOG_HINT => 3156

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_GEN_S => 3168

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_GEN_T => 3169

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_GEN_R => 3170

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_GEN_Q => 3171

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_I_TO_I => 3184

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_S_TO_S => 3185

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_I_TO_R => 3186

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_I_TO_G => 3187

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_I_TO_B => 3188

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_I_TO_A => 3189

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_R_TO_R => 3190

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_G_TO_G => 3191

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_B_TO_B => 3192

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_A_TO_A => 3193

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_I_TO_I_SIZE => 3248

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_S_TO_S_SIZE => 3249

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_I_TO_R_SIZE => 3250

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_I_TO_G_SIZE => 3251

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_I_TO_B_SIZE => 3252

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_I_TO_A_SIZE => 3253

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_R_TO_R_SIZE => 3254

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_G_TO_G_SIZE => 3255

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_B_TO_B_SIZE => 3256

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PIXEL_MAP_A_TO_A_SIZE => 3257

    /**
     * @type {Integer (UInt32)}
     */
    static GL_UNPACK_SWAP_BYTES => 3312

    /**
     * @type {Integer (UInt32)}
     */
    static GL_UNPACK_LSB_FIRST => 3313

    /**
     * @type {Integer (UInt32)}
     */
    static GL_UNPACK_ROW_LENGTH => 3314

    /**
     * @type {Integer (UInt32)}
     */
    static GL_UNPACK_SKIP_ROWS => 3315

    /**
     * @type {Integer (UInt32)}
     */
    static GL_UNPACK_SKIP_PIXELS => 3316

    /**
     * @type {Integer (UInt32)}
     */
    static GL_UNPACK_ALIGNMENT => 3317

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PACK_SWAP_BYTES => 3328

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PACK_LSB_FIRST => 3329

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PACK_ROW_LENGTH => 3330

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PACK_SKIP_ROWS => 3331

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PACK_SKIP_PIXELS => 3332

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PACK_ALIGNMENT => 3333

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP_COLOR => 3344

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP_STENCIL => 3345

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INDEX_SHIFT => 3346

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INDEX_OFFSET => 3347

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RED_SCALE => 3348

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RED_BIAS => 3349

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ZOOM_X => 3350

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ZOOM_Y => 3351

    /**
     * @type {Integer (UInt32)}
     */
    static GL_GREEN_SCALE => 3352

    /**
     * @type {Integer (UInt32)}
     */
    static GL_GREEN_BIAS => 3353

    /**
     * @type {Integer (UInt32)}
     */
    static GL_BLUE_SCALE => 3354

    /**
     * @type {Integer (UInt32)}
     */
    static GL_BLUE_BIAS => 3355

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ALPHA_SCALE => 3356

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ALPHA_BIAS => 3357

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DEPTH_SCALE => 3358

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DEPTH_BIAS => 3359

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAX_EVAL_ORDER => 3376

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAX_LIGHTS => 3377

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAX_CLIP_PLANES => 3378

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAX_TEXTURE_SIZE => 3379

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAX_PIXEL_MAP_TABLE => 3380

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAX_ATTRIB_STACK_DEPTH => 3381

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAX_MODELVIEW_STACK_DEPTH => 3382

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAX_NAME_STACK_DEPTH => 3383

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAX_PROJECTION_STACK_DEPTH => 3384

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAX_TEXTURE_STACK_DEPTH => 3385

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAX_VIEWPORT_DIMS => 3386

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAX_CLIENT_ATTRIB_STACK_DEPTH => 3387

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SUBPIXEL_BITS => 3408

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INDEX_BITS => 3409

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RED_BITS => 3410

    /**
     * @type {Integer (UInt32)}
     */
    static GL_GREEN_BITS => 3411

    /**
     * @type {Integer (UInt32)}
     */
    static GL_BLUE_BITS => 3412

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ALPHA_BITS => 3413

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DEPTH_BITS => 3414

    /**
     * @type {Integer (UInt32)}
     */
    static GL_STENCIL_BITS => 3415

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ACCUM_RED_BITS => 3416

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ACCUM_GREEN_BITS => 3417

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ACCUM_BLUE_BITS => 3418

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ACCUM_ALPHA_BITS => 3419

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NAME_STACK_DEPTH => 3440

    /**
     * @type {Integer (UInt32)}
     */
    static GL_AUTO_NORMAL => 3456

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP1_COLOR_4 => 3472

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP1_INDEX => 3473

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP1_NORMAL => 3474

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP1_TEXTURE_COORD_1 => 3475

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP1_TEXTURE_COORD_2 => 3476

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP1_TEXTURE_COORD_3 => 3477

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP1_TEXTURE_COORD_4 => 3478

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP1_VERTEX_3 => 3479

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP1_VERTEX_4 => 3480

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP2_COLOR_4 => 3504

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP2_INDEX => 3505

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP2_NORMAL => 3506

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP2_TEXTURE_COORD_1 => 3507

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP2_TEXTURE_COORD_2 => 3508

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP2_TEXTURE_COORD_3 => 3509

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP2_TEXTURE_COORD_4 => 3510

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP2_VERTEX_3 => 3511

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP2_VERTEX_4 => 3512

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP1_GRID_DOMAIN => 3536

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP1_GRID_SEGMENTS => 3537

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP2_GRID_DOMAIN => 3538

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAP2_GRID_SEGMENTS => 3539

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_1D => 3552

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_2D => 3553

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FEEDBACK_BUFFER_POINTER => 3568

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FEEDBACK_BUFFER_SIZE => 3569

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FEEDBACK_BUFFER_TYPE => 3570

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SELECTION_BUFFER_POINTER => 3571

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SELECTION_BUFFER_SIZE => 3572

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_WIDTH => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_HEIGHT => 4097

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_INTERNAL_FORMAT => 4099

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_BORDER_COLOR => 4100

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_BORDER => 4101

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DONT_CARE => 4352

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FASTEST => 4353

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NICEST => 4354

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LIGHT0 => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LIGHT1 => 16385

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LIGHT2 => 16386

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LIGHT3 => 16387

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LIGHT4 => 16388

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LIGHT5 => 16389

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LIGHT6 => 16390

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LIGHT7 => 16391

    /**
     * @type {Integer (UInt32)}
     */
    static GL_AMBIENT => 4608

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DIFFUSE => 4609

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SPECULAR => 4610

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POSITION => 4611

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SPOT_DIRECTION => 4612

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SPOT_EXPONENT => 4613

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SPOT_CUTOFF => 4614

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CONSTANT_ATTENUATION => 4615

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINEAR_ATTENUATION => 4616

    /**
     * @type {Integer (UInt32)}
     */
    static GL_QUADRATIC_ATTENUATION => 4617

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COMPILE => 4864

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COMPILE_AND_EXECUTE => 4865

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CLEAR => 5376

    /**
     * @type {Integer (UInt32)}
     */
    static GL_AND => 5377

    /**
     * @type {Integer (UInt32)}
     */
    static GL_AND_REVERSE => 5378

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COPY => 5379

    /**
     * @type {Integer (UInt32)}
     */
    static GL_AND_INVERTED => 5380

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NOOP => 5381

    /**
     * @type {Integer (UInt32)}
     */
    static GL_XOR => 5382

    /**
     * @type {Integer (UInt32)}
     */
    static GL_OR => 5383

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NOR => 5384

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EQUIV => 5385

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INVERT => 5386

    /**
     * @type {Integer (UInt32)}
     */
    static GL_OR_REVERSE => 5387

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COPY_INVERTED => 5388

    /**
     * @type {Integer (UInt32)}
     */
    static GL_OR_INVERTED => 5389

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NAND => 5390

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SET => 5391

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EMISSION => 5632

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SHININESS => 5633

    /**
     * @type {Integer (UInt32)}
     */
    static GL_AMBIENT_AND_DIFFUSE => 5634

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_INDEXES => 5635

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MODELVIEW => 5888

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PROJECTION => 5889

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE => 5890

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR => 6144

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DEPTH => 6145

    /**
     * @type {Integer (UInt32)}
     */
    static GL_STENCIL => 6146

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_INDEX => 6400

    /**
     * @type {Integer (UInt32)}
     */
    static GL_STENCIL_INDEX => 6401

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DEPTH_COMPONENT => 6402

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RED => 6403

    /**
     * @type {Integer (UInt32)}
     */
    static GL_GREEN => 6404

    /**
     * @type {Integer (UInt32)}
     */
    static GL_BLUE => 6405

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ALPHA => 6406

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RGB => 6407

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RGBA => 6408

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LUMINANCE => 6409

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LUMINANCE_ALPHA => 6410

    /**
     * @type {Integer (UInt32)}
     */
    static GL_BITMAP => 6656

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POINT => 6912

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINE => 6913

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FILL => 6914

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RENDER => 7168

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FEEDBACK => 7169

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SELECT => 7170

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FLAT => 7424

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SMOOTH => 7425

    /**
     * @type {Integer (UInt32)}
     */
    static GL_KEEP => 7680

    /**
     * @type {Integer (UInt32)}
     */
    static GL_REPLACE => 7681

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INCR => 7682

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DECR => 7683

    /**
     * @type {Integer (UInt32)}
     */
    static GL_VENDOR => 7936

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RENDERER => 7937

    /**
     * @type {Integer (UInt32)}
     */
    static GL_VERSION => 7938

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EXTENSIONS => 7939

    /**
     * @type {Integer (UInt32)}
     */
    static GL_S => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static GL_T => 8193

    /**
     * @type {Integer (UInt32)}
     */
    static GL_R => 8194

    /**
     * @type {Integer (UInt32)}
     */
    static GL_Q => 8195

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MODULATE => 8448

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DECAL => 8449

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_ENV_MODE => 8704

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_ENV_COLOR => 8705

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_ENV => 8960

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EYE_LINEAR => 9216

    /**
     * @type {Integer (UInt32)}
     */
    static GL_OBJECT_LINEAR => 9217

    /**
     * @type {Integer (UInt32)}
     */
    static GL_SPHERE_MAP => 9218

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_GEN_MODE => 9472

    /**
     * @type {Integer (UInt32)}
     */
    static GL_OBJECT_PLANE => 9473

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EYE_PLANE => 9474

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NEAREST => 9728

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINEAR => 9729

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NEAREST_MIPMAP_NEAREST => 9984

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINEAR_MIPMAP_NEAREST => 9985

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NEAREST_MIPMAP_LINEAR => 9986

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LINEAR_MIPMAP_LINEAR => 9987

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_MAG_FILTER => 10240

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_MIN_FILTER => 10241

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_WRAP_S => 10242

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_WRAP_T => 10243

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CLAMP => 10496

    /**
     * @type {Integer (UInt32)}
     */
    static GL_REPEAT => 10497

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CLIENT_PIXEL_STORE_BIT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CLIENT_VERTEX_ARRAY_BIT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static GL_CLIENT_ALL_ATTRIB_BITS => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POLYGON_OFFSET_FACTOR => 32824

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POLYGON_OFFSET_UNITS => 10752

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POLYGON_OFFSET_POINT => 10753

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POLYGON_OFFSET_LINE => 10754

    /**
     * @type {Integer (UInt32)}
     */
    static GL_POLYGON_OFFSET_FILL => 32823

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ALPHA4 => 32827

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ALPHA8 => 32828

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ALPHA12 => 32829

    /**
     * @type {Integer (UInt32)}
     */
    static GL_ALPHA16 => 32830

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LUMINANCE4 => 32831

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LUMINANCE8 => 32832

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LUMINANCE12 => 32833

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LUMINANCE16 => 32834

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LUMINANCE4_ALPHA4 => 32835

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LUMINANCE6_ALPHA2 => 32836

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LUMINANCE8_ALPHA8 => 32837

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LUMINANCE12_ALPHA4 => 32838

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LUMINANCE12_ALPHA12 => 32839

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LUMINANCE16_ALPHA16 => 32840

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INTENSITY => 32841

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INTENSITY4 => 32842

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INTENSITY8 => 32843

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INTENSITY12 => 32844

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INTENSITY16 => 32845

    /**
     * @type {Integer (UInt32)}
     */
    static GL_R3_G3_B2 => 10768

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RGB4 => 32847

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RGB5 => 32848

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RGB8 => 32849

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RGB10 => 32850

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RGB12 => 32851

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RGB16 => 32852

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RGBA2 => 32853

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RGBA4 => 32854

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RGB5_A1 => 32855

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RGBA8 => 32856

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RGB10_A2 => 32857

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RGBA12 => 32858

    /**
     * @type {Integer (UInt32)}
     */
    static GL_RGBA16 => 32859

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_RED_SIZE => 32860

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_GREEN_SIZE => 32861

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_BLUE_SIZE => 32862

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_ALPHA_SIZE => 32863

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_LUMINANCE_SIZE => 32864

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_INTENSITY_SIZE => 32865

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PROXY_TEXTURE_1D => 32867

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PROXY_TEXTURE_2D => 32868

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_PRIORITY => 32870

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_RESIDENT => 32871

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_BINDING_1D => 32872

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_BINDING_2D => 32873

    /**
     * @type {Integer (UInt32)}
     */
    static GL_VERTEX_ARRAY => 32884

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NORMAL_ARRAY => 32885

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_ARRAY => 32886

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INDEX_ARRAY => 32887

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_COORD_ARRAY => 32888

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EDGE_FLAG_ARRAY => 32889

    /**
     * @type {Integer (UInt32)}
     */
    static GL_VERTEX_ARRAY_SIZE => 32890

    /**
     * @type {Integer (UInt32)}
     */
    static GL_VERTEX_ARRAY_TYPE => 32891

    /**
     * @type {Integer (UInt32)}
     */
    static GL_VERTEX_ARRAY_STRIDE => 32892

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NORMAL_ARRAY_TYPE => 32894

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NORMAL_ARRAY_STRIDE => 32895

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_ARRAY_SIZE => 32897

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_ARRAY_TYPE => 32898

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_ARRAY_STRIDE => 32899

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INDEX_ARRAY_TYPE => 32901

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INDEX_ARRAY_STRIDE => 32902

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_COORD_ARRAY_SIZE => 32904

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_COORD_ARRAY_TYPE => 32905

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_COORD_ARRAY_STRIDE => 32906

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EDGE_FLAG_ARRAY_STRIDE => 32908

    /**
     * @type {Integer (UInt32)}
     */
    static GL_VERTEX_ARRAY_POINTER => 32910

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NORMAL_ARRAY_POINTER => 32911

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_ARRAY_POINTER => 32912

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INDEX_ARRAY_POINTER => 32913

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_COORD_ARRAY_POINTER => 32914

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EDGE_FLAG_ARRAY_POINTER => 32915

    /**
     * @type {Integer (UInt32)}
     */
    static GL_V2F => 10784

    /**
     * @type {Integer (UInt32)}
     */
    static GL_V3F => 10785

    /**
     * @type {Integer (UInt32)}
     */
    static GL_C4UB_V2F => 10786

    /**
     * @type {Integer (UInt32)}
     */
    static GL_C4UB_V3F => 10787

    /**
     * @type {Integer (UInt32)}
     */
    static GL_C3F_V3F => 10788

    /**
     * @type {Integer (UInt32)}
     */
    static GL_N3F_V3F => 10789

    /**
     * @type {Integer (UInt32)}
     */
    static GL_C4F_N3F_V3F => 10790

    /**
     * @type {Integer (UInt32)}
     */
    static GL_T2F_V3F => 10791

    /**
     * @type {Integer (UInt32)}
     */
    static GL_T4F_V4F => 10792

    /**
     * @type {Integer (UInt32)}
     */
    static GL_T2F_C4UB_V3F => 10793

    /**
     * @type {Integer (UInt32)}
     */
    static GL_T2F_C3F_V3F => 10794

    /**
     * @type {Integer (UInt32)}
     */
    static GL_T2F_N3F_V3F => 10795

    /**
     * @type {Integer (UInt32)}
     */
    static GL_T2F_C4F_N3F_V3F => 10796

    /**
     * @type {Integer (UInt32)}
     */
    static GL_T4F_C4F_N3F_V4F => 10797

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EXT_vertex_array => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EXT_bgra => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EXT_paletted_texture => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GL_WIN_swap_hint => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GL_WIN_draw_range_elements => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GL_VERTEX_ARRAY_EXT => 32884

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NORMAL_ARRAY_EXT => 32885

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_ARRAY_EXT => 32886

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INDEX_ARRAY_EXT => 32887

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_COORD_ARRAY_EXT => 32888

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EDGE_FLAG_ARRAY_EXT => 32889

    /**
     * @type {Integer (UInt32)}
     */
    static GL_VERTEX_ARRAY_SIZE_EXT => 32890

    /**
     * @type {Integer (UInt32)}
     */
    static GL_VERTEX_ARRAY_TYPE_EXT => 32891

    /**
     * @type {Integer (UInt32)}
     */
    static GL_VERTEX_ARRAY_STRIDE_EXT => 32892

    /**
     * @type {Integer (UInt32)}
     */
    static GL_VERTEX_ARRAY_COUNT_EXT => 32893

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NORMAL_ARRAY_TYPE_EXT => 32894

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NORMAL_ARRAY_STRIDE_EXT => 32895

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NORMAL_ARRAY_COUNT_EXT => 32896

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_ARRAY_SIZE_EXT => 32897

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_ARRAY_TYPE_EXT => 32898

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_ARRAY_STRIDE_EXT => 32899

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_ARRAY_COUNT_EXT => 32900

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INDEX_ARRAY_TYPE_EXT => 32901

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INDEX_ARRAY_STRIDE_EXT => 32902

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INDEX_ARRAY_COUNT_EXT => 32903

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_COORD_ARRAY_SIZE_EXT => 32904

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_COORD_ARRAY_TYPE_EXT => 32905

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_COORD_ARRAY_STRIDE_EXT => 32906

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_COORD_ARRAY_COUNT_EXT => 32907

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EDGE_FLAG_ARRAY_STRIDE_EXT => 32908

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EDGE_FLAG_ARRAY_COUNT_EXT => 32909

    /**
     * @type {Integer (UInt32)}
     */
    static GL_VERTEX_ARRAY_POINTER_EXT => 32910

    /**
     * @type {Integer (UInt32)}
     */
    static GL_NORMAL_ARRAY_POINTER_EXT => 32911

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_ARRAY_POINTER_EXT => 32912

    /**
     * @type {Integer (UInt32)}
     */
    static GL_INDEX_ARRAY_POINTER_EXT => 32913

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_COORD_ARRAY_POINTER_EXT => 32914

    /**
     * @type {Integer (UInt32)}
     */
    static GL_EDGE_FLAG_ARRAY_POINTER_EXT => 32915

    /**
     * @type {Integer (UInt32)}
     */
    static GL_DOUBLE_EXT => 5130

    /**
     * @type {Integer (UInt32)}
     */
    static GL_BGR_EXT => 32992

    /**
     * @type {Integer (UInt32)}
     */
    static GL_BGRA_EXT => 32993

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_TABLE_FORMAT_EXT => 32984

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_TABLE_WIDTH_EXT => 32985

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_TABLE_RED_SIZE_EXT => 32986

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_TABLE_GREEN_SIZE_EXT => 32987

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_TABLE_BLUE_SIZE_EXT => 32988

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_TABLE_ALPHA_SIZE_EXT => 32989

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_TABLE_LUMINANCE_SIZE_EXT => 32990

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_TABLE_INTENSITY_SIZE_EXT => 32991

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_INDEX1_EXT => 32994

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_INDEX2_EXT => 32995

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_INDEX4_EXT => 32996

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_INDEX8_EXT => 32997

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_INDEX12_EXT => 32998

    /**
     * @type {Integer (UInt32)}
     */
    static GL_COLOR_INDEX16_EXT => 32999

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAX_ELEMENTS_VERTICES_WIN => 33000

    /**
     * @type {Integer (UInt32)}
     */
    static GL_MAX_ELEMENTS_INDICES_WIN => 33001

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PHONG_WIN => 33002

    /**
     * @type {Integer (UInt32)}
     */
    static GL_PHONG_HINT_WIN => 33003

    /**
     * @type {Integer (UInt32)}
     */
    static GL_FOG_SPECULAR_TEXTURE_WIN => 33004

    /**
     * @type {Integer (UInt32)}
     */
    static GL_LOGIC_OP => 3057

    /**
     * @type {Integer (UInt32)}
     */
    static GL_TEXTURE_COMPONENTS => 4099

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_VERSION_1_1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_VERSION_1_2 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_INVALID_ENUM => 100900

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_INVALID_VALUE => 100901

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_OUT_OF_MEMORY => 100902

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_INCOMPATIBLE_GL_VERSION => 100903

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_VERSION => 100800

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_EXTENSIONS => 100801

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TRUE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_FALSE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_SMOOTH => 100000

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_FLAT => 100001

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NONE => 100002

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_POINT => 100010

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_LINE => 100011

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_FILL => 100012

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_SILHOUETTE => 100013

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_OUTSIDE => 100020

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_INSIDE => 100021

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_WINDING_RULE => 100140

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_BOUNDARY_ONLY => 100141

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_TOLERANCE => 100142

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_WINDING_ODD => 100130

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_WINDING_NONZERO => 100131

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_WINDING_POSITIVE => 100132

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_WINDING_NEGATIVE => 100133

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_WINDING_ABS_GEQ_TWO => 100134

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_BEGIN => 100100

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_VERTEX => 100101

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_END => 100102

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_ERROR => 100103

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_EDGE_FLAG => 100104

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_COMBINE => 100105

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_BEGIN_DATA => 100106

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_VERTEX_DATA => 100107

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_END_DATA => 100108

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_ERROR_DATA => 100109

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_EDGE_FLAG_DATA => 100110

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_COMBINE_DATA => 100111

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_ERROR1 => 100151

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_ERROR2 => 100152

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_ERROR3 => 100153

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_ERROR4 => 100154

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_ERROR5 => 100155

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_ERROR6 => 100156

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_ERROR7 => 100157

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_ERROR8 => 100158

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_MISSING_BEGIN_POLYGON => 100151

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_MISSING_BEGIN_CONTOUR => 100152

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_MISSING_END_POLYGON => 100153

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_MISSING_END_CONTOUR => 100154

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_COORD_TOO_LARGE => 100155

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_TESS_NEED_COMBINE_CALLBACK => 100156

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_AUTO_LOAD_MATRIX => 100200

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_CULLING => 100201

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_SAMPLING_TOLERANCE => 100203

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_DISPLAY_MODE => 100204

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_PARAMETRIC_TOLERANCE => 100202

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_SAMPLING_METHOD => 100205

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_U_STEP => 100206

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_V_STEP => 100207

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_PATH_LENGTH => 100215

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_PARAMETRIC_ERROR => 100216

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_DOMAIN_DISTANCE => 100217

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_MAP1_TRIM_2 => 100210

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_MAP1_TRIM_3 => 100211

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_OUTLINE_POLYGON => 100240

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_OUTLINE_PATCH => 100241

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR1 => 100251

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR2 => 100252

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR3 => 100253

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR4 => 100254

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR5 => 100255

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR6 => 100256

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR7 => 100257

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR8 => 100258

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR9 => 100259

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR10 => 100260

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR11 => 100261

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR12 => 100262

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR13 => 100263

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR14 => 100264

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR15 => 100265

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR16 => 100266

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR17 => 100267

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR18 => 100268

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR19 => 100269

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR20 => 100270

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR21 => 100271

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR22 => 100272

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR23 => 100273

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR24 => 100274

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR25 => 100275

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR26 => 100276

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR27 => 100277

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR28 => 100278

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR29 => 100279

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR30 => 100280

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR31 => 100281

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR32 => 100282

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR33 => 100283

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR34 => 100284

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR35 => 100285

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR36 => 100286

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_NURBS_ERROR37 => 100287

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_CW => 100120

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_CCW => 100121

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_INTERIOR => 100122

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_EXTERIOR => 100123

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_UNKNOWN => 100124

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_BEGIN => 100100

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_VERTEX => 100101

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_END => 100102

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_ERROR => 100103

    /**
     * @type {Integer (UInt32)}
     */
    static GLU_EDGE_FLAG => 100104
;@endregion Constants

;@region Methods
    /**
     * The ChoosePixelFormat function attempts to match an appropriate pixel format supported by a device context to a given pixel format specification.
     * @remarks
     * You must ensure that the pixel format matched by the <b>ChoosePixelFormat</b> function satisfies your requirements. For example, if you request a pixel format with a 24-bit RGB color buffer but the device context offers only 8-bit RGB color buffers, the function returns a pixel format with an 8-bit RGB color buffer.
     * @param {Pointer<HDC>} hdc Specifies the device context that the function examines to determine the best match for the pixel format descriptor pointed to by <i>ppfd</i>.
     * @param {Pointer<PIXELFORMATDESCRIPTOR>} ppfd Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-pixelformatdescriptor">PIXELFORMATDESCRIPTOR</a> structure that specifies the requested pixel format. In this context, the members of the <b>PIXELFORMATDESCRIPTOR</b> structure that <i>ppfd</i> points to are used as follows:
     * 
     * <table>
     * <tr>
     * <td><i>nSize</i></td>
     * <td>Specifies the size of the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-pixelformatdescriptor">PIXELFORMATDESCRIPTOR</a> data structure. Set this member to <c>sizeof(PIXELFORMATDESCRIPTOR)</c>.</td>
     * </tr>
     * <tr>
     * <td><i>nVersion</i></td>
     * <td>Specifies the version number of the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-pixelformatdescriptor">PIXELFORMATDESCRIPTOR</a> data structure. Set this member to 1.</td>
     * </tr>
     * <tr>
     * <td><i>dwFlags</i></td>
     * <td>A set of bit flags that specify properties of the pixel buffer. You can combine the following bit flag constants by using bitwise-OR. If any of the following flags are set, the <b>ChoosePixelFormat</b> function attempts to match pixel formats that also have that flag or flags set. Otherwise, <b>ChoosePixelFormat</b> ignores that flag in the pixel formats: <b>PFD_DRAW_TO_WINDOW</b>, <b>PFD_DRAW_TO_BITMAP</b>, <b>PFD_SUPPORT_GDI</b>, <b>PFD_SUPPORT_OPENGL</b> If any of the following flags are set, <b>ChoosePixelFormat</b> attempts to match pixel formats that also have that flag or flags set. Otherwise, it attempts to match pixel formats without that flag set: <b>PFD_DOUBLEBUFFER PFD_STEREO</b> If the following flag is set, the function ignores the <b>PFD_DOUBLEBUFFER</b> flag in the pixel formats: <b>PFD_DOUBLEBUFFER_DONTCARE</b> If the following flag is set, the function ignores the <b>PFD_STEREO</b> flag in the pixel formats: <b>PFD_STEREO_DONTCARE</b></td>
     * </tr>
     * <tr>
     * <td><i>iPixelType</i></td>
     * <td>Specifies the type of pixel format for the function to consider: <b>PFD_TYPE_RGBA</b>, <b>PFD_TYPE_COLORINDEX</b></td>
     * </tr>
     * <tr>
     * <td><i>cColorBits</i></td>
     * <td>Zero or greater.</td>
     * </tr>
     * <tr>
     * <td><i>cRedBits</i></td>
     * <td>Not used.</td>
     * </tr>
     * <tr>
     * <td><i>cRedShift</i></td>
     * <td>Not used.</td>
     * </tr>
     * <tr>
     * <td><i>cGreenBits</i></td>
     * <td>Not used.</td>
     * </tr>
     * <tr>
     * <td><i>cGreenShift</i></td>
     * <td>Not used.</td>
     * </tr>
     * <tr>
     * <td><i>cBlueBits</i></td>
     * <td>Not used.</td>
     * </tr>
     * <tr>
     * <td><i>cBlueShift</i></td>
     * <td>Not used.</td>
     * </tr>
     * <tr>
     * <td><i>cAlphaBits</i></td>
     * <td>Zero or greater.</td>
     * </tr>
     * <tr>
     * <td><i>cAlphaShift</i></td>
     * <td>Not used.</td>
     * </tr>
     * <tr>
     * <td><i>cAccumBits</i></td>
     * <td>Zero or greater.</td>
     * </tr>
     * <tr>
     * <td><i>cAccumRedBits</i></td>
     * <td>Not used.</td>
     * </tr>
     * <tr>
     * <td><i>cAccumGreenBits</i></td>
     * <td>Not used.</td>
     * </tr>
     * <tr>
     * <td><i>cAccumBlueBits</i></td>
     * <td>Not used.</td>
     * </tr>
     * <tr>
     * <td><i>cAccumAlphaBits</i></td>
     * <td>Not used.</td>
     * </tr>
     * <tr>
     * <td><i>cDepthBits</i></td>
     * <td>Zero or greater.</td>
     * </tr>
     * <tr>
     * <td><i>cStencilBits</i></td>
     * <td>Zero or greater.</td>
     * </tr>
     * <tr>
     * <td><i>cAuxBuffers</i></td>
     * <td>Zero or greater.</td>
     * </tr>
     * <tr>
     * <td><i>iLayerType</i></td>
     * <td>Specifies one of the following layer type values: <b>PFD_MAIN_PLANE</b>, <b>PFD_OVERLAY_PLANE</b>, <b>PFD_UNDERLAY_PLANE</b></td>
     * </tr>
     * <tr>
     * <td><i>bReserved</i></td>
     * <td>Not used.</td>
     * </tr>
     * <tr>
     * <td><i>dwLayerMask</i></td>
     * <td>Not used.</td>
     * </tr>
     * <tr>
     * <td><i>dwVisibleMask</i></td>
     * <td>Not used.</td>
     * </tr>
     * <tr>
     * <td><i>dwDamageMask</i></td>
     * <td>Not used.</td>
     * </tr>
     * </table>
     *  
     * 
     * <i></i>
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-choosepixelformat
     * @since windows5.0
     */
    static ChoosePixelFormat(hdc, ppfd) {
        A_LastError := 0

        DllCall("GDI32.dll\ChoosePixelFormat", "ptr", hdc, "ptr", ppfd)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The DescribePixelFormat function obtains information about the pixel format identified by iPixelFormat of the device associated with hdc. The function sets the members of the PIXELFORMATDESCRIPTOR structure pointed to by ppfd with that pixel format data.
     * @param {Pointer<HDC>} hdc Specifies the device context.
     * @param {Integer} iPixelFormat Index that specifies the pixel format. The pixel formats that a device context supports are identified by positive one-based integer indexes.
     * @param {Integer} nBytes The size, in bytes, of the structure pointed to by <i>ppfd</i>. The <b>DescribePixelFormat</b> function stores no more than <i>nBytes</i> bytes of data to that structure. Set this value to <b>sizeof</b>(<b>PIXELFORMATDESCRIPTOR</b>).
     * @param {Pointer<PIXELFORMATDESCRIPTOR>} ppfd Pointer to a <b>PIXELFORMATDESCRIPTOR</b> structure whose members the function sets with pixel format data. The function stores the number of bytes copied to the structure in the structure's <b>nSize</b> member. If, upon entry, <i>ppfd</i> is <b>NULL</b>, the function writes no data to the structure. This is useful when you only want to obtain the maximum pixel format index of a device context.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-describepixelformat
     * @since windows5.0
     */
    static DescribePixelFormat(hdc, iPixelFormat, nBytes, ppfd) {
        A_LastError := 0

        DllCall("GDI32.dll\DescribePixelFormat", "ptr", hdc, "int", iPixelFormat, "uint", nBytes, "ptr", ppfd)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The GetPixelFormat function obtains the index of the currently selected pixel format of the specified device context.
     * @param {Pointer<HDC>} hdc Specifies the device context of the currently selected pixel format index returned by the function.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-getpixelformat
     * @since windows5.0
     */
    static GetPixelFormat(hdc) {
        A_LastError := 0

        DllCall("GDI32.dll\GetPixelFormat", "ptr", hdc)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetPixelFormat function sets the pixel format of the specified device context to the format specified by the iPixelFormat index.
     * @remarks
     * If <i>hdc</i> references a window, calling the <b>SetPixelFormat</b> function also changes the pixel format of the window. Setting the pixel format of a window more than once can lead to significant complications for the Window Manager and for multithread applications, so it is not allowed. An application can only set the pixel format of a window one time. Once a window's pixel format is set, it cannot be changed.
     * 
     * You should select a pixel format in the device context before calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-wglcreatecontext">wglCreateContext</a> function. The <b>wglCreateContext</b> function creates a rendering context for drawing on the device in the selected pixel format of the device context.
     * 
     * An OpenGL window has its own pixel format. Because of this, only device contexts retrieved for the client area of an OpenGL window are allowed to draw into the window. As a result, an OpenGL window should be created with the WS_CLIPCHILDREN and WS_CLIPSIBLINGS styles. Additionally, the window class attribute should not include the CS_PARENTDC style.
     * @param {Pointer<HDC>} hdc Specifies the device context whose pixel format the function attempts to set.
     * @param {Integer} format Index that identifies the pixel format to set. The various pixel formats supported by a device context are identified by one-based indexes.
     * @param {Pointer<PIXELFORMATDESCRIPTOR>} ppfd Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-pixelformatdescriptor">PIXELFORMATDESCRIPTOR</a> structure that contains the logical pixel format specification. The system's metafile component uses this structure to record the logical pixel format specification. The structure has no other effect upon the behavior of the <b>SetPixelFormat</b> function.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-setpixelformat
     * @since windows5.0
     */
    static SetPixelFormat(hdc, format, ppfd) {
        A_LastError := 0

        result := DllCall("GDI32.dll\SetPixelFormat", "ptr", hdc, "int", format, "ptr", ppfd, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The GetEnhMetaFilePixelFormat function retrieves pixel format information for an enhanced metafile.
     * @remarks
     * When an enhanced metafile specifies a pixel format in its <b>ENHMETAHEADER</b> structure and the pixel format fits in the buffer, the pixel format information is copied into <i>ppfd</i>. When <i>cbBuffer</i> is too small to contain the pixel format of the metafile, the pixel format is not copied to the buffer. In either case, the function returns the size of the metafile's pixel format.
     * 
     * For information on metafile recording and other operations, see Enhanced Metafile Operations.
     * @param {Pointer<HENHMETAFILE>} hemf Identifies the enhanced metafile.
     * @param {Integer} cbBuffer Specifies the size, in bytes, of the buffer into which the pixel format information is copied.
     * @param {Pointer<PIXELFORMATDESCRIPTOR>} ppfd Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-pixelformatdescriptor">PIXELFORMATDESCRIPTOR</a> structure that contains the logical pixel format specification. The metafile uses this structure to record the logical pixel format specification.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-getenhmetafilepixelformat
     * @since windows5.0
     */
    static GetEnhMetaFilePixelFormat(hemf, cbBuffer, ppfd) {
        A_LastError := 0

        DllCall("GDI32.dll\GetEnhMetaFilePixelFormat", "ptr", hemf, "uint", cbBuffer, "ptr", ppfd)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The wglCopyContext function copies selected groups of rendering states from one OpenGL rendering context to another.
     * @remarks
     * Using the <b>wglCopyContext</b> function, you can synchronize the rendering state of two rendering contexts. You can only copy the rendering state between two rendering contexts within the same process. The rendering contexts must be from the same OpenGL implementation. For example, you can always copy a rendering state between two rendering contexts with identical pixel format in the same process.
     * 
     * You can copy the same state information available only with the <b>glPushAttrib</b> function. You cannot copy some state information, such as pixel pack/unpack state, render mode state, select state, and feedback state. When you call <b>wglCopyContext</b>, make sure that the destination rendering context, <i>hglrcDst</i>, is not current to any thread.
     * @param {Pointer<HGLRC>} param0 
     * @param {Pointer<HGLRC>} param1 
     * @param {Integer} param2 
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglcopycontext
     * @since windows5.0
     */
    static wglCopyContext(param0, param1, param2) {
        A_LastError := 0

        result := DllCall("OPENGL32.dll\wglCopyContext", "ptr", param0, "ptr", param1, "uint", param2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The wglCreateContext function creates a new OpenGL rendering context, which is suitable for drawing on the device referenced by hdc. The rendering context has the same pixel format as the device context.
     * @remarks
     * A rendering context is not the same as a device context. Set the pixel format of the device context before creating a rendering context. For more information on setting the device context's pixel format, see the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-setpixelformat">SetPixelFormat</a> function.
     * 
     * To use OpenGL, you create a rendering context, select it as a thread's current rendering context, and then call OpenGL functions. When you are finished with the rendering context, you dispose of it by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-wgldeletecontext">wglDeleteContext</a> function.
     * 
     * The following code example shows <b>wglCreateContext</b> usage.
     * 
     * 
     * ``` syntax
     * HDC    hdc; 
     * HGLRC  hglrc; 
     *  
     * // create a rendering context  
     * hglrc = wglCreateContext (hdc); 
     *  
     * // make it the calling thread's current rendering context 
     * wglMakeCurrent (hdc, hglrc);
     *  
     * // call OpenGL APIs as desired ... 
     *  
     * // when the rendering context is no longer needed ...   
     *  
     * // make the rendering context not current  
     * wglMakeCurrent (NULL, NULL) ; 
     *  
     * // delete the rendering context  
     * wglDeleteContext (hglrc);
     * ```
     * @param {Pointer<HDC>} param0 
     * @returns {Pointer<HGLRC>} If the function succeeds, the return value is a valid handle to an OpenGL rendering context.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglcreatecontext
     * @since windows5.0
     */
    static wglCreateContext(param0) {
        A_LastError := 0

        result := DllCall("OPENGL32.dll\wglCreateContext", "ptr", param0, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The wglCreateLayerContext function creates a new OpenGL rendering context for drawing to a specified layer plane on a device context.
     * @remarks
     * A rendering context is a port through which all OpenGL commands pass. Every thread that makes OpenGL calls must have one current, active rendering context. A rendering context is not the same as a device context; a rendering context contains information specific to OpenGL, while a device context contains information specific to GDI.
     * 
     * Before you create a rendering context, set the pixel format of the device context with the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-setpixelformat">SetPixelFormat</a> function. You can use a rendering context in a specified layer plane of a window with identical pixel formats only.
     * 
     * With OpenGL applications that use multiple threads, you create a rendering context, select it as the current rendering context of a thread, and make OpenGL calls for the specified thread. When you are finished with the rendering context of the thread, call the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-wgldeletecontext">wglDeleteContext</a> function.
     * @param {Pointer<HDC>} param0 
     * @param {Integer} param1 
     * @returns {Pointer<HGLRC>} If the function succeeds, the return value is a handle to an OpenGL rendering context.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglcreatelayercontext
     * @since windows5.0
     */
    static wglCreateLayerContext(param0, param1) {
        A_LastError := 0

        result := DllCall("OPENGL32.dll\wglCreateLayerContext", "ptr", param0, "int", param1, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The wglDeleteContext function deletes a specified OpenGL rendering context.
     * @remarks
     * It is an error to delete an OpenGL rendering context that is the current context of another thread. However, if a rendering context is the calling thread's current context, the <b>wglDeleteContext</b> function changes the rendering context to being not current before deleting it.
     * 
     * The <b>wglDeleteContext</b> function does not delete the device context associated with the OpenGL rendering context when you call the <b>wglMakeCurrent</b> function. After calling <b>wglDeleteContext</b>, you must call <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deletedc">DeleteDC</a> to delete the associated device context.
     * @param {Pointer<HGLRC>} param0 
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wgldeletecontext
     * @since windows5.0
     */
    static wglDeleteContext(param0) {
        A_LastError := 0

        result := DllCall("OPENGL32.dll\wglDeleteContext", "ptr", param0, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The wglGetCurrentContext function obtains a handle to the current OpenGL rendering context of the calling thread.
     * @remarks
     * The current OpenGL rendering context of a thread is associated with a device context by means of the <b>wglMakeCurrent</b> function. You can use the <b>wglGetCurrentDC</b> function to obtain a handle to the device context associated with the current OpenGL rendering context.
     * @returns {Pointer<HGLRC>} If the calling thread has a current OpenGL rendering context, <b>wglGetCurrentContext</b> returns a handle to that rendering context. Otherwise, the return value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglgetcurrentcontext
     * @since windows5.0
     */
    static wglGetCurrentContext() {
        result := DllCall("OPENGL32.dll\wglGetCurrentContext", "ptr")
        return result
    }

    /**
     * The wglGetCurrentDC function obtains a handle to the device context that is associated with the current OpenGL rendering context of the calling thread.
     * @remarks
     * You associate a device context with an OpenGL rendering context when it calls the <b>wglMakeCurrent</b> function. You can use the <b>wglGetCurrentContext</b> function to obtain a handle to the calling thread's current OpenGL rendering context.
     * @returns {Pointer<HDC>} If the calling thread has a current OpenGL rendering context, the function returns a handle to the device context associated with that rendering context by means of the <b>wglMakeCurrent</b> function. Otherwise, the return value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglgetcurrentdc
     * @since windows5.0
     */
    static wglGetCurrentDC() {
        result := DllCall("OPENGL32.dll\wglGetCurrentDC", "ptr")
        return result
    }

    /**
     * The wglGetProcAddress function returns the address of an OpenGL extension function for use with the current OpenGL rendering context.
     * @remarks
     * The OpenGL library supports multiple implementations of its functions. Extension functions supported in one rendering context are not necessarily available in a separate rendering context. Thus, for a given rendering context in an application, use the function addresses returned by the <b>wglGetProcAddress</b> function only.
     * 
     * The spelling and the case of the extension function pointed to by <i>lpszProc</i> must be identical to that of a function supported and implemented by OpenGL. Because extension functions are not exported by OpenGL, you must use <b>wglGetProcAddress</b> to get the addresses of vendor-specific extension functions.
     * 
     * The extension function addresses are unique for each pixel format. All rendering contexts of a given pixel format share the same extension function addresses.
     * @param {Pointer<PSTR>} param0 
     * @returns {Pointer<PROC>} When the function succeeds, the return value is the address of the extension function.
     * 
     * When no current rendering context exists or the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglgetprocaddress
     * @since windows5.0
     */
    static wglGetProcAddress(param0) {
        A_LastError := 0

        result := DllCall("OPENGL32.dll\wglGetProcAddress", "ptr", param0, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The wglMakeCurrent function makes a specified OpenGL rendering context the calling thread's current rendering context.
     * @remarks
     * The <i>hdc</i> parameter must refer to a drawing surface supported by OpenGL. It need not be the same <i>hdc</i> that was passed to <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-wglcreatecontext">wglCreateContext</a> when <i>hglrc</i> was created, but it must be on the same device and have the same pixel format. GDI transformation and clipping in <i>hdc</i> are not supported by the rendering context. The current rendering context uses the <i>hdc</i> device context until the rendering context is no longer current.
     * 
     * Before switching to the new rendering context, OpenGL flushes any previous rendering context that was current to the calling thread.
     * 
     * A thread can have one current rendering context. A process can have multiple rendering contexts by means of multithreading. A thread must set a current rendering context before calling any OpenGL functions. Otherwise, all OpenGL calls are ignored.
     * 
     * A rendering context can be current to only one thread at a time. You cannot make a rendering context current to multiple threads.
     * 
     * An application can perform multithread drawing by making different rendering contexts current to different threads, supplying each thread with its own rendering context and device context.
     * 
     * If an error occurs, the <b>wglMakeCurrent</b> function makes the thread's current rendering context not current before returning.
     * @param {Pointer<HDC>} param0 
     * @param {Pointer<HGLRC>} param1 
     * @returns {Integer} When the <b>wglMakeCurrent</b> function succeeds, the return value is <b>TRUE</b>; otherwise the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglmakecurrent
     * @since windows5.0
     */
    static wglMakeCurrent(param0, param1) {
        A_LastError := 0

        result := DllCall("OPENGL32.dll\wglMakeCurrent", "ptr", param0, "ptr", param1, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The wglShareLists function enables multiple OpenGL rendering contexts to share a single display-list space.
     * @remarks
     * When you create an OpenGL rendering context, it has its own display-list space. The <b>wglShareLists</b> function enables a rendering context to share the display-list space of another rendering context; any number of rendering contexts can share a single display-list space. Once a rendering context shares a display-list space, the rendering context always uses the display-list space until the rendering context is deleted. When the last rendering context of a shared display-list space is deleted, the shared display-list space is deleted. All the indexes and definitions of display lists in a shared display-list space are shared.
     * 
     * You can only share display lists with rendering contexts within the same process. However, not all rendering contexts in a process can share display lists. Rendering contexts can share display lists only if they use the same implementation of OpenGL functions. All client rendering contexts of a given pixel format can always share display lists.
     * 
     * All rendering contexts of a shared display list must use an identical pixel format. Otherwise the results depend on the implementation of OpenGL used.
     * 
     * <div class="alert"><b>Note</b>  The <b>wglShareLists</b> function is only available with OpenGL version 1.01 or later. To determine the version number of the implementation of OpenGL, call <b>glGetString</b>.</div>
     * <div> </div>
     * @param {Pointer<HGLRC>} param0 
     * @param {Pointer<HGLRC>} param1 
     * @returns {Integer} When the function succeeds, the return value is <b>TRUE</b>.
     * 
     * When the function fails, the return value is <b>FALSE</b> and the display lists are not shared. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglsharelists
     * @since windows5.0
     */
    static wglShareLists(param0, param1) {
        A_LastError := 0

        result := DllCall("OPENGL32.dll\wglShareLists", "ptr", param0, "ptr", param1, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The wglUseFontBitmaps function creates a set of bitmap display lists for use in the current OpenGL rendering context. (ANSI)
     * @remarks
     * The <b>wglUseFontBitmaps</b> function defines <i>count</i> display lists in the current OpenGL rendering context. Each display list has an identifying number, starting at <i>listBase</i>. Each display list consists of a single call to <a href="https://docs.microsoft.com/windows/desktop/OpenGL/glbitmap">glBitmap</a>. The definition of bitmap <i>listBase</i> + <i>i</i> is taken from the glyph <i>first</i> + <i>i</i> of the font currently selected in the device context specified by <i>hdc</i>. If a glyph is not defined, then the function defines an empty display list for it.
     * 
     * The <b>wglUseFontBitmaps</b> function creates bitmap text in the plane of the screen. It enables the labeling of objects in OpenGL.
     * 
     * In the current version of Microsoft's implementation of OpenGL, you cannot make GDI calls to a device context that has a double-buffered pixel format. Therefore, you cannot use the GDI fonts and text functions with such device contexts. You can use the <b>wglUseFontBitmaps</b> function to circumvent this limitation and draw text in a double-buffered device context.
     * 
     * The function determines the parameters of each call to <b>glBitmap</b> as follows.
     * 
     * <table>
     * <tr>
     * <th>glBitmap Parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><i>width</i></td>
     * <td>The width of the glyph's bitmap, as returned in the <b>gmBlackBoxX</b> member of the glyph's <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-glyphmetrics">GLYPHMETRICS</a> structure.</td>
     * </tr>
     * <tr>
     * <td><i>height</i></td>
     * <td>The height of the glyph's bitmap, as returned in the <b>gmBlackBoxY</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</td>
     * </tr>
     * <tr>
     * <td><i>xorig</i></td>
     * <td>The x offset of the glyph's origin, as returned in the <b>gmptGlyphOrigin.x</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</td>
     * </tr>
     * <tr>
     * <td><i>yorig</i></td>
     * <td>The y offset of the glyph's origin, as returned in the <b>gmptGlyphOrigin.y</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</td>
     * </tr>
     * <tr>
     * <td><i>xmove</i></td>
     * <td>The horizontal distance to the origin of the next character cell, as returned in the <b>gmCellIncX</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</td>
     * </tr>
     * <tr>
     * <td><i>ymove</i></td>
     * <td>The vertical distance to the origin of the next character cell as returned in the <b>gmCellIncY</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</td>
     * </tr>
     * <tr>
     * <td><i>bitmap</i></td>
     * <td>The bitmap for the glyph, as returned by <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getglyphoutlinea">GetGlyphOutline</a> with <i>uFormat</i> equal to 1.</td>
     * </tr>
     * </table>
     * @param {Pointer<HDC>} param0 
     * @param {Integer} param1 
     * @param {Integer} param2 
     * @param {Integer} param3 
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglusefontbitmapsa
     * @since windows5.0
     */
    static wglUseFontBitmapsA(param0, param1, param2, param3) {
        A_LastError := 0

        result := DllCall("OPENGL32.dll\wglUseFontBitmapsA", "ptr", param0, "uint", param1, "uint", param2, "uint", param3, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The wglUseFontBitmaps function creates a set of bitmap display lists for use in the current OpenGL rendering context. (Unicode)
     * @remarks
     * The <b>wglUseFontBitmaps</b> function defines <i>count</i> display lists in the current OpenGL rendering context. Each display list has an identifying number, starting at <i>listBase</i>. Each display list consists of a single call to <a href="https://docs.microsoft.com/windows/desktop/OpenGL/glbitmap">glBitmap</a>. The definition of bitmap <i>listBase</i> + <i>i</i> is taken from the glyph <i>first</i> + <i>i</i> of the font currently selected in the device context specified by <i>hdc</i>. If a glyph is not defined, then the function defines an empty display list for it.
     * 
     * The <b>wglUseFontBitmaps</b> function creates bitmap text in the plane of the screen. It enables the labeling of objects in OpenGL.
     * 
     * In the current version of Microsoft's implementation of OpenGL, you cannot make GDI calls to a device context that has a double-buffered pixel format. Therefore, you cannot use the GDI fonts and text functions with such device contexts. You can use the <b>wglUseFontBitmaps</b> function to circumvent this limitation and draw text in a double-buffered device context.
     * 
     * The function determines the parameters of each call to <b>glBitmap</b> as follows.
     * 
     * <table>
     * <tr>
     * <th>glBitmap Parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><i>width</i></td>
     * <td>The width of the glyph's bitmap, as returned in the <b>gmBlackBoxX</b> member of the glyph's <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-glyphmetrics">GLYPHMETRICS</a> structure.</td>
     * </tr>
     * <tr>
     * <td><i>height</i></td>
     * <td>The height of the glyph's bitmap, as returned in the <b>gmBlackBoxY</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</td>
     * </tr>
     * <tr>
     * <td><i>xorig</i></td>
     * <td>The x offset of the glyph's origin, as returned in the <b>gmptGlyphOrigin.x</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</td>
     * </tr>
     * <tr>
     * <td><i>yorig</i></td>
     * <td>The y offset of the glyph's origin, as returned in the <b>gmptGlyphOrigin.y</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</td>
     * </tr>
     * <tr>
     * <td><i>xmove</i></td>
     * <td>The horizontal distance to the origin of the next character cell, as returned in the <b>gmCellIncX</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</td>
     * </tr>
     * <tr>
     * <td><i>ymove</i></td>
     * <td>The vertical distance to the origin of the next character cell as returned in the <b>gmCellIncY</b> member of the glyph's <b>GLYPHMETRICS</b> structure.</td>
     * </tr>
     * <tr>
     * <td><i>bitmap</i></td>
     * <td>The bitmap for the glyph, as returned by <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getglyphoutlinea">GetGlyphOutline</a> with <i>uFormat</i> equal to 1.</td>
     * </tr>
     * </table>
     * @param {Pointer<HDC>} param0 
     * @param {Integer} param1 
     * @param {Integer} param2 
     * @param {Integer} param3 
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglusefontbitmapsw
     * @since windows5.0
     */
    static wglUseFontBitmapsW(param0, param1, param2, param3) {
        A_LastError := 0

        result := DllCall("OPENGL32.dll\wglUseFontBitmapsW", "ptr", param0, "uint", param1, "uint", param2, "uint", param3, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SwapBuffers function exchanges the front and back buffers if the current pixel format for the window referenced by the specified device context includes a back buffer.
     * @remarks
     * If the current pixel format for the window referenced by the device context does not include a back buffer, this call has no effect and the content of the back buffer is undefined when the function returns.
     * 
     * With multithread applications, flush the drawing commands in any other threads drawing to the same window before calling <b>SwapBuffers</b>.
     * @param {Pointer<HDC>} param0 
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-swapbuffers
     * @since windows5.0
     */
    static SwapBuffers(param0) {
        A_LastError := 0

        result := DllCall("GDI32.dll\SwapBuffers", "ptr", param0, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The wglUseFontOutlines function creates a set of display lists, one for each glyph of the currently selected outline font of a device context, for use with the current rendering context. (ANSI)
     * @remarks
     * The <b>wglUseFontOutlines</b> function defines the glyphs of an outline font with display lists in the current rendering context. The <b>wglUseFontOutlines</b> function works with TrueType fonts only; stroke and raster fonts are not supported.
     * 
     * Each display list consists of either line segments or polygons, and has a unique identifying number starting with the <i>listBase</i> number.
     * 
     * The <b>wglUseFontOutlines</b> function approximates glyph outlines by subdividing the quadratic B-spline curves of the outline into line segments, until the distance between the outline and the interpolated midpoint is within the value specified by <i>deviation</i>. This is the final format used when <i>format</i> is WGL_FONT_LINES. When you specify WGL_FONT_OUTLINES, the display lists created don't contain any normals; thus lighting doesn't work properly. To get the correct lighting of lines use WGL_FONT_POLYGONS and set <b>glPolygonMode</b>( GL_FRONT, GL_LINE ). When you specify <i>format</i> as WGL_FONT_POLYGONS the outlines are further tessellated into separate triangles, triangle fans, triangle strips, or quadrilateral strips to create the surface of each glyph. With WGL_FONT_POLYGONS, the created display lists call <b>glFrontFace</b>( GL_CW ) or <b>glFrontFace</b>( GL_CCW ); thus the current front-face value might be altered. For the best appearance of text with WGL_FONT_POLYGONS, cull the back faces as follows:
     * 
     * 
     * ```cpp
     * glCullFace(GL_BACK); 
     * glEnable(GL_CULL_FACE);
     * ```
     * 
     * 
     * A <b>GLYPHMETRICSFLOAT</b> structure contains information about the placement and orientation of each glyph in a character cell. The <i>lpgmf</i> parameter is an array of <b>GLYPHMETRICSFLOAT</b> structures holding the entire set of glyphs for a font. Each display list ends with a translation specified with the <b>gmfCellIncX</b> and <b>gmfCellIncY</b> members of the corresponding <b>GLYPHMETRICSFLOAT</b> structure. The translation enables the drawing of successive characters in their natural direction with a single call to <a href="https://docs.microsoft.com/windows/desktop/OpenGL/glcalllists">glCallLists</a>.
     * 
     * <div class="alert"><b>Note</b>  With OpenGL for Windows, you cannot make GDI calls to a device context when a pixel format is double-buffered. You can work around this limitation by using <b>wglUseFontOutlines</b> and <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-wglusefontbitmapsa">wglUseFontBitmaps</a>, when using double-buffered device contexts.</div>
     * <div> </div>
     * @param {Pointer<HDC>} param0 
     * @param {Integer} param1 
     * @param {Integer} param2 
     * @param {Integer} param3 
     * @param {Float} param4 
     * @param {Float} param5 
     * @param {Integer} param6 
     * @param {Pointer<GLYPHMETRICSFLOAT>} param7 
     * @returns {Integer} When the function succeeds, the return value is <b>TRUE</b>.
     * 
     * When the function fails, the return value is <b>FALSE</b> and no display lists are generated. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglusefontoutlinesa
     * @since windows5.0
     */
    static wglUseFontOutlinesA(param0, param1, param2, param3, param4, param5, param6, param7) {
        A_LastError := 0

        result := DllCall("OPENGL32.dll\wglUseFontOutlinesA", "ptr", param0, "uint", param1, "uint", param2, "uint", param3, "float", param4, "float", param5, "int", param6, "ptr", param7, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The wglUseFontOutlines function creates a set of display lists, one for each glyph of the currently selected outline font of a device context, for use with the current rendering context. (Unicode)
     * @remarks
     * The <b>wglUseFontOutlines</b> function defines the glyphs of an outline font with display lists in the current rendering context. The <b>wglUseFontOutlines</b> function works with TrueType fonts only; stroke and raster fonts are not supported.
     * 
     * Each display list consists of either line segments or polygons, and has a unique identifying number starting with the <i>listBase</i> number.
     * 
     * The <b>wglUseFontOutlines</b> function approximates glyph outlines by subdividing the quadratic B-spline curves of the outline into line segments, until the distance between the outline and the interpolated midpoint is within the value specified by <i>deviation</i>. This is the final format used when <i>format</i> is WGL_FONT_LINES. When you specify WGL_FONT_OUTLINES, the display lists created don't contain any normals; thus lighting doesn't work properly. To get the correct lighting of lines use WGL_FONT_POLYGONS and set <b>glPolygonMode</b>( GL_FRONT, GL_LINE ). When you specify <i>format</i> as WGL_FONT_POLYGONS the outlines are further tessellated into separate triangles, triangle fans, triangle strips, or quadrilateral strips to create the surface of each glyph. With WGL_FONT_POLYGONS, the created display lists call <b>glFrontFace</b>( GL_CW ) or <b>glFrontFace</b>( GL_CCW ); thus the current front-face value might be altered. For the best appearance of text with WGL_FONT_POLYGONS, cull the back faces as follows:
     * 
     * 
     * ```cpp
     * glCullFace(GL_BACK); 
     * glEnable(GL_CULL_FACE);
     * ```
     * 
     * 
     * A <b>GLYPHMETRICSFLOAT</b> structure contains information about the placement and orientation of each glyph in a character cell. The <i>lpgmf</i> parameter is an array of <b>GLYPHMETRICSFLOAT</b> structures holding the entire set of glyphs for a font. Each display list ends with a translation specified with the <b>gmfCellIncX</b> and <b>gmfCellIncY</b> members of the corresponding <b>GLYPHMETRICSFLOAT</b> structure. The translation enables the drawing of successive characters in their natural direction with a single call to <a href="https://docs.microsoft.com/windows/desktop/OpenGL/glcalllists">glCallLists</a>.
     * 
     * <div class="alert"><b>Note</b>  With OpenGL for Windows, you cannot make GDI calls to a device context when a pixel format is double-buffered. You can work around this limitation by using <b>wglUseFontOutlines</b> and <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-wglusefontbitmapsa">wglUseFontBitmaps</a>, when using double-buffered device contexts.</div>
     * <div> </div>
     * @param {Pointer<HDC>} param0 
     * @param {Integer} param1 
     * @param {Integer} param2 
     * @param {Integer} param3 
     * @param {Float} param4 
     * @param {Float} param5 
     * @param {Integer} param6 
     * @param {Pointer<GLYPHMETRICSFLOAT>} param7 
     * @returns {Integer} When the function succeeds, the return value is <b>TRUE</b>.
     * 
     * When the function fails, the return value is <b>FALSE</b> and no display lists are generated. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglusefontoutlinesw
     * @since windows5.0
     */
    static wglUseFontOutlinesW(param0, param1, param2, param3, param4, param5, param6, param7) {
        A_LastError := 0

        result := DllCall("OPENGL32.dll\wglUseFontOutlinesW", "ptr", param0, "uint", param1, "uint", param2, "uint", param3, "float", param4, "float", param5, "int", param6, "ptr", param7, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The wglDescribeLayerPlane function obtains information about the layer planes of a given pixel format.
     * @remarks
     * The numbering of planes (<i>iLayerPlane</i> ) determines their order. Higher-numbered planes overlay lower-numbered planes.
     * @param {Pointer<HDC>} param0 
     * @param {Integer} param1 
     * @param {Integer} param2 
     * @param {Integer} param3 
     * @param {Pointer<LAYERPLANEDESCRIPTOR>} param4 
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>. In addition, the <b>wglDescribeLayerPlane</b> function sets the members of the <b>LAYERPLANEDESCRIPTOR</b> structure pointed to by <i>plpd</i> according to the specified layer plane (<i>iLayerPlane</i> ) of the specified pixel format (<i>iPixelFormat</i> ).
     * 
     * If the function fails, the return value is <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wgldescribelayerplane
     * @since windows5.0
     */
    static wglDescribeLayerPlane(param0, param1, param2, param3, param4) {
        result := DllCall("OPENGL32.dll\wglDescribeLayerPlane", "ptr", param0, "int", param1, "int", param2, "uint", param3, "ptr", param4, "int")
        return result
    }

    /**
     * Sets the palette entries in a given color-index layer plane for a specified device context.
     * @remarks
     * Each color-index plane in a window has a palette with a size 2^n, where <i>n</i> is the number of bit planes in the layer plane. You cannot modify the transparent index of a palette.
     * 
     * Use the <b>wglRealizeLayerPalette</b> function to realize the layer palette. Initially the layer palette contains only entries for white.
     * 
     * The <b>wglSetLayerPaletteEntries</b> function doesn't set the palette entries of the main plane palette. To update the main plane palette, use GDI palette functions.
     * @param {Pointer<HDC>} param0 
     * @param {Integer} param1 
     * @param {Integer} param2 
     * @param {Integer} param3 
     * @param {Pointer<UInt32>} param4 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglsetlayerpaletteentries
     * @since windows5.0
     */
    static wglSetLayerPaletteEntries(param0, param1, param2, param3, param4) {
        A_LastError := 0

        DllCall("OPENGL32.dll\wglSetLayerPaletteEntries", "ptr", param0, "int", param1, "int", param2, "int", param3, "ptr", param4)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Retrieves the palette entries from a given color-index layer plane for a specified device context.
     * @remarks
     * Each color-index layer plane in a window has a palette with a size 2^<i>n</i>, where <i>n</i> is the number of bit planes in the layer plane. You cannot modify the transparent index of a palette.
     * 
     * Use the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-wglrealizelayerpalette">wglRealizeLayerPalette</a> function to realize the layer palette. Initially the layer palette contains only entries for white.
     * @param {Pointer<HDC>} param0 
     * @param {Integer} param1 
     * @param {Integer} param2 
     * @param {Integer} param3 
     * @param {Pointer<UInt32>} param4 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglgetlayerpaletteentries
     * @since windows5.0
     */
    static wglGetLayerPaletteEntries(param0, param1, param2, param3, param4) {
        A_LastError := 0

        DllCall("OPENGL32.dll\wglGetLayerPaletteEntries", "ptr", param0, "int", param1, "int", param2, "int", param3, "ptr", param4)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The wglRealizeLayerPalette function maps palette entries from a given color-index layer plane into the physical palette or initializes the palette of an RGBA layer plane.
     * @remarks
     * The physical palette for a layer plane is a shared resource among windows with layer planes. When more than one window attempts to realize a palette for a given physical layer plane, only one palette at a time is realized. When you call the <b>wglRealizeLayerPalette</b> function, the layer palette of a foreground window is always realized first.
     * 
     * When a window's layer palette is realized, its palette entries are always mapped one-to-one into the physical palette. Unlike GDI logical palettes, with <b>wglRealizeLayerPalette</b> there is no mapping of other windows' layer palettes to the current physical palette.
     * 
     * Whenever a window becomes the foreground window, call <b>wglRealizeLayerPalette</b> to realize its layer palettes again, even if the pixel type of the layer plane is RGBA.
     * 
     * Because <b>wglRealizeLayerPalette</b> doesn't realize the palette of the main plane, use GDI palette functions to realize the main plane palette.
     * @param {Pointer<HDC>} param0 
     * @param {Integer} param1 
     * @param {Integer} param2 
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>, even if <i>bRealize</i> is <b>TRUE</b> and the physical palette is not available. If the function fails or when no pixel format is selected, the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglrealizelayerpalette
     * @since windows5.0
     */
    static wglRealizeLayerPalette(param0, param1, param2) {
        A_LastError := 0

        result := DllCall("OPENGL32.dll\wglRealizeLayerPalette", "ptr", param0, "int", param1, "int", param2, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The wglSwapLayerBuffers function swaps the front and back buffers in the overlay, underlay, and main planes of the window referenced by a specified device context.
     * @remarks
     * When a layer plane doesn't include a back buffer, calling the <b>wglSwapLayerBuffers</b> function has no effect on that layer plane. After you call <b>wglSwapLayerBuffers</b>, the state of the back buffer content is given in the corresponding <b>LAYERPLANEDESCRIPTOR</b> structure of the layer plane or in the <b>PIXELFORMATDESCRIPTOR</b> structure of the main plane. The <b>wglSwapLayerBuffers</b> function swaps the front and back buffers in the specified layer planes simultaneously.
     * 
     * Some devices don't support swapping layer planes individually; they swap all layer planes as a group. When the PFD_SWAP_LAYER_BUFFERS flag of the <b>PIXELFORMATDESCRIPTOR</b> structure is set, it indicates that a device can swap individual layer planes and that you can call <b>wglSwapLayerBuffers</b>.
     * 
     * With applications that use multiple threads, before calling <b>wglSwapLayerBuffers</b>, clear all drawing commands in all threads drawing to the same window.
     * @param {Pointer<HDC>} param0 
     * @param {Integer} param1 
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-wglswaplayerbuffers
     * @since windows5.0
     */
    static wglSwapLayerBuffers(param0, param1) {
        A_LastError := 0

        result := DllCall("OPENGL32.dll\wglSwapLayerBuffers", "ptr", param0, "uint", param1, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The glAccum function operates on the accumulation buffer.
     * @remarks
     * The accumulation buffer is an extended-range color buffer. Images are not rendered into it. Rather, images rendered into one of the color buffers are added to the contents of the accumulation buffer after rendering. You can create effects such as antialiasing (of points, lines, and polygons), motion blur, and depth of field by accumulating images generated with different transformation matrices.
     * 
     * Each pixel in the accumulation buffer consists of red, green, blue, and alpha values. The number of bits per component in the accumulation buffer depends on the implementation. You can examine this number by calling [**glGetIntegerv**](glgetintegerv.md) four times, with the arguments GL\_ACCUM\_RED\_BITS, GL\_ACCUM\_GREEN\_BITS, GL\_ACCUM\_BLUE\_BITS, and GL\_ACCUM\_ALPHA\_BITS, respectively. Regardless of the number of bits per component, however, the range of values stored by each component is \[ 1,?1\]. The accumulation buffer pixels are mapped one-to-one with framebuffer pixels.
     * 
     * The **glAccum** function operates on the accumulation buffer. The first argument, *op*, is a symbolic constant that selects an accumulation buffer operation. The second argument, *value*, is a floating-point value to be used in that operation. Five operations are specified: GL\_ACCUM, GL\_LOAD, GL\_ADD, GL\_MULT, and GL\_RETURN.
     * 
     * All accumulation buffer operations are limited to the area of the current scissor box and are applied identically to the red, green, blue, and alpha components of each pixel. The contents of an accumulation buffer pixel component are undefined if the **glAccum** operation results in a value outside the range \[ 1,1\].
     * 
     * To clear the accumulation buffer, use the [**glClearAccum**](glclearaccum.md) function to specify R, G, B, and A values to set it to, and issue a [**glClear**](glclear.md) function with the accumulation buffer enabled.
     * 
     * Only those pixels within the current scissor box are updated by any **glAccum** operation.
     * 
     * The following functions retrieve information related to the **glAccum** function:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_ACCUM\_RED\_BITS
     * 
     * **glGet** with argument GL\_ACCUM\_GREEN\_BITS
     * 
     * **glGet** with argument GL\_ACCUM\_BLUE\_BITS
     * 
     * **glGet** with argument GL\_ACCUM\_ALPHA\_BITS
     * @param {Integer} op The accumulation buffer operation. The accepted symbolic constants are as follows.
     * 
     * 
     * 
     * | Value                                                                                                                                             | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * |---------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_ACCUM"></span><span id="gl_accum"></span><dl> <dt>**GL\_ACCUM**</dt> </dl>    | Obtains R, G, B, and A values from the buffer currently selected for reading (see [**glReadBuffer**](glreadbuffer.md)). Each component value is divided by 2*n*  1, where *n* is the number of bits allocated to each color component in the currently selected buffer. The result is a floating-point value in the range \[0,1\], which is multiplied by *value* and added to the corresponding pixel component in the accumulation buffer, thereby updating the accumulation buffer.<br/> |
     * | <span id="GL_LOAD"></span><span id="gl_load"></span><dl> <dt>**GL\_LOAD**</dt> </dl>       | Similar to GL\_ACCUM, except that the current value in the accumulation buffer is not used in the calculation of the new value. That is, the R, G, B, and A values from the currently selected buffer are divided by 2*n*  1, multiplied by *value*, and then stored in the corresponding accumulation buffer cell, overwriting the current value.<br/>                                                                                                                                      |
     * | <span id="GL_ADD"></span><span id="gl_add"></span><dl> <dt>**GL\_ADD**</dt> </dl>          | Adds *value* to each R, G, B, and A in the accumulation buffer.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MULT"></span><span id="gl_mult"></span><dl> <dt>**GL\_MULT**</dt> </dl>       | Multiplies each R, G, B, and A in the accumulation buffer by *value* and returns the scaled component to its corresponding accumulation buffer location.<br/>                                                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_RETURN"></span><span id="gl_return"></span><dl> <dt>**GL\_RETURN**</dt> </dl> | Transfers accumulation buffer values to the color buffer or buffers currently selected for writing. Each R, G, B, and A component is multiplied by *value*, then multiplied by 2*n*  1, clamped to the range \[0, 2*n*  1 \], and stored in the corresponding display buffer cell. The only fragment operations that are applied to this transfer are pixel ownership, scissor, dithering, and color writemasks.<br/>                                                                        |
     * @param {Float} value A floating-point value used in the accumulation buffer operation. The *op* parameter determines how *value* is used.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glaccum
     */
    static glAccum(op, value) {
        DllCall("OPENGL32.dll\glAccum", "uint", op, "float", value)
    }

    /**
     * The glAlphaFunc function enables your application to set the alpha test function.
     * @remarks
     * The alpha test discards fragments depending on the outcome of a comparison between the incoming fragments' alpha values and a constant reference value. The **glAlphaFunc** function specifies the reference and comparison function. The comparison is performed only if alpha testing is enabled. (For more information on GL\_ALPHA\_TEST, see [**glEnable**](glenable.md).)
     * 
     * The *func* and *ref* parameters specify the conditions under which the pixel is drawn. The incoming alpha value is compared to *ref* using the function specified by *func*. If the comparison passes, the incoming fragment is drawn, conditional on subsequent stencil and depth-buffer tests. If the comparison fails, no change is made to the framebuffer at that pixel location.
     * 
     * The **glAlphaFunc** function operates on all pixel writes, including those resulting from the scan conversion of points, lines, polygons, and bitmaps, and from pixel draw and copy operations. The **glAlphaFunc** function does not affect screen clear operations.
     * 
     * Alpha testing is done only in RGBA mode.
     * 
     * The following functions retrieve information related to the **glAlphaFunc** function:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_ALPHA\_TEST\_FUNC
     * 
     * **glGet** with argument GL\_ALPHA\_TEST\_REF
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_ALPHA\_TEST
     * @param {Integer} func The alpha comparison function. The following are the accepted symbolic constants and their meanings.
     * 
     * 
     * 
     * | Value                                                                                                                                                   | Meaning                                                                                        |
     * |---------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|
     * | <span id="GL_NEVER"></span><span id="gl_never"></span><dl> <dt>**GL\_NEVER**</dt> </dl>          | Never passes.<br/>                                                                       |
     * | <span id="GL_LESS"></span><span id="gl_less"></span><dl> <dt>**GL\_LESS**</dt> </dl>             | Passes if the incoming alpha value is less than the reference value.<br/>                |
     * | <span id="GL_EQUAL"></span><span id="gl_equal"></span><dl> <dt>**GL\_EQUAL**</dt> </dl>          | Passes if the incoming alpha value is equal to the reference value.<br/>                 |
     * | <span id="GL_LEQUAL"></span><span id="gl_lequal"></span><dl> <dt>**GL\_LEQUAL**</dt> </dl>       | Passes if the incoming alpha value is less than or equal to the reference value.<br/>    |
     * | <span id="GL_GREATER"></span><span id="gl_greater"></span><dl> <dt>**GL\_GREATER**</dt> </dl>    | Passes if the incoming alpha value is greater than the reference value.<br/>             |
     * | <span id="GL_NOTEQUAL"></span><span id="gl_notequal"></span><dl> <dt>**GL\_NOTEQUAL**</dt> </dl> | Passes if the incoming alpha value is not equal to the reference value.<br/>             |
     * | <span id="GL_GEQUAL"></span><span id="gl_gequal"></span><dl> <dt>**GL\_GEQUAL**</dt> </dl>       | Passes if the incoming alpha value is greater than or equal to the reference value.<br/> |
     * | <span id="GL_ALWAYS"></span><span id="gl_always"></span><dl> <dt>**GL\_ALWAYS**</dt> </dl>       | Always passes. This is the default.<br/>                                                 |
     * @param {Float} ref The reference value to which incoming alpha values are compared. This value is clamped to the range 0 through 1, where 0 represents the lowest possible alpha value and 1 the highest possible value. The default reference is 0.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glalphafunc
     */
    static glAlphaFunc(func, ref) {
        DllCall("OPENGL32.dll\glAlphaFunc", "uint", func, "float", ref)
    }

    /**
     * The glAreTexturesResident function determines whether specified texture objects are resident in texture memory.
     * @remarks
     * On machines with a limited amount of texture memory, OpenGL establishes a working set of textures that are resident in texture memory. These textures can be bound to a texture target much more efficiently than textures that are not resident.
     * 
     * The **glAreTexturesResident** function queries the texture residence status of the *n* textures named by the elements of *textures*. If all the named textures are resident, **glAreTexturesResident** returns GL\_TRUE, and the contents of *residences* are undisturbed. If any of the named textures are not resident, **glAreTexturesResident** returns GL\_FALSE, and detailed status is returned in the *n* elements of *residences*.
     * 
     * If an element of *residences* is GL\_TRUE, then the texture named by the corresponding element of *textures* is resident in texture memory.
     * 
     * To query the residence status of a single bound texture, call [**glGetTexParameter**](glgettexparameter.md) with the *target* parameter set to the target texture to which the target is bound and set the *pname* parameter to GL\_TEXTURE\_RESIDENT. You must use this method to query the resident status of a default texture.
     * 
     * You cannot include **glAreTexturesResident** in display lists.
     * 
     * The **glAreTexturesResident** function returns the residency status of the textures at the time of invocation. It does not guarantee that the textures will remain resident at any other time.
     * 
     * If textures reside in virtual memory (there is no texture memory), they are considered always resident.
     * 
     * > [!Note]  
     * > The **glAreTexturesResident** function is only available in OpenGL version 1.1 or later.
     * @param {Integer} n The number of textures to be queried.
     * @param {Pointer<UInt32>} textures The address of an array containing the names of the textures to be queried.
     * @param {Pointer<Byte>} residences The address of an array in which the texture residence status is returned. The residence status of a texture named by an element of *textures* is returned in the corresponding element of *residences*.
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glaretexturesresident
     */
    static glAreTexturesResident(n, textures, residences) {
        result := DllCall("OPENGL32.dll\glAreTexturesResident", "int", n, "ptr", textures, "ptr", residences, "char")
        return result
    }

    /**
     * The glArrayElement function specifies the array elements used to render a vertex.
     * @remarks
     * Use the **glArrayElement** function within [**glBegin**](glbegin.md) and [**glEnd**](glend.md) pairs to specify vertex and attribute data for point, line, and polygon primitives. The **glArrayElement** function specifies the data for a single vertex using vertex and attribute data located at the *index* of the enabled vertex arrays.
     * 
     * You can use **glArrayElement** to construct primitives by indexing vertex data, rather than by streaming through arrays of data in first-to-last order. Because **glArrayElement** specifies a single vertex only, you can explicitly specify attributes for individual primitives. For example, you can set a single normal for each individual triangle.
     * 
     * When you include calls to **glArrayElement** in display lists, the necessary array data, determined by the array pointers and enable values, is entered in the display list also. Array pointer and enable values are determined when display lists are created, not when display lists are executed.
     * 
     * You can read and cache static array data at any time with **glArrayElement**. When you modify the elements of a static array without specifying the array again, the results of any subsequent calls to **glArrayElement** are undefined.
     * 
     * When you call **glArrayElement** without first calling **glEnableClientState**(GL\_VERTEX\_ARRAY), no drawing occurs, but the attributes corresponding to enabled arrays are modified. Although no error is generated when you specify an array within **glBegin** and **glEnd** pairs, the results are undefined.
     * 
     * > [!Note]  
     * > The **glArrayElement** function is only available in OpenGL version 1.1 or later.
     * @param {Integer} i 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glarrayelement
     */
    static glArrayElement(i) {
        DllCall("OPENGL32.dll\glArrayElement", "int", i)
    }

    /**
     * The glBegin and glend functions delimit the vertices of a primitive or a group of like primitives. | glBegin function (Gl.h)
     * @remarks
     * The **glBegin** and [**glend**](glend.md) functions delimit the vertices that define a primitive or a group of like primitives. The **glBegin** function accepts a single argument that specifies which of ten primitives the vertices compose. Taking *n* as an integer count starting at one, and *N* as the total number of vertices specified, the interpretations are as follows:
     * 
     * -   You can use only a subset of OpenGL functions between **glBegin** and [**glend**](glend.md). The functions you can use are:
     * 
     *     [**glVertex**](glvertex-functions.md)
     * 
     *      
     * 
     *     [**glColor**](glcolor-functions.md)
     * 
     *      
     * 
     *     [**glIndex**](glindex-functions.md)
     * 
     *      
     * 
     *     [**glNormal**](glnormal-functions.md)
     * 
     *      
     * 
     *     [**glTexCoord**](gltexcoord-functions.md)
     * 
     *      
     * 
     *     [**glEvalCoord**](glevalcoord-functions.md)
     * 
     *      
     * 
     *     [**glEvalPoint**](glevalpoint.md)
     * 
     *      
     * 
     *     [**glMaterial**](glmaterial-functions.md)
     * 
     *      
     * 
     *     [**glEdgeFlag**](gledgeflag-functions.md)
     * 
     *     You can also use [**glCallList**](glcalllist.md) or [**glCallLists**](glcalllists.md) to execute display lists that include only the preceding functions. If any other OpenGL function is called between **glBegin** and [**glend**](glend.md), the error flag is set and the function is ignored.
     * 
     * -   Regardless of the value chosen for *mode* in **glBegin**, there is no limit to the number of vertices you can define between **glBegin** and [**glend**](glend.md). Lines, triangles, quadrilaterals, and polygons that are incompletely specified are not drawn. Incomplete specification results when either too few vertices are provided to specify even a single primitive or when an incorrect multiple of vertices is specified. The incomplete primitive is ignored; the complete primitives are drawn.
     * -   The minimum specification of vertices for each primitive is: 
     * 
     *     | Minimum number of vertices | Type of primitive |
     *     |----------------------------|-------------------|
     *     | 1                          | point             |
     *     | 2                          | line              |
     *     | 3                          | triangle          |
     *     | 4                          | quadrilateral     |
     *     | 3                          | polygon           |
     * 
     *     
     * 
     *      
     * 
     * -   Modes that require a certain multiple of vertices are GL\_LINES (2), GL\_TRIANGLES (3), GL\_QUADS (4), and GL\_QUAD\_STRIP (2).
     * @param {Integer} mode The primitive or primitives that will be created from vertices presented between **glBegin** and the subsequent [**glend**](glend.md). The following are accepted symbolic constants and their meanings:
     * 
     * 
     * 
     * | Value                                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                                                                                                                                                                   |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_POINTS"></span><span id="gl_points"></span><dl> <dt>**GL\_POINTS**</dt> </dl>                          | Treats each vertex as a single point. Vertex *n* defines point *n*. *N* points are drawn.<br/>                                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_LINES"></span><span id="gl_lines"></span><dl> <dt>**GL\_LINES**</dt> </dl>                             | Treats each pair of vertices as an independent line segment. Vertices *2n - 1* and *2n* define line *n*. *N/2* lines are drawn.<br/>                                                                                                                                                                                                                                                                |
     * | <span id="GL_LINE_STRIP"></span><span id="gl_line_strip"></span><dl> <dt>**GL\_LINE\_STRIP**</dt> </dl>             | Draws a connected group of line segments from the first vertex to the last. Vertices *n* and *n+1* define line *n*. *N - 1* lines are drawn.<br/>                                                                                                                                                                                                                                                   |
     * | <span id="GL_LINE_LOOP"></span><span id="gl_line_loop"></span><dl> <dt>**GL\_LINE\_LOOP**</dt> </dl>                | Draws a connected group of line segments from the first vertex to the last, then back to the first. Vertices *n* and *n + 1* define line *n*. The last line, however, is defined by vertices *N* and *1*. *N* lines are drawn.<br/>                                                                                                                                                                 |
     * | <span id="GL_TRIANGLES"></span><span id="gl_triangles"></span><dl> <dt>**GL\_TRIANGLES**</dt> </dl>                 | Treats each triplet of vertices as an independent triangle. Vertices *3n - 2*, *3n - 1*, and *3n* define triangle *n*. *N/3* triangles are drawn.<br/>                                                                                                                                                                                                                                              |
     * | <span id="GL_TRIANGLE_STRIP"></span><span id="gl_triangle_strip"></span><dl> <dt>**GL\_TRIANGLE\_STRIP**</dt> </dl> | Draws a connected group of triangles. One triangle is defined for each vertex presented after the first two vertices. For odd *n*, vertices *n*, *n + 1*, and *n + 2* define triangle *n*. For even *n*, vertices *n + 1*, *n*, and *n + 2* define triangle *n*. *N - 2* triangles are drawn.<br/>                                                                                                  |
     * | <span id="GL_TRIANGLE_FAN"></span><span id="gl_triangle_fan"></span><dl> <dt>**GL\_TRIANGLE\_FAN**</dt> </dl>       | Draws a connected group of triangles. one triangle is defined for each vertex presented after the first two vertices. Vertices *1*, *n + 1*, *n + 2* define triangle *n*. *N - 2* triangles are drawn.<br/>                                                                                                                                                                                         |
     * | <span id="GL_QUADS"></span><span id="gl_quads"></span><dl> <dt>**GL\_QUADS**</dt> </dl>                             | Treats each group of four vertices as an independent quadrilateral. Vertices *4n - 3*, *4n - 2*, *4n - 1*, and *4n* define quadrilateral *n*. *N/4* quadrilaterals are drawn.<br/>                                                                                                                                                                                                                  |
     * | <span id="GL_QUAD_STRIP"></span><span id="gl_quad_strip"></span><dl> <dt>**GL\_QUAD\_STRIP**</dt> </dl>             | Draws a connected group of quadrilaterals. One quadrilateral is defined for each pair of vertices presented after the first pair. Vertices *2n - 1*, *2n*, *2n + 2*, and *2n + 1* define quadrilateral *n*. *N/2 - 1* quadrilaterals are drawn. Note that the order in which vertices are used to construct a quadrilateral from strip data is different from that used with independent data.<br/> |
     * | <span id="GL_POLYGON"></span><span id="gl_polygon"></span><dl> <dt>**GL\_POLYGON**</dt> </dl>                       | Draws a single, convex polygon. Vertices *1* through *N* define this polygon.<br/>                                                                                                                                                                                                                                                                                                                  |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glbegin
     */
    static glBegin(mode) {
        DllCall("OPENGL32.dll\glBegin", "uint", mode)
    }

    /**
     * The glBindTexture function enables the creation of a named texture that is bound to a texture target.
     * @remarks
     * The **glBindTexture** function enables you to create a named texture. Calling **glBindTexture** with *target* set to GL\_TEXTURE\_1D or GL\_TEXTURE\_2D, and *texture* set to the name of the new texture you have created binds the texture name to the appropriate texture target. When a texture is bound to a target, the previous binding for that target is no longer in effect.
     * 
     * Texture names are unsigned integers with the value zero reserved to represent the default texture for each texture target. Texture names and the corresponding texture contents are local to the shared display-list space of the current OpenGL rendering context; two rendering contexts share texture names only if they also share display lists. You can generate a set of new texture names using [**glGenTextures**](glgentextures.md).
     * 
     * When a texture is first bound, it assumes the dimensionality of its texture target; a texture bound to GL\_TEXTURE\_1D becomes one-dimensional and a texture bound to GL\_TEXTURE\_2D becomes two-dimensional. Operations you perform on a texture target also affect a texture bound to the target. When you query a texture target, the return value is the state of the texture bound to it. Texture targets become aliases for textures currently bound to them.
     * 
     * When you bind a texture with **glBindTexture**, the binding remains active until a different texture is bound to the same target or you delete the bound texture with the [**glDeleteTextures**](gldeletetextures.md) function. Once you create a named texture you can bind it to a texture target that has the same dimensionality as often as needed.
     * 
     * It is usually much faster to use **glBindTexture** to bind an existing named texture to one of the texture targets than it is to reload the texture image using [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md). For additional control of texturing performance, use [**glPrioritizeTextures**](glprioritizetextures.md).
     * 
     * You can include calls to **glBindTexture** in display lists.
     * 
     * > [!Note]  
     * > The **glBindTexture** function is only available in OpenGL version 1.1 or later.
     * 
     *  
     * 
     * The following functions retrieve information related to **glBindTexture**:
     * 
     * -   [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_TEXTURE\_1D\_BINDING
     * 
     * **glGet** with argument GL\_TEXTURE\_2D\_BINDING
     * @param {Integer} target The target to which the texture is bound. Must have the value GL\_TEXTURE\_1D or GL\_TEXTURE\_2D.
     * @param {Integer} texture The name of a texture; the texture name cannot currently be in use.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glbindtexture
     */
    static glBindTexture(target, texture) {
        DllCall("OPENGL32.dll\glBindTexture", "uint", target, "uint", texture)
    }

    /**
     * The glBitmap function draws a bitmap.
     * @remarks
     * A bitmap is a binary image. When drawn, the bitmap is positioned relative to the current raster position, and framebuffer pixels corresponding to 1s in the bitmap are written using the current raster color or index. Frame-buffer pixels corresponding to zeros in the bitmap are not modified.
     * 
     * The bitmap image is interpreted like image data for the [**glDrawPixels**](gldrawpixels.md) function, with *width* and *height* corresponding to the width and height arguments of that function, and with *type* set to GL\_BITMAP and *format* set to GL\_COLOR\_INDEX. Modes you specify using [**glPixelStore**](glpixelstore-functions.md) affect the interpretation of bitmap image data; modes you specify using [**glPixelTransfer**](glpixeltransfer.md) do not.
     * 
     * If the current raster position is invalid, **glBitmap** is ignored. Otherwise, the lower-left corner of the bitmap image is positioned at the following window coordinates:
     * 
     * *x*<sub>w</sub> = *x*<sub>r</sub> *x*?
     * 
     * *y*<sub>w</sub> = *y*<sub>r</sub> *y*?
     * 
     * In these coordinates, (*x*<sub>r</sub> , *y*<sub>r</sub> ) is the raster position, and (*x*? , *y*? ) is the bitmap origin. Fragments are then generated for each pixel corresponding to a 1 in the bitmap image. These fragments are generated using the current raster *z*-coordinate, color or color index, and current raster texture coordinates. They are then treated just as if they had been generated by a point, line, or polygon, including texture mapping, fogging, and all per-fragment operations such as alpha and depth testing.
     * 
     * After the bitmap has been drawn, the *x* and *y* coordinates of the current raster position are offset by *xmove* and *ymove*. No change is made to the *z*-coordinate of the current raster position, or to the current raster color, index, or texture coordinates.
     * 
     * The following functions retrieve information related to the **glBitmap** function:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION
     * 
     *  
     * 
     * **glGet** with argument GL\_CURRENT\_RASTER\_COLOR
     * 
     *  
     * 
     * **glGet** with argument GL\_CURRENT\_RASTER\_INDEX
     * 
     *  
     * 
     * **glGet** with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS
     * 
     *  
     * 
     * **glGet** with argument GL\_CURRENT\_RASTER\_POSITION\_VALID
     * @param {Integer} width The pixel width of the bitmap image.
     * @param {Integer} height The pixel height of the bitmap image.
     * @param {Float} xorig The *x* location of the origin in the bitmap image. The origin is measured from the lower-left corner of the bitmap, with right and up directions being the positive axes.
     * @param {Float} yorig The *y* location of the origin in the bitmap image. The origin is measured from the lower-left corner of the bitmap, with right and up directions being the positive axes.
     * @param {Float} xmove The *x* offset to be added to the current raster position after the bitmap is drawn.
     * @param {Float} ymove The *y* offset to be added to the current raster position after the bitmap is drawn.
     * @param {Pointer<Byte>} bitmap The address of the bitmap image.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glbitmap
     */
    static glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap) {
        DllCall("OPENGL32.dll\glBitmap", "int", width, "int", height, "float", xorig, "float", yorig, "float", xmove, "float", ymove, "ptr", bitmap)
    }

    /**
     * The glBlendFunc function specifies pixel arithmetic.
     * @remarks
     * In RGB mode, pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the framebuffer (the destination values). By default, blending is disabled. Use [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with the GL\_BLEND argument to enable and disable blending.
     * 
     * When enabled, **glBlendFunc** defines the operation of blending. The *sfactor* parameter specifies which of nine methods is used to scale the source color components. The *dfactor* parameter specifies which of eight methods is used to scale the destination color components. The eleven possible methods are described in the following table. Each method defines four scale factors one each for red, green, blue, and alpha.
     * 
     * In the table and in subsequent equations, source and destination color components are referred to as (*R*? , *G*? , *B*? , *A*? ) and (*R*<sub>d</sub> , *G*<sub>d</sub> , *B*<sub>d</sub> , *A*<sub>d</sub> ). They are understood to have integer values between zero and (*k*<sub>R</sub> , *k*<sub>G</sub> , *k*<sub>R</sub> , *k*<sub>A</sub> ), where
     * 
     * *k*<sub>R</sub> = 2<sup>m</sup>*R* - 1
     * 
     * *k*<sub>G</sub> = 2<sup>m</sup>*G* - 1
     * 
     * *k*<sub>B</sub> = 2<sup>m</sup>*B* - 1
     * 
     * *k*<sub>A</sub> = 2<sup>m</sup>*A* - 1
     * 
     * and (*m*<sub>R</sub> , *m*<sub>G</sub> , *m*<sub>B</sub> , *m*<sub>A</sub> ) is the number of red, green, blue, and alpha bitplanes.
     * 
     * Source and destination scale factors are referred to as (*s*<sub>R</sub> , *s*<sub>G</sub> , *s*<sub>B</sub> , *s*<sub>A</sub> ) and (*d*<sub>R</sub> , *d*<sub>G</sub> , *d*<sub>B</sub> , *d*<sub>A</sub> ). The scale factors described in the table, denoted (*f*<sub>R</sub> , *f*<sub>G</sub> , *f*<sub>B</sub> , *f*<sub>A</sub> ), represent either source or destination factors. All scale factors have range \[0,1\].
     * 
     * 
     * 
     * | Parameter                  | (*f*<sub>R</sub>  , *f*<sub>G</sub>  , *f*<sub>B</sub>  , *f*<sub>A</sub>  )                                                                                 |
     * |----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | GL\_ZERO                   | (0,0,0,0)                                                                                                                                                    |
     * | GL\_ONE                    | (1,1,1,1)                                                                                                                                                    |
     * | GL\_SRC\_COLOR             | (*R*? / *k*<sub>R</sub> , *G*? / *k*<sub>G</sub> , *B*? / *k*<sub>B</sub> , *A*? / *k*<sub>A</sub> )                                                         |
     * | GL\_ONE\_MINUS\_SRC\_COLOR | (1,1,1,1) - (*R*? / *k*<sub>R</sub> , *G*? / *k*<sub>G</sub> , *B*? / *k*<sub>B</sub> , *A*? / *k*<sub>A</sub> )                                             |
     * | GL\_DST\_COLOR             | (*R*<sub>d</sub> / *k*<sub>R</sub> , *G*<sub>d</sub> / *k*<sub>G</sub> , *B*<sub>d</sub> / *k*<sub>B</sub> , *A*<sub>d</sub> / *k*<sub>A</sub> )             |
     * | GL\_ONE\_MINUS\_DST\_COLOR | (1,1,1,1) - (*R*<sub>d</sub> / *k*<sub>R</sub> , *G*<sub>d</sub> / *k*<sub>G</sub> , *B*<sub>d</sub> / *k*<sub>B</sub> , *A*<sub>d</sub> / *k*<sub>A</sub> ) |
     * | GL\_SRC\_ALPHA             | (*A*? / *k*<sub>A</sub> , *A*? / *k*<sub>A</sub> , *A*? / *k*<sub>A</sub> , *A*? / *k*<sub>A</sub> )                                                         |
     * | GL\_ONE\_MINUS\_SRC\_ALPHA | (1,1,1,1) - (*A*? / *k*<sub>A</sub> , *A*? / *k*<sub>A</sub> , *A*? / *k*<sub>A</sub> , *A*? / *k*<sub>A</sub> )                                             |
     * | GL\_DST\_ALPHA             | (*A*<sub>d</sub> / *k*<sub>A</sub> , *A*<sub>d</sub> / *k*<sub>A</sub> , *A*<sub>d</sub> / *k*<sub>A</sub> , *A*<sub>d</sub> / *k*<sub>A</sub> )             |
     * | GL\_ONE\_MINUS\_DST\_ALPHA | (1,1,1,1) - (*A*<sub>d</sub> / *k*<sub>A</sub> , *A*<sub>d</sub> / *k*<sub>A</sub> , *A*<sub>d</sub> / *k*<sub>A</sub> , *A*<sub>d</sub> / *k*<sub>A</sub> ) |
     * | GL\_SRC\_ALPHA\_SATURATE   | (*i,i,i,* 1)                                                                                                                                                 |
     * 
     * 
     * 
     *  
     * 
     * In the table,
     * 
     * *i* = min (*A*? , *k*<sub>A</sub>  - *A*<sub>d</sub> ) / *k*<sub>A</sub>
     * 
     * To determine the blended RGBA values of a pixel when drawing in RGBA mode, the system uses the following equations:
     * 
     * *R* (*d*) = min( *k*<sub>R</sub> , *R*? *s*<sub>R</sub> + *R*<sub>d</sub> *d*<sub>R</sub> )
     * 
     * *G* (*d*) = min( *k*<sub>G</sub> , *G*? *s*<sub>G</sub> + *G*<sub>d</sub> *d*<sub>G</sub>  )
     * 
     * *B* (*d*) = min( *k*<sub>B</sub> *, B*? *s*<sub>B</sub> + *B*<sub>d</sub> *d*<sub>B</sub>  )
     * 
     * *A* (*d*) = min( *k*<sub>A</sub> , *A*? *s*<sub>A</sub> + *A*<sub>d</sub> *d*<sub>A</sub>  )
     * 
     * Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to one is guaranteed not to modify its multiplicand, and a blend factor equal to zero reduces its multiplicand to zero. Thus, for example, when *sfactor* is GL\_SRC\_ALPHA, *dfactor* is GL\_ONE\_MINUS\_SRC\_ALPHA, and *A*? is equal to *k*<sub>A</sub>, the equations reduce to simple replacement:
     * 
     * *R*<sub>d</sub> = *R*?
     * 
     * *G*<sub>d</sub> = *G*?
     * 
     * B<sub>d</sub> = *B*?
     * 
     * *A*<sub>d</sub> = *A*?
     * @param {Integer} sfactor Specifies how the red, green, blue, and alpha source-blending factors are computed. Nine symbolic constants are accepted: GL\_ZERO, GL\_ONE, GL\_DST\_COLOR, GL\_ONE\_MINUS\_DST\_COLOR, GL\_SRC\_ALPHA, GL\_ONE\_MINUS\_SRC\_ALPHA, GL\_DST\_ALPHA, GL\_ONE\_MINUS\_DST\_ALPHA, and GL\_SRC\_ALPHA\_SATURATE.
     * @param {Integer} dfactor Specifies how the red, green, blue, and alpha destination-blending factors are computed. Eight symbolic constants are accepted: GL\_ZERO, GL\_ONE, GL\_SRC\_COLOR, GL\_ONE\_MINUS\_SRC\_COLOR, GL\_SRC\_ALPHA, GL\_ONE\_MINUS\_SRC\_ALPHA, GL\_DST\_ALPHA, and GL\_ONE\_MINUS\_DST\_ALPHA.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glblendfunc
     */
    static glBlendFunc(sfactor, dfactor) {
        DllCall("OPENGL32.dll\glBlendFunc", "uint", sfactor, "uint", dfactor)
    }

    /**
     * The glCallList function executes a display list.
     * @remarks
     * Invoking the **glCallList** function begins execution of the named display list. The functions saved in the display list are executed in order, just as if you called them without using a display list. If *list* has not been defined as a display list, **glCallList** is ignored.
     * 
     * The **glCallList** function can appear inside a display list. To avoid the possibility of infinite recursion resulting from display lists calling one another, a limit is placed on the nesting level of display lists during display-list execution. This limit is at least 64, however, it depends on the implementation.
     * 
     * The OpenGL state is not saved and restored across a call to **glCallList**. Thus, changes made to the OpenGL state during the execution of a display list remain after execution of the display list is completed. To preserve the OpenGL state across **glCallList** calls, use [**glPushAttrib**](glpushattrib.md), [**glPopAttrib**](glpopattrib.md), [**glPushMatrix**](glpushmatrix.md), and [**glPopMatrix**](glpopmatrix.md).
     * 
     * You can execute display lists between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md), as long as the display list includes only functions that are allowed in this interval.
     * 
     * The following functions retrieve information related to **glCallList**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAX\_LIST\_NESTING
     * 
     * [**glIsList**](glislist.md)
     * @param {Integer} list The integer name of the display list to be executed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcalllist
     */
    static glCallList(list) {
        DllCall("OPENGL32.dll\glCallList", "uint", list)
    }

    /**
     * The glCallLists function executes a list of display lists.
     * @remarks
     * The **glCallLists** function causes each display list in the list of names passed as *lists* to be executed. As a result, the functions saved in each display list are executed in order, just as if they were called without using a display list. Names of display lists that have not been defined are ignored.
     * 
     * The **glCallLists** function provides an efficient means for executing display lists. The *n* parameter specifies the number of lists with various name formats (specified by the *type* parameter) **glCallLists** executes.
     * 
     * The list of display list names is not null-terminated. Rather, *n* specifies how many names are to be taken from *lists*.
     * 
     * The [**glListBase**](gllistbase.md) function makes an additional level of indirection available. The **glListBase** function specifies an unsigned offset that is added to each display list name specified in *lists* before that display list is executed.
     * 
     * The **glCallLists** function can appear inside a display list. To avoid the possibility of infinite recursion resulting from display lists calling one another, a limit is placed on the nesting level of display lists during display list execution. This limit must be at least 64, and it depends on the implementation.
     * 
     * The OpenGL state is not saved and restored across a call to **glCallLists**. Thus, changes made to the OpenGL state during the execution of the display lists remain after execution is completed. Use [**glPushAttrib**](glpushattrib.md), [**glPopAttrib**](glpopattrib.md), [**glPushMatrix**](glpushmatrix.md), and [**glPopMatrix**](glpopmatrix.md) to preserve the OpenGL state across **glCallLists** calls.
     * 
     * You can execute display lists between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md), as long as the display list includes only functions that are allowed in this interval.
     * 
     * The following functions retrieve information related to the **glCallLists** function:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_LIST\_BASE
     * 
     * **glGet** with argument GL\_MAX\_LIST\_NESTING
     * 
     * [**glIsList**](glislist.md)
     * @param {Integer} n The number of display lists to be executed.
     * @param {Integer} type The type of values in *lists*. The following symbolic constants are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                                                                                                                                                            |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_BYTE"></span><span id="gl_byte"></span><dl> <dt>**GL\_BYTE**</dt> </dl>                                | The *lists* parameter is treated as an array of signed bytes, each in the range -128 through 127.<br/>                                                                                                                                                                                                                                                                                       |
     * | <span id="GL_UNSIGNED_BYTE"></span><span id="gl_unsigned_byte"></span><dl> <dt>**GL\_UNSIGNED\_BYTE**</dt> </dl>    | The *lists* parameter is treated as an array of unsigned bytes, each in the range 0 through 255.<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_SHORT"></span><span id="gl_short"></span><dl> <dt>**GL\_SHORT**</dt> </dl>                             | The *lists* parameter is treated as an array of signed 2-byte integers, each in the range -32768 through 32767.<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_UNSIGNED_SHORT"></span><span id="gl_unsigned_short"></span><dl> <dt>**GL\_UNSIGNED\_SHORT**</dt> </dl> | The *lists* parameter is treated as an array of unsigned 2-byte integers, each in the range 0 through 65535.<br/>                                                                                                                                                                                                                                                                            |
     * | <span id="GL_INT"></span><span id="gl_int"></span><dl> <dt>**GL\_INT**</dt> </dl>                                   | The *lists* parameter is treated as an array of signed 4-byte integers.<br/>                                                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_UNSIGNED_INT"></span><span id="gl_unsigned_int"></span><dl> <dt>**GL\_UNSIGNED\_INT**</dt> </dl>       | The *lists* parameter is treated as an array of unsigned 4-byte integers.<br/>                                                                                                                                                                                                                                                                                                               |
     * | <span id="GL_FLOAT"></span><span id="gl_float"></span><dl> <dt>**GL\_FLOAT**</dt> </dl>                             | The *lists* parameter is treated as an array of 4-byte, floating-point values.<br/>                                                                                                                                                                                                                                                                                                          |
     * | <span id="GL_2_BYTES"></span><span id="gl_2_bytes"></span><dl> <dt>**GL\_2\_BYTES**</dt> </dl>                      | The *lists* parameter is treated as an array of unsigned bytes. Each pair of bytes specifies a single display-list name. The value of the pair is computed as 256 times the unsigned value of the first byte plus the unsigned value of the second byte.<br/>                                                                                                                                |
     * | <span id="GL_3_BYTES"></span><span id="gl_3_bytes"></span><dl> <dt>**GL\_3\_BYTES**</dt> </dl>                      | The *lists* parameter is treated as an array of unsigned bytes. Each triplet of bytes specifies a single display list name. The value of the triplet is computed as 65536 times the unsigned value of the first byte, plus 256 times the unsigned value of the second byte, plus the unsigned value of the third byte.<br/>                                                                  |
     * | <span id="GL_4_BYTES"></span><span id="gl_4_bytes"></span><dl> <dt>**GL\_4\_BYTES**</dt> </dl>                      | The *lists* parameter is treated as an array of unsigned bytes. Each quadruplet of bytes specifies a single display list name. The value of the quadruplet is computed as 16777216 times the unsigned value of the first byte, plus 65536 times the unsigned value of the second byte, plus 256 times the unsigned value of the third byte, plus the unsigned value of the fourth byte.<br/> |
     * @param {Pointer<Void>} lists The address of an array of name offsets in the display list. The pointer type is void because the offsets can be bytes, shorts, ints, or floats, depending on the value of *type*.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcalllists
     */
    static glCallLists(n, type, lists) {
        DllCall("OPENGL32.dll\glCallLists", "int", n, "uint", type, "ptr", lists)
    }

    /**
     * The glClear function clears buffers to preset values.
     * @remarks
     * The **glClear** function sets the bitplane area of the window to values previously selected by [**glClearColor**](glclearcolor.md), [**glClearIndex**](glclearindex.md), [**glClearDepth**](glcleardepth.md), [**glClearStencil**](glclearstencil.md), and [**glClearAccum**](glclearaccum.md). You can clear multiple color buffers simultaneously by selecting more than one buffer at a time using [**glDrawBuffer**](gldrawbuffer.md).
     * 
     * The pixel-ownership test, the scissor test, dithering, and the buffer writemasks affect the operation of **glClear**. The scissor box bounds the cleared region. The **glClear** function ignores the alpha function, blend function, logical operation, stenciling, texture mapping, and *z*-buffering.
     * 
     * The **glClear** function takes a single argument (*mask*) that is the bitwise OR of several values indicating which buffer is to be cleared.
     * 
     * The value to which each buffer is cleared depends on the setting of the clear value for that buffer.
     * 
     * If a buffer is not present, a **glClear** call directed at that buffer has no effect.
     * 
     * The following functions retrieve information related to **glClear**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_ACCUM\_CLEAR\_VALUE
     * 
     * **glGet** with argument GL\_DEPTH\_CLEAR\_VALUE
     * 
     * **glGet** with argument GL\_INDEX\_CLEAR\_VALUE
     * 
     * **glGet** with argument GL\_COLOR\_CLEAR\_VALUE
     * 
     * **glGet** with argument GL\_STENCIL\_CLEAR\_VALUE
     * @param {Integer} mask Bitwise OR operators of masks that indicate the buffers to be cleared. The four masks are as follows.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                   | Meaning                                                     |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------|
     * | <span id="GL_COLOR_BUFFER_BIT"></span><span id="gl_color_buffer_bit"></span><dl> <dt>**GL\_COLOR\_BUFFER\_BIT**</dt> </dl>       | The buffers currently enabled for color writing.<br/> |
     * | <span id="GL_DEPTH_BUFFER_BIT"></span><span id="gl_depth_buffer_bit"></span><dl> <dt>**GL\_DEPTH\_BUFFER\_BIT**</dt> </dl>       | The depth buffer.<br/>                                |
     * | <span id="GL_ACCUM_BUFFER_BIT"></span><span id="gl_accum_buffer_bit"></span><dl> <dt>**GL\_ACCUM\_BUFFER\_BIT**</dt> </dl>       | The accumulation buffer.<br/>                         |
     * | <span id="GL_STENCIL_BUFFER_BIT"></span><span id="gl_stencil_buffer_bit"></span><dl> <dt>**GL\_STENCIL\_BUFFER\_BIT**</dt> </dl> | The stencil buffer.<br/>                              |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glclear
     */
    static glClear(mask) {
        DllCall("OPENGL32.dll\glClear", "uint", mask)
    }

    /**
     * The glClearAccum function specifies the clear values for the accumulation buffer.
     * @remarks
     * The **glClearAccum** function specifies the red, green, blue, and alpha values used by [**glClear**](glclear.md) to clear the accumulation buffer.
     * 
     * Values specified by **glClearAccum** are clamped to the range \[1,1\].
     * 
     * The following function retrieves information related to **glClearAccum**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_ACCUM\_CLEAR\_VALUE
     * @param {Float} red The red value used when the accumulation buffer is cleared. The default value is zero.
     * @param {Float} green The green value used when the accumulation buffer is cleared. The default value is zero.
     * @param {Float} blue The blue value used when the accumulation buffer is cleared. The default value is zero.
     * @param {Float} alpha The alpha value used when the accumulation buffer is cleared. The default value is zero.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glclearaccum
     */
    static glClearAccum(red, green, blue, alpha) {
        DllCall("OPENGL32.dll\glClearAccum", "float", red, "float", green, "float", blue, "float", alpha)
    }

    /**
     * The glClearColor function specifies clear values for the color buffers.
     * @remarks
     * The **glClearColor** function specifies the red, green, blue, and alpha values used by [**glClear**](glclear.md) to clear the color buffers. Values specified by **glClearColor** are clamped to the range \[0,1\].
     * 
     * The following functions retrieve information related to the **glClearColor** function:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_ACCUM\_CLEAR\_VALUE
     * 
     * **glGet** with argument GL\_COLOR\_CLEAR\_VALUE
     * @param {Float} red The red value that [**glClear**](glclear.md) uses to clear the color buffers. The default value is zero.
     * @param {Float} green The green value that [**glClear**](glclear.md) uses to clear the color buffers. The default value is zero.
     * @param {Float} blue The blue value that [**glClear**](glclear.md) uses to clear the color buffers. The default value is zero.
     * @param {Float} alpha The alpha value that [**glClear**](glclear.md) uses to clear the color buffers. The default value is zero.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glclearcolor
     */
    static glClearColor(red, green, blue, alpha) {
        DllCall("OPENGL32.dll\glClearColor", "float", red, "float", green, "float", blue, "float", alpha)
    }

    /**
     * The glClearDepth function specifies the clear value for the depth buffer.
     * @remarks
     * The **glClearDepth** function specifies the depth value used by [**glClear**](glclear.md) to clear the depth buffer. Values specified by **glClearDepth** are clamped to the range \[0,1\].
     * 
     * The following function retrieves information related to the **glClearDepth** function:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_DEPTH\_CLEAR\_VALUE
     * @param {Float} depth The depth value used when the depth buffer is cleared.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcleardepth
     */
    static glClearDepth(depth) {
        DllCall("OPENGL32.dll\glClearDepth", "double", depth)
    }

    /**
     * The glClearIndex function specifies the clear value for the color-index buffers.
     * @remarks
     * The **glClearIndex** function specifies the index used by [**glClear**](glclear.md) to clear the color-index buffers. The *c* parameter is not clamped. Rather, *c* is converted to a fixed-point value with unspecified precision to the right of the binary point. The integer part of this value is then masked with 2<sup>m</sup>  - 1, where *m* is the number of bits in a color index stored in the framebuffer.
     * 
     * The following functions retrieve information related to **glClearIndex**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_INDEX\_CLEAR\_VALUE
     * 
     * **glGet** with argument GL\_INDEX\_BITS
     * @param {Float} c The index used when the color-index buffers are cleared. The default value is zero.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glclearindex
     */
    static glClearIndex(c) {
        DllCall("OPENGL32.dll\glClearIndex", "float", c)
    }

    /**
     * The glClearStencil function specifies the clear value for the stencil buffer.
     * @remarks
     * The **glClearStencil** function specifies the index used by [**glClear**](glclear.md) to clear the stencil buffer. The *s* parameter is masked with 2<sup>m</sup>  - 1, where *m* is the number of bits in the stencil buffer.
     * 
     * The following functions retrieve information related to the **glClearStencil** function:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_STENCIL\_CLEAR\_VALUE
     * 
     * **glGet** with argument GL\_STENCIL\_BITS
     * @param {Integer} s The index used when the stencil buffer is cleared. The default value is zero.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glclearstencil
     */
    static glClearStencil(s) {
        DllCall("OPENGL32.dll\glClearStencil", "int", s)
    }

    /**
     * The glClipPlane function specifies a plane against which all geometry is clipped.
     * @remarks
     * Geometry is always clipped against the boundaries of a six-plane frustum in *x*, *y*, and *z*. The **glClipPlane** function allows the specification of additional planes, not necessarily perpendicular to the *x-*axis, *y-*axis, or *z*-axis, against which all geometry is clipped. Up to GL\_MAX\_CLIP\_PLANES planes can be specified, where GL\_MAX\_CLIP\_PLANES is at least six in all implementations. Because the resulting clipping region is the intersection of the defined half-spaces, it is always convex.
     * 
     * The **glClipPlane** function specifies a half-space using a four-component plane equation. When you call **glClipPlane**,*equation* is transformed by the inverse of the modelview matrix and stored in the resulting eye coordinates. Subsequent changes to the modelview matrix have no effect on the stored plane-equation components. If the dot product of the eye coordinates of a vertex with the stored plane equation components is positive or zero, the vertex is in with respect to that clipping plane. Otherwise, it is out.
     * 
     * Use the [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) functions to enable and disable clipping planes. Call clipping planes with the argument GL\_CLIP\_PLANE*i*, where *i* is the plane number.
     * 
     * By default, all clipping planes are defined as (0,0,0,0) in eye coordinates and are disabled.
     * 
     * It is always the case that GL\_CLIP\_PLANE*i* = GL\_CLIP\_PLANE0 + *i*.
     * 
     * The following functions retrieve information related to **glClipPlane**:
     * 
     * [**glGetClipPlane**](glgetclipplane.md)
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_CLIP\_PLANE *i*
     * @param {Integer} plane The clipping plane that is being positioned. Symbolic names of the form GL\_CLIP\_PLANE*i*, where *i* is an integer between 0 and GL\_MAX\_CLIP\_PLANES - 1, are accepted.
     * @param {Pointer<Double>} equation The address of an array of four double-precision floating-point values. These values are interpreted as a plane equation.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glclipplane
     */
    static glClipPlane(plane, equation) {
        DllCall("OPENGL32.dll\glClipPlane", "uint", plane, "ptr", equation)
    }

    /**
     * Sets the current color. | glColor3b function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Integer} red The new red value for the current color.
     * @param {Integer} green The new green value for the current color.
     * @param {Integer} blue The new blue value for the current color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor3b
     */
    static glColor3b(red, green, blue) {
        DllCall("OPENGL32.dll\glColor3b", "char", red, "char", green, "char", blue)
    }

    /**
     * Sets the current color from an already existing array of color values. | glColor3bv function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Pointer<SByte>} v A pointer to an array that contains red, green, and blue values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor3bv
     */
    static glColor3bv(v) {
        DllCall("OPENGL32.dll\glColor3bv", "ptr", v)
    }

    /**
     * Sets the current color. | glColor3d function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Float} red The new red value for the current color.
     * @param {Float} green The new green value for the current color.
     * @param {Float} blue The new blue value for the current color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor3d
     */
    static glColor3d(red, green, blue) {
        DllCall("OPENGL32.dll\glColor3d", "double", red, "double", green, "double", blue)
    }

    /**
     * Sets the current color from an already existing array of color values. | glColor3dv function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Pointer<Double>} v A pointer to an array that contains red, green, and blue values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor3dv
     */
    static glColor3dv(v) {
        DllCall("OPENGL32.dll\glColor3dv", "ptr", v)
    }

    /**
     * Sets the current color. | glColor3f function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Float} red The new red value for the current color.
     * @param {Float} green The new green value for the current color.
     * @param {Float} blue The new blue value for the current color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor3f
     */
    static glColor3f(red, green, blue) {
        DllCall("OPENGL32.dll\glColor3f", "float", red, "float", green, "float", blue)
    }

    /**
     * Sets the current color from an already existing array of color values. | glColor3fv function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Pointer<Single>} v A pointer to an array that contains red, green, and blue values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor3fv
     */
    static glColor3fv(v) {
        DllCall("OPENGL32.dll\glColor3fv", "ptr", v)
    }

    /**
     * Sets the current color. | glColor3i function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Integer} red The new red value for the current color.
     * @param {Integer} green The new green value for the current color.
     * @param {Integer} blue The new blue value for the current color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor3i
     */
    static glColor3i(red, green, blue) {
        DllCall("OPENGL32.dll\glColor3i", "int", red, "int", green, "int", blue)
    }

    /**
     * Sets the current color from an already existing array of color values. | glColor3iv function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Pointer<Int32>} v A pointer to an array that contains red, green, and blue values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor3iv
     */
    static glColor3iv(v) {
        DllCall("OPENGL32.dll\glColor3iv", "ptr", v)
    }

    /**
     * Sets the current color. | glColor3s function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Integer} red The new red value for the current color.
     * @param {Integer} green The new green value for the current color.
     * @param {Integer} blue The new blue value for the current color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor3s
     */
    static glColor3s(red, green, blue) {
        DllCall("OPENGL32.dll\glColor3s", "short", red, "short", green, "short", blue)
    }

    /**
     * Sets the current color from an already existing array of color values. | glColor3sv function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Pointer<Int16>} v A pointer to an array that contains red, green, and blue values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor3sv
     */
    static glColor3sv(v) {
        DllCall("OPENGL32.dll\glColor3sv", "ptr", v)
    }

    /**
     * Sets the current color. | glColor3ub function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Integer} red The new red value for the current color.
     * @param {Integer} green The new green value for the current color.
     * @param {Integer} blue The new blue value for the current color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor3ub
     */
    static glColor3ub(red, green, blue) {
        DllCall("OPENGL32.dll\glColor3ub", "char", red, "char", green, "char", blue)
    }

    /**
     * Sets the current color from an already existing array of color values. | glColor3ubv function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Pointer<Byte>} v A pointer to an array that contains red, green, and blue values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor3ubv
     */
    static glColor3ubv(v) {
        DllCall("OPENGL32.dll\glColor3ubv", "ptr", v)
    }

    /**
     * Sets the current color. | glColor3ui function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Integer} red The new red value for the current color.
     * @param {Integer} green The new green value for the current color.
     * @param {Integer} blue The new blue value for the current color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor3ui
     */
    static glColor3ui(red, green, blue) {
        DllCall("OPENGL32.dll\glColor3ui", "uint", red, "uint", green, "uint", blue)
    }

    /**
     * Sets the current color from an already existing array of color values. | glColor3uiv function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Pointer<UInt32>} v A pointer to an array that contains red, green, and blue values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor3uiv
     */
    static glColor3uiv(v) {
        DllCall("OPENGL32.dll\glColor3uiv", "ptr", v)
    }

    /**
     * Sets the current color. | glColor3us function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Integer} red The new red value for the current color.
     * @param {Integer} green The new green value for the current color.
     * @param {Integer} blue The new blue value for the current color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor3us
     */
    static glColor3us(red, green, blue) {
        DllCall("OPENGL32.dll\glColor3us", "ushort", red, "ushort", green, "ushort", blue)
    }

    /**
     * Sets the current color from an already existing array of color values. | glColor3usv function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Pointer<UInt16>} v A pointer to an array that contains red, green, and blue values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor3usv
     */
    static glColor3usv(v) {
        DllCall("OPENGL32.dll\glColor3usv", "ptr", v)
    }

    /**
     * Sets the current color. | glColor4b function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Integer} red The new red value for the current color.
     * @param {Integer} green The new green value for the current color.
     * @param {Integer} blue The new blue value for the current color.
     * @param {Integer} alpha The new alpha value for the current color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor4b
     */
    static glColor4b(red, green, blue, alpha) {
        DllCall("OPENGL32.dll\glColor4b", "char", red, "char", green, "char", blue, "char", alpha)
    }

    /**
     * Sets the current color from an already existing array of color values. | glColor4bv function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Pointer<SByte>} v A pointer to an array that contains red, green, blue, and alpha values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor4bv
     */
    static glColor4bv(v) {
        DllCall("OPENGL32.dll\glColor4bv", "ptr", v)
    }

    /**
     * Sets the current color. | glColor4d function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Float} red The new red value for the current color.
     * @param {Float} green The new green value for the current color.
     * @param {Float} blue The new blue value for the current color.
     * @param {Float} alpha The new alpha value for the current color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor4d
     */
    static glColor4d(red, green, blue, alpha) {
        DllCall("OPENGL32.dll\glColor4d", "double", red, "double", green, "double", blue, "double", alpha)
    }

    /**
     * Sets the current color from an already existing array of color values. | glColor4dv function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Pointer<Double>} v A pointer to an array that contains red, green, blue, and alpha values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor4dv
     */
    static glColor4dv(v) {
        DllCall("OPENGL32.dll\glColor4dv", "ptr", v)
    }

    /**
     * Sets the current color. | glColor4f function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Float} red The new red value for the current color.
     * @param {Float} green The new green value for the current color.
     * @param {Float} blue The new blue value for the current color.
     * @param {Float} alpha The new alpha value for the current color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor4f
     */
    static glColor4f(red, green, blue, alpha) {
        DllCall("OPENGL32.dll\glColor4f", "float", red, "float", green, "float", blue, "float", alpha)
    }

    /**
     * Sets the current color from an already existing array of color values. | glColor4fv function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Pointer<Single>} v A pointer to an array that contains red, green, blue, and alpha values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor4fv
     */
    static glColor4fv(v) {
        DllCall("OPENGL32.dll\glColor4fv", "ptr", v)
    }

    /**
     * Sets the current color. | glColor4i function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Integer} red The new red value for the current color.
     * @param {Integer} green The new green value for the current color.
     * @param {Integer} blue The new blue value for the current color.
     * @param {Integer} alpha The new alpha value for the current color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor4i
     */
    static glColor4i(red, green, blue, alpha) {
        DllCall("OPENGL32.dll\glColor4i", "int", red, "int", green, "int", blue, "int", alpha)
    }

    /**
     * Sets the current color from an already existing array of color values. | glColor4iv function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Pointer<Int32>} v A pointer to an array that contains red, green, blue, and alpha values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor4iv
     */
    static glColor4iv(v) {
        DllCall("OPENGL32.dll\glColor4iv", "ptr", v)
    }

    /**
     * Sets the current color. | glColor4s function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Integer} red The new red value for the current color.
     * @param {Integer} green The new green value for the current color.
     * @param {Integer} blue The new blue value for the current color.
     * @param {Integer} alpha The new alpha value for the current color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor4s
     */
    static glColor4s(red, green, blue, alpha) {
        DllCall("OPENGL32.dll\glColor4s", "short", red, "short", green, "short", blue, "short", alpha)
    }

    /**
     * Sets the current color from an already existing array of color values. | glColor4sv function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Pointer<Int16>} v A pointer to an array that contains red, green, blue, and alpha values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor4sv
     */
    static glColor4sv(v) {
        DllCall("OPENGL32.dll\glColor4sv", "ptr", v)
    }

    /**
     * Sets the current color. | glColor4ub function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Integer} red The new red value for the current color.
     * @param {Integer} green The new green value for the current color.
     * @param {Integer} blue The new blue value for the current color.
     * @param {Integer} alpha The new alpha value for the current color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor4ub
     */
    static glColor4ub(red, green, blue, alpha) {
        DllCall("OPENGL32.dll\glColor4ub", "char", red, "char", green, "char", blue, "char", alpha)
    }

    /**
     * Sets the current color from an already existing array of color values. | glColor4ubv function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Pointer<Byte>} v A pointer to an array that contains red, green, blue, and alpha values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor4ubv
     */
    static glColor4ubv(v) {
        DllCall("OPENGL32.dll\glColor4ubv", "ptr", v)
    }

    /**
     * Sets the current color. | glColor4ui function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Integer} red The new red value for the current color.
     * @param {Integer} green The new green value for the current color.
     * @param {Integer} blue The new blue value for the current color.
     * @param {Integer} alpha The new alpha value for the current color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor4ui
     */
    static glColor4ui(red, green, blue, alpha) {
        DllCall("OPENGL32.dll\glColor4ui", "uint", red, "uint", green, "uint", blue, "uint", alpha)
    }

    /**
     * Sets the current color from an already existing array of color values. | glColor4uiv function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Pointer<UInt32>} v A pointer to an array that contains red, green, blue, and alpha values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor4uiv
     */
    static glColor4uiv(v) {
        DllCall("OPENGL32.dll\glColor4uiv", "ptr", v)
    }

    /**
     * Sets the current color. | glColor4us function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Integer} red The new red value for the current color.
     * @param {Integer} green The new green value for the current color.
     * @param {Integer} blue The new blue value for the current color.
     * @param {Integer} alpha The new alpha value for the current color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor4us
     */
    static glColor4us(red, green, blue, alpha) {
        DllCall("OPENGL32.dll\glColor4us", "ushort", red, "ushort", green, "ushort", blue, "ushort", alpha)
    }

    /**
     * Sets the current color from an already existing array of color values. | glColor4usv function (Gl.h)
     * @remarks
     * The GL stores both a current single-valued color index and a current four-valued RGBA color. **glcolor** sets a new four-valued RGBA color. **glcolor** has two major variants: **glcolor3** and **glcolor4**. **glcolor3** variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. **glcolor4** variants specify all four color components explicitly.
     * 
     * **glcolor3b**, **glcolor4b**, **glcolor3s**, **glcolor4s**, **glcolor3i**, and **glcolor4i** take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
     * 
     * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
     * 
     * Neither floating-point nor signed integer values are clamped to the range \[0,1\] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     * @param {Pointer<UInt16>} v A pointer to an array that contains red, green, blue, and alpha values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolor4usv
     */
    static glColor4usv(v) {
        DllCall("OPENGL32.dll\glColor4usv", "ptr", v)
    }

    /**
     * The glColorMask function enables and disables writing of frame-buffer color components.
     * @remarks
     * The **glColorMask** function specifies whether the individual color components in the framebuffer can or cannot be written. If *red* is GL\_FALSE, for example, no change is made to the red component of any pixel in any of the color buffers, regardless of the drawing operation attempted.
     * 
     * Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled for entire color components.
     * 
     * The following functions retrieve information related to **glColorMask**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_COLOR\_WRITEMASK
     * 
     * **glGet** with argument GL\_RGBA\_MODE
     * @param {Integer} red Specify whether red can or cannot be written into the framebuffer. The default values is GL\_TRUE, indicating that the color component can be written.
     * @param {Integer} green Specify whether green can or cannot be written into the framebuffer. The default value is GL\_TRUE, indicating that the color component can be written.
     * @param {Integer} blue Specify whether blue can or cannot be written into the framebuffer. The default value is GL\_TRUE, indicating that the color component can be written.
     * @param {Integer} alpha Specify whether alpha can or cannot be written into the framebuffer. The default value is GL\_TRUE, indicating that the color component can be written.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolormask
     */
    static glColorMask(red, green, blue, alpha) {
        DllCall("OPENGL32.dll\glColorMask", "char", red, "char", green, "char", blue, "char", alpha)
    }

    /**
     * The glColorMaterial function causes a material color to track the current color.
     * @remarks
     * The **glColorMaterial** function specifies which material parameters track the current color. When you enable GL\_COLOR\_MATERIAL, for each of the material or materials specified by *face*, the material parameter or parameters specified by *mode* track the current color at all times. Enable and disable GL\_COLOR\_MATERIAL with the functions [**glEnable**](glenable.md) and [**glDisable**](gldisable.md), which you call with GL\_COLOR\_MATERIAL as their argument. By default, GL\_COLOR\_MATERIAL is disabled.
     * 
     * With **glColorMaterial**, you can change a subset of material parameters for each vertex using only the [**glColor**](glcolor-functions.md) function, without calling [**glMaterial**](glmaterial-functions.md). If you are going to specify only such a subset of parameters for each vertex, it is better to do so with **glColorMaterial** than with **glMaterial**.
     * 
     * The following functions retrieve information related to **glColorMaterial**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_COLOR\_MATERIAL\_PARAMETER
     * 
     * **glGet** with argument GL\_COLOR\_MATERIAL\_FACE
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_COLOR\_MATERIAL
     * @param {Integer} face Specifies whether front, back, or both front and back material parameters should track the current color. Accepted values are GL\_FRONT, GL\_BACK, and GL\_FRONT\_AND\_BACK. The default value is GL\_FRONT\_AND\_BACK.
     * @param {Integer} mode Specifies which of several material parameters track the current color. Accepted values are GL\_EMISSION, GL\_AMBIENT, GL\_DIFFUSE, GL\_SPECULAR, and GL\_AMBIENT\_AND\_DIFFUSE. The default value is GL\_AMBIENT\_AND\_DIFFUSE.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolormaterial
     */
    static glColorMaterial(face, mode) {
        DllCall("OPENGL32.dll\glColorMaterial", "uint", face, "uint", mode)
    }

    /**
     * The glColorPointer function defines an array of colors.
     * @remarks
     * The **glColorPointer** function specifies the location and data format of an array of color components to use when rendering. The *stride* parameter determines the byte offset from one color to the next, enabling the packing of vertex attributes in a single array or storage in separate arrays. In some implementations, storing vertex attributes in a single array can be more efficient than the use of separate arrays.
     * 
     * Enabled the color array by specifying the GL\_COLOR\_ARRAY constant with [**glEnableClientState**](glenableclientstate.md). Calling [**glArrayElement**](glarrayelement.md), [**glDrawElements**](gldrawelements.md), or [**glDrawArrays**](gldrawarrays.md) uses the color array that is thus enabled. By default, the color array is disabled. The **glColorPointer** calls cannot by entered in display lists.
     * 
     * When you specify a color array using **glColorPointer**, the values of all the function's color array parameters are saved in a client-side state, and you can cache static array elements. Because the color array parameters are in a client-side state, [**glPushAttrib**](glpushattrib.md) and [**glPopAttrib**](glpopattrib.md) do not save or restore the parameters' values.
     * 
     * Although specifying the color array within [**glBegin**](glbegin.md) and [**glend**](glend.md) pairs does not generate an error, the results are undefined.
     * 
     * The following functions retrieve information related to the **glColorPointer** function:
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_COLOR\_ARRAY
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_COLOR\_ARRAY\_SIZE
     * 
     * **glGet** with argument GL\_COLOR\_ARRAY\_TYPE
     * 
     * **glGet** with argument GL\_COLOR\_ARRAY\_STRIDE
     * 
     * **glGet** with argument GL\_COLOR\_ARRAY\_COUNT
     * 
     * [**glGetPointerv**](glgetpointerv.md) with argument GL\_COLOR\_ARRAY\_POINTER
     * @param {Integer} size The number of components per color. The value must be either 3 or 4.
     * @param {Integer} type The data type of each color component in a color array. Acceptable data types are specified with the following constants: GL\_BYTE, GL\_UNSIGNED\_BYTE, GL\_SHORT, GL\_UNSIGNED\_SHORT, GL\_INT, GL\_UNSIGNED\_INT, GL\_FLOAT, or GL\_DOUBLE.
     * @param {Integer} stride The byte offset between consecutive colors. When *stride* is zero, the colors are tightly packed in the array.
     * @param {Pointer<Void>} pointer A pointer to the first component of the first color element in a color array.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcolorpointer
     */
    static glColorPointer(size, type, stride, pointer) {
        DllCall("OPENGL32.dll\glColorPointer", "int", size, "uint", type, "int", stride, "ptr", pointer)
    }

    /**
     * The glCopyPixels function copies pixels in the framebuffer.
     * @remarks
     * The **glCopyPixels** function copies a screen-aligned rectangle of pixels from the specified framebuffer location to a region relative to the current raster position. Its operation is well defined only if the entire pixel source region is within the exposed portion of the window. Results of copies from outside the window, or from regions of the window that are not exposed, are hardware dependent and undefined.
     * 
     * The *x* and *y* parameters specify the window coordinates of the lower-left corner of the rectangular region to be copied. The *width* and *height* parameters specify the dimensions of the rectangular region to be copied. Both *width* and *height* must be nonnegative.
     * 
     * Several parameters control the processing of the pixel data while it is being copied. These parameters are set with three functions: [**glPixelTransfer**](glpixeltransfer.md), [**glPixelMap**](glpixelmap.md), and [**glPixelZoom**](glpixelzoom.md). This topic describes the effects on **glCopyPixels** of most, but not all, of the parameters specified by these three functions.
     * 
     * The **glCopyPixels** function copies values from each pixel with the lower-left corner at (*x* + *i*, *y* + *j*) for 0 = *i* < *width* and 0 = *j* < *height*. This pixel is said to be the *i* pixel in the *j* row. Pixels are copied in row order from the lowest to the highest row, left to right in each row.
     * 
     * The *type* parameter specifies whether color, depth, or stencil data is to be copied.
     * 
     * The rasterization described thus far assumes pixel zoom factors of 1.0. If you use [**glPixelZoom**](glpixelzoom.md) to change the *x* and *y* pixel zoom factors, pixels are converted to fragments as follows. If (*x*<sub>r</sub> , *y*<sub>r</sub> ) is the current raster position, and a given pixel is in the *i* location in the *j* row of the source pixel rectangle, then fragments are generated for pixels whose centers are in the rectangle with corners at
     * 
     * (*x*<sub>r</sub> + *zoom*? i, y<sub>r</sub> + *zoom*<sub>y</sub> *j*)
     * 
     * and
     * 
     * (*x*<sub>r</sub> + *zoom*? (*i* + 1), *y*<sub>r</sub> + *zoom*<sub>y</sub> (*j* + 1))
     * 
     * where *zoom*? is the value of GL\_ZOOM\_X and *zoom*<sub>y</sub> is the value of GL\_ZOOM\_Y.
     * 
     * Modes specified by [**glPixelStore**](glpixelstore-functions.md) have no effect on the operation of **glCopyPixels**.
     * 
     * The following functions retrieve information related to **glCopyPixels**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION
     * 
     * **glGet** with argument GL\_CURRENT\_RASTER\_POSITION\_VALID
     * 
     * To copy the color pixel in the lower-left corner of the window to the current raster position, use
     * 
     * **glCopyPixels**( 0, 0, 1, 1, GL\_COLOR );
     * @param {Integer} x The window x-plane coordinate of the lower-left corner of the rectangular region of pixels to be copied.
     * @param {Integer} y The window y-plane coordinate of the lower-left corner of the rectangular region of pixels to be copied.
     * @param {Integer} width The width dimension of the rectangular region of pixels to be copied. Must be nonnegative.
     * @param {Integer} height The height dimension of the rectangular region of pixels to be copied. Must be nonnegative.
     * @param {Integer} type Specifies whether **glCopyPixels** is to copy color values, depth values, or stencil values. The acceptable symbolic constants are.
     * 
     * 
     * 
     * 
     * | Value | Meaning | 
     * |-------|---------|
     * | <span id="GL_COLOR"></span><span id="gl_color"></span><dl><dt><strong>GL_COLOR</strong></dt></dl> | The <strong>glCopyPixels</strong> function reads indexes or RGBA colors from the buffer currently specified as the read source buffer (see <a href="glreadbuffer.md"><strong>glReadBuffer</strong></a>). <br /> If OpenGL is in color-index mode:<br /><ol><li>Each index that is read from this buffer is converted to a fixed-point format with an unspecified number of bits to the right of the binary point.</li><li>Each index is shifted left by GL_INDEX_SHIFT bits, and added to GL_INDEX_OFFSET.If GL_INDEX_SHIFT is negative, the shift is to the right. In either case, zero bits fill otherwise unspecified bit locations in the result.<br /></li><li>If GL_MAP_COLOR is true, the index is replaced with the value that it references in lookup table GL_PIXEL_MAP_I_TO_I.</li><li>Whether the lookup replacement of the index is done or not, the integer part of the index is then <strong>AND</strong>ed with 2<em><sup>b</sup></em> 1, where <em>b</em> is the number of bits in a color-index buffer.</li></ol>If OpenGL is in RGBA mode:<br /><ol><li>The red, green, blue, and alpha components of each pixel that is read are converted to an internal floating-point format with unspecified precision.</li><li>The conversion maps the largest representable component value to 1.0, and component value zero to 0.0.</li><li>The resulting floating-point color values are then multiplied by GL_c_SCALE and added to GL_c_BIAS, where <em>c</em> is RED, GREEN, BLUE, and ALPHA for the respective color components.</li><li>The results are clamped to the range [0,1].</li><li>If GL_MAP_COLOR is true, each color component is scaled by the size of lookup table GL_PIXEL_MAP_c_TO_c, and then replaced by the value that it references in that table; <em>c</em> is R, G, B, or A, respectively. The resulting indexes or RGBA colors are then converted to fragments by attaching the current raster position <em>z</em>-coordinate and texture coordinates to each pixel, and then assigning window coordinates (<em>x</em><sub>r</sub> + i, <em>y</em><sub>r</sub> + <em>j</em>), where (<em>x</em><sub>r</sub> , <em>y</em><sub>r</sub> ) is the current raster position, and the pixel was the pixel in the <em>i</em> position in the <em>j</em> row. These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the framebuffer.<br /></li></ol> | 
     * | <span id="GL_DEPTH"></span><span id="gl_depth"></span><dl><dt><strong>GL_DEPTH</strong></dt></dl> | Depth values are read from the depth buffer and converted directly to an internal floating-point format with unspecified precision. The resulting floating-point depth value is then multiplied by GL_DEPTH_SCALE and added to GL_DEPTH_BIAS. The result is clamped to the range [0,1]. <br /> The resulting depth components are then converted to fragments by attaching the current raster position color or color index and texture coordinates to each pixel, then assigning window coordinates (<em>x</em><sub>r</sub> + i, <em>y</em><sub>r</sub> + <em>j</em>), where (<em>x</em><sub>r</sub> , <em>y</em><sub>r</sub> ) is the current raster position, and the pixel was the pixel in the <em>i</em> position in the <em>j</em> row. These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the framebuffer.<br /> | 
     * | <span id="GL_STENCIL"></span><span id="gl_stencil"></span><dl><dt><strong>GL_STENCIL</strong></dt></dl> | Stencil indexes are read from the stencil buffer and converted to an internal fixed-point format with an unspecified number of bits to the right of the binary point. Each fixed-point index is then shifted left by GL_INDEX_SHIFT bits, and added to GL_INDEX_OFFSET. If GL_INDEX_SHIFT is negative, the shift is to the right. In either case, zero bits fill otherwise unspecified bit locations in the result. If GL_MAP_STENCIL is true, the index is replaced with the value that it references in lookup table GL_PIXEL_MAP_S_TO_S. Whether the lookup replacement of the index is done or not, the integer part of the index is then <strong>AND</strong>ed with 2<sup>b</sup> - 1, where <em>b</em> is the number of bits in the stencil buffer. The resulting stencil indexes are then written to the stencil buffer such that the index read from the <em>i</em> location of the <em>j</em> row is written to location (<em>x</em><sub>r</sub> + <em>i</em>, <em>y</em><sub>r</sub> + <em>j</em>), where (<em>x</em><sub>r</sub> , <em>y</em><sub>r</sub> ) is the current raster position. Only the pixel-ownership test, the scissor test, and the stencil writemask affect these writes.<br /> |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcopypixels
     */
    static glCopyPixels(x, y, width, height, type) {
        DllCall("OPENGL32.dll\glCopyPixels", "int", x, "int", y, "int", width, "int", height, "uint", type)
    }

    /**
     * The glCopyTexImage1D function copies pixels from the framebuffer into a one-dimensional texture image.
     * @remarks
     * The **glCopyTexImage1D** function defines a one-dimensional texture image using pixels from the current framebuffer, rather than from main memory as is the case for [**glTexImage1D**](glteximage1d.md).
     * 
     * Using the mipmap level specified with *level*, texture arrays are defined as a pixel row aligned with the lower-left corner of the window at the coordinates specified by *x* and *y*, with a length equal to *width* + 2 \* *border*. The internal format of the texture array is specified with the *internalFormat* parameter.
     * 
     * The **glCopyTexImage1D** function processes the pixels in a row in the same way as [**glCopyPixels**](glcopypixels.md), except that before the final conversion of the pixels, all pixel component values are clamped to the range \[0,1\] and converted to the texture's internal format for storage in the texture array. Pixel ordering is determined with lower *x* coordinates corresponding to lower texture coordinates. If any of the pixels within a specified row of the current framebuffer are outside the window associated with the current rendering context, then their values are undefined.
     * 
     * You cannot include calls to **glCopyTexImage1D** in display lists.
     * 
     * > [!Note]  
     * > The **glCopyTexImage1D** function is only available in OpenGL version 1.1 or later.
     * 
     *  
     * 
     * Texturing has no effect in color-index mode. The [**glPixelStore**](glpixelstore-functions.md) and [**glPixelTransfer**](glpixeltransfer.md) functions affect texture images in exactly the way they affect [**glDrawPixels**](gldrawpixels.md).
     * 
     * The following function retrieves information related to **glCopyTexImage1D**:
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_1D
     * @param {Integer} target The target for which the image data will be changed. Must have the value GL\_TEXTURE\_1D.
     * @param {Integer} level The level-of-detail number. Level 0 is the base image. Level *n* is the *n*th mipmap reduction image.
     * @param {Integer} internalFormat The internal format and resolution of the texture data. This parameter must be one of the following symbolic values.
     * 
     * 
     * 
     * | Constant                 | R Bits | G Bits | B Bits | A Bits | L Bits | I Bits |
     * |--------------------------|--------|--------|--------|--------|--------|--------|
     * | GL\_ALPHA                |        |        |        |        |        |        |
     * | GL\_ALPHA4               |        |        |        | 4      |        |        |
     * | GL\_ALPHA8               |        |        |        | 8      |        |        |
     * | GL\_ALPHA12              |        |        |        | 12     |        |        |
     * | GL\_ALPHA16              |        |        |        | 16     |        |        |
     * | GL\_LUMINANCE            |        |        |        |        |        |        |
     * | GL\_LUMINANCE4           |        |        |        |        | 4      |        |
     * | GL\_LUMINANCE8           |        |        |        |        | 8      |        |
     * | GL\_LUMINANCE12          |        |        |        |        | 12     |        |
     * | GL\_LUMINANCE16          |        |        |        |        | 16     |        |
     * | GL\_LUMINANCE\_ALPHA     |        |        |        |        |        |        |
     * | GL\_LUMINANCE4\_ALPHA4   |        |        |        | 4      | 4      |        |
     * | GL\_LUMINANCE6\_ALPHA2   |        |        |        | 2      | 6      |        |
     * | GL\_LUMINANCE8\_ALPHA8   |        |        |        | 8      | 8      |        |
     * | GL\_LUMINANCE12\_ALPHA4  |        |        |        | 4      | 12     |        |
     * | GL\_LUMINANCE12\_ALPHA12 |        |        |        | 12     | 12     |        |
     * | GL\_LUMINANCE16\_ALPHA16 |        |        |        | 16     | 16     |        |
     * | GL\_INTENSITY            |        |        |        |        |        |        |
     * | GL\_INTENSITY4           |        |        |        |        |        | 4      |
     * | GL\_INTENSITY8           |        |        |        |        |        | 8      |
     * | GL\_INTENSITY12          |        |        |        |        |        | 12     |
     * | GL\_INTENSITY16          |        |        |        |        |        | 16     |
     * | GL\_RGB                  |        |        |        |        |        |        |
     * | GL\_R3\_G3\_B2           | 3      | 3      | 2      |        |        |        |
     * | GL\_RGB4                 | 4      | 4      | 4      |        |        |        |
     * | GL\_RGB5                 | 5      | 5      | 5      |        |        |        |
     * | GL\_RGB8                 | 8      | 8      | 8      |        |        |        |
     * | GL\_RGB10                | 10     | 10     | 10     |        |        |        |
     * | GL\_RGB12                | 12     | 12     | 12     |        |        |        |
     * | GL\_RGB16                | 16     | 16     | 16     |        |        |        |
     * | GL\_RGBA                 |        |        |        |        |        |        |
     * | GL\_RGBA2                | 2      | 2      | 2      | 2      |        |        |
     * | GL\_RGBA4                | 4      | 4      | 4      | 4      |        |        |
     * | GL\_RGB5\_A1             | 5      | 5      | 5      | 1      |        |        |
     * | GL\_RGBA8                | 8      | 8      | 8      | 8      |        |        |
     * | GL\_RGB10\_A2            | 10     | 10     | 10     | 2      |        |        |
     * | GL\_RGBA12               | 12     | 12     | 12     | 12     |        |        |
     * | GL\_RGBA16               | 16     | 16     | 16     | 16     |        |        |
     * @param {Integer} x The window x-plane coordinate of the lower-left corner of the row of pixels to be copied.
     * @param {Integer} y The window y-plane coordinate of the lower-left corner of the row of pixels to be copied.
     * @param {Integer} width The width of the texture image. Must be zero or 2n + 2(*border*) for some integer *n*. The height of the texture image is 1.
     * @param {Integer} border The width of the border. Must be either zero or 1.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcopyteximage1d
     */
    static glCopyTexImage1D(target, level, internalFormat, x, y, width, border) {
        DllCall("OPENGL32.dll\glCopyTexImage1D", "uint", target, "int", level, "uint", internalFormat, "int", x, "int", y, "int", width, "int", border)
    }

    /**
     * The glCopyTexImage2D function copies pixels from the framebuffer into a two-dimensional texture image.
     * @remarks
     * The **glCopyTexImage2D** function defines a two-dimensional texture image using pixels from the current framebuffer, rather than from main memory as is the case for [**glTexImage2D**](glteximage2d.md).
     * 
     * Using the mipmap level specified with *level*, texture arrays are defined as a rectangle of pixels with the lower-left corner located at the coordinates *x* and *y*, width equal to *width* + (2 \* *border*), and a height equal to *height* + (2 \* *border*). The internal format of the texture array is specified with the *internalFormat* parameter.
     * 
     * The **glCopyTexImage2D** function processes the pixels in a row in the same way as [**glCopyPixels**](glcopypixels.md) except that before the final conversion of the pixels, all pixel component values are clamped to the range \[0,1\] and converted to the texture's internal format for storage in the texture array. Pixel ordering is determined with lower *x* and *y* coordinates corresponding to lower *s* and *t* texture coordinates. If any of the pixels within a specified row of the current framebuffer are outside the window associated with the current rendering context, then their values are undefined.
     * 
     * You cannot include calls to **glCopyTexImage2D** in display lists.
     * 
     * > [!Note]  
     * > The **glCopyTexImage2D** function is only available in OpenGL version 1.1 or later.
     * 
     *  
     * 
     * Texturing has no effect in color-index mode. The [**glPixelStore**](glpixelstore-functions.md) and [**glPixelTransfer**](glpixeltransfer.md) functions affect texture images in exactly the way they affect [**glDrawPixels**](gldrawpixels.md).
     * 
     * The following function retrieves information related to **glCopyTexImage2D**:
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_2D
     * @param {Integer} target The target to which the image data will be changed. Must have the value GL\_TEXTURE\_2D.
     * @param {Integer} level The level-of-detail number. Level 0 is the base image. Level *n* is the *n*th mipmap reduction image.
     * @param {Integer} internalFormat The internal format and resolution of the texture data. The values 1, 2, 3, and 4 are not accepted for *internalFormat*. The parameter can assume one of the following symbolic values.
     * 
     * 
     * 
     * | Constant                 | R Bits | G Bits | B Bits | A Bits | L Bits | I Bits |
     * |--------------------------|--------|--------|--------|--------|--------|--------|
     * | GL\_ALPHA                |        |        |        |        |        |        |
     * | GL\_ALPHA4               |        |        |        | 4      |        |        |
     * | GL\_ALPHA8               |        |        |        | 8      |        |        |
     * | GL\_ALPHA12              |        |        |        | 12     |        |        |
     * | GL\_ALPHA16              |        |        |        | 16     |        |        |
     * | GL\_LUMINANCE            |        |        |        |        |        |        |
     * | GL\_LUMINANCE4           |        |        |        |        | 4      |        |
     * | GL\_LUMINANCE8           |        |        |        |        | 8      |        |
     * | GL\_LUMINANCE12          |        |        |        |        | 12     |        |
     * | GL\_LUMINANCE16          |        |        |        |        | 16     |        |
     * | GL\_LUMINANCE\_ALPHA     |        |        |        |        |        |        |
     * | GL\_LUMINANCE4\_ALPHA4   |        |        |        | 4      | 4      |        |
     * | GL\_LUMINANCE6\_ALPHA2   |        |        |        | 2      | 6      |        |
     * | GL\_LUMINANCE8\_ALPHA8   |        |        |        | 8      | 8      |        |
     * | GL\_LUMINANCE12\_ALPHA4  |        |        |        | 4      | 12     |        |
     * | GL\_LUMINANCE12\_ALPHA12 |        |        |        | 12     | 12     |        |
     * | GL\_LUMINANCE16\_ALPHA16 |        |        |        | 16     | 16     |        |
     * | GL\_INTENSITY            |        |        |        |        |        |        |
     * | GL\_INTENSITY4           |        |        |        |        |        | 4      |
     * | GL\_INTENSITY8           |        |        |        |        |        | 8      |
     * | GL\_INTENSITY12          |        |        |        |        |        | 12     |
     * | GL\_INTENSITY16          |        |        |        |        |        | 16     |
     * | GL\_RGB                  |        |        |        |        |        |        |
     * | GL\_R3\_G3\_B2           | 3      | 3      | 2      |        |        |        |
     * | GL\_RGB4                 | 4      | 4      | 4      |        |        |        |
     * | GL\_RGB5                 | 5      | 5      | 5      |        |        |        |
     * | GL\_RGB8                 | 8      | 8      | 8      |        |        |        |
     * | GL\_RGB10                | 10     | 10     | 10     |        |        |        |
     * | GL\_RGB12                | 12     | 12     | 12     |        |        |        |
     * | GL\_RGB16                | 16     | 16     | 16     |        |        |        |
     * | GL\_RGBA                 |        |        |        |        |        |        |
     * | GL\_RGBA2                | 2      | 2      | 2      | 2      |        |        |
     * | GL\_RGBA4                | 4      | 4      | 4      | 4      |        |        |
     * | GL\_RGB5\_A1             | 5      | 5      | 5      | 1      |        |        |
     * | GL\_RGBA8                | 8      | 8      | 8      | 8      |        |        |
     * | GL\_RGB10\_A2            | 10     | 10     | 10     | 2      |        |        |
     * | GL\_RGBA12               | 12     | 12     | 12     | 12     |        |        |
     * | GL\_RGBA16               | 16     | 16     | 16     | 16     |        |        |
     * @param {Integer} x The window x-plane coordinate of the lower-left corner of the rectangular region of pixels to be copied.
     * @param {Integer} y The window y-plane coordinate of the lower-left corner of the rectangular region of pixels to be copied.
     * @param {Integer} width The width of the texture image. Must be 2n + 2 \* *border* for some integer *n*.
     * @param {Integer} height The height of the texture image. Must be 2n + 2 \* *border* for some integer *n*.
     * @param {Integer} border The width of the border. Must be either zero or 1.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcopyteximage2d
     */
    static glCopyTexImage2D(target, level, internalFormat, x, y, width, height, border) {
        DllCall("OPENGL32.dll\glCopyTexImage2D", "uint", target, "int", level, "uint", internalFormat, "int", x, "int", y, "int", width, "int", height, "int", border)
    }

    /**
     * The glCopyTexSubImage1D function copies a sub-image of a one-dimensional texture image from the framebuffer.
     * @remarks
     * The **glCopyTexSubImage1D** function replaces a portion of a one-dimensional texture image using pixels from the current framebuffer, rather than from main memory as is the case for [**glTexSubImage1D**](gltexsubimage1d.md).
     * 
     * A row of pixels beginning with the window coordinates specified by *x* and *y* and with the length *width* replaces the portion of the texture array with the indexes *xoffset* through *xoffset* + (*width* - 1). The destination in the texture array cannot include any texels outside the originally specified texture array.
     * 
     * The **glCopyTexSubImage1D** function processes the pixels in a row in the same way as [**glCopyPixels**](glcopypixels.md) except that before the final conversion of the pixels, all pixel component values are clamped to the range \[0,1\] and converted to the texture's internal format for storage in the texture array. Pixel ordering is determined with lower *x* coordinates corresponding to lower texture coordinates. If any of the pixels within a specified row of the current framebuffer are outside the window associated with the current rendering context, then their values are undefined.
     * 
     * No change is made to the *internalFormat*, *width*, or *border* parameter of the specified texture array or to texel values outside the specified texture sub-image.
     * 
     * You cannot include calls to **glCopyTexSubImage1D** in display lists.
     * 
     * > [!Note]  
     * > The **glCopyTexSubImage1D** function is only available in OpenGL version 1.1 or later.
     * 
     *  
     * 
     * Texturing has no effect in color-index mode. The [**glPixelStore**](glpixelstore-functions.md) and [**glPixelTransfer**](glpixeltransfer.md) functions affect texture images in exactly the way they affect the way pixels are drawn using [**glDrawPixels**](gldrawpixels.md).
     * 
     * The following functions retrieve information related to **glCopyTexSubImage1D**:
     * 
     * [**glGetTexImage**](glgetteximage.md)
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_1D
     * @param {Integer} target The target to which the image data will be changed. Must have the value GL\_TEXTURE\_1D.
     * @param {Integer} level The level-of-detail number. Level 0 is the base image. Level *n* is the *n*th mipmap reduction image.
     * @param {Integer} xoffset The texel offset within the texture array.
     * @param {Integer} x The window x-plane coordinate of the lower-left corner of the row of pixels to be copied.
     * @param {Integer} y The window y-plane coordinate of the lower-left corner of the row of pixels to be copied.
     * @param {Integer} width The width of the sub-image of the texture image. Specifying a texture sub-image with zero width has no effect.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcopytexsubimage1d
     */
    static glCopyTexSubImage1D(target, level, xoffset, x, y, width) {
        DllCall("OPENGL32.dll\glCopyTexSubImage1D", "uint", target, "int", level, "int", xoffset, "int", x, "int", y, "int", width)
    }

    /**
     * The glCopyTexSubImage2D function copies a sub-image of a two-dimensional texture image from the framebuffer.
     * @remarks
     * The **glCopyTexSubImage2D** function replaces a rectangular portion of a two-dimensional texture image with pixels from the current framebuffer, rather than from main memory as is the case for [**glTexSubImage2D**](gltexsubimage2d.md).
     * 
     * A rectangle of pixels beginning with the *x* and *y* window coordinates and with the dimensions *width* and *height* replaces the portion of the texture array with the indexes *xoffset* through *xoffset* + (*width* - 1), with the indexes *yoffset* through *yoffset* + (*width* - 1) at the mipmap level specified by *level*. The destination rectangle in the texture array cannot include any texels outside the originally specified texture array.
     * 
     * The **glCopyTexSubImage2D** function processes the pixels in a row in the same way as [**glCopyPixels**](glcopypixels.md), except that before the final conversion of the pixels, all pixel component values are clamped to the range \[0,1\] and converted to the texture's internal format for storage in the texture array. Pixel ordering is determined with lower *x* coordinates corresponding to lower texture coordinates. If any of the pixels within a specified row of the current framebuffer are outside the window associated with the current rendering context, then their values are undefined.
     * 
     * If any of the pixels within the specified rectangle of the current framebuffer are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined. No change is made to the *internalFormat*, *width*, *height*, or *border* parameter of the specified texture array or to texel values outside the specified texture sub-image.
     * 
     * You cannot include calls to **glCopyTexSubImage2D** in display lists.
     * 
     * > [!Note]  
     * > The **glCopyTexSubImage2D** function is only available in OpenGL version 1.1 or later.
     * 
     *  
     * 
     * Texturing has no effect in color-index mode. The [**glPixelStore**](glpixelstore-functions.md) and [**glPixelTransfer**](glpixeltransfer.md) functions affect texture images in exactly the way they affect the way pixels are drawn using [**glDrawPixels**](gldrawpixels.md).
     * 
     * The following functions retrieve information related to **glCopyTexSubImage2D**:
     * 
     * [**glGetTexImage**](glgetteximage.md)
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_2D
     * @param {Integer} target The target to which the image data will be changed. Must have the value GL\_TEXTURE\_2D.
     * @param {Integer} level The level-of-detail number. Level 0 is the base image. Level *n* is the *n*th mipmap reduction image.
     * @param {Integer} xoffset The texel offset in the *x* direction within the texture array.
     * @param {Integer} yoffset The texel offset in the *y* direction within the texture array.
     * @param {Integer} x The window x-plane coordinates of the lower-left corner of the row of pixels to be copied.
     * @param {Integer} y The window y-plane coordinates of the lower-left corner of the row of pixels to be copied.
     * @param {Integer} width The width of the sub-image of the texture image. Specifying a texture sub-image with zero width has no effect.
     * @param {Integer} height The height of the sub-image of the texture image. Specifying a texture sub-image with zero width has no effect.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcopytexsubimage2d
     */
    static glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height) {
        DllCall("OPENGL32.dll\glCopyTexSubImage2D", "uint", target, "int", level, "int", xoffset, "int", yoffset, "int", x, "int", y, "int", width, "int", height)
    }

    /**
     * The glCullFace function specifies whether front-facing or back-facing facets can be culled.
     * @remarks
     * The **glCullFace** function specifies whether front-facing or back-facing facets are culled (as specified by *mode*) when facet culling is enabled. You enable and disable facet culling using [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with the argument GL\_CULL\_FACE. Facets include triangles, quadrilaterals, polygons, and rectangles.
     * 
     * The [**glFrontFace**](glfrontface.md) function specifies which of the clockwise and counterclockwise facets are front-facing and back-facing.
     * 
     * If *mode* is GL\_FRONT\_AND\_BACK, no facets are drawn, but other primitives, such as points and lines, are drawn.
     * 
     * The following functions retrieve information related to **glCullFace**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CULL\_FACE\_MODE
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_CULL\_FACE
     * @param {Integer} mode Specifies whether front-facing or back-facing facets are candidates for culling. The symbolic constants GL\_FRONT, GL\_BACK, and GL\_FRONT\_AND\_BACK are accepted. The default value is GL\_BACK.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glcullface
     */
    static glCullFace(mode) {
        DllCall("OPENGL32.dll\glCullFace", "uint", mode)
    }

    /**
     * The glDeleteLists function deletes a contiguous group of display lists.
     * @remarks
     * The **glDeleteLists** function causes a contiguous group of display lists to be deleted. The *list* parameter is the name of the first display list to be deleted, and *range* is the number of display lists to delete. All display lists *d* with *list* = *d* = *list* + *range* - 1 are deleted.
     * 
     * All storage locations allocated to the specified display lists are freed, and the names are available for reuse at a later time. Names within the range that do not have an associated display list are ignored. If *range* is zero, nothing happens.
     * @param {Integer} list The integer name of the first display list to delete.
     * @param {Integer} range The number of display lists to delete.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gldeletelists
     */
    static glDeleteLists(list, range) {
        DllCall("OPENGL32.dll\glDeleteLists", "uint", list, "int", range)
    }

    /**
     * The glDeleteTextures function deletes named textures.
     * @remarks
     * The **glDeleteTextures** function deletes *n* textures named by the elements of the array *textures*. After a texture is deleted, it has no contents or dimensionality, and its name is free for reuse (for example, by **glGenTextures**). The **glDeleteTextures** function ignores zeros and names that do not correspond to existing textures.
     * 
     * If a texture that is currently bound is deleted, the binding reverts to zero (the default texture).
     * 
     * You cannot include calls to **glDeleteTextures** in display lists.
     * 
     * > [!Note]  
     * > The **glDeleteTextures** function is only available in OpenGL version 1.1 or later.
     * 
     *  
     * 
     * The following function retrieves information related to **glDeleteTextures**:
     * 
     * -   [**glIsTexture**](glistexture.md)
     * @param {Integer} n The number of textures to be deleted.
     * @param {Pointer<UInt32>} textures An array of textures to be deleted.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gldeletetextures
     */
    static glDeleteTextures(n, textures) {
        DllCall("OPENGL32.dll\glDeleteTextures", "int", n, "ptr", textures)
    }

    /**
     * The glDepthFunc function specifies the value used for depth-buffer comparisons.
     * @remarks
     * The **glDepthFunc** function specifies the function used to compare each incoming pixel *z* value with the *z* value present in the depth buffer. The comparison is performed only if depth testing is enabled. (See [**glEnable**](glenable.md) with the argument GL\_DEPTH\_TEST.)
     * 
     * Initially, depth testing is disabled.
     * 
     * The following functions retrieve information related to **glDepthFunc**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_DEPTH\_FUNC
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_DEPTH\_TEST
     * @param {Integer} func Specifies the depth-comparison function. The following symbolic constants are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                   | Meaning                                                                                                   |
     * |---------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------|
     * | <span id="GL_NEVER"></span><span id="gl_never"></span><dl> <dt>**GL\_NEVER**</dt> </dl>          | Never passes.<br/>                                                                                  |
     * | <span id="GL_LESS"></span><span id="gl_less"></span><dl> <dt>**GL\_LESS**</dt> </dl>             | Passes if the incoming *z* value is less than the stored *z* value. This is the default value.<br/> |
     * | <span id="GL_LEQUAL"></span><span id="gl_lequal"></span><dl> <dt>**GL\_LEQUAL**</dt> </dl>       | Passes if the incoming z value is less than or equal to the stored z value.<br/>                    |
     * | <span id="GL_EQUAL"></span><span id="gl_equal"></span><dl> <dt>**GL\_EQUAL**</dt> </dl>          | Passes if the incoming z value is equal to the stored z value.<br/>                                 |
     * | <span id="GL_GREATER"></span><span id="gl_greater"></span><dl> <dt>**GL\_GREATER**</dt> </dl>    | Passes if the incoming z value is greater than the stored z value.<br/>                             |
     * | <span id="GL_NOTEQUAL"></span><span id="gl_notequal"></span><dl> <dt>**GL\_NOTEQUAL**</dt> </dl> | Passes if the incoming z value is not equal to the stored z value.<br/>                             |
     * | <span id="GL_GEQUAL"></span><span id="gl_gequal"></span><dl> <dt>**GL\_GEQUAL**</dt> </dl>       | Passes if the incoming z value is greater than or equal to the stored z value.<br/>                 |
     * | <span id="GL_ALWAYS"></span><span id="gl_always"></span><dl> <dt>**GL\_ALWAYS**</dt> </dl>       | Always passes.<br/>                                                                                 |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gldepthfunc
     */
    static glDepthFunc(func) {
        DllCall("OPENGL32.dll\glDepthFunc", "uint", func)
    }

    /**
     * The glDepthMask function enables or disables writing into the depth buffer.
     * @remarks
     * The following function retrieves information related to **glDepthMask**:
     * 
     * **glGet** with argument GL\_DEPTH\_WRITEMASK
     * @param {Integer} flag Specifies whether the depth buffer is enabled for writing. If *flag* is zero, depth-buffer writing is disabled. Otherwise, it is enabled. Initially, depth-buffer writing is enabled.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gldepthmask
     */
    static glDepthMask(flag) {
        DllCall("OPENGL32.dll\glDepthMask", "char", flag)
    }

    /**
     * The glDepthRange function specifies the mapping of z values from normalized device coordinates to window coordinates.
     * @remarks
     * After clipping and division by *w*, *z* -coordinates range from 0.0 to 1.0, corresponding to the near and far clipping planes. The **glDepthRange** function specifies a linear mapping of the normalized *z*-coordinates in this range to window *z*-coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0.0 through 1.0 (like color components). Thus, the values accepted by **glDepthRange** are both clamped to this range before they are accepted.
     * 
     * The default mapping of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.
     * 
     * It is not necessary that *zNear* be less than *zFar*. Reverse mappings such as (1,0) are acceptable.
     * 
     * The following function retrieves information related to **glDepthRange**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_DEPTH\_RANGE
     * @param {Float} zNear The mapping of the near clipping plane to window coordinates. The default value is zero.
     * @param {Float} zFar The mapping of the far clipping plane to window coordinates. The default value is 1.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gldepthrange
     */
    static glDepthRange(zNear, zFar) {
        DllCall("OPENGL32.dll\glDepthRange", "double", zNear, "double", zFar)
    }

    /**
     * The glEnable and glDisable functions enable or disable OpenGL capabilities. | glDisable function (Gl.h)
     * @remarks
     * The [**glEnable**](glenable.md) and **glDisable** functions enable and disable various OpenGL graphics capabilities. Use [**glIsEnabled**](glisenabled.md) or [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) to determine the current setting of any capability.
     * 
     * Both [**glEnable**](glenable.md) and **glDisable** take a single argument, *cap*, which can assume one of the following values:
     * 
     * 
     * 
     * | Value                       | Meaning                                                                                                                                                                                                                                                     |
     * |-----------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | GL\_ALPHA\_TEST             | If enabled, do alpha testing. See [**glAlphaFunc**](glalphafunc.md).                                                                                                                                                                                       |
     * | GL\_AUTO\_NORMAL            | If enabled, compute surface normal vectors analytically when either GL\_MAP2\_VERTEX\_3 or GL\_MAP2\_VERTEX\_4 has generated vertices. See [**glMap2**](glmap2.md).                                                                                        |
     * | GL\_BLEND                   | If enabled, blend the incoming RGBA color values with the values in the color buffers. See [**glBlendFunc**](glblendfunc.md).                                                                                                                              |
     * | GL\_CLIP\_PLANE*i*          | If enabled, clip geometry against user-defined clipping plane *i*. See [**glClipPlane**](glclipplane.md).                                                                                                                                                  |
     * | GL\_COLOR\_LOGIC\_OP        | If enabled, apply the current logical operation to the incoming RGBA color and color buffer values. See [**glLogicOp**](gllogicop.md).                                                                                                                     |
     * | GL\_COLOR\_MATERIAL         | If enabled, have one or more material parameters track the current color. See [**glColorMaterial**](glcolormaterial.md).                                                                                                                                   |
     * | GL\_CULL\_FACE              | If enabled, cull polygons based on their winding in window coordinates. See [**glCullFace**](glcullface.md).                                                                                                                                               |
     * | GL\_DEPTH\_TEST             | If enabled, do depth comparisons and update the depth buffer. See [**glDepthFunc**](gldepthfunc.md) and [**glDepthRange**](gldepthrange.md).                                                                                                              |
     * | GL\_DITHER                  | If enabled, dither color components or indexes before they are written to the color buffer.                                                                                                                                                                 |
     * | GL\_FOG                     | If enabled, blend a fog color into the post-texturing color. See [**glFog**](glfog.md).                                                                                                                                                                    |
     * | GL\_INDEX\_LOGIC\_OP        | If enabled, apply the current logical operation to the incoming index and color buffer indices. See [**glLogicOp**](gllogicop.md).                                                                                                                         |
     * | GL\_LIGHT*i*                | If enabled, include light *i* in the evaluation of the lighting equation. See [**glLightModel**](gllightmodel-functions.md) and [**glLight**](gllight-functions.md).                                                                                      |
     * | GL\_LIGHTING                | If enabled, use the current lighting parameters to compute the vertex color or index. If disabled, associate the current color or index with each vertex. See [**glMaterial**](glmaterial-functions.md), **glLightModel**, and **glLight**.                |
     * | GL\_LINE\_SMOOTH            | If enabled, draw lines with correct filtering. If disabled, draw aliased lines. See [**glLineWidth**](gllinewidth.md).                                                                                                                                     |
     * | GL\_LINE\_STIPPLE           | If enabled, use the current line stipple pattern when drawing lines. See [**glLineStipple**](gllinestipple.md).                                                                                                                                            |
     * | GL\_LOGIC\_OP               | If enabled, apply the currently selected logical operation to the incoming and color-buffer indexes. See [**glLogicOp**](gllogicop.md).                                                                                                                    |
     * | GL\_MAP1\_COLOR\_4          | If enabled, calls to [**glEvalCoord1**](glevalcoord-functions.md), [**glEvalMesh1**](glevalmesh-functions.md), and [**glEvalPoint1**](glevalpoint.md) generate RGBA values. See also [**glMap1**](glmap1.md).                                           |
     * | GL\_MAP1\_INDEX             | If enabled, calls to **glEvalCoord1**, **glEvalMesh1**, and **glEvalPoint1** generate color indexes. See also **glMap1**.                                                                                                                                   |
     * | GL\_MAP1\_NORMAL            | If enabled, calls to [**glEvalCoord1**](glevalcoord-functions.md), [**glEvalMesh1**](glevalmesh-functions.md), and [**glEvalPoint1**](glevalpoint.md) generate normals. See also [**glMap1**](glmap1.md).                                               |
     * | GL\_MAP1\_TEXTURE\_COORD\_1 | If enabled, calls to **glEvalCoord1**, **glEvalMesh1**, and **glEvalPoint1** generate *s* texture coordinates. See also **glMap1**.                                                                                                                         |
     * | GL\_MAP1\_TEXTURE\_COORD\_2 | If enabled, calls to [**glEvalCoord1**](glevalcoord-functions.md), [**glEvalMesh1**](glevalmesh-functions.md), and [**glEvalPoint1**](glevalpoint.md) generate *s* and *t* texture coordinates. See also [**glMap1**](glmap1.md).                       |
     * | GL\_MAP1\_TEXTURE\_COORD\_3 | If enabled, calls to **glEvalCoord1**, **glEvalMesh1**, and **glEvalPoint1** generate *s*, *t*, and *r* texture coordinates. See also **glMap1**.                                                                                                           |
     * | GL\_MAP1\_TEXTURE\_COORD\_4 | If enabled, calls to [glEvalCoord1](glevalcoord-functions.md), [glEvalMesh1](glevalmesh-functions.md), and [**glEvalPoint1**](glevalpoint.md) generate *s*, *t*, *r*, and *q* texture coordinates. See also [**glMap1**](glmap1.md).                    |
     * | GL\_MAP1\_VERTEX\_3         | If enabled, calls to **glEvalCoord1**, **glEvalMesh1**, and **glEvalPoint1** generate *x*, *y*, and *z* vertex coordinates. See also **glMap1**.                                                                                                            |
     * | GL\_MAP1\_VERTEX\_4         | If enabled, calls to [**glEvalCoord1**](glevalcoord-functions.md), [**glEvalMesh1**](glevalmesh-functions.md), and [**glEvalPoint1**](glevalpoint.md) generate homogeneous *x*, *y*, *z*, and *w* vertex coordinates. See also [**glMap1**](glmap1.md). |
     * | GL\_MAP2\_COLOR\_4          | If enabled, calls to [**glEvalCoord2**](glevalcoord-functions.md), [**glEvalMesh2**](glevalmesh-functions.md), and [**glEvalPoint2**](glevalpoint.md) generate RGBA values. See also [**glMap2**](glmap2.md).                                           |
     * | GL\_MAP2\_INDEX             | If enabled, calls to **glEvalCoord2**, **glEvalMesh2**, and **glEvalPoint2** generate color indexes. See also **glMap2**.                                                                                                                                   |
     * | GL\_MAP2\_NORMAL            | If enabled, calls to [**glEvalCoord2**](glevalcoord-functions.md), [**glEvalMesh2**](glevalmesh-functions.md), and [**glEvalPoint2**](glevalpoint.md) generate normals. See also [**glMap2**](glmap2.md).                                               |
     * | GL\_MAP2\_TEXTURE\_COORD\_1 | If enabled, calls to **glEvalCoord2**, **glEvalMesh2**, and **glEvalPoint2** generate *s* texture coordinates. See also **glMap2**.                                                                                                                         |
     * | GL\_MAP2\_TEXTURE\_COORD\_2 | If enabled, calls to [**glEvalCoord2**](glevalcoord-functions.md), [**glEvalMesh2**](glevalmesh-functions.md), and [**glEvalPoint2**](glevalpoint.md) generate *s* and *t* texture coordinates. See also [**glMap2**](glmap2.md).                       |
     * | GL\_MAP2\_TEXTURE\_COORD\_3 | If enabled, calls to **glEvalCoord2**, **glEvalMesh2**, and **glEvalPoint2** generate *s*, *t*, and *r* texture coordinates. See also **glMap2**.                                                                                                           |
     * | GL\_MAP2\_TEXTURE\_COORD\_4 | If enabled, calls to [**glEvalCoord2**](glevalcoord-functions.md), [**glEvalMesh2**](glevalmesh-functions.md), and [**glEvalPoint2**](glevalpoint.md) generate *s*, *t*, *r*, and *q* texture coordinates. See also [**glMap2**](glmap2.md).            |
     * | GL\_MAP2\_VERTEX\_3         | If enabled, calls to **glEvalCoord2**, **glEvalMesh2**, and **glEvalPoint2** generate *x*, *y*, and *z* vertex coordinates. See also **glMap2**.                                                                                                            |
     * | GL\_MAP2\_VERTEX\_4         | If enabled, calls to [**glEvalCoord2**](glevalcoord-functions.md), [**glEvalMesh2**](glevalmesh-functions.md), and [**glEvalPoint2**](glevalpoint.md) generate homogeneous *x*, *y*, *z*, and *w* vertex coordinates. See also [**glMap2**](glmap2.md). |
     * | GL\_NORMALIZE               | If enabled, normal vectors specified with **glNormal** are scaled to unit length after transformation. See [**glNormal**](glnormal-functions.md).                                                                                                          |
     * | GL\_POINT\_SMOOTH           | If enabled, draw points with proper filtering. If disabled, draw aliased points. See [**glPointSize**](glpointsize.md).                                                                                                                                    |
     * | GL\_POLYGON\_OFFSET\_FILL   | If enabled, and if the polygon is rendered in GL\_FILL mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See [**glPolygonOffset**](glpolygonoffset.md)**.**                                      |
     * | GL\_POLYGON\_OFFSET\_LINE   | If enabled, and if the polygon is rendered in GL\_LINE mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See **glPolygonOffset**.                                                                 |
     * | GL\_POLYGON\_OFFSET\_POINT  | If enabled, an offset is added to depth values of a polygon's fragments before the depth comparison is performed, if the polygon is rendered in GL\_POINT mode. See [**glPolygonOffset**](glpolygonoffset.md).                                             |
     * | GL\_POLYGON\_SMOOTH         | If enabled, draw polygons with proper filtering. If disabled, draw aliased polygons. See [**glPolygonMode**](glpolygonmode.md).                                                                                                                            |
     * | GL\_POLYGON\_STIPPLE        | If enabled, use the current polygon stipple pattern when rendering polygons. See [**glPolygonStipple**](glpolygonstipple.md).                                                                                                                              |
     * | GL\_SCISSOR\_TEST           | If enabled, discard fragments that are outside the scissor rectangle. See [**glScissor**](glscissor.md).                                                                                                                                                   |
     * | GL\_STENCIL\_TEST           | If enabled, do stencil testing and update the stencil buffer. See [**glStencilFunc**](glstencilfunc.md) and [**glStencilOp**](glstencilop.md).                                                                                                            |
     * | GL\_TEXTURE\_1D             | If enabled, one-dimensional texturing is performed (unless two-dimensional texturing is also enabled). See [**glTexImage1D**](glteximage1d.md).                                                                                                            |
     * | GL\_TEXTURE\_2D             | If enabled, two-dimensional texturing is performed. See [**glTexImage2D**](glteximage2d.md).                                                                                                                                                               |
     * | GL\_TEXTURE\_GEN\_Q         | If enabled, the *q* texture coordinate is computed using the texture-generation function defined with [**glTexGen**](gltexgen-functions.md). Otherwise, the current *q* texture coordinate is used.                                                        |
     * | GL\_TEXTURE\_GEN\_R         | If enabled, the *r* texture coordinate is computed using the texture generation function defined with [**glTexGen**](gltexgen-functions.md). If disabled, the current *r* texture coordinate is used.                                                      |
     * | GL\_TEXTURE\_GEN\_S         | If enabled, the *s* texture coordinate is computed using the texture generation function defined with **glTexGen**. If disabled, the current *s* texture coordinate is used.                                                                                |
     * | GL\_TEXTURE\_GEN\_T         | If enabled, the *t* texture coordinate is computed using the texture generation function defined with [**glTexGen**](gltexgen-functions.md). If disabled, the current *t* texture coordinate is used.                                                      |
     * @param {Integer} cap A symbolic constant indicating an OpenGL capability.
     * 
     * For discussion of the values *cap* can take, see the following Remarks section.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gldisable
     */
    static glDisable(cap) {
        DllCall("OPENGL32.dll\glDisable", "uint", cap)
    }

    /**
     * The glEnableClientState and glDisableClientState functions enable and disable arrays respectively. | glDisableClientState function (Gl.h)
     * @remarks
     * The [**glEnableClientState**](glenableclientstate.md) and **glDisableClientState** functions enable and disable various individual arrays. Use [**glIsEnabled**](glisenabled.md) or [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) to determine the current setting of any capability.
     * 
     * Calling [**glEnableClientState**](glenableclientstate.md) and **glDisableClientState** between calls to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md) can cause an error. If no error is generated, the behavior is undefined.
     * 
     * > [!Note]  
     * > The [**glEnableClientState**](glenableclientstate.md) and **glDisableClientState** functions are only available in OpenGL version 1.1 or later.
     * @param {Integer} array A symbolic constant for the array you want to enable or disable. This parameter can assume one of the following values.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                             |
     * |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_COLOR_ARRAY"></span><span id="gl_color_array"></span><dl> <dt>**GL\_COLOR\_ARRAY**</dt> </dl>                          | If enabled, use color arrays with calls to [**glArrayElement**](glarrayelement.md), [**glDrawElements**](gldrawelements.md), or [**glDrawArrays**](gldrawarrays.md).<br/> See also [**glColorPointer**](glcolorpointer.md).<br/>                    |
     * | <span id="GL_EDGE_FLAG_ARRAY"></span><span id="gl_edge_flag_array"></span><dl> <dt>**GL\_EDGE\_FLAG\_ARRAY**</dt> </dl>             | If enabled, use edge flag arrays with calls to [**glArrayElement**](glarrayelement.md), [**glDrawElements**](gldrawelements.md), or [**glDrawArrays**](gldrawarrays.md).<br/> See also [**glEdgeFlagPointer**](gledgeflagpointer.md).<br/>          |
     * | <span id="GL_INDEX_ARRAY"></span><span id="gl_index_array"></span><dl> <dt>**GL\_INDEX\_ARRAY**</dt> </dl>                          | If enabled, use index arrays with calls to [**glArrayElement**](glarrayelement.md), [**glDrawElements**](gldrawelements.md), or [**glDrawArrays**](gldrawarrays.md).<br/> See also [**glIndexPointer**](glindexpointer.md).<br/>                    |
     * | <span id="GL_NORMAL_ARRAY"></span><span id="gl_normal_array"></span><dl> <dt>**GL\_NORMAL\_ARRAY**</dt> </dl>                       | If enabled, use normal arrays with calls to [**glArrayElement**](glarrayelement.md), [**glDrawElements**](gldrawelements.md), or [**glDrawArrays**](gldrawarrays.md).<br/> See also [**glNormalPointer**](glnormalpointer.md).<br/>                 |
     * | <span id="GL_TEXTURE_COORD_ARRAY"></span><span id="gl_texture_coord_array"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY**</dt> </dl> | If enabled, use texture coordinate arrays with calls to [**glArrayElement**](glarrayelement.md), [**glDrawElements**](gldrawelements.md), or [**glDrawArrays**](gldrawarrays.md).<br/> See also [**glTexCoordPointer**](gltexcoordpointer.md).<br/> |
     * | <span id="GL_VERTEX_ARRAY"></span><span id="gl_vertex_array"></span><dl> <dt>**GL\_VERTEX\_ARRAY**</dt> </dl>                       | If enabled, use vertex arrays with calls to [**glArrayElement**](glarrayelement.md), [**glDrawElements**](gldrawelements.md), or [**glDrawArrays**](gldrawarrays.md).<br/> See also [**glVertexPointer**](glvertexpointer.md).<br/>                 |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gldisableclientstate
     */
    static glDisableClientState(array) {
        DllCall("OPENGL32.dll\glDisableClientState", "uint", array)
    }

    /**
     * The glDrawArrays function specifies multiple primitives to render.
     * @remarks
     * With **glDrawArrays**, you can specify multiple geometric primitives to render. Instead of calling separate OpenGL functions to pass each individual vertex, normal, or color, you can specify separate arrays of vertices, normals, and colors to define a sequence of primitives (all the same kind) with a single call to **glDrawArrays**.
     * 
     * When you call **glDrawArrays**, *count* sequential elements from each enabled array are used to construct a sequence of geometric primitives, beginning with the *first* element. The *mode* parameter specifies what kind of primitive to construct and how to use the array elements to construct the primitives.
     * 
     * After **glDrawArrays** returns, the values of vertex attributes that are modified by **glDrawArrays** are undefined. For example, if GL\_COLOR\_ARRAY is enabled, the value of the current color is undefined after **glDrawArrays** returns. Attributes not modified by **glDrawArrays** remain defined. When GL\_VERTEX\_ARRAY is not enabled, no geometric primitives are generated but the attributes corresponding to enabled arrays are modified.
     * 
     * You can include **glDrawArrays** in display lists. When you include **glDrawArrays** in a display list, the necessary array data, determined by the array pointers and the enables, are generated and entered in the display list. The values of array pointers and enables are determined during the creation of display lists.
     * 
     * You can read static array data at any time. If any static array elements are modified and the array is not specified again, the results of any subsequent calls to **glDrawArrays** are undefined.
     * 
     * Although no error is generated when you specify an array more than once within [**glBegin**](glbegin.md) and [**glend**](glend.md) pairs, the results are undefined.
     * @param {Integer} mode The kind of primitives to render. The following constants specify acceptable types of primitives: GL\_POINTS, GL\_LINE\_STRIP, GL\_LINE\_LOOP, GL\_LINES, GL\_TRIANGLE\_STRIP, GL\_TRIANGLE\_FAN, GL\_TRIANGLES, GL\_QUAD\_STRIP, GL\_QUADS, and GL\_POLYGON.
     * @param {Integer} first The starting index in the enabled arrays.
     * @param {Integer} count The number of indexes to render.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gldrawarrays
     */
    static glDrawArrays(mode, first, count) {
        DllCall("OPENGL32.dll\glDrawArrays", "uint", mode, "int", first, "int", count)
    }

    /**
     * The glDrawBuffer function specifies which color buffers are to be drawn into.
     * @remarks
     * When colors are written to the framebuffer, they are written into the color buffers specified by **glDrawBuffer**.
     * 
     * If more than one color buffer is selected for drawing, then blending or logical operations are computed and applied independently for each color buffer and can produce different results in each buffer.
     * 
     * Monoscopic contexts include only left buffers, and stereoscopic contexts include both left and right buffers. Likewise, single-buffered contexts include only front buffers, and double-buffered contexts include both front and back buffers. The context is selected at OpenGL initialization.
     * 
     * It is always the case that GL\_AUX *i* = GL\_AUX0 + *i*.
     * 
     * The following functions retrieve information related to the **glDrawBuffer** function:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_DRAW\_BUFFER
     * 
     * **glGet** with argument GL\_AUX\_BUFFERS
     * @param {Integer} mode Specifies up to four color buffers to be drawn into with the following acceptable symbolic constants.
     * 
     * 
     * 
     * | Value                                                                                                                                                                       | Meaning                                                                                                                                                                                                                                                                                                                                                                                                      |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_NONE"></span><span id="gl_none"></span><dl> <dt>**GL\_NONE**</dt> </dl>                                 | No color buffers are written.<br/>                                                                                                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_FRONT_LEFT"></span><span id="gl_front_left"></span><dl> <dt>**GL\_FRONT\_LEFT**</dt> </dl>              | Only the front-left color buffer is written.<br/>                                                                                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_FRONT_RIGHT"></span><span id="gl_front_right"></span><dl> <dt>**GL\_FRONT\_RIGHT**</dt> </dl>           | Only the front-right color buffer is written.<br/>                                                                                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_BACK_LEFT"></span><span id="gl_back_left"></span><dl> <dt>**GL\_BACK\_LEFT**</dt> </dl>                 | Only the back-left color buffer is written.<br/>                                                                                                                                                                                                                                                                                                                                                       |
     * | <span id="GL_BACK_RIGHT"></span><span id="gl_back_right"></span><dl> <dt>**GL\_BACK\_RIGHT**</dt> </dl>              | Only the back-right color buffer is written.<br/>                                                                                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_FRONT"></span><span id="gl_front"></span><dl> <dt>**GL\_FRONT**</dt> </dl>                              | Only the front-left and front-right color buffers are written. If there is no front-right color buffer, only the front left-color buffer is written.<br/>                                                                                                                                                                                                                                              |
     * | <span id="GL_BACK"></span><span id="gl_back"></span><dl> <dt>**GL\_BACK**</dt> </dl>                                 | Only the back-left and back-right color buffers are written. If there is no back-right color buffer, only the back-left color buffer is written.<br/>                                                                                                                                                                                                                                                  |
     * | <span id="GL_LEFT"></span><span id="gl_left"></span><dl> <dt>**GL\_LEFT**</dt> </dl>                                 | Only the front-left and back-left color buffers are written. If there is no back-left color buffer, only the front-left color buffer is written.<br/>                                                                                                                                                                                                                                                  |
     * | <span id="GL_RIGHT"></span><span id="gl_right"></span><dl> <dt>**GL\_RIGHT**</dt> </dl>                              | Only the front-right and back-right color buffers are written. If there is no back-right color buffer, only the front-right color buffer is written.<br/>                                                                                                                                                                                                                                              |
     * | <span id="GL_FRONT_AND_BACK"></span><span id="gl_front_and_back"></span><dl> <dt>**GL\_FRONT\_AND\_BACK**</dt> </dl> | All the front and back color buffers (front-left, front-right, back-left, back-right) are written. If there are no back color buffers, only the front-left and front-right color buffers are written. If there are no right color buffers, only the front-left and back-left color buffers are written. If there are no right or back color buffers, only the front-left color buffer is written.<br/> |
     * | <span id="GL_AUXi"></span><span id="gl_auxi"></span><span id="GL_AUXI"></span><dl> <dt>**GL\_AUXi**</dt> </dl>       | Only the auxiliary color buffer *i* is written; *i* is between 0 and GL\_AUX\_BUFFERS - 1. (GL\_AUX\_BUFFERS is not the upper limit; use [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) to query the number of available auxiliary buffers.)<br/>                                                                                                                            |
     * 
     * 
     * 
     *  
     * 
     * The default value is GL\_FRONT for single-buffered contexts, and GL\_BACK for double-buffered contexts.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gldrawbuffer
     */
    static glDrawBuffer(mode) {
        DllCall("OPENGL32.dll\glDrawBuffer", "uint", mode)
    }

    /**
     * The glDrawElements function renders primitives from array data.
     * @remarks
     * The **glDrawElements** function enables you to specify multiple geometric primitives with very few function calls. Instead of calling an OpenGL function to pass each individual vertex, normal, or color, you can specify separate arrays of vertices, normals, and colors beforehand and use them to define a sequence of primitives (all of the same type) with a single call to **glDrawElements**.
     * 
     * When you call the **glDrawElements** function, it uses *count* sequential elements from *indices* to construct a sequence of geometric primitives. The *mode* parameter specifies what kind of primitives are constructed, and how the array elements are used to construct these primitives. If GL\_VERTEX\_ARRAY is not enabled, no geometric primitives are generated.
     * 
     * Vertex attributes that are modified by **glDrawElements** have an unspecified value after **glDrawElements** returns. For example, if GL\_COLOR\_ARRAY is enabled, the value of the current color is undefined after **glDrawElements** executes. Attributes that aren't modified remain unchanged.
     * 
     * You can include the **glDrawElements** function in display lists. When **glDrawElements** is included in a display list, the necessary array data (determined by the array pointers and enables) is also entered into the display list. Because the array pointers and enables are client-side state variables, their values affect display lists when the lists are created, not when the lists are executed.
     * 
     * > [!Note]  
     * > The **glDrawElements** function is only available in OpenGL version 1.1 or later.
     * @param {Integer} mode The kind of primitives to render. It can assume one of the following symbolic values: GL\_POINTS, GL\_LINE\_STRIP, GL\_LINE\_LOOP, GL\_LINES, GL\_TRIANGLE\_STRIP, GL\_TRIANGLE\_FAN, GL\_TRIANGLES, GL\_QUAD\_STRIP, GL\_QUADS, and GL\_POLYGON.
     * @param {Integer} count The number of elements to be rendered.
     * @param {Integer} type The type of the values in indices. Must be one of GL\_UNSIGNED\_BYTE, GL\_UNSIGNED\_SHORT, or GL\_UNSIGNED\_INT.
     * @param {Pointer<Void>} indices A pointer to the location where the indices are stored.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gldrawelements
     */
    static glDrawElements(mode, count, type, indices) {
        DllCall("OPENGL32.dll\glDrawElements", "uint", mode, "int", count, "uint", type, "ptr", indices)
    }

    /**
     * The glDrawPixels function writes a block of pixels to the framebuffer.
     * @remarks
     * The **glDrawPixels** function reads pixel data from memory and writes it into the framebuffer relative to the current raster position. Use [**glRasterPos**](glrasterpos-functions.md) to set the current raster position, and use [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION to query the raster position.
     * 
     * Several parameters define the encoding of pixel data in memory and control the processing of the pixel data before it is placed in the framebuffer. These parameters are set with four functions: [**glPixelStore**](glpixelstore-functions.md), [**glPixelTransfer**](glpixeltransfer.md), [**glPixelMap**](glpixelmap.md), and [**glPixelZoom**](glpixelzoom.md). This topic describes the effects on **glDrawPixels** of many, but not all, of the parameters specified by these four functions.
     * 
     * Data is read from *pixels* as a sequence of signed or unsigned bytes, signed or unsigned shorts, signed or unsigned integers, or single-precision floating-point values, depending on *type*. Each of these bytes, shorts, integers, or floating-point values is interpreted as one color or depth component, or one index, depending on *format*. Indexes are always treated individually. Color components are treated as groups of one, two, three, or four values, again based on *format*. Both individual indexes and groups of components are referred to as pixels. If *type* is GL\_BITMAP, the data must be unsigned bytes, and *format* must be either GL\_COLOR\_INDEX or GL\_STENCIL\_INDEX. Each unsigned byte is treated as eight 1-bit pixels, with bit ordering determined by GL\_UNPACK\_LSB\_FIRST (see [**glPixelStore**](glpixelstore-functions.md)).
     * 
     * The *width* by *height* pixels are read from memory, starting at location *pixels*. By default, these pixels are taken from adjacent memory locations, except that after all *width* pixels are read, the read pointer is advanced to the next 4-byte boundary. The **glPixelStore** function specifies the 4-byte row alignment with argument GL\_UNPACK\_ALIGNMENT, and you can set it to 1, 2, 4, or 8 bytes. Other pixel store parameters specify different read pointer advancements, both before the first pixel is read, and after all *width* pixels are read. The **glPixelStore** function operates on each of the *width-by-height* pixels that it reads from memory in the same way, based on the values of several parameters specified by [**glPixelTransfer**](glpixeltransfer.md) and [**glPixelMap**](glpixelmap.md). The details of these operations, as well as the target buffer into which the pixels are drawn, are specific to the format of the pixels, as specified by *format*.
     * 
     * The rasterization described thus far assumes pixel zoom factors of 1.0. If you use [**glPixelZoom**](glpixelzoom.md) to change the *x* and *y* pixel zoom factors, pixels are converted to fragments as follows. If (*xr,yr*) is the current raster position, and a given pixel is in the *n*th column and *m*th row of the pixel rectangle, then fragments are generated for pixels whose centers are in the rectangle with corners at
     * 
     * (*x*<sub>r</sub> + *zoom*? *n*, *y*<sub>r</sub> + *zoom*<sub>y</sub> *m*)
     * 
     * (*x*<sub>r</sub> + *zoom*? (*n* + 1), *y*<sub>r</sub> + *zoom*<sub>y</sub> (*m* + 1))
     * 
     * where *zoom*? is the value of GL\_ZOOM\_X and *zoom*<sub>y</sub> is the value of GL\_ZOOM\_Y.
     * 
     * The following functions retrieve information related to **glDrawPixels**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION
     * 
     * **glGet** with argument GL\_CURRENT\_RASTER\_POSITION\_VALID
     * @param {Integer} width The width dimension of the pixel rectangle that will be written into the framebuffer.
     * @param {Integer} height The height dimension of the pixel rectangle that will be written into the framebuffer.
     * @param {Integer} format The format of the pixel data. Acceptable symbolic constants are as follows.
     * 
     * 
     * 
     * 
     * | Value | Meaning | 
     * |-------|---------|
     * | <span id="GL_COLOR_INDEX"></span><span id="gl_color_index"></span><dl><dt><strong>GL_COLOR_INDEX</strong></dt></dl> | Each pixel is a single value, a color index. <br /><ol><li>The <strong>glDrawPixels</strong> function converts each pixel to fixed-point format, with an unspecified number of bits to the right of the binary point, regardless of the memory data type. Floating-point values convert to true fixed-point values. The <strong>glDrawPixels</strong> function converts signed and unsigned integer data with all fraction bits set to zero. The function converts bitmap data to either 0.0 or 1.0.</li><li>The <strong>glDrawPixels</strong> function shifts each fixed-point index left by GL_INDEX_SHIFT bits and adds it to GL_INDEX_OFFSET. If GL_INDEX_SHIFT is negative, the shift is to the right. In either case, zero bits fill otherwise unspecified bit locations in the result.</li><li>When in RGBA mode, <strong>glDrawPixels</strong> converts the resulting index to an RGBA pixel using the GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, and GL_PIXEL_MAP_I_TO_A tables. When in the color-index mode and GL_MAP_COLOR is true, the index is replaced with the value that <strong>glDrawPixels</strong> references in lookup table GL_PIXEL_MAP_I_TO_I.</li><li>Whether the lookup replacement of the index is done or not, the integer part of the index is <strong>AND</strong>ed with 2<sup>b</sup> - 1, where <em>b</em> is the number of bits in a color-index buffer.</li><li>The resulting indexes or RGBA colors are then converted to fragments by attaching the current raster position <em>z</em>-coordinate and texture coordinates to each pixel, and then assigning <em>x</em> and <em>y</em> window coordinates to the <em>n</em>th fragment such that <em>x</em>? = <em>x</em><sub>r</sub> + <em>n</em> mod <em>width</em><br /><em>y</em>? = <em>y</em><sub>r</sub> + <em>n/width</em><br /> where (<em>x</em><sub>r</sub> , <em>y</em><sub>r</sub> ) is the current raster position.<br /></li><li>The <strong>glDrawPixels</strong> function treats these pixel fragments just like the fragments generated by rasterizing points, lines, or polygons. It applies texture mapping, fog, and all the fragment operations before writing the fragments to the framebuffer.</li></ol> | 
     * | <span id="GL_STENCIL_INDEX"></span><span id="gl_stencil_index"></span><dl><dt><strong>GL_STENCIL_INDEX</strong></dt></dl> | Each pixel is a single value, a stencil index. <br /><ol><li>The <strong>glDrawPixels</strong> function converts it to fixed-point format, with an unspecified number of bits to the right of the binary point, regardless of the memory data type. Floating-point values convert to true fixed-point values. The <strong>glDrawPixels</strong> function converts signed and unsigned integer data with all fraction bits set to zero. Bitmap data converts to either 0.0 or 1.0.</li><li>The <strong>glDrawPixels</strong> function shifts each fixed-point index left by GL_INDEX_SHIFT bits, and adds it to GL_INDEX_OFFSET. If GL_INDEX_SHIFT is negative, the shift is to the right. In either case, zero bits fill otherwise unspecified bit locations in the result.</li><li>If GL_MAP_STENCIL is true, the index is replaced with the value that <strong>glDrawPixels</strong> references in lookup table GL_PIXEL_MAP_S_TO_S.</li><li>Whether the lookup replacement of the index is done or not, the integer part of the index is then <strong>AND</strong>ed with 2<sup>b</sup> - 1, where <em>b</em> is the number of bits in the stencil buffer. The resulting stencil indexes are then written to the stencil buffer such that the <em>n</em>th index is written to location <em>x</em>? = <em>x</em><sub>r</sub> + <em>n</em> mod <em>width</em><br /><em>y</em>? = <em>y</em><sub>r</sub> + <em>n/width</em><br /> where (<em>x</em><sub>r</sub> ,<em></em>y<sub>r</sub> ) is the current raster position. Only the pixel ownership test, the scissor test, and the stencil writemask affect these writes.<br /></li></ol> | 
     * | <span id="GL_DEPTH_COMPONENT"></span><span id="gl_depth_component"></span><dl><dt><strong>GL_DEPTH_COMPONENT</strong></dt></dl> | Each pixel is a single-depth component. <br /><ol><li>The <strong>glDrawPixels</strong> function converts floating-point data directly to an internal floating-point format with unspecified precision. Signed integer data is mapped linearly to the internal floating-point format such that the most positive representable integer value maps to 1.0, and the most negative representable value maps to -1.0. Unsigned integer data is mapped similarly: the largest integer value maps to 1.0, and zero maps to 0.0.</li><li>The <strong>glDrawPixels</strong> function multiplies the resulting floating-point depth value by GL_DEPTH_SCALE and adds it to GL_DEPTH_BIAS. The result is clamped to the range [0,1].</li><li>The <strong>glDrawPixels</strong> function converts the resulting depth components to fragments by attaching the current raster position color or color index and texture coordinates to each pixel, and then assigning <em>x</em> and <em>y</em> window coordinates to the <em>n</em> th fragment such that <em>x</em>? = <em></em>x<sub>r</sub> + <em>n</em> mod <em>width</em><br /><em>y</em>? = <em>y</em><sub>r</sub> + <em>n/width</em><br /> where (<em></em>x<sub>r</sub> ,<em>y</em><sub>r</sub> ) is the current raster position.<br /></li><li>These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. The <strong>glDrawPixels</strong> function applies texture mapping, fog, and all the fragment operations before writing the fragments to the framebuffer.</li></ol> | 
     * | <span id="GL_RGBA"></span><span id="gl_rgba"></span><dl><dt><strong>GL_RGBA</strong></dt></dl> | Each pixel is a four-component group in this order: red, green, blue, alpha. <br /><ol><li>The <strong>glDrawPixels</strong> function converts floating-point values directly to an internal floating-point format with unspecified precision. Signed integer values are mapped linearly to the internal floating-point format such that the most positive representable integer value maps to 1.0, and the most negative representable value maps to -1.0. Unsigned integer data is mapped similarly: the largest integer value maps to 1.0, and zero maps to 0.0.</li><li>The <strong>glDrawPixels</strong> function multiplies the resulting floating-point color values by GL_c_SCALE and adds them to GL_c_BIAS, where <em>c</em> is RED, GREEN, BLUE, and ALPHA for the respective color components. The results are clamped to the range [0,1].</li><li>If GL_MAP_COLOR is true, <strong>glDrawPixels</strong> scales each color component by the size of lookup table GL_PIXEL_MAP_c_TO_c, and then replaces the component by the value that it references in that table; <em>c</em> is R, G, B, or A, respectively.</li><li>The <strong>glDrawPixels</strong> function converts the resulting RGBA colors to fragments by attaching the current raster position <em>z</em>-coordinate and texture coordinates to each pixel, then assigning <em>x</em> and <em>y</em> window coordinates to the <em>n</em>th fragment such that <em>x</em>? = <em>x</em><sub>r</sub> + <em>n</em> mod <em>width</em><br /><em>y</em>? = <em>y</em><sub>r</sub> + <em>n /width</em><br /> where (<em>x</em><sub>r</sub> ,<em>y</em><sub>r</sub> ) is the current raster position.<br /></li><li>These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. The <strong>glDrawPixels</strong> function applies texture mapping, fog, and all the fragment operations before writing the fragments to the framebuffer.</li></ol> | 
     * | <span id="GL_RED"></span><span id="gl_red"></span><dl><dt><strong>GL_RED</strong></dt></dl> | Each pixel is a single red component.<br /> The <strong>glDrawPixels</strong> function converts this component to the internal floating-point format in the same way that the red component of an RGBA pixel is, and then converts it to an RGBA pixel with green and blue set to 0.0, and alpha set to 1.0. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.<br /> | 
     * | <span id="GL_GREEN"></span><span id="gl_green"></span><dl><dt><strong>GL_GREEN</strong></dt></dl> | Each pixel is a single green component.<br /> The <strong>glDrawPixels</strong> function converts this component to the internal floating-point format in the same way that the green component of an RGBA pixel is, and then converts it to an RGBA pixel with red and blue set to 0.0, and alpha set to 1.0. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.<br /> | 
     * | <span id="GL_BLUE"></span><span id="gl_blue"></span><dl><dt><strong>GL_BLUE</strong></dt></dl> | Each pixel is a single blue component.<br /> The <strong>glDrawPixels</strong> function converts this component to the internal floating-point format in the same way that the blue component of an RGBA pixel is, and then converts it to an RGBA pixel with red and green set to 0.0, and alpha set to 1.0. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.<br /> | 
     * | <span id="GL_ALPHA"></span><span id="gl_alpha"></span><dl><dt><strong>GL_ALPHA</strong></dt></dl> | Each pixel is a single alpha component.<br /> The <strong>glDrawPixels</strong> function converts this component to the internal floating-point format in the same way that the alpha component of an RGBA pixel is, and then converts it to an RGBA pixel with red, green, and blue set to 0.0. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.<br /> | 
     * | <span id="GL_RGB"></span><span id="gl_rgb"></span><dl><dt><strong>GL_RGB</strong></dt></dl> | Each pixel is a group of three components in this order: red, green, blue. The <strong>glDrawPixels</strong> function converts each component to the internal floating-point format in the same way that the red, green, and blue components of an RGBA pixel are. The color triple is converted to an RGBA pixel with alpha set to 1.0. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.<br /> | 
     * | <span id="GL_LUMINANCE"></span><span id="gl_luminance"></span><dl><dt><strong>GL_LUMINANCE</strong></dt></dl> | Each pixel is a single luminance component.<br /> The <strong>glDrawPixels</strong> function converts this component to the internal floating-point format in the same way that the red component of an RGBA pixel is, and then converts it to an RGBA pixel with red, green, and blue set to the converted luminance value, and alpha set to 1.0. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.<br /> | 
     * | <span id="GL_LUMINANCE_ALPHA"></span><span id="gl_luminance_alpha"></span><dl><dt><strong>GL_LUMINANCE_ALPHA</strong></dt></dl> | Each pixel is a group of two components in this order: luminance, alpha.<br /> The <strong>glDrawPixels</strong> function converts the two components to the internal floating-point format in the same way that the red component of an RGBA pixel is, and then converts them to an RGBA pixel with red, green, and blue set to the converted luminance value, and alpha set to the converted alpha value. After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.<br /> | 
     * | <span id="GL_BGR_EXT"></span><span id="gl_bgr_ext"></span><dl><dt><strong>GL_BGR_EXT</strong></dt></dl> | Each pixel is a group of three components in this order: blue, green, red.<br /> GL_BGR_EXT provides a format that matches the memory layout of Windows device-independent bitmaps (DIBs). Thus, your applications can use the same data with Windows function calls and OpenGL pixel function calls.<br /> | 
     * | <span id="GL_BGRA_EXT"></span><span id="gl_bgra_ext"></span><dl><dt><strong>GL_BGRA_EXT</strong></dt></dl> | Each pixel is a group of four components in this order: blue, green, red, alpha.<br /> GL_BGRA_EXT provides a format that matches the memory layout of Windows device-independent bitmaps (DIBs). Thus, your applications can use the same data with Windows function calls and OpenGL pixel function calls.<br /> |
     * @param {Integer} type The data type for *pixels*. The following are the accepted symbolic constants and their meanings.
     * 
     * 
     * 
     * | Value                                                                                                                                                                      | Meaning                                           |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------|
     * | <span id="GL_UNSIGNED_BYTE"></span><span id="gl_unsigned_byte"></span><dl> <dt>**GL\_UNSIGNED\_BYTE**</dt> </dl>    | Unsigned 8-bit integer<br/>                 |
     * | <span id="GL_BYTE"></span><span id="gl_byte"></span><dl> <dt>**GL\_BYTE**</dt> </dl>                                | Signed 8-bit integer<br/>                   |
     * | <span id="GL_BITMAP"></span><span id="gl_bitmap"></span><dl> <dt>**GL\_BITMAP**</dt> </dl>                          | Single bits in unsigned 8-bit integers<br/> |
     * | <span id="GL_UNSIGNED_SHORT"></span><span id="gl_unsigned_short"></span><dl> <dt>**GL\_UNSIGNED\_SHORT**</dt> </dl> | Unsigned 16-bit integer<br/>                |
     * | <span id="GL_SHORT"></span><span id="gl_short"></span><dl> <dt>**GL\_SHORT**</dt> </dl>                             | Signed 16-bit integer<br/>                  |
     * | <span id="GL_UNSIGNED_INT"></span><span id="gl_unsigned_int"></span><dl> <dt>**GL\_UNSIGNED\_INT**</dt> </dl>       | Unsigned 32-bit integer<br/>                |
     * | <span id="GL_INT"></span><span id="gl_int"></span><dl> <dt>**GL\_INT**</dt> </dl>                                   | 32-bit integer<br/>                         |
     * | <span id="GL_FLOAT"></span><span id="gl_float"></span><dl> <dt>**GL\_FLOAT**</dt> </dl>                             | Single-precision floating-point<br/>        |
     * @param {Pointer<Void>} pixels A pointer to the pixel data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gldrawpixels
     */
    static glDrawPixels(width, height, format, type, pixels) {
        DllCall("OPENGL32.dll\glDrawPixels", "int", width, "int", height, "uint", format, "uint", type, "ptr", pixels)
    }

    /**
     * Flags edges as either boundary or nonboundary. | glEdgeFlag function (Gl.h)
     * @remarks
     * Each vertex of a polygon, separate triangle, or separate quadrilateral specified between a [**glBegin**](/windows/desktop/OpenGL/glbegin)/[**glEnd**](/windows/desktop/OpenGL/glend) pair is marked as the start of either a boundary or nonboundary edge. If the current edge flag is **TRUE** when the vertex is specified, the vertex is marked as the start of a boundary edge. If the current edge flag is **FALSE**, the vertex is marked as the start of a nonboundary edge. The **glEdgeFlag** function sets the edge flag to **TRUE** if flag is nonzero, **FALSE** otherwise.
     * 
     * The vertices of connected triangles and connected quadrilaterals are always marked as boundary, regardless of the value of the edge flag.
     * 
     * Boundary and nonboundary edge flags on vertices are significant only if GL\_POLYGON\_MODE is set to GL\_POINT or GL\_LINE. See [**glPolygonMode**](/windows/desktop/OpenGL/glpolygonmode).
     * 
     * Initially, the edge flag bit is **TRUE**.
     * 
     * The current edge flag can be updated at any time. In particular, **glEdgeFlag** can be called between a call to [**glBegin**](/windows/desktop/OpenGL/glbegin) and the corresponding call to [**glEnd**](/windows/desktop/OpenGL/glend).
     * 
     * The following functions retrieve information related to **glEdgeFlag**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_EDGE\_FLAG
     * @param {Integer} flag Specifies the current edge flag value, either **TRUE** or **FALSE**.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gledgeflag
     */
    static glEdgeFlag(flag) {
        DllCall("OPENGL32.dll\glEdgeFlag", "char", flag)
    }

    /**
     * The glEdgeFlagPointer function defines an array of edge flags.
     * @remarks
     * The **glEdgeFlagPointer** function specifies the location and data of an array of Boolean edge flags to use when rendering. The *stride* parameter determines the byte offset from one edge flag to the next, which enables the packing of vertices and attributes in a single array or storage in separate arrays. In some implementations, storing the vertices and attributes in a single array can be more efficient than using separate arrays.
     * 
     * An edge-flag array is enabled when you specify the GL\_EDGE\_FLAG\_ARRAY constant with [**glEnableClientState**](glenableclientstate.md). When enabled, [**glDrawArrays**](gldrawarrays.md) or [**glArrayElement**](glarrayelement.md) uses the edge-flag array. By default the edge-flag array is disabled.
     * 
     * Use **glDrawArrays** to construct a sequence of primitives (all of the same type) from prespecified vertex and vertex attribute arrays. Use **glArrayElement** to specify primitives by indexing vertices and vertex attributes, and [**glDrawElements**](gldrawelements.md) to construct a sequence of primitives by indexing vertices and vertex attributes.
     * 
     * You cannot include **glEdgeFlagPointer** in display lists.
     * 
     * When you specify an edge-flag array using **glEdgeFlagPointer**, the values of all the function's edge-flag array parameters are saved in a client-side state and static array elements can be cached. Because the edge-flag array parameters are in a client-side state, [**glPushAttrib**](glpushattrib.md) and [**glPopAttrib**](glpopattrib.md) do not save or restore their values.
     * 
     * Although calling **glEdgeFlagPointer** within a [**glBegin**](glbegin.md)/[**glend**](glend.md) pair does not generate an error, the results are undefined.
     * 
     * The following functions retrieve information related to the **glEdgeFlagPointer** function:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_EDGE\_FLAG\_ARRAY\_STRIDE
     * 
     * **glGet** with argument GL\_EDGE\_FLAG\_ARRAY\_COUNT
     * 
     * [**glGetPointerv**](glgetpointerv.md) with argument GL\_EDGE\_FLAG\_ARRAY\_POINTER
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_EDGE\_FLAG\_ARRAY
     * @param {Integer} stride The byte offset between consecutive edge flags. When *stride* is zero, the edge flags are tightly packed in the array.
     * @param {Pointer<Void>} pointer A pointer to the first edge flag in the array.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gledgeflagpointer
     */
    static glEdgeFlagPointer(stride, pointer) {
        DllCall("OPENGL32.dll\glEdgeFlagPointer", "int", stride, "ptr", pointer)
    }

    /**
     * Flags edges as either boundary or nonboundary. | glEdgeFlagv function (Gl.h)
     * @remarks
     * Each vertex of a polygon, separate triangle, or separate quadrilateral specified between a [**glBegin**](/windows/desktop/OpenGL/glbegin)/[**glEnd**](/windows/desktop/OpenGL/glend) pair is marked as the start of either a boundary or nonboundary edge. If the current edge flag is **TRUE** when the vertex is specified, the vertex is marked as the start of a boundary edge. If the current edge flag is **FALSE**, the vertex is marked as the start of a nonboundary edge. The **glEdgeFlagv** function sets the edge flag to **TRUE** if flag is nonzero, **FALSE** otherwise.
     * 
     * The vertices of connected triangles and connected quadrilaterals are always marked as boundary, regardless of the value of the edge flag.
     * 
     * Boundary and nonboundary edge flags on vertices are significant only if GL\_POLYGON\_MODE is set to GL\_POINT or GL\_LINE. See [**glPolygonMode**](/windows/desktop/OpenGL/glpolygonmode).
     * 
     * Initially, the edge flag bit is **TRUE**.
     * 
     * The current edge flag can be updated at any time. In particular, **glEdgeFlagv** can be called between a call to [**glBegin**](/windows/desktop/OpenGL/glbegin) and the corresponding call to [**glEnd**](/windows/desktop/OpenGL/glend).
     * 
     * The following functions retrieve information related to **glEdgeFlagv**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_EDGE\_FLAG
     * @param {Pointer<Byte>} flag Specifies a pointer to an array that contains a single Boolean element, which replaces the current edge flag value.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gledgeflagv
     */
    static glEdgeFlagv(flag) {
        DllCall("OPENGL32.dll\glEdgeFlagv", "ptr", flag)
    }

    /**
     * The glEnable and glDisable functions enable or disable OpenGL capabilities. | glEnable function (Gl.h)
     * @remarks
     * The **glEnable** and **glDisable** functions enable and disable various OpenGL graphics capabilities. Use [**glIsEnabled**](glisenabled.md) or [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) to determine the current setting of any capability.
     * 
     * Both **glEnable** and **glDisable** take a single argument, *cap*, which can assume one of the following values:
     * 
     * 
     * 
     * | Value                       | Meaning                                                                                                                                                                                                                                                     |
     * |-----------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | GL\_ALPHA\_TEST             | If enabled, do alpha testing. See [**glAlphaFunc**](glalphafunc.md).                                                                                                                                                                                       |
     * | GL\_AUTO\_NORMAL            | If enabled, compute surface normal vectors analytically when either GL\_MAP2\_VERTEX\_3 or GL\_MAP2\_VERTEX\_4 has generated vertices. See [**glMap2**](glmap2.md).                                                                                        |
     * | GL\_BLEND                   | If enabled, blend the incoming RGBA color values with the values in the color buffers. See [**glBlendFunc**](glblendfunc.md).                                                                                                                              |
     * | GL\_CLIP\_PLANE*i*          | If enabled, clip geometry against user-defined clipping plane *i*. See [**glClipPlane**](glclipplane.md).                                                                                                                                                  |
     * | GL\_COLOR\_LOGIC\_OP        | If enabled, apply the current logical operation to the incoming RGBA color and color buffer values. See [**glLogicOp**](gllogicop.md).                                                                                                                     |
     * | GL\_COLOR\_MATERIAL         | If enabled, have one or more material parameters track the current color. See [**glColorMaterial**](glcolormaterial.md).                                                                                                                                   |
     * | GL\_CULL\_FACE              | If enabled, cull polygons based on their winding in window coordinates. See [**glCullFace**](glcullface.md).                                                                                                                                               |
     * | GL\_DEPTH\_TEST             | If enabled, do depth comparisons and update the depth buffer. See [**glDepthFunc**](gldepthfunc.md) and [**glDepthRange**](gldepthrange.md).                                                                                                              |
     * | GL\_DITHER                  | If enabled, dither color components or indexes before they are written to the color buffer.                                                                                                                                                                 |
     * | GL\_FOG                     | If enabled, blend a fog color into the post-texturing color. See [**glFog**](glfog.md).                                                                                                                                                                    |
     * | GL\_INDEX\_LOGIC\_OP        | If enabled, apply the current logical operation to the incoming index and color buffer indices. See [**glLogicOp**](gllogicop.md).                                                                                                                         |
     * | GL\_LIGHT*i*                | If enabled, include light *i* in the evaluation of the lighting equation. See [**glLightModel**](gllightmodel-functions.md) and [**glLight**](gllight-functions.md).                                                                                      |
     * | GL\_LIGHTING                | If enabled, use the current lighting parameters to compute the vertex color or index. If disabled, associate the current color or index with each vertex. See [**glMaterial**](glmaterial-functions.md), **glLightModel**, and **glLight**.                |
     * | GL\_LINE\_SMOOTH            | If enabled, draw lines with correct filtering. If disabled, draw aliased lines. See [**glLineWidth**](gllinewidth.md).                                                                                                                                     |
     * | GL\_LINE\_STIPPLE           | If enabled, use the current line stipple pattern when drawing lines. See [**glLineStipple**](gllinestipple.md).                                                                                                                                            |
     * | GL\_LOGIC\_OP               | If enabled, apply the currently selected logical operation to the incoming and color-buffer indexes. See [**glLogicOp**](gllogicop.md).                                                                                                                    |
     * | GL\_MAP1\_COLOR\_4          | If enabled, calls to [**glEvalCoord1**](glevalcoord-functions.md), [**glEvalMesh1**](glevalmesh-functions.md), and [**glEvalPoint1**](glevalpoint.md) generate RGBA values. See also [**glMap1**](glmap1.md).                                           |
     * | GL\_MAP1\_INDEX             | If enabled, calls to **glEvalCoord1**, **glEvalMesh1**, and **glEvalPoint1** generate color indexes. See also **glMap1**.                                                                                                                                   |
     * | GL\_MAP1\_NORMAL            | If enabled, calls to [**glEvalCoord1**](glevalcoord-functions.md), [**glEvalMesh1**](glevalmesh-functions.md), and [**glEvalPoint1**](glevalpoint.md) generate normals. See also [**glMap1**](glmap1.md).                                               |
     * | GL\_MAP1\_TEXTURE\_COORD\_1 | If enabled, calls to **glEvalCoord1**, **glEvalMesh1**, and **glEvalPoint1** generate *s* texture coordinates. See also **glMap1**.                                                                                                                         |
     * | GL\_MAP1\_TEXTURE\_COORD\_2 | If enabled, calls to [**glEvalCoord1**](glevalcoord-functions.md), [**glEvalMesh1**](glevalmesh-functions.md), and [**glEvalPoint1**](glevalpoint.md) generate *s* and *t* texture coordinates. See also [**glMap1**](glmap1.md).                       |
     * | GL\_MAP1\_TEXTURE\_COORD\_3 | If enabled, calls to **glEvalCoord1**, **glEvalMesh1**, and **glEvalPoint1** generate *s*, *t*, and *r* texture coordinates. See also **glMap1**.                                                                                                           |
     * | GL\_MAP1\_TEXTURE\_COORD\_4 | If enabled, calls to [glEvalCoord1](glevalcoord-functions.md), [glEvalMesh1](glevalmesh-functions.md), and [**glEvalPoint1**](glevalpoint.md) generate *s*, *t*, *r*, and *q* texture coordinates. See also [**glMap1**](glmap1.md).                    |
     * | GL\_MAP1\_VERTEX\_3         | If enabled, calls to **glEvalCoord1**, **glEvalMesh1**, and **glEvalPoint1** generate *x*, *y*, and *z* vertex coordinates. See also **glMap1**.                                                                                                            |
     * | GL\_MAP1\_VERTEX\_4         | If enabled, calls to [**glEvalCoord1**](glevalcoord-functions.md), [**glEvalMesh1**](glevalmesh-functions.md), and [**glEvalPoint1**](glevalpoint.md) generate homogeneous *x*, *y*, *z*, and *w* vertex coordinates. See also [**glMap1**](glmap1.md). |
     * | GL\_MAP2\_COLOR\_4          | If enabled, calls to [**glEvalCoord2**](glevalcoord-functions.md), [**glEvalMesh2**](glevalmesh-functions.md), and [**glEvalPoint2**](glevalpoint.md) generate RGBA values. See also [**glMap2**](glmap2.md).                                           |
     * | GL\_MAP2\_INDEX             | If enabled, calls to **glEvalCoord2**, **glEvalMesh2**, and **glEvalPoint2** generate color indexes. See also **glMap2**.                                                                                                                                   |
     * | GL\_MAP2\_NORMAL            | If enabled, calls to [**glEvalCoord2**](glevalcoord-functions.md), [**glEvalMesh2**](glevalmesh-functions.md), and [**glEvalPoint2**](glevalpoint.md) generate normals. See also [**glMap2**](glmap2.md).                                               |
     * | GL\_MAP2\_TEXTURE\_COORD\_1 | If enabled, calls to **glEvalCoord2**, **glEvalMesh2**, and **glEvalPoint2** generate *s* texture coordinates. See also **glMap2**.                                                                                                                         |
     * | GL\_MAP2\_TEXTURE\_COORD\_2 | If enabled, calls to [**glEvalCoord2**](glevalcoord-functions.md), [**glEvalMesh2**](glevalmesh-functions.md), and [**glEvalPoint2**](glevalpoint.md) generate *s* and *t* texture coordinates. See also [**glMap2**](glmap2.md).                       |
     * | GL\_MAP2\_TEXTURE\_COORD\_3 | If enabled, calls to **glEvalCoord2**, **glEvalMesh2**, and **glEvalPoint2** generate *s*, *t*, and *r* texture coordinates. See also **glMap2**.                                                                                                           |
     * | GL\_MAP2\_TEXTURE\_COORD\_4 | If enabled, calls to [**glEvalCoord2**](glevalcoord-functions.md), [**glEvalMesh2**](glevalmesh-functions.md), and [**glEvalPoint2**](glevalpoint.md) generate *s*, *t*, *r*, and *q* texture coordinates. See also [**glMap2**](glmap2.md).            |
     * | GL\_MAP2\_VERTEX\_3         | If enabled, calls to **glEvalCoord2**, **glEvalMesh2**, and **glEvalPoint2** generate *x*, *y*, and *z* vertex coordinates. See also **glMap2**.                                                                                                            |
     * | GL\_MAP2\_VERTEX\_4         | If enabled, calls to [**glEvalCoord2**](glevalcoord-functions.md), [**glEvalMesh2**](glevalmesh-functions.md), and [**glEvalPoint2**](glevalpoint.md) generate homogeneous *x*, *y*, *z*, and *w* vertex coordinates. See also [**glMap2**](glmap2.md). |
     * | GL\_NORMALIZE               | If enabled, normal vectors specified with **glNormal** are scaled to unit length after transformation. See [**glNormal**](glnormal-functions.md).                                                                                                          |
     * | GL\_POINT\_SMOOTH           | If enabled, draw points with proper filtering. If disabled, draw aliased points. See [**glPointSize**](glpointsize.md).                                                                                                                                    |
     * | GL\_POLYGON\_OFFSET\_FILL   | If enabled, and if the polygon is rendered in GL\_FILL mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See [**glPolygonOffset**](glpolygonoffset.md)**.**                                      |
     * | GL\_POLYGON\_OFFSET\_LINE   | If enabled, and if the polygon is rendered in GL\_LINE mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See **glPolygonOffset**.                                                                 |
     * | GL\_POLYGON\_OFFSET\_POINT  | If enabled, an offset is added to depth values of a polygon's fragments before the depth comparison is performed, if the polygon is rendered in GL\_POINT mode. See [**glPolygonOffset**](glpolygonoffset.md).                                             |
     * | GL\_POLYGON\_SMOOTH         | If enabled, draw polygons with proper filtering. If disabled, draw aliased polygons. See [**glPolygonMode**](glpolygonmode.md).                                                                                                                            |
     * | GL\_POLYGON\_STIPPLE        | If enabled, use the current polygon stipple pattern when rendering polygons. See [**glPolygonStipple**](glpolygonstipple.md).                                                                                                                              |
     * | GL\_SCISSOR\_TEST           | If enabled, discard fragments that are outside the scissor rectangle. See [**glScissor**](glscissor.md).                                                                                                                                                   |
     * | GL\_STENCIL\_TEST           | If enabled, do stencil testing and update the stencil buffer. See [**glStencilFunc**](glstencilfunc.md) and [**glStencilOp**](glstencilop.md).                                                                                                            |
     * | GL\_TEXTURE\_1D             | If enabled, one-dimensional texturing is performed (unless two-dimensional texturing is also enabled). See [**glTexImage1D**](glteximage1d.md).                                                                                                            |
     * | GL\_TEXTURE\_2D             | If enabled, two-dimensional texturing is performed. See [**glTexImage2D**](glteximage2d.md).                                                                                                                                                               |
     * | GL\_TEXTURE\_GEN\_Q         | If enabled, the *q* texture coordinate is computed using the texture-generation function defined with [**glTexGen**](gltexgen-functions.md). Otherwise, the current *q* texture coordinate is used.                                                        |
     * | GL\_TEXTURE\_GEN\_R         | If enabled, the *r* texture coordinate is computed using the texture generation function defined with [**glTexGen**](gltexgen-functions.md). If disabled, the current *r* texture coordinate is used.                                                      |
     * | GL\_TEXTURE\_GEN\_S         | If enabled, the *s* texture coordinate is computed using the texture generation function defined with **glTexGen**. If disabled, the current *s* texture coordinate is used.                                                                                |
     * | GL\_TEXTURE\_GEN\_T         | If enabled, the *t* texture coordinate is computed using the texture generation function defined with [**glTexGen**](gltexgen-functions.md). If disabled, the current *t* texture coordinate is used.                                                      |
     * @param {Integer} cap A symbolic constant indicating an OpenGL capability.
     * 
     * For discussion of the values *cap* can take, see the following Remarks section.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glenable
     */
    static glEnable(cap) {
        DllCall("OPENGL32.dll\glEnable", "uint", cap)
    }

    /**
     * The glEnableClientState and glDisableClientState functions enable and disable arrays respectively. | glEnableClientState function (Gl.h)
     * @remarks
     * The **glEnableClientState** and **glDisableClientState** functions enable and disable various individual arrays. Use [**glIsEnabled**](glisenabled.md) or [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) to determine the current setting of any capability.
     * 
     * Calling **glEnableClientState** and **glDisableClientState** between calls to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md) can cause an error. If no error is generated, the behavior is undefined.
     * 
     * > [!Note]  
     * > The **glEnableClientState** and **glDisableClientState** functions are only available in OpenGL version 1.1 or later.
     * @param {Integer} array A symbolic constant for the array you want to enable or disable. This parameter can assume one of the following values.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                             |
     * |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_COLOR_ARRAY"></span><span id="gl_color_array"></span><dl> <dt>**GL\_COLOR\_ARRAY**</dt> </dl>                          | If enabled, use color arrays with calls to [**glArrayElement**](glarrayelement.md), [**glDrawElements**](gldrawelements.md), or [**glDrawArrays**](gldrawarrays.md).<br/> See also [**glColorPointer**](glcolorpointer.md).<br/>                    |
     * | <span id="GL_EDGE_FLAG_ARRAY"></span><span id="gl_edge_flag_array"></span><dl> <dt>**GL\_EDGE\_FLAG\_ARRAY**</dt> </dl>             | If enabled, use edge flag arrays with calls to [**glArrayElement**](glarrayelement.md), [**glDrawElements**](gldrawelements.md), or [**glDrawArrays**](gldrawarrays.md).<br/> See also [**glEdgeFlagPointer**](gledgeflagpointer.md).<br/>          |
     * | <span id="GL_INDEX_ARRAY"></span><span id="gl_index_array"></span><dl> <dt>**GL\_INDEX\_ARRAY**</dt> </dl>                          | If enabled, use index arrays with calls to [**glArrayElement**](glarrayelement.md), [**glDrawElements**](gldrawelements.md), or [**glDrawArrays**](gldrawarrays.md).<br/> See also [**glIndexPointer**](glindexpointer.md).<br/>                    |
     * | <span id="GL_NORMAL_ARRAY"></span><span id="gl_normal_array"></span><dl> <dt>**GL\_NORMAL\_ARRAY**</dt> </dl>                       | If enabled, use normal arrays with calls to [**glArrayElement**](glarrayelement.md), [**glDrawElements**](gldrawelements.md), or [**glDrawArrays**](gldrawarrays.md).<br/> See also [**glNormalPointer**](glnormalpointer.md).<br/>                 |
     * | <span id="GL_TEXTURE_COORD_ARRAY"></span><span id="gl_texture_coord_array"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY**</dt> </dl> | If enabled, use texture coordinate arrays with calls to [**glArrayElement**](glarrayelement.md), [**glDrawElements**](gldrawelements.md), or [**glDrawArrays**](gldrawarrays.md).<br/> See also [**glTexCoordPointer**](gltexcoordpointer.md).<br/> |
     * | <span id="GL_VERTEX_ARRAY"></span><span id="gl_vertex_array"></span><dl> <dt>**GL\_VERTEX\_ARRAY**</dt> </dl>                       | If enabled, use vertex arrays with calls to [**glArrayElement**](glarrayelement.md), [**glDrawElements**](gldrawelements.md), or [**glDrawArrays**](gldrawarrays.md).<br/> See also [**glVertexPointer**](glvertexpointer.md).<br/>                 |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glenableclientstate
     */
    static glEnableClientState(array) {
        DllCall("OPENGL32.dll\glEnableClientState", "uint", array)
    }

    /**
     * The glBegin and glEnd functions delimit the vertices of a primitive or a group of like primitives. | glEnd function (Gl.h)
     * @remarks
     * The [**glBegin**](glbegin.md) and **glEnd** functions delimit the vertices that define a primitive or a group of like primitives. The **glBegin** function accepts a single argument that specifies which of ten primitives the vertices compose. Taking *n* as an integer count starting at one, and *N* as the total number of vertices specified, the interpretations are as follows:
     * 
     * -   You can use only a subset of OpenGL functions between **glBegin** and **glEnd**. The functions you can use are:
     * 
     *     -   [**glVertex**](glvertex-functions.md)
     *     -   [**glColor**](glcolor-functions.md)
     *     -   [**glIndex**](glindex-functions.md)
     *     -   [**glNormal**](glnormal-functions.md)
     *     -   [**glTexCoord**](gltexcoord-functions.md)
     *     -   [**glEvalCoord**](glevalcoord-functions.md)
     *     -   [**glEvalPoint**](glevalpoint.md)
     *     -   [**glMaterial**](glmaterial-functions.md)
     *     -   [**glEdgeFlag**](gledgeflag-functions.md)
     * 
     *     You can also use [**glCallList**](glcalllist.md) or [**glCallLists**](glcalllists.md) to execute display lists that include only the preceding functions. If any other OpenGL function is called between **glBegin** and **glEnd**, the error flag is set and the function is ignored.
     * 
     * -   Regardless of the value chosen for *mode* in **glBegin**, there is no limit to the number of vertices you can define between **glBegin** and **glEnd**. Lines, triangles, quadrilaterals, and polygons that are incompletely specified are not drawn. Incomplete specification results when either too few vertices are provided to specify even a single primitive or when an incorrect multiple of vertices is specified. The incomplete primitive is ignored; the complete primitives are drawn.
     * -   The minimum specification of vertices for each primitive is: 
     * 
     *     | Minimum number of vertices | Type of primitive |
     *     |----------------------------|-------------------|
     *     | 1                          | point             |
     *     | 2                          | line              |
     *     | 3                          | triangle          |
     *     | 4                          | quadrilateral     |
     *     | 3                          | polygon           |
     * 
     *     
     * 
     *      
     * 
     * -   Modes that require a certain multiple of vertices are GL\_LINES (2), GL\_TRIANGLES (3), GL\_QUADS (4), and GL\_QUAD\_STRIP (2).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glend
     */
    static glEnd() {
        DllCall("OPENGL32.dll\glEnd")
    }

    /**
     * The glNewList and glEndList functions create or replace a display list. | glEndList function (Gl.h)
     * @remarks
     * Display lists are groups of OpenGL commands that have been stored for subsequent execution. The display lists are created with [**glNewList**](glnewlist.md). All subsequent commands are placed in the display list, in the order issued, until **glEndList** is called.
     * 
     * The [**glNewList**](glnewlist.md) function has two parameters. The first parameter, *list*, is a positive integer that becomes the unique name for the display list. Names can be created and reserved with [**glGenLists**](glgenlists.md) and tested for uniqueness with [**glIsList**](glislist.md). The second parameter, *mode*, is a symbolic constant that can assume one of the two preceding values.
     * 
     * Certain commands are not compiled into the display list, but are executed immediately, regardless of the display list mode. These commands are [**glColorPointer**](glcolorpointer.md), [**glDeleteLists**](gldeletelists.md), [**glDisableClientState**](gldisableclientstate.md), [**glEdgeFlagPointer**](gledgeflagpointer.md), [**glEnableClientState**](glenableclientstate.md), [**glFeedbackBuffer**](glfeedbackbuffer.md), [**glFinish**](glfinish.md), [**glFlush**](glflush.md), [**glGenLists**](glgenlists.md), [**glIndexPointer**](glindexpointer.md), [**glInterleavedArrays**](glinterleavedarrays.md), [**glIsEnabled**](glisenabled.md), [**glIsList**](glislist.md), [**glNormalPointer**](glnormalpointer.md), [**glPopClientAttrib**](glpopclientattrib.md), [**glPixelStore**](glpixelstore-functions.md), [**glPushClientAttrib**](glpushclientattrib.md), [**glReadPixels**](glreadpixels.md), [**glRenderMode**](glrendermode.md), [**glSelectBuffer**](glselectbuffer.md), [**glTexCoordPointer**](gltexcoordpointer.md), [**glVertexPointer**](glvertexpointer.md), and all of the [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) routines.
     * 
     * Similarly, [**glTexImage2D**](glteximage2d.md) and [**glTexImage1D**](glteximage1d.md) are executed immediately and not compiled into the display list when their first argument is GL\_PROXY\_TEXTURE\_2D or GL\_PROXY\_TEXTURE\_1D, respectively.
     * 
     * When the **glEndList** function is encountered, the display list definition is completed by associating the list with the unique name *list* (specified in the [**glNewList**](glnewlist.md) command). If a display list with name *list* already exists, it is replaced only when **glEndList** is called.
     * 
     * The [**glCallList**](glcalllist.md) and [**glCallLists**](glcalllists.md) functions can be entered into display lists. The commands in the display list or lists executed by **glCallList** or **glCallLists** are not included in the display list being created, even if the list creation mode is GL\_COMPILE\_AND\_EXECUTE.
     * 
     * The following function retrieves information related to [**glNewList**](glnewlist.md):
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glendlist
     */
    static glEndList() {
        DllCall("OPENGL32.dll\glEndList")
    }

    /**
     * The glEvalCoord1d function evaluates enabled one-dimensional maps.
     * @remarks
     * The **glEvalCoord1d** function evaluates enabled one-dimensional maps at argument *u*. Define maps with [**glMap1**](glmap1.md). Enable or disable them with [**glEnable**](glenable.md) and [**glDisable**](gldisable.md).
     * 
     * When one of the **glEvalCoord** functions is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding OpenGL function were issued with the computed value. That is, if GL\_MAP1\_INDEX or GL\_MAP2\_INDEX is enabled, a [**glIndex**](glindex-functions.md) function is simulated. If GL\_MAP1\_COLOR\_4 or GL\_MAP2\_COLOR\_4 is enabled, a **glcolor** function is simulated. If GL\_MAP1\_NORMAL or GL\_MAP2\_NORMAL is enabled, a normal vector is produced, and if any of GL\_MAP1\_TEXTURE\_COORD\_1, GL\_MAP1\_TEXTURE\_COORD\_2, GL\_MAP1\_TEXTURE\_COORD\_3, GL\_MAP1\_TEXTURE\_COORD\_4, GL\_MAP2\_TEXTURE\_COORD\_1, GL\_MAP2\_TEXTURE\_COORD\_2, GL\_MAP2\_TEXTURE\_COORD\_3, and GL\_MAP2\_TEXTURE\_COORD\_4 is enabled, then an appropriate [**glTexCoord**](gltexcoord-functions.md) function is simulated.
     * 
     * OpenGL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, for color, color index, normal, and texture coordinates. However, the evaluated values do not update the current values. Thus, if [**glVertex**](glvertex-functions.md) functions are interspersed with **glEvalCoord** functions, the color, normal, and texture coordinates associated with the **glVertex** functions are not affected by the values generated by the **glEvalCoord** functions, but only by the most recent [**glColor**](glcolor-functions.md), [**glIndex**](glindex-functions.md), [**glNormal**](glnormal-functions.md), and [**glTexCoord**](gltexcoord-functions.md) functions.
     * 
     * The following functions retrieve information related to the **glEvalCoord1d** function:
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_INDEX
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_COLOR\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_NORMAL
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_1
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_2
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_INDEX
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_COLOR\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_NORMAL
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_1
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_2
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_AUTO\_NORMAL
     * @param {Float} u A value that is the domain coordinate *u* to the basis function defined in a previous [**glMap1**](glmap1.md) function.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glevalcoord1d
     */
    static glEvalCoord1d(u) {
        DllCall("OPENGL32.dll\glEvalCoord1d", "double", u)
    }

    /**
     * The glEvalCoord1dv function evaluates enabled one-dimensional maps.
     * @remarks
     * The **glEvalCoord1dv** function evaluates enabled one-dimensional maps at argument *u*. Define maps with [**glMap1**](glmap1.md). Enable or disable them with [**glEnable**](glenable.md) and [**glDisable**](gldisable.md).
     * 
     * When one of the **glEvalCoord** functions is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding OpenGL function were issued with the computed value. That is, if GL\_MAP1\_INDEX or GL\_MAP2\_INDEX is enabled, a [**glIndex**](glindex-functions.md) function is simulated. If GL\_MAP1\_COLOR\_4 or GL\_MAP2\_COLOR\_4 is enabled, a **glcolor** function is simulated. If GL\_MAP1\_NORMAL or GL\_MAP2\_NORMAL is enabled, a normal vector is produced, and if any of GL\_MAP1\_TEXTURE\_COORD\_1, GL\_MAP1\_TEXTURE\_COORD\_2, GL\_MAP1\_TEXTURE\_COORD\_3, GL\_MAP1\_TEXTURE\_COORD\_4, GL\_MAP2\_TEXTURE\_COORD\_1, GL\_MAP2\_TEXTURE\_COORD\_2, GL\_MAP2\_TEXTURE\_COORD\_3, and GL\_MAP2\_TEXTURE\_COORD\_4 is enabled, then an appropriate [**glTexCoord**](gltexcoord-functions.md) function is simulated.
     * 
     * OpenGL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, for color, color index, normal, and texture coordinates. However, the evaluated values do not update the current values. Thus, if [**glVertex**](glvertex-functions.md) functions are interspersed with **glEvalCoord** functions, the color, normal, and texture coordinates associated with the **glVertex** functions are not affected by the values generated by the **glEvalCoord** functions, but only by the most recent [**glColor**](glcolor-functions.md), [**glIndex**](glindex-functions.md), [**glNormal**](glnormal-functions.md), and [**glTexCoord**](gltexcoord-functions.md) functions.
     * 
     * The following functions retrieve information related to the **glEvalCoord1dv** function:
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_INDEX
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_COLOR\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_NORMAL
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_1
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_2
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_INDEX
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_COLOR\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_NORMAL
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_1
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_2
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_AUTO\_NORMAL
     * @param {Pointer<Double>} u A pointer to an array containing the domain coordinate *u*.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glevalcoord1dv
     */
    static glEvalCoord1dv(u) {
        DllCall("OPENGL32.dll\glEvalCoord1dv", "ptr", u)
    }

    /**
     * The glEvalCoord1f function evaluates enabled one-dimensional maps.
     * @remarks
     * The **glEvalCoord1f** function evaluates enabled one-dimensional maps at argument *u*. Define maps with [**glMap1**](glmap1.md). Enable or disable them with [**glEnable**](glenable.md) and [**glDisable**](gldisable.md).
     * 
     * When one of the **glEvalCoord** functions is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding OpenGL function were issued with the computed value. That is, if GL\_MAP1\_INDEX or GL\_MAP2\_INDEX is enabled, a [**glIndex**](glindex-functions.md) function is simulated. If GL\_MAP1\_COLOR\_4 or GL\_MAP2\_COLOR\_4 is enabled, a **glcolor** function is simulated. If GL\_MAP1\_NORMAL or GL\_MAP2\_NORMAL is enabled, a normal vector is produced, and if any of GL\_MAP1\_TEXTURE\_COORD\_1, GL\_MAP1\_TEXTURE\_COORD\_2, GL\_MAP1\_TEXTURE\_COORD\_3, GL\_MAP1\_TEXTURE\_COORD\_4, GL\_MAP2\_TEXTURE\_COORD\_1, GL\_MAP2\_TEXTURE\_COORD\_2, GL\_MAP2\_TEXTURE\_COORD\_3, and GL\_MAP2\_TEXTURE\_COORD\_4 is enabled, then an appropriate [**glTexCoord**](gltexcoord-functions.md) function is simulated.
     * 
     * OpenGL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, for color, color index, normal, and texture coordinates. However, the evaluated values do not update the current values. Thus, if [**glVertex**](glvertex-functions.md) functions are interspersed with **glEvalCoord** functions, the color, normal, and texture coordinates associated with the **glVertex** functions are not affected by the values generated by the **glEvalCoord** functions, but only by the most recent [**glColor**](glcolor-functions.md), [**glIndex**](glindex-functions.md), [**glNormal**](glnormal-functions.md), and [**glTexCoord**](gltexcoord-functions.md) functions.
     * 
     * The following functions retrieve information related to the **glEvalCoord1f** function:
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_INDEX
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_COLOR\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_NORMAL
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_1
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_2
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_INDEX
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_COLOR\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_NORMAL
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_1
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_2
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_AUTO\_NORMAL
     * @param {Float} u A value that is the domain coordinate *u* to the basis function defined in a previous [**glMap1**](glmap1.md) function.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glevalcoord1f
     */
    static glEvalCoord1f(u) {
        DllCall("OPENGL32.dll\glEvalCoord1f", "float", u)
    }

    /**
     * The glEvalCoord1fv function evaluates enabled one-dimensional maps.
     * @remarks
     * The [**glEvalCoord1fv**](glevalcoord1dv.md) function evaluates enabled one-dimensional maps at argument *u*. Define maps with [**glMap1**](glmap1.md). Enable or disable them with [**glEnable**](glenable.md) and [**glDisable**](gldisable.md).
     * 
     * When one of the **glEvalCoord** functions is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding OpenGL function were issued with the computed value. That is, if GL\_MAP1\_INDEX or GL\_MAP2\_INDEX is enabled, a [**glIndex**](glindex-functions.md) function is simulated. If GL\_MAP1\_COLOR\_4 or GL\_MAP2\_COLOR\_4 is enabled, a **glcolor** function is simulated. If GL\_MAP1\_NORMAL or GL\_MAP2\_NORMAL is enabled, a normal vector is produced, and if any of GL\_MAP1\_TEXTURE\_COORD\_1, GL\_MAP1\_TEXTURE\_COORD\_2, GL\_MAP1\_TEXTURE\_COORD\_3, GL\_MAP1\_TEXTURE\_COORD\_4, GL\_MAP2\_TEXTURE\_COORD\_1, GL\_MAP2\_TEXTURE\_COORD\_2, GL\_MAP2\_TEXTURE\_COORD\_3, and GL\_MAP2\_TEXTURE\_COORD\_4 is enabled, then an appropriate [**glTexCoord**](gltexcoord-functions.md) function is simulated.
     * 
     * OpenGL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, for color, color index, normal, and texture coordinates. However, the evaluated values do not update the current values. Thus, if [**glVertex**](glvertex-functions.md) functions are interspersed with **glEvalCoord** functions, the color, normal, and texture coordinates associated with the **glVertex** functions are not affected by the values generated by the **glEvalCoord** functions, but only by the most recent [**glColor**](glcolor-functions.md), [**glIndex**](glindex-functions.md), [**glNormal**](glnormal-functions.md), and [**glTexCoord**](gltexcoord-functions.md) functions.
     * 
     * The following functions retrieve information related to the **glEvalCoord1fv** function:
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_INDEX
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_COLOR\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_NORMAL
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_1
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_2
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_INDEX
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_COLOR\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_NORMAL
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_1
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_2
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_AUTO\_NORMAL
     * @param {Pointer<Single>} u A pointer to an array containing the domain coordinate *u*.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glevalcoord1fv
     */
    static glEvalCoord1fv(u) {
        DllCall("OPENGL32.dll\glEvalCoord1fv", "ptr", u)
    }

    /**
     * The glEvalCoord2d function evaluates enabled two-dimensional maps.
     * @remarks
     * The **glEvalCoord2d** function evaluates enabled two-dimensional maps using two domain values, *u* and *v*. Define maps with [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md). Enable or disable them with [**glEnable**](glenable.md) and [**glDisable**](gldisable.md).
     * 
     * When one of the **glEvalCoord** functions is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding OpenGL function were issued with the computed value. That is, if GL\_MAP1\_INDEX or GL\_MAP2\_INDEX is enabled, a [**glIndex**](glindex-functions.md) function is simulated. If GL\_MAP1\_COLOR\_4 or GL\_MAP2\_COLOR\_4 is enabled, a **glcolor** function is simulated. If GL\_MAP1\_NORMAL or GL\_MAP2\_NORMAL is enabled, a normal vector is produced, and if any of GL\_MAP1\_TEXTURE\_COORD\_1, GL\_MAP1\_TEXTURE\_COORD\_2, GL\_MAP1\_TEXTURE\_COORD\_3, GL\_MAP1\_TEXTURE\_COORD\_4, GL\_MAP2\_TEXTURE\_COORD\_1, GL\_MAP2\_TEXTURE\_COORD\_2, GL\_MAP2\_TEXTURE\_COORD\_3, and GL\_MAP2\_TEXTURE\_COORD\_4 is enabled, then an appropriate [**glTexCoord**](gltexcoord-functions.md) function is simulated.
     * 
     * OpenGL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, for color, color index, normal, and texture coordinates. However, the evaluated values do not update the current values. Thus, if [**glVertex**](glvertex-functions.md) functions are interspersed with **glEvalCoord** functions, the color, normal, and texture coordinates associated with the **glVertex** functions are not affected by the values generated by the **glEvalCoord** functions, but only by the most recent [**glColor**](glcolor-functions.md), [**glIndex**](glindex-functions.md), [**glNormal**](glnormal-functions.md), and [**glTexCoord**](gltexcoord-functions.md) functions.
     * 
     * If automatic normal generation is enabled, **glEvalCoord2d** calls [**glEnable**](glenable.md) with argument GL\_AUTO\_NORMAL to generate surface normals analytically, regardless of the contents or enabling of the GL\_MAP2\_NORMAL map. Let
     * 
     * ![Equation showing a cross-product value for a map m.](images/evlcrd01.png)
     * 
     * The generated normal **n** is
     * 
     * ![Equation showing the generated normal n for the map.](images/evlcrd02.png)
     * 
     * The following functions retrieve information related to the **glEvalCoord2d** function:
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_INDEX
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_COLOR\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_NORMAL
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_1
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_2
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_INDEX
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_COLOR\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_NORMAL
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_1
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_2
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_AUTO\_NORMAL
     * @param {Float} u A value that is the domain coordinate *u* to the basis function defined in a previous [**glMap2**](glmap2.md) function.
     * @param {Float} v A value that is the domain coordinate *v* to the basis function defined in a previous [**glMap2**](glmap2.md) function.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glevalcoord2d
     */
    static glEvalCoord2d(u, v) {
        DllCall("OPENGL32.dll\glEvalCoord2d", "double", u, "double", v)
    }

    /**
     * The glEvalCoord2dv function evaluates enabled two-dimensional maps.
     * @remarks
     * The **glEvalCoord2dv** function evaluates enabled two-dimensional maps using two domain values, *u* and *v*. Define maps with [**glMap1**](glmap1.md). Enable or disable them with [**glEnable**](glenable.md) and [**glDisable**](gldisable.md).
     * 
     * When one of the **glEvalCoord** functions is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding OpenGL function were issued with the computed value. That is, if GL\_MAP1\_INDEX or GL\_MAP2\_INDEX is enabled, a [**glIndex**](glindex-functions.md) function is simulated. If GL\_MAP1\_COLOR\_4 or GL\_MAP2\_COLOR\_4 is enabled, a **glcolor** function is simulated. If GL\_MAP1\_NORMAL or GL\_MAP2\_NORMAL is enabled, a normal vector is produced, and if any of GL\_MAP1\_TEXTURE\_COORD\_1, GL\_MAP1\_TEXTURE\_COORD\_2, GL\_MAP1\_TEXTURE\_COORD\_3, GL\_MAP1\_TEXTURE\_COORD\_4, GL\_MAP2\_TEXTURE\_COORD\_1, GL\_MAP2\_TEXTURE\_COORD\_2, GL\_MAP2\_TEXTURE\_COORD\_3, and GL\_MAP2\_TEXTURE\_COORD\_4 is enabled, then an appropriate [**glTexCoord**](gltexcoord-functions.md) function is simulated.
     * 
     * OpenGL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, for color, color index, normal, and texture coordinates. However, the evaluated values do not update the current values. Thus, if [**glVertex**](glvertex-functions.md) functions are interspersed with **glEvalCoord** functions, the color, normal, and texture coordinates associated with the **glVertex** functions are not affected by the values generated by the **glEvalCoord** functions, but only by the most recent [**glColor**](glcolor-functions.md), [**glIndex**](glindex-functions.md), [**glNormal**](glnormal-functions.md), and [**glTexCoord**](gltexcoord-functions.md) functions.
     * 
     * If automatic normal generation is enabled, **glEvalCoord2dv** calls [**glEnable**](glenable.md) with argument GL\_AUTO\_NORMAL to generate surface normals analytically, regardless of the contents or enabling of the GL\_MAP2\_NORMAL map. Let
     * 
     * ![Equation showing a cross-product value for a map m.](images/evlcrd01.png)
     * 
     * The generated normal **n** is
     * 
     * ![Equation showing the generated normal n for the map.](images/evlcrd02.png)
     * 
     * The following functions retrieve information related to the **glEvalCoord2dv** function:
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_INDEX
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_COLOR\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_NORMAL
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_1
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_2
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_INDEX
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_COLOR\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_NORMAL
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_1
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_2
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_AUTO\_NORMAL
     * @param {Pointer<Double>} u A pointer to an array containing the domain coordinate *u*.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glevalcoord2dv
     */
    static glEvalCoord2dv(u) {
        DllCall("OPENGL32.dll\glEvalCoord2dv", "ptr", u)
    }

    /**
     * The glEvalCoord2f function evaluates enabled two-dimensional maps.
     * @remarks
     * The [**glEvalCoord2f**](glevalcoord2d.md) function evaluates enabled two-dimensional maps using two domain values, *u* and *v*. Define maps with [**glMap2**](glmap2.md). Enable or disable them with [**glEnable**](glenable.md) and [**glDisable**](gldisable.md).
     * 
     * When one of the **glEvalCoord** functions is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding OpenGL function were issued with the computed value. That is, if GL\_MAP1\_INDEX or GL\_MAP2\_INDEX is enabled, a [**glIndex**](glindex-functions.md) function is simulated. If GL\_MAP1\_COLOR\_4 or GL\_MAP2\_COLOR\_4 is enabled, a **glcolor** function is simulated. If GL\_MAP1\_NORMAL or GL\_MAP2\_NORMAL is enabled, a normal vector is produced, and if any of GL\_MAP1\_TEXTURE\_COORD\_1, GL\_MAP1\_TEXTURE\_COORD\_2, GL\_MAP1\_TEXTURE\_COORD\_3, GL\_MAP1\_TEXTURE\_COORD\_4, GL\_MAP2\_TEXTURE\_COORD\_1, GL\_MAP2\_TEXTURE\_COORD\_2, GL\_MAP2\_TEXTURE\_COORD\_3, and GL\_MAP2\_TEXTURE\_COORD\_4 is enabled, then an appropriate [**glTexCoord**](gltexcoord-functions.md) function is simulated.
     * 
     * OpenGL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, for color, color index, normal, and texture coordinates. However, the evaluated values do not update the current values. Thus, if [**glVertex**](glvertex-functions.md) functions are interspersed with **glEvalCoord** functions, the color, normal, and texture coordinates associated with the **glVertex** functions are not affected by the values generated by the **glEvalCoord** functions, but only by the most recent [**glColor**](glcolor-functions.md), [**glIndex**](glindex-functions.md), [**glNormal**](glnormal-functions.md), and [**glTexCoord**](gltexcoord-functions.md) functions.
     * 
     * If automatic normal generation is enabled, [**glEvalCoord2f**](glevalcoord2d.md) calls [**glEnable**](glenable.md) with argument GL\_AUTO\_NORMAL to generate surface normals analytically, regardless of the contents or enabling of the GL\_MAP2\_NORMAL map. Let
     * 
     * ![Equation showing a cross-product value for a map m.](images/evlcrd01.png)
     * 
     * The generated normal **n** is
     * 
     * ![Equation showing the generated normal n for the map.](images/evlcrd02.png)
     * 
     * The following functions retrieve information related to the [**glEvalCoord2f**](glevalcoord2d.md) function:
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_INDEX
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_COLOR\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_NORMAL
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_1
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_2
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_INDEX
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_COLOR\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_NORMAL
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_1
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_2
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_AUTO\_NORMAL
     * @param {Float} u A value that is the domain coordinate *u* to the basis function defined in a previous [**glMap2**](glmap2.md) function.
     * @param {Float} v A value that is the domain coordinate *v* to the basis function defined in a previous [**glMap2**](glmap2.md) function.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glevalcoord2f
     */
    static glEvalCoord2f(u, v) {
        DllCall("OPENGL32.dll\glEvalCoord2f", "float", u, "float", v)
    }

    /**
     * The glEvalCoord2fv function evaluates enabled two-dimensional maps.
     * @remarks
     * The **glEvalCoord2fv** function evaluates enabled two-dimensional maps using two domain values, *u* and *v*. Define maps with [**glMap1**](glmap1.md). Enable or disable them with [**glEnable**](glenable.md) and [**glDisable**](gldisable.md).
     * 
     * When one of the **glEvalCoord** functions is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding OpenGL function were issued with the computed value. That is, if GL\_MAP1\_INDEX or GL\_MAP2\_INDEX is enabled, a [**glIndex**](glindex-functions.md) function is simulated. If GL\_MAP1\_COLOR\_4 or GL\_MAP2\_COLOR\_4 is enabled, a **glcolor** function is simulated. If GL\_MAP1\_NORMAL or GL\_MAP2\_NORMAL is enabled, a normal vector is produced, and if any of GL\_MAP1\_TEXTURE\_COORD\_1, GL\_MAP1\_TEXTURE\_COORD\_2, GL\_MAP1\_TEXTURE\_COORD\_3, GL\_MAP1\_TEXTURE\_COORD\_4, GL\_MAP2\_TEXTURE\_COORD\_1, GL\_MAP2\_TEXTURE\_COORD\_2, GL\_MAP2\_TEXTURE\_COORD\_3, and GL\_MAP2\_TEXTURE\_COORD\_4 is enabled, then an appropriate [**glTexCoord**](gltexcoord-functions.md) function is simulated.
     * 
     * OpenGL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, for color, color index, normal, and texture coordinates. However, the evaluated values do not update the current values. Thus, if [**glVertex**](glvertex-functions.md) functions are interspersed with **glEvalCoord** functions, the color, normal, and texture coordinates associated with the **glVertex** functions are not affected by the values generated by the **glEvalCoord** functions, but only by the most recent [**glColor**](glcolor-functions.md), [**glIndex**](glindex-functions.md), [**glNormal**](glnormal-functions.md), and [**glTexCoord**](gltexcoord-functions.md) functions.
     * 
     * If automatic normal generation is enabled, **glEvalCoord2fv** calls [**glEnable**](glenable.md) with argument GL\_AUTO\_NORMAL to generate surface normals analytically, regardless of the contents or enabling of the GL\_MAP2\_NORMAL map. Let
     * 
     * ![Equation showing a cross-product value for a map m.](images/evlcrd01.png)
     * 
     * The generated normal **n** is
     * 
     * ![Equation showing the generated normal n for the map.](images/evlcrd02.png)
     * 
     * The following functions retrieve information related to the **glEvalCoord2fv** function:
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_INDEX
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_COLOR\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_NORMAL
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_1
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_2
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_TEXTURE\_COORD\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_INDEX
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_COLOR\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_NORMAL
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_1
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_2
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_3
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_TEXTURE\_COORD\_4
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_AUTO\_NORMAL
     * @param {Pointer<Single>} u A pointer to an array containing the domain coordinate *u*.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glevalcoord2fv
     */
    static glEvalCoord2fv(u) {
        DllCall("OPENGL32.dll\glEvalCoord2fv", "ptr", u)
    }

    /**
     * Computes a one-dimensional grid of points or lines.
     * @remarks
     * Use [**glMapGrid**](glmapgrid-functions.md) and [**glEvalMesh**](glevalmesh-functions.md) together to efficiently generate and evaluate a series of evenly spaced map domain values. The **glEvalMesh** function steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md). The mode parameter determines whether the resulting vertices are connected as points, lines, or filled polygons.
     * 
     * In the one-dimensional case, **glEvalMesh1**, the mesh is generated as if the following code fragment were executed:
     * 
     * [**glBegin**](glbegin.md)(*type*);
     * 
     * for (i = i1; i <= i2; i += 1)
     * 
     * {
     * 
     * [**glEvalCoord1**](glevalcoord1d.md)(i?u + u1)
     * 
     * }
     * 
     * [**glEnd**](glend.md)( );
     * 
     * where
     * 
     * ?u = (u2 u1) / n
     * 
     * and n, u1, and u2 are the arguments to the most recent [**glMapGrid1**](glmapgrid1d.md) function. The *type* parameter is GL\_POINTS if mode is GL\_POINT, or GL\_LINES if mode is GL\_LINE. The one absolute numeric requirement is that if i = n, then the value computed from i?u + u1 is exactly u2.
     * @param {Integer} mode A value that specifies whether to compute a one-dimensional mesh of points or lines. The following symbolic constants are accepted: GL\_POINT and GL\_LINE.
     * @param {Integer} i1 The first integer value for grid domain variable i.
     * @param {Integer} i2 The last integer value for grid domain variable i.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glevalmesh1
     */
    static glEvalMesh1(mode, i1, i2) {
        DllCall("OPENGL32.dll\glEvalMesh1", "uint", mode, "int", i1, "int", i2)
    }

    /**
     * Computes a two-dimensional grid of points or lines.
     * @remarks
     * Use [**glMapGrid**](glmapgrid-functions.md) and [**glEvalMesh**](glevalmesh-functions.md) in tandem to efficiently generate and evaluate a series of evenly spaced map domain values. The **glEvalMesh** function steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md). The mode parameter determines whether the resulting vertices are connected as points, lines, or filled polygons.
     * 
     * In the two-dimensional case, **glEvalMesh2**, let
     * 
     * ? u = (u2 u1)/n
     * 
     * ? v = (v2 v1)/m,
     * 
     * where n, u1, u2, m, v1, and v2 are the arguments to the most recent [**glMapGrid2**](glmapgrid-functions.md) function. Then, if *mode* is GL\_FILL, **glEvalMesh2** is equivalent to:
     * 
     * for (j = j1; j < j2; j += 1)
     * 
     * {
     * 
     * [**glBegin**](glbegin.md)(GL\_QUAD\_STRIP);
     * 
     * for (i = i1; i <= i2; i += 1)
     * 
     * {
     * 
     * [**glEvalCoord2**](glevalcoord2d.md)(i? u + u1 ( ) , j ? v + v1);
     * 
     * [**glEvalCoord2**](glevalcoord2d.md)(i? u + u1 ( ) , (j+1) ? v + v1);
     * 
     * }
     * 
     * [**glEnd**](glend.md)( ); }
     * 
     * If *mode* is GL\_LINE, then a call to **glEvalMesh2** is equivalent to:
     * 
     * for (j = j1; j <= j2; j += 1)
     * 
     * {
     * 
     * [**glBegin**](glbegin.md)(GL\_LINE\_STRIP);
     * 
     * for (i = i1; i <= i2; i += 1)
     * 
     * {
     * 
     * [**glEvalCoord2**](glevalcoord2d.md)(i? u + u1, j? v + v1);
     * 
     * }
     * 
     * [**glEnd**](glend.md)( );
     * 
     * }
     * 
     * for (i = i1; i <= i2; i += 1)
     * 
     * {
     * 
     * [**glBegin**](glbegin.md)(GL\_LINE\_STRIP);
     * 
     * for (j = j1; j <= j1; j += 1)
     * 
     * {
     * 
     * [**glEvalCoord2**](glevalcoord2d.md)(i? u + u1, j? v + v1);
     * 
     * }
     * 
     * glEnd( );
     * 
     * }
     * 
     * And finally, if *mode* is GL\_POINT, then a call to **glEvalMesh2** is equivalent to:
     * 
     * [**glBegin**](glbegin.md)(GL\_POINTS);
     * 
     * for (j = j1; j <= j2; j += 1)
     * 
     * {
     * 
     * for (i = i1; i <= i2; i += 1)
     * 
     * {
     * 
     * [**glEvalCoord2**](glevalcoord2d.md)(i? u + u1, j? v + v1);
     * 
     * }
     * 
     * }
     * 
     * [**glEnd**](glend.md)( );
     * 
     * In all three cases, the only absolute numeric requirements are that if i = n, then the value computed from i? u + u1 is exactly u2, and if j = m, then the value computed from j? v + v1 is exactly v2. The following functions retrieve information relating to **glEvalMesh**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP1\_GRID\_DOMAIN
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP2\_GRID\_DOMAIN
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP1\_GRID\_SEGMENTS
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP2\_GRID\_SEGMENTS
     * @param {Integer} mode A value that specifies whether to compute a two-dimensional mesh of points, lines, or polygons. The following symbolic constants are accepted: GL\_POINT, GL\_LINE, and GL\_FILL.
     * @param {Integer} i1 The first integer value for grid domain variable i.
     * @param {Integer} i2 The last integer value for grid domain variable i.
     * @param {Integer} j1 The first integer value for grid domain variable j.
     * @param {Integer} j2 The last integer value for grid domain variable j.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glevalmesh2
     */
    static glEvalMesh2(mode, i1, i2, j1, j2) {
        DllCall("OPENGL32.dll\glEvalMesh2", "uint", mode, "int", i1, "int", i2, "int", j1, "int", j2)
    }

    /**
     * The glEvalPoint1 and glEvalPoint2 functions generate and evaluate a single point in a mesh. | glEvalPoint1 function (Gl.h)
     * @remarks
     * The [**glMapGrid**](glmapgrid-functions.md) and [**glEvalMesh**](glevalmesh-functions.md) functions are used in tandem to efficiently generate and evaluate a series of evenly spaced map domain values. You can use **glEvalPoint** to evaluate a single grid point in the same gridspace that is traversed by **glEvalMesh**. Calling [**glEvalPoint1**](glevalpoint.md) is equivalent to calling
     * 
     * **glEvalCoord1** (*i* ?*u* +*u*1 );
     * 
     * where
     * 
     * ?*u* = (*u*2 *u*1 )//n*
     * 
     * and *n*, *u*1 , and *u*2 are the arguments to the most recent **glMapGrid1** function. The one absolute numeric requirement is that if *i* = *n*, then the value computed from (*i* ?*u* + u1 ) is exactly *u*2 .
     * 
     * In the two-dimensional case, **glEvalPoint2**, let
     * 
     * ?*u* = (*u*2 *u*1 )//n*
     * 
     * ?*v* = (*v*2 *v*1 )//m*
     * 
     * where *n*, *u*1 , *u*2 , *m*, *v*1 , and *v*2  are the arguments to the most recent **glMapGrid2** function. Then the **glEvalPoint2** function is equivalent to calling
     * 
     * **glEvalCoord2** (*i* ?*u* + *u*1 , *j* ?*v* + *v*1 );
     * 
     * The only absolute numeric requirements are that if *i*=*n*, then the value computed from (*i* ?*u* + *u*1 ) is exactly u2 , and if *j* = *m*, then the value computed from (*j* ?*v* + *v*1  ) is exactly *v*2 .
     * 
     * The following functions retrieve information relating to [**glEvalPoint1**](glevalpoint.md) and **glEvalPoint2**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP1\_GRID\_DOMAIN
     * 
     * **glGet** with argument GL\_MAP2\_GRID\_DOMAIN
     * 
     * **glGet** with argument GL\_MAP1\_GRID\_SEGMENTS
     * 
     * **glGet** with argument GL\_MAP2\_GRID\_SEGMENTS
     * @param {Integer} i The integer value for grid domain variable *i*.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glevalpoint1
     */
    static glEvalPoint1(i) {
        DllCall("OPENGL32.dll\glEvalPoint1", "int", i)
    }

    /**
     * The glEvalPoint1 and glEvalPoint2 functions generate and evaluate a single point in a mesh. | glEvalPoint2 function (Gl.h)
     * @remarks
     * The [**glMapGrid**](glmapgrid-functions.md) and [**glEvalMesh**](glevalmesh-functions.md) functions are used in tandem to efficiently generate and evaluate a series of evenly spaced map domain values. You can use **glEvalPoint** to evaluate a single grid point in the same gridspace that is traversed by **glEvalMesh**. Calling [**glEvalPoint1**](glevalpoint.md) is equivalent to calling
     * 
     * **glEvalCoord1** (*i* ?*u* +*u*1 );
     * 
     * where
     * 
     * ?*u* = (*u*2 *u*1 )//n*
     * 
     * and *n*, *u*1 , and *u*2 are the arguments to the most recent **glMapGrid1** function. The one absolute numeric requirement is that if *i* = *n*, then the value computed from (*i* ?*u* + u1 ) is exactly *u*2 .
     * 
     * In the two-dimensional case, **glEvalPoint2**, let
     * 
     * ?*u* = (*u*2 *u*1 )//n*
     * 
     * ?*v* = (*v*2 *v*1 )//m*
     * 
     * where *n*, *u*1 , *u*2 , *m*, *v*1 , and *v*2  are the arguments to the most recent **glMapGrid2** function. Then the **glEvalPoint2** function is equivalent to calling
     * 
     * **glEvalCoord2** (*i* ?*u* + *u*1 , *j* ?*v* + *v*1 );
     * 
     * The only absolute numeric requirements are that if *i*=*n*, then the value computed from (*i* ?*u* + *u*1 ) is exactly u2 , and if *j* = *m*, then the value computed from (*j* ?*v* + *v*1  ) is exactly *v*2 .
     * 
     * The following functions retrieve information relating to [**glEvalPoint1**](glevalpoint.md) and **glEvalPoint2**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP1\_GRID\_DOMAIN
     * 
     * **glGet** with argument GL\_MAP2\_GRID\_DOMAIN
     * 
     * **glGet** with argument GL\_MAP1\_GRID\_SEGMENTS
     * 
     * **glGet** with argument GL\_MAP2\_GRID\_SEGMENTS
     * @param {Integer} i The integer value for grid domain variable *i*.
     * @param {Integer} j The integer value for grid domain variable *j* .
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glevalpoint2
     */
    static glEvalPoint2(i, j) {
        DllCall("OPENGL32.dll\glEvalPoint2", "int", i, "int", j)
    }

    /**
     * The glFeedbackBuffer function controls feedback mode.
     * @remarks
     * The **glFeedbackBuffer** function controls feedback. Feedback, like selection, is an OpenGL mode. The mode is selected by calling [**glRenderMode**](glrendermode.md) with GL\_FEEDBACK. When OpenGL is in feedback mode, no pixels are produced by rasterization. Instead, information about primitives that would have been rasterized is fed back to the application using OpenGL.
     * 
     * The **glFeedbackBuffer** function has three arguments:
     * 
     * -   *buffer* is a pointer to an array of floating-point values into which feedback information is placed.
     * -   *size* indicates the size of the array.
     * -   *type* is a symbolic constant describing the information that is fed back for each vertex.
     * 
     * You must issue **glFeedbackBuffer** before feedback mode is enabled (by calling **glRenderMode** with argument GL\_FEEDBACK). Setting GL\_FEEDBACK without establishing the feedback buffer, or calling **glFeedbackBuffer** while OpenGL is in feedback mode, is an error.
     * 
     * Take OpenGL out of feedback mode by calling [**glRenderMode**](glrendermode.md) with a parameter value other than GL\_FEEDBACK. When you do this while OpenGL is in feedback mode, **glRenderMode** returns the number of entries placed in the feedback array. The returned value never exceeds *size*. If the feedback data required more room than was available in *buffer*, **glRenderMode** returns a negative value.
     * 
     * While in feedback mode, each primitive that would be rasterized generates a block of values that gets copied into the feedback array. If doing so would cause the number of entries to exceed the maximum, **glFeedbackBuffer** partially writes the block so as to fill the array (if there is any room left at all), and sets an overflow flag. Each block begins with a code indicating the primitive type, followed by values that describe the primitive's vertices and associated data. The **glFeedbackBuffer** function also writes entries for bitmaps and pixel rectangles. Feedback occurs after polygon culling and [**glPolygonMode**](glpolygonmode.md) interpretation of polygons has taken place, so polygons that are culled are not returned in the feedback buffer. It can also occur after polygons with more than three edges are broken up into triangles, if the OpenGL implementation renders polygons by performing this decomposition.
     * 
     * You can insert a marker into the feedback buffer with [**glPassThrough**](glpassthrough.md).
     * 
     * The following is the grammar for the blocks of values written into the feedback buffer. Each primitive is indicated with a unique identifying value followed by some number of vertices. Polygon entries include an integer value indicating how many vertices follow. A vertex is fed back as some number of floating-point values, as determined by *type*. Colors are fed back as four values in RGBA mode and one value in color-index mode.
     * 
     * feedbackList <  feedbackItem feedbackList \| feedbackItem
     * 
     * feedbackItem <  point \| lineSegment \| polygon \| bitmap \| pixelRectangle \| passThru
     * 
     * point <  GL\_POINT\_TOKEN vertex
     * 
     * lineSegment <  GL\_LINE\_TOKEN vertex vertex \| GL\_LINE\_RESET\_TOKEN vertex vertex
     * 
     * polygon <  GL\_POLYGON\_TOKEN n polySpec
     * 
     * polySpec <  polySpec vertex \| vertex vertex vertex
     * 
     * bitmap <  GL\_BITMAP\_TOKEN vertex
     * 
     * pixelRectangle <  GL\_DRAW\_PIXEL\_TOKEN vertex \| GL\_COPY\_PIXEL\_TOKEN vertex
     * 
     * passThru <  GL\_PASS\_THROUGH\_TOKEN value
     * 
     * vertex <  2d \| 3d \| 3dColor \| 3dColorTexture \| 4dColorTexture
     * 
     * 2d <  value value
     * 
     * 3d <  value value value
     * 
     * 3dColor <  value value value color
     * 
     * 3dColorTexture <  value value value color tex
     * 
     * 4dColorTexture <  value value value value color tex
     * 
     * color <  rgba \| index
     * 
     * rgba <  value value value value
     * 
     * index <  value
     * 
     * tex <  value value value value
     * 
     * The *value* parameter is a floating-point number, and *n* is a floating-point integer giving the number of vertices in the polygon. The following are symbolic floating-point constants: GL\_POINT\_TOKEN, GL\_LINE\_TOKEN, GL\_LINE\_RESET\_TOKEN, GL\_POLYGON\_TOKEN, GL\_BITMAP\_TOKEN, GL\_DRAW\_PIXEL\_TOKEN, GL\_COPY\_PIXEL\_TOKEN, and GL\_PASS\_THROUGH\_TOKEN. GL\_LINE\_RESET\_TOKEN is returned whenever the line stipple pattern is reset. The data returned as a vertex depends on the feedback *type*.
     * 
     * The following table gives the correspondence between *type* and the number of values per vertex; *k* is 1 in color-index mode and 4 in RGBA mode.
     * 
     * 
     * 
     * | Type                   | Coordinates        | Color | Texture | Total number of values |
     * |------------------------|--------------------|-------|---------|------------------------|
     * | GL\_2D                 | *x*, *y*           |       |         | 2                      |
     * | GL\_3D                 | *x*, *y*, *z*      |       |         | 3                      |
     * | GL\_3D\_COLOR          | *x*, *y*, *z*      | *k*   |         | 3 + *k*                |
     * | GL\_3D\_COLOR\_TEXTURE | *x*, *y*, *z*,     | *k*   | 4       | 7 + *k*                |
     * | GL\_4D\_COLOR\_TEXTURE | *x*, *y*, *z*, *w* | *k*   | 4       | 8 + *k*                |
     * 
     * 
     * 
     *  
     * 
     * Feedback vertex coordinates are in window coordinates, except *w*, which is in clip coordinates. Feedback colors are lighted, if lighting is enabled. Feedback texture coordinates are generated, if texture coordinate generation is enabled. They are always transformed by the texture matrix.
     * 
     * The **glFeedbackBuffer** function, when used in a display list, is not compiled into the display list but rather is executed immediately.
     * 
     * The following function retrieves information related to **glFeedbackBuffer**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_RENDER\_MODE
     * @param {Integer} size The maximum number of values that can be written into *buffer*.
     * @param {Integer} type A symbolic constant that describes the information that will be returned for each vertex. The following symbolic constants are accepted: GL\_2D, GL\_3D, GL\_3D\_COLOR, GL\_3D\_COLOR\_TEXTURE, and GL\_4D\_COLOR\_TEXTURE.
     * @param {Pointer<Single>} buffer Returns the feedback data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glfeedbackbuffer
     */
    static glFeedbackBuffer(size, type, buffer) {
        DllCall("OPENGL32.dll\glFeedbackBuffer", "int", size, "uint", type, "ptr", buffer)
    }

    /**
     * The glFinish function blocks until all OpenGL execution is complete.
     * @remarks
     * The **glFinish** function does not return until the effects of all previously called OpenGL functions are complete. Such effects include all changes to the OpenGL state, all changes to the connection state, and all changes to the framebuffer contents.
     * 
     * The **glFinish** function requires a round trip to the server.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glfinish
     */
    static glFinish() {
        DllCall("OPENGL32.dll\glFinish")
    }

    /**
     * The glFlush function forces execution of OpenGL functions in finite time.
     * @remarks
     * Different OpenGL implementations buffer commands in several different locations, including network buffers and the graphics accelerator itself. The **glFlush** function empties all these buffers, causing all issued commands to be executed as quickly as they are accepted by the actual rendering engine. Though this execution may not be completed in any particular time period, it does complete in a finite amount of time.
     * 
     * Because any OpenGL program might be executed over a network, or on an accelerator that buffers commands, be sure to call **glFlush** in any programs requiring that all of their previously issued commands have been completed. For example, call **glFlush** before waiting for user input that depends on the generated image.
     * 
     * The **glFlush** function can return at any time. It does not wait until the execution of all previously issued OpenGL functions is complete.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glflush
     */
    static glFlush() {
        DllCall("OPENGL32.dll\glFlush")
    }

    /**
     * The glFogf and function specifies fog parameters.
     * @remarks
     * You enable and disable fog with [**glEnable**](glenable.md) and [**glDisable**](gldisable.md), using the argument GL\_FOG. While enabled, fog affects rasterized geometry, bitmaps, and pixel blocks, but not buffer-clear operations.
     * 
     * The **glFogf** function assigns the value or values in *params* to the fog parameter specified by *pname*.
     * 
     * Fog blends a fog color with each rasterized pixel fragment's posttexturing color using a blending factor *f*. Factor *f* is computed in one of three ways, depending on the fog mode. Let *z* be the distance in eye coordinates from the origin to the fragment being fogged. The equation for GL\_LINEAR fog is:
     * 
     * ![Equation showing the value of GL_LINEAR fog.](images/fog01.png)
     * 
     * The equation for GL\_EXP fog is:
     * 
     * ![Equation showing the value of the blending factor in GL_EXP fog mode.](images/fog02.png)
     * 
     * The equation for GL\_EXP2 fog is:
     * 
     * ![Equation showing the value of the blending factor in GL_EXP2 fog mode.](images/fog03.png)
     * 
     * Regardless of the fog mode, *f* is clamped to the range \[0,1\] after it is computed. Then, if OpenGL is in RGBA color mode, the fragment's color *C*<sub>r</sub> is replaced by
     * 
     * ![Equation showing the fogged fragment's color as a function of blending factor and fog color.](images/fog04.png)
     * 
     * In color-index mode, the fragment's color index *i*<sub>r</sub> is replaced by
     * 
     * ![Equation showing the fogged fragment's color index as a function of blending factor and indexed color.](images/fog05.png)
     * 
     * The following functions retrieve information related to the **glFog** functions:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_FOG\_COLOR
     * 
     * **glGet** with argument GL\_FOG\_INDEX
     * 
     * **glGet** with argument GL\_FOG\_DENSITY
     * 
     * **glGet** with argument GL\_FOG\_START
     * 
     * **glGet** with argument GL\_FOG\_END
     * 
     * **glGet** with argument GL\_FOG\_MODE
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_FOG
     * @param {Integer} pname Specifies a single-valued fog parameter.
     * 
     * Accepts one of the following values.
     * 
     * 
     * 
     * | Value                                                                                                                                                             | Meaning                                                                                                                                                                                                                                                                                                                                                          |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_FOG_MODE"></span><span id="gl_fog_mode"></span><dl> <dt>**GL\_FOG\_MODE**</dt> </dl>          | The *params* parameter is a single floating-point value that specifies the equation to be used to compute the fog blend factor, *f*. Three symbolic constants are accepted: GL\_LINEAR, GL\_EXP, and GL\_EXP2. The equations corresponding to these symbolic constants are defined in the following Remarks section. The default fog mode is GL\_EXP.<br/> |
     * | <span id="GL_FOG_DENSITY"></span><span id="gl_fog_density"></span><dl> <dt>**GL\_FOG\_DENSITY**</dt> </dl> | The *params* parameter is a single floating-point value that specifies *density*, the fog density used in both exponential fog equations. Only nonnegative densities are accepted. The default fog density is 1.0.<br/>                                                                                                                                    |
     * | <span id="GL_FOG_START"></span><span id="gl_fog_start"></span><dl> <dt>**GL\_FOG\_START**</dt> </dl>       | The *params* parameter is a single floating-point value that specifies *start*, the near distance used in the linear fog equation. The default near distance is 0.0.<br/>                                                                                                                                                                                  |
     * | <span id="GL_FOG_END"></span><span id="gl_fog_end"></span><dl> <dt>**GL\_FOG\_END**</dt> </dl>             | The *params* parameter is a single floating-point value that specifies *end*, the far distance used in the linear fog equation. The default far distance is 1.0.<br/>                                                                                                                                                                                      |
     * | <span id="GL_FOG_INDEX"></span><span id="gl_fog_index"></span><dl> <dt>**GL\_FOG\_INDEX**</dt> </dl>       | The *params* parameter is a single floating-point value that specifies *i*<sub>f</sub> , the fog color index. The default fog index is 0.0.<br/>                                                                                                                                                                                                           |
     * @param {Float} param1 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glfogf
     */
    static glFogf(pname, param1) {
        DllCall("OPENGL32.dll\glFogf", "uint", pname, "float", param1)
    }

    /**
     * The glFogfv function specifies fog parameters. | glFogfv function (Gl.h)
     * @remarks
     * You enable and disable fog with [**glEnable**](glenable.md) and [**glDisable**](gldisable.md), using the argument GL\_FOG. While enabled, fog affects rasterized geometry, bitmaps, and pixel blocks, but not buffer-clear operations.
     * 
     * The **glFogfv** function assigns the value or values in *params* to the fog parameter specified by *pname*.
     * 
     * Fog blends a fog color with each rasterized pixel fragment's posttexturing color using a blending factor *f*. Factor *f* is computed in one of three ways, depending on the fog mode. Let *z* be the distance in eye coordinates from the origin to the fragment being fogged. The equation for GL\_LINEAR fog is:
     * 
     * ![Equation showing the value of GL_LINEAR fog.](images/fog01.png)
     * 
     * The equation for GL\_EXP fog is:
     * 
     * ![Equation showing the value of the blending factor in GL_EXP fog mode.](images/fog02.png)
     * 
     * The equation for GL\_EXP2 fog is:
     * 
     * ![Equation showing the value of the blending factor in GL_EXP2 fog mode.](images/fog03.png)
     * 
     * Regardless of the fog mode, *f* is clamped to the range \[0,1\] after it is computed. Then, if OpenGL is in RGBA color mode, the fragment's color *C*<sub>r</sub> is replaced by
     * 
     * ![Equation showing the fogged fragment's color as a function of blending factor and fog color.](images/fog04.png)
     * 
     * In color-index mode, the fragment's color index *i*<sub>r</sub> is replaced by
     * 
     * ![Equation showing the fogged fragment's color index as a function of blending factor and indexed color.](images/fog05.png)
     * 
     * The following functions retrieve information related to the **glFog** functions:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_FOG\_COLOR
     * 
     * **glGet** with argument GL\_FOG\_INDEX
     * 
     * **glGet** with argument GL\_FOG\_DENSITY
     * 
     * **glGet** with argument GL\_FOG\_START
     * 
     * **glGet** with argument GL\_FOG\_END
     * 
     * **glGet** with argument GL\_FOG\_MODE
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_FOG
     * @param {Integer} pname Specifies a fog parameter.
     * 
     * Accepts one of the following values.
     * 
     * 
     * 
     * | Value                                                                                                                                                             | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                             |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_FOG_MODE"></span><span id="gl_fog_mode"></span><dl> <dt>**GL\_FOG\_MODE**</dt> </dl>          | The *params* parameter is a floating-point value that specifies the equation to be used to compute the fog blend factor, *f*. Three symbolic constants are accepted: GL\_LINEAR, GL\_EXP, and GL\_EXP2. The equations corresponding to these symbolic constants are defined in the following Remarks section. The default fog mode is GL\_EXP.<br/>                                                                           |
     * | <span id="GL_FOG_DENSITY"></span><span id="gl_fog_density"></span><dl> <dt>**GL\_FOG\_DENSITY**</dt> </dl> | The *params* parameter is a floating-point value that specifies *density*, the fog density used in both exponential fog equations. Only nonnegative densities are accepted. The default fog density is 1.0.<br/>                                                                                                                                                                                                              |
     * | <span id="GL_FOG_START"></span><span id="gl_fog_start"></span><dl> <dt>**GL\_FOG\_START**</dt> </dl>       | The *params* parameter is a floating-point value that specifies *start*, the near distance used in the linear fog equation. The default near distance is 0.0.<br/>                                                                                                                                                                                                                                                            |
     * | <span id="GL_FOG_END"></span><span id="gl_fog_end"></span><dl> <dt>**GL\_FOG\_END**</dt> </dl>             | The *params* parameter is a floating-point value that specifies *end*, the far distance used in the linear fog equation. The default far distance is 1.0.<br/>                                                                                                                                                                                                                                                                |
     * | <span id="GL_FOG_INDEX"></span><span id="gl_fog_index"></span><dl> <dt>**GL\_FOG\_INDEX**</dt> </dl>       | The *params* parameter is a floating-point value that specifies *i*<sub>f</sub> , the fog color index. The default fog index is 0.0.<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_FOG_COLOR"></span><span id="gl_fog_color"></span><dl> <dt>**GL\_FOG\_COLOR**</dt> </dl>       | The *params* parameter contains four floating-point values that specify *C*<sub>f</sub> , the fog color. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. After conversion, all color components are clamped to the range \[0,1\]. The default fog color is (0,0,0,0).<br/> |
     * @param {Pointer<Single>} params Specifies the value or values to be assigned to *pname*. GL\_FOG\_COLOR requires an array of four values. All other parameters accept an array containing only a single value.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glfogfv
     */
    static glFogfv(pname, params) {
        DllCall("OPENGL32.dll\glFogfv", "uint", pname, "ptr", params)
    }

    /**
     * The glFogi function specifies fog parameters.
     * @remarks
     * You enable and disable fog with [**glEnable**](glenable.md) and [**glDisable**](gldisable.md), using the argument GL\_FOG. While enabled, fog affects rasterized geometry, bitmaps, and pixel blocks, but not buffer-clear operations.
     * 
     * The **glFogi** function assigns the value or values in *params* to the fog parameter specified by *pname*.
     * 
     * Fog blends a fog color with each rasterized pixel fragment's posttexturing color using a blending factor *f*. Factor *f* is computed in one of three ways, depending on the fog mode. Let *z* be the distance in eye coordinates from the origin to the fragment being fogged. The equation for GL\_LINEAR fog is:
     * 
     * ![Equation showing the value of GL_LINEAR fog.](images/fog01.png)
     * 
     * The equation for GL\_EXP fog is:
     * 
     * ![Equation showing the value of the blending factor in GL_EXP fog mode.](images/fog02.png)
     * 
     * The equation for GL\_EXP2 fog is:
     * 
     * ![Equation showing the value of the blending factor in GL_EXP2 fog mode.](images/fog03.png)
     * 
     * Regardless of the fog mode, *f* is clamped to the range \[0,1\] after it is computed. Then, if OpenGL is in RGBA color mode, the fragment's color *C*<sub>r</sub> is replaced by
     * 
     * ![Equation showing the fogged fragment's color as a function of blending factor and fog color.](images/fog04.png)
     * 
     * In color-index mode, the fragment's color index *i*<sub>r</sub> is replaced by
     * 
     * ![Equation showing the fogged fragment's color index as a function of blending factor and indexed color.](images/fog05.png)
     * 
     * The following functions retrieve information related to the **glFog** functions:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_FOG\_COLOR
     * 
     * **glGet** with argument GL\_FOG\_INDEX
     * 
     * **glGet** with argument GL\_FOG\_DENSITY
     * 
     * **glGet** with argument GL\_FOG\_START
     * 
     * **glGet** with argument GL\_FOG\_END
     * 
     * **glGet** with argument GL\_FOG\_MODE
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_FOG
     * @param {Integer} pname Specifies a single-valued fog parameter.
     * 
     * Accepts one of the following values.
     * 
     * 
     * 
     * | Value                                                                                                                                                             | Meaning                                                                                                                                                                                                                                                                                                                                                   |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_FOG_MODE"></span><span id="gl_fog_mode"></span><dl> <dt>**GL\_FOG\_MODE**</dt> </dl>          | The *params* parameter is a single integer value that specifies the equation to be used to compute the fog blend factor, *f*. Three symbolic constants are accepted: GL\_LINEAR, GL\_EXP, and GL\_EXP2. The equations corresponding to these symbolic constants are defined in the following Remarks section. The default fog mode is GL\_EXP.<br/> |
     * | <span id="GL_FOG_DENSITY"></span><span id="gl_fog_density"></span><dl> <dt>**GL\_FOG\_DENSITY**</dt> </dl> | The *params* parameter is a single integer value that specifies *density*, the fog density used in both exponential fog equations. Only nonnegative densities are accepted. The default fog density is 1.0.<br/>                                                                                                                                    |
     * | <span id="GL_FOG_START"></span><span id="gl_fog_start"></span><dl> <dt>**GL\_FOG\_START**</dt> </dl>       | The *params* parameter is a single integer value that specifies *start*, the near distance used in the linear fog equation. The default near distance is 0.0.<br/>                                                                                                                                                                                  |
     * | <span id="GL_FOG_END"></span><span id="gl_fog_end"></span><dl> <dt>**GL\_FOG\_END**</dt> </dl>             | The *params* parameter is a single integer value that specifies *end*, the far distance used in the linear fog equation. The default far distance is 1.0.<br/>                                                                                                                                                                                      |
     * | <span id="GL_FOG_INDEX"></span><span id="gl_fog_index"></span><dl> <dt>**GL\_FOG\_INDEX**</dt> </dl>       | The *params* parameter is a single integer value that specifies *i*<sub>f</sub> , the fog color index. The default fog index is 0.0.<br/>                                                                                                                                                                                                           |
     * @param {Integer} param1 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glfogi
     */
    static glFogi(pname, param1) {
        DllCall("OPENGL32.dll\glFogi", "uint", pname, "int", param1)
    }

    /**
     * The glFogiv function specifies fog parameters. | glFogiv function (Gl.h)
     * @remarks
     * You enable and disable fog with [**glEnable**](glenable.md) and [**glDisable**](gldisable.md), using the argument GL\_FOG. While enabled, fog affects rasterized geometry, bitmaps, and pixel blocks, but not buffer-clear operations.
     * 
     * The **glFogiv** function assigns the value or values in *params* to the fog parameter specified by *pname*.
     * 
     * Fog blends a fog color with each rasterized pixel fragment's posttexturing color using a blending factor *f*. Factor *f* is computed in one of three ways, depending on the fog mode. Let *z* be the distance in eye coordinates from the origin to the fragment being fogged. The equation for GL\_LINEAR fog is:
     * 
     * ![Equation showing the value of the blending factor in GL_LINEAR fog mode as a function of distance.](images/fog01.png)
     * 
     * The equation for GL\_EXP fog is:
     * 
     * ![Equation showing the value of the blending factor in GL_EXP fog mode.](images/fog02.png)
     * 
     * The equation for GL\_EXP2 fog is:
     * 
     * ![Equation showing the value of the blending factor in GL_EXP2 fog mode.](images/fog03.png)
     * 
     * Regardless of the fog mode, *f* is clamped to the range \[0,1\] after it is computed. Then, if OpenGL is in RGBA color mode, the fragment's color *C*<sub>r</sub> is replaced by
     * 
     * ![Equation showing the fogged fragment's color as a function of blending factor and fog color.](images/fog04.png)
     * 
     * In color-index mode, the fragment's color index *i*<sub>r</sub> is replaced by
     * 
     * ![Equation showing the fogged fragment's color index as a function of blending factor and indexed color.](images/fog05.png)
     * 
     * The following functions retrieve information related to the **glFog** functions:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_FOG\_COLOR
     * 
     * **glGet** with argument GL\_FOG\_INDEX
     * 
     * **glGet** with argument GL\_FOG\_DENSITY
     * 
     * **glGet** with argument GL\_FOG\_START
     * 
     * **glGet** with argument GL\_FOG\_END
     * 
     * **glGet** with argument GL\_FOG\_MODE
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_FOG
     * @param {Integer} pname Specifies a fog parameter.
     * 
     * Accepts one of the following values.
     * 
     * 
     * 
     * | Value                                                                                                                                                             | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                        |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_FOG_MODE"></span><span id="gl_fog_mode"></span><dl> <dt>**GL\_FOG\_MODE**</dt> </dl>          | The *params* parameter is a single integer value that specifies the equation to be used to compute the fog blend factor, *f*. Three symbolic constants are accepted: GL\_LINEAR, GL\_EXP, and GL\_EXP2. The equations corresponding to these symbolic constants are defined in the following Remarks section. The default fog mode is GL\_EXP.<br/>                                                                                      |
     * | <span id="GL_FOG_DENSITY"></span><span id="gl_fog_density"></span><dl> <dt>**GL\_FOG\_DENSITY**</dt> </dl> | The *params* parameter is a single integer value that specifies *density*, the fog density used in both exponential fog equations. Only nonnegative densities are accepted. The default fog density is 1.0.<br/>                                                                                                                                                                                                                         |
     * | <span id="GL_FOG_START"></span><span id="gl_fog_start"></span><dl> <dt>**GL\_FOG\_START**</dt> </dl>       | The *params* parameter is a single integer value that specifies *start*, the near distance used in the linear fog equation. The default near distance is 0.0.<br/>                                                                                                                                                                                                                                                                       |
     * | <span id="GL_FOG_END"></span><span id="gl_fog_end"></span><dl> <dt>**GL\_FOG\_END**</dt> </dl>             | The *params* parameter is a single integer value that specifies *end*, the far distance used in the linear fog equation. The default far distance is 1.0.<br/>                                                                                                                                                                                                                                                                           |
     * | <span id="GL_FOG_INDEX"></span><span id="gl_fog_index"></span><dl> <dt>**GL\_FOG\_INDEX**</dt> </dl>       | The *params* parameter is a single integer value that specifies *i*<sub>f</sub> , the fog color index. The default fog index is 0.0.<br/>                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_FOG_COLOR"></span><span id="gl_fog_color"></span><dl> <dt>**GL\_FOG\_COLOR**</dt> </dl>       | The *params* parameter contains four integer or floating-point values that specify *C*<sub>f</sub> , the fog color. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. After conversion, all color components are clamped to the range \[0,1\]. The default fog color is (0,0,0,0).<br/> |
     * @param {Pointer<Int32>} params Specifies the value or values to be assigned to *pname*. GL\_FOG\_COLOR requires an array of four values. All other parameters accept an array containing only a single value.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glfogiv
     */
    static glFogiv(pname, params) {
        DllCall("OPENGL32.dll\glFogiv", "uint", pname, "ptr", params)
    }

    /**
     * The glFrontFace function defines front-facing and back-facing polygons.
     * @remarks
     * In a scene composed entirely of opaque closed surfaces, back-facing polygons are never visible. Eliminating these invisible polygons has the obvious benefit of speeding up the rendering of the image. You enable and disable elimination of back-facing polygons with [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) using argument GL\_CULL\_FACE.
     * 
     * The projection of a polygon to window coordinates is said to have clockwise winding if an imaginary object following the path from its first vertex, its second vertex, and so on, to its last vertex, and finally back to its first vertex, moves in a clockwise direction about the interior of the polygon. The polygon's winding is said to be counterclockwise if the imaginary object following the same path moves in a counterclockwise direction about the interior of the polygon. The **glFrontFace** function specifies whether polygons with clockwise winding in window coordinates, or counterclockwise winding in window coordinates, are taken to be front-facing. Passing GL\_CCW to *mode* selects counterclockwise polygons as front-facing; GL\_CW selects clockwise polygons as front-facing. By default, counterclockwise polygons are taken to be front-facing.
     * 
     * The following function retrieves information about **glFrontface**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_FRONT\_FACE
     * @param {Integer} mode The orientation of front-facing polygons. GL\_CW and GL\_CCW are accepted. The default value is GL\_CCW.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glfrontface
     */
    static glFrontFace(mode) {
        DllCall("OPENGL32.dll\glFrontFace", "uint", mode)
    }

    /**
     * The glFrustum function multiplies the current matrix by a perspective matrix.
     * @remarks
     * The **glFrustum** function describes a perspective matrix that produces a perspective projection. The (*left*, *bottom*, *zNear*) and (*right*, *top*, *zNear*) parameters specify the points on the near clipping plane that are mapped to the lower-left and upper-right corners of the window, respectively, assuming that the eye is located at (0,0,0). The *zFar* parameter specifies the location of the far clipping plane. Both *zNear* and *zFar* must be positive. The corresponding matrix is shown in the following image.
     * 
     * ![Diagram showing the perspective matrix that produces a perspective projection.](images/frust01.png)![Equations showing the glFrustum function that describes a perspective matrix.](images/frust02.png)
     * 
     * The **glFrustum** function multiplies the current matrix by this matrix, with the result replacing the current matrix. That is, if M is the current matrix and F is the frustum perspective matrix, then **glFrustum** replaces M with M   F.
     * 
     * Use [**glPushMatrix**](glpushmatrix.md) and [**glPopMatrix**](glpopmatrix.md) to save and restore the current matrix stack.
     * 
     * Depth-buffer precision is affected by the values specified for *zNear* and *zFar*. The greater the ratio of *zFar* to *zNear* is, the less effective the depth buffer will be at distinguishing between surfaces that are near each other. If
     * 
     * ![Equation showing the ratio of far to near.](images/frust03.png)
     * 
     * roughly *log*2 (*r*) bits of depth buffer precision are lost. Because *r* approaches infinity as *zNear* approaches zero, you should never set *zNear* to zero.
     * 
     * The following functions retrieve information about **glFrustum**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * 
     * **glGet** with argument GL\_MODELVIEW\_MATRIX
     * 
     * **glGet** with argument GL\_PROJECTION\_MATRIX
     * 
     * **glGet** with argument GL\_TEXTURE\_MATRIX
     * @param {Float} left The coordinate for the left-vertical clipping plane.
     * @param {Float} right The coordinate for the right-vertical clipping plane.
     * @param {Float} bottom The coordinate for the bottom-horizontal clipping plane.
     * @param {Float} top The coordinate for the bottom-horizontal clipping plane.
     * @param {Float} zNear The distances to the near-depth clipping plane. Must be positive.
     * @param {Float} zFar The distances to the far-depth clipping planes. Must be positive.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glfrustum
     */
    static glFrustum(left, right, bottom, top, zNear, zFar) {
        DllCall("OPENGL32.dll\glFrustum", "double", left, "double", right, "double", bottom, "double", top, "double", zNear, "double", zFar)
    }

    /**
     * The glGenLists function generates a contiguous set of empty display lists.
     * @remarks
     * The **glGenLists** function has one argument, *range*. It returns an integer *n* such that *range* contiguous empty display lists, named *n*, *n* + 1, . . ., *n* + (*range* - 1), are created. If *range* is zero, if there is no group of *range* contiguous names available, or if any error is generated, then no display lists are generated and zero is returned.
     * 
     * The following function retrieves information related to **glGenLists**:
     * 
     * [**glIsList**](glislist.md)
     * @param {Integer} range The number of contiguous empty display lists to be generated.
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgenlists
     */
    static glGenLists(range) {
        result := DllCall("OPENGL32.dll\glGenLists", "int", range, "uint")
        return result
    }

    /**
     * The glGenTextures function generates texture names.
     * @remarks
     * The **glGenTextures** function returns *n* texture names in the *textures* parameter. The texture names are not necessarily a contiguous set of integers, however, none of the returned names can have been in use immediately prior to calling the **glGenTextures** function. The generated textures assume the dimensionality of the texture target to which they are first bound with the [**glBindTexture**](glbindtexture.md) function. Texture names returned by **glGenTextures** are not returned by subsequent calls to **glGenTextures** unless they are first deleted by calling [**glDeleteTextures**](gldeletetextures.md).
     * 
     * You cannot include **glGenTextures** in display lists.
     * 
     * > [!Note]  
     * > The **glGenTextures** function is only available in OpenGL version 1.1 or later.
     * 
     *  
     * 
     * The following function retrieves information related to **glGenTextures**:
     * 
     * -   [**glIsTexture**](glistexture.md)
     * @param {Integer} n The number of texture names to be generated.
     * @param {Pointer<UInt32>} textures A pointer to the first element of an array in which the generated texture names are stored.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgentextures
     */
    static glGenTextures(n, textures) {
        DllCall("OPENGL32.dll\glGenTextures", "int", n, "ptr", textures)
    }

    /**
     * The glGetBooleanv function returns the value or values of a selected parameter.
     * @remarks
     * This function returns values for simple state variables in OpenGL. The *pname* parameter is a symbolic constant indicating the state variable to be returned, and *params* is a pointer to an array of the indicated type in which to place the returned data.
     * 
     * Type conversion is performed if *params* has a different type from the state variable value being requested. If you call **glGetBooleanv**, a floating-point or integer value is converted to GL\_FALSE if and only if it is zero. Otherwise, it is converted to GL\_TRUE.
     * 
     * If you call [**glGetIntegerv**](glgetintegerv.md), Boolean values are returned as GL\_TRUE or GL\_FALSE, and most floating-point values are rounded to the nearest integer value. Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most positive representable integer value and 1.0 to the most negative representable integer value.
     * 
     * If you call [**glGetFloatv**](glgetfloatv.md) or [**glGetDoublev**](glgetdoublev.md), Boolean values are returned as GL\_TRUE or GL\_FALSE, and integer values are converted to floating-point values.
     * 
     * You can query many of the Boolean parameters more easily with [**glIsEnabled**](glisenabled.md).
     * @param {Integer} pname The parameter value to be returned. The following symbolic constants are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                    |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_ACCUM_ALPHA_BITS"></span><span id="gl_accum_alpha_bits"></span><dl> <dt>**GL\_ACCUM\_ALPHA\_BITS**</dt> </dl>                                          | The *params* parameter returns one value: the number of alpha bitplanes in the accumulation buffer.<br/>                                                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_ACCUM_BLUE_BITS"></span><span id="gl_accum_blue_bits"></span><dl> <dt>**GL\_ACCUM\_BLUE\_BITS**</dt> </dl>                                             | The *params* parameter returns one value: the number of blue bitplanes in the accumulation buffer.<br/>                                                                                                                                                                                                                                                                                                                              |
     * | <span id="GL_ACCUM_CLEAR_VALUE"></span><span id="gl_accum_clear_value"></span><dl> <dt>**GL\_ACCUM\_CLEAR\_VALUE**</dt> </dl>                                       | The *params* parameter returns four values: the red, green, blue, and alpha values used to clear the accumulation buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glClearAccum**](glclearaccum.md).<br/>                      |
     * | <span id="GL_ACCUM_GREEN_BITS"></span><span id="gl_accum_green_bits"></span><dl> <dt>**GL\_ACCUM\_GREEN\_BITS**</dt> </dl>                                          | The *params* parameter returns one value: the number of green bitplanes in the accumulation buffer.<br/>                                                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_ACCUM_RED_BITS"></span><span id="gl_accum_red_bits"></span><dl> <dt>**GL\_ACCUM\_RED\_BITS**</dt> </dl>                                                | The *params* parameter returns one value: the number of red bitplanes in the accumulation buffer.<br/>                                                                                                                                                                                                                                                                                                                               |
     * | <span id="GL_ALPHA_BIAS"></span><span id="gl_alpha_bias"></span><dl> <dt>**GL\_ALPHA\_BIAS**</dt> </dl>                                                             | The *params* parameter returns one value: the alpha bias factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_ALPHA_BITS"></span><span id="gl_alpha_bits"></span><dl> <dt>**GL\_ALPHA\_BITS**</dt> </dl>                                                             | The *params* parameter returns one value: the number of alpha bitplanes in each color buffer.<br/>                                                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_ALPHA_SCALE"></span><span id="gl_alpha_scale"></span><dl> <dt>**GL\_ALPHA\_SCALE**</dt> </dl>                                                          | The *params* parameter returns one value: the alpha scale factor used during pixel transfers. See [glPixelTransfer](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                       |
     * | <span id="GL_ALPHA_TEST"></span><span id="gl_alpha_test"></span><dl> <dt>**GL\_ALPHA\_TEST**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether alpha testing of fragments is enabled. See [**glAlphaFunc**](glalphafunc.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_ALPHA_TEST_FUNC"></span><span id="gl_alpha_test_func"></span><dl> <dt>**GL\_ALPHA\_TEST\_FUNC**</dt> </dl>                                             | The *params* parameter returns one value: the symbolic name of the alpha test function. See [**glAlphaFunc**](glalphafunc.md).<br/>                                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_ALPHA_TEST_REF"></span><span id="gl_alpha_test_ref"></span><dl> <dt>**GL\_ALPHA\_TEST\_REF**</dt> </dl>                                                | The *params* parameter returns one value: the reference value for the alpha test. See [**glAlphaFunc**](glalphafunc.md). An integer value, if requested, is linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value.<br/>                                                               |
     * | <span id="GL_ATTRIB_STACK_DEPTH"></span><span id="gl_attrib_stack_depth"></span><dl> <dt>**GL\_ATTRIB\_STACK\_DEPTH**</dt> </dl>                                    | The *params* parameter returns one value: the depth of the attribute stack. If the stack is empty, zero is returned. See [**glPushAttrib**](glpushattrib.md).<br/>                                                                                                                                                                                                                                                                  |
     * | <span id="GL_AUTO_NORMAL"></span><span id="gl_auto_normal"></span><dl> <dt>**GL\_AUTO\_NORMAL**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether 2-D map evaluation automatically generates surface normals. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                              |
     * | <span id="GL_AUX_BUFFERS"></span><span id="gl_aux_buffers"></span><dl> <dt>**GL\_AUX\_BUFFERS**</dt> </dl>                                                          | The *params* parameter returns one value: the number of auxiliary color buffers.<br/>                                                                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_BLEND"></span><span id="gl_blend"></span><dl> <dt>**GL\_BLEND**</dt> </dl>                                                                             | The *params* parameter returns a single Boolean value indicating whether blending is enabled. See [**glBlendFunc**](glblendfunc.md).<br/>                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_BLEND_DST"></span><span id="gl_blend_dst"></span><dl> <dt>**GL\_BLEND\_DST**</dt> </dl>                                                                | The *params* parameter returns one value: the symbolic constant identifying the destination blend function. See [**glBlendFunc**](glblendfunc.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_BLEND_SRC"></span><span id="gl_blend_src"></span><dl> <dt>**GL\_BLEND\_SRC**</dt> </dl>                                                                | The *params* parameter returns one value: the symbolic constant identifying the source blend function. See [**glBlendFunc**](glblendfunc.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_BLUE_BIAS"></span><span id="gl_blue_bias"></span><dl> <dt>**GL\_BLUE\_BIAS**</dt> </dl>                                                                | The *params* parameter returns one value: the blue bias factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_BLUE_BITS"></span><span id="gl_blue_bits"></span><dl> <dt>**GL\_BLUE\_BITS**</dt> </dl>                                                                | The *params* parameter returns one value: the number of blue bitplanes in each color buffer.<br/>                                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_BLUE_SCALE"></span><span id="gl_blue_scale"></span><dl> <dt>**GL\_BLUE\_SCALE**</dt> </dl>                                                             | The *params* parameter returns one value: the blue scale factor used during pixel transfers. See [glPixelTransfer](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_CLIENT_ATTRIB_STACK_DEPTH"></span><span id="gl_client_attrib_stack_depth"></span><dl> <dt>**GL\_CLIENT\_ATTRIB\_STACK\_DEPTH**</dt> </dl>              | The *params* parameter returns one value indicating the depth of the attribute stack. The initial value is zero. See [**glPushClientAttrib**](glpushclientattrib.md).<br/>                                                                                                                                                                                                                                                          |
     * | <span id="GL_CLIP_PLANEi"></span><span id="gl_clip_planei"></span><span id="GL_CLIP_PLANEI"></span><dl> <dt>**GL\_CLIP\_PLANE*i***</dt> </dl>                       | The *params* parameter returns a single Boolean value indicating whether the specified clipping plane is enabled. See [**glClipPlane**](glclipplane.md).<br/>                                                                                                                                                                                                                                                                       |
     * | <span id="GL_COLOR_ARRAY"></span><span id="gl_color_array"></span><dl> <dt>**GL\_COLOR\_ARRAY**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether the specified color array is defined. See [**glColorPointer**](glcolorpointer.md).<br/>                                                                                                                                                                                                                                                                    |
     * | <span id="GL_COLOR_ARRAY_SIZE"></span><span id="gl_color_array_size"></span><dl> <dt>**GL\_COLOR\_ARRAY\_SIZE**</dt> </dl>                                          | The *params* parameter returns one value, the number of components per color in the color array. See [**glColorPointer**](glcolorpointer.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_COLOR_ARRAY_STRIDE"></span><span id="gl_color_array_stride"></span><dl> <dt>**GL\_COLOR\_ARRAY\_STRIDE**</dt> </dl>                                    | The *params* parameter returns one value, the byte offset between consecutive colors in the color array. See [**glColorPointer**](glcolorpointer.md).<br/>                                                                                                                                                                                                                                                                          |
     * | <span id="GL_COLOR_ARRAY_TYPE"></span><span id="gl_color_array_type"></span><dl> <dt>**GL\_COLOR\_ARRAY\_TYPE**</dt> </dl>                                          | The *params* parameter returns one value, the data type of each component in the color array. See [**glColorPointer**](glcolorpointer.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_COLOR_CLEAR_VALUE"></span><span id="gl_color_clear_value"></span><dl> <dt>**GL\_COLOR\_CLEAR\_VALUE**</dt> </dl>                                       | The *params* parameter returns four values: the red, green, blue, and alpha values used to clear the color buffers. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glClearColor**](glclearcolor.md).<br/>                            |
     * | <span id="GL_COLOR_LOGIC_OP"></span><span id="gl_color_logic_op"></span><dl> <dt>**GL\_COLOR\_LOGIC\_OP**</dt> </dl>                                                | The *params* parameter returns a single Boolean value indicating whether a fragment's RGBA color values are merged into the framebuffer using a logical operation. See [**glLogicOp**](gllogicop.md).<br/>                                                                                                                                                                                                                          |
     * | <span id="GL_COLOR_MATERIAL"></span><span id="gl_color_material"></span><dl> <dt>**GL\_COLOR\_MATERIAL**</dt> </dl>                                                 | The *params* parameter returns a single Boolean value indicating whether one or more material parameters are tracking the current color. See [**glColorMaterial**](glcolormaterial.md).<br/>                                                                                                                                                                                                                                        |
     * | <span id="GL_COLOR_MATERIAL_FACE"></span><span id="gl_color_material_face"></span><dl> <dt>**GL\_COLOR\_MATERIAL\_FACE**</dt> </dl>                                 | The *params* parameter returns one value: a symbolic constant indicating which materials have a parameter that is tracking the current color. See [**glColorMaterial**](glcolormaterial.md).<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_COLOR_MATERIAL_PARAMETER"></span><span id="gl_color_material_parameter"></span><dl> <dt>**GL\_COLOR\_MATERIAL\_PARAMETER**</dt> </dl>                  | The *params* parameter returns one value: a symbolic constant indicating which material parameters are tracking the current color. See [**glColorMaterial**](glcolormaterial.md).<br/>                                                                                                                                                                                                                                              |
     * | <span id="GL_COLOR_WRITEMASK"></span><span id="gl_color_writemask"></span><dl> <dt>**GL\_COLOR\_WRITEMASK**</dt> </dl>                                              | The *params* parameter returns four Boolean values: the red, green, blue, and alpha write enables for the color buffers. See [**glColorMask**](glcolormask.md).<br/>                                                                                                                                                                                                                                                                |
     * | <span id="GL_CULL_FACE"></span><span id="gl_cull_face"></span><dl> <dt>**GL\_CULL\_FACE**</dt> </dl>                                                                | The *params* parameter returns a single Boolean value indicating whether polygon culling is enabled. See [**glCullFace**](glcullface.md).<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_CULL_FACE_MODE"></span><span id="gl_cull_face_mode"></span><dl> <dt>**GL\_CULL\_FACE\_MODE**</dt> </dl>                                                | The *params* parameter returns one value: a symbolic constant indicating which polygon faces are to be culled. See [**glCullFace**](glcullface.md).<br/>                                                                                                                                                                                                                                                                            |
     * | <span id="GL_CURRENT_COLOR"></span><span id="gl_current_color"></span><dl> <dt>**GL\_CURRENT\_COLOR**</dt> </dl>                                                    | The *params* parameter returns four values: the red, green, blue, and alpha values of the current color. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glColor**](glcolor-functions.md).<br/>                                       |
     * | <span id="GL_CURRENT_INDEX"></span><span id="gl_current_index"></span><dl> <dt>**GL\_CURRENT\_INDEX**</dt> </dl>                                                    | The *params* parameter returns one value: the current color index. See [**glIndex**](glindex-functions.md).<br/>                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_CURRENT_NORMAL"></span><span id="gl_current_normal"></span><dl> <dt>**GL\_CURRENT\_NORMAL**</dt> </dl>                                                 | The *params* parameter returns three values: the *x*, *y*, and *z* values of the current normal. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glNormal**](glnormal-functions.md).<br/>                                             |
     * | <span id="GL_CURRENT_RASTER_COLOR"></span><span id="gl_current_raster_color"></span><dl> <dt>**GL\_CURRENT\_RASTER\_COLOR**</dt> </dl>                              | The *params* parameter returns four values: the red, green, blue, and alpha values of the current raster position. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glRasterPos**](glrasterpos-functions.md).<br/>                     |
     * | <span id="GL_CURRENT_RASTER_DISTANCE"></span><span id="gl_current_raster_distance"></span><dl> <dt>**GL\_CURRENT\_RASTER\_DISTANCE**</dt> </dl>                     | The *params* parameter returns one value: the distance from the eye to the current raster position. See [**glRasterPos**](glrasterpos-functions.md).<br/>                                                                                                                                                                                                                                                                           |
     * | <span id="GL_CURRENT_RASTER_INDEX"></span><span id="gl_current_raster_index"></span><dl> <dt>**GL\_CURRENT\_RASTER\_INDEX**</dt> </dl>                              | The *params* parameter returns one value: the color index of the current raster position. See [**glRasterPos**](glrasterpos-functions.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_CURRENT_RASTER_POSITION"></span><span id="gl_current_raster_position"></span><dl> <dt>**GL\_CURRENT\_RASTER\_POSITION**</dt> </dl>                     | The *params* parameter returns four values: the *x*, *y*, *z*, and *w* components of the current raster position. The *x*, *y*, and *z* components are in window coordinates, and *w* is in clip coordinates. See [glRasterPos](glrasterpos-functions.md).<br/>                                                                                                                                                                     |
     * | <span id="GL_CURRENT_RASTER_POSITION_VALID"></span><span id="gl_current_raster_position_valid"></span><dl> <dt>**GL\_CURRENT\_RASTER\_POSITION\_VALID**</dt> </dl>  | The *params* parameter returns a single Boolean value indicating whether the current raster position is valid. See [**glRasterPos**](glrasterpos-functions.md).<br/>                                                                                                                                                                                                                                                                |
     * | <span id="GL_CURRENT_RASTER_TEXTURE_COORDS"></span><span id="gl_current_raster_texture_coords"></span><dl> <dt>**GL\_CURRENT\_RASTER\_TEXTURE\_COORDS**</dt> </dl>  | The *params* parameter returns four values: the *s*, *t*, *r*, and *q* current raster texture coordinates. See [**glRasterPos**](glrasterpos-functions.md) and [**glTexCoord**](gltexcoord-functions.md).<br/>                                                                                                                                                                                                                     |
     * | <span id="GL_CURRENT_TEXTURE_COORDS"></span><span id="gl_current_texture_coords"></span><dl> <dt>**GL\_CURRENT\_TEXTURE\_COORDS**</dt> </dl>                        | The *params* parameter returns four values: the *s*, *t*, *r*, and *q* current texture coordinates. See [**glTexCoord**](gltexcoord-functions.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_DEPTH_BIAS"></span><span id="gl_depth_bias"></span><dl> <dt>**GL\_DEPTH\_BIAS**</dt> </dl>                                                             | The *params* parameter returns one value: the depth bias factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_DEPTH_BITS"></span><span id="gl_depth_bits"></span><dl> <dt>**GL\_DEPTH\_BITS**</dt> </dl>                                                             | The *params* parameter returns one value: the number of bitplanes in the depth buffer.<br/>                                                                                                                                                                                                                                                                                                                                          |
     * | <span id="GL_DEPTH_CLEAR_VALUE"></span><span id="gl_depth_clear_value"></span><dl> <dt>**GL\_DEPTH\_CLEAR\_VALUE**</dt> </dl>                                       | The *params* parameter returns one value: the value that is used to clear the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glClearDepth**](glcleardepth.md).<br/>                                                    |
     * | <span id="GL_DEPTH_FUNC"></span><span id="gl_depth_func"></span><dl> <dt>**GL\_DEPTH\_FUNC**</dt> </dl>                                                             | The *params* parameter returns one value: the symbolic constant that indicates the depth comparison function. See [**glDepthFunc**](gldepthfunc.md).<br/>                                                                                                                                                                                                                                                                           |
     * | <span id="GL_DEPTH_RANGE"></span><span id="gl_depth_range"></span><dl> <dt>**GL\_DEPTH\_RANGE**</dt> </dl>                                                          | The *params* parameter returns two values: the near and far mapping limits for the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glDepthRange**](gldepthrange.md).<br/>                                               |
     * | <span id="GL_DEPTH_SCALE"></span><span id="gl_depth_scale"></span><dl> <dt>**GL\_DEPTH\_SCALE**</dt> </dl>                                                          | The *params* parameter returns one value: the depth scale factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_DEPTH_TEST"></span><span id="gl_depth_test"></span><dl> <dt>**GL\_DEPTH\_TEST**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether depth testing of fragments is enabled. See [**glDepthFunc**](gldepthfunc.md) and [**glDepthRange**](gldepthrange.md).<br/>                                                                                                                                                                                                                                |
     * | <span id="GL_DEPTH_WRITEMASK"></span><span id="gl_depth_writemask"></span><dl> <dt>**GL\_DEPTH\_WRITEMASK**</dt> </dl>                                              | The *params* parameter returns a single Boolean value indicating if the depth buffer is enabled for writing. See [**glDepthMask**](gldepthmask.md).<br/>                                                                                                                                                                                                                                                                            |
     * | <span id="GL_DITHER"></span><span id="gl_dither"></span><dl> <dt>**GL\_DITHER**</dt> </dl>                                                                          | The *params* parameter returns a single Boolean value indicating whether dithering of fragment colors and indexes is enabled.<br/>                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_DOUBLEBUFFER"></span><span id="gl_doublebuffer"></span><dl> <dt>**GL\_DOUBLEBUFFER**</dt> </dl>                                                        | The *params* parameter returns a single Boolean value indicating whether double buffering is supported.<br/>                                                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_DRAW_BUFFER"></span><span id="gl_draw_buffer"></span><dl> <dt>**GL\_DRAW\_BUFFER**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating which buffers are being drawn to. See [**glDrawBuffer**](gldrawbuffer.md).<br/>                                                                                                                                                                                                                                                                            |
     * | <span id="GL_EDGE_FLAG"></span><span id="gl_edge_flag"></span><dl> <dt>**GL\_EDGE\_FLAG**</dt> </dl>                                                                | The *params* parameter returns a single Boolean value indicating whether the current edge flag is true or false. See [glEdgeFlag](gledgeflag-functions.md).<br/>                                                                                                                                                                                                                                                                    |
     * | <span id="GL_EDGE_FLAG_ARRAY"></span><span id="gl_edge_flag_array"></span><dl> <dt>**GL\_EDGE\_FLAG\_ARRAY**</dt> </dl>                                             | The *params* parameter returns a single Boolean value indicating whether the edge flag array is enabled. See [**glEdgeFlagPointer**](gledgeflagpointer.md).<br/>                                                                                                                                                                                                                                                                    |
     * | <span id="GL_EDGE_FLAG_ARRAY_STRIDE"></span><span id="gl_edge_flag_array_stride"></span><dl> <dt>**GL\_EDGE\_FLAG\_ARRAY\_STRIDE**</dt> </dl>                       | The *params* parameter returns one value, the byte offset between consecutive edge flags in the edge flag array. See [**glEdgeFlagPointer**](gledgeflagpointer.md).<br/>                                                                                                                                                                                                                                                            |
     * | <span id="GL_FOG"></span><span id="gl_fog"></span><dl> <dt>**GL\_FOG**</dt> </dl>                                                                                   | The *params* parameter returns a single Boolean value indicating whether fogging is enabled. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_FOG_COLOR"></span><span id="gl_fog_color"></span><dl> <dt>**GL\_FOG\_COLOR**</dt> </dl>                                                                | The *params* parameter returns four values: the red, green, blue, and alpha components of the fog color. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glFog**](glfog.md).<br/>                                                     |
     * | <span id="GL_FOG_DENSITY"></span><span id="gl_fog_density"></span><dl> <dt>**GL\_FOG\_DENSITY**</dt> </dl>                                                          | The *params* parameter returns one value: the fog density parameter. See [glFog](glfog.md).<br/>                                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_FOG_END"></span><span id="gl_fog_end"></span><dl> <dt>**GL\_FOG\_END**</dt> </dl>                                                                      | The *params* parameter returns one value: the end factor for the linear fog equation. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                                               |
     * | <span id="GL_FOG_HINT"></span><span id="gl_fog_hint"></span><dl> <dt>**GL\_FOG\_HINT**</dt> </dl>                                                                   | The *params* parameter returns one value: a symbolic constant indicating the mode of the fog hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_FOG_INDEX"></span><span id="gl_fog_index"></span><dl> <dt>**GL\_FOG\_INDEX**</dt> </dl>                                                                | The *params* parameter returns one value: the fog color index. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_FOG_MODE"></span><span id="gl_fog_mode"></span><dl> <dt>**GL\_FOG\_MODE**</dt> </dl>                                                                   | The *params* parameter returns one value: a symbolic constant indicating which fog equation is selected. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_FOG_START"></span><span id="gl_fog_start"></span><dl> <dt>**GL\_FOG\_START**</dt> </dl>                                                                | The *params* parameter returns one value: the start factor for the linear fog equation. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_FRONT_FACE"></span><span id="gl_front_face"></span><dl> <dt>**GL\_FRONT\_FACE**</dt> </dl>                                                             | The *params* parameter returns one value: a symbolic constant indicating whether clockwise or counterclockwise polygon winding is treated as front-facing. See [**glFrontFace**](glfrontface.md).<br/>                                                                                                                                                                                                                              |
     * | <span id="GL_GREEN_BIAS"></span><span id="gl_green_bias"></span><dl> <dt>**GL\_GREEN\_BIAS**</dt> </dl>                                                             | The *params* parameter returns one value: the green bias factor used during pixel transfers.<br/>                                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_GREEN_BITS"></span><span id="gl_green_bits"></span><dl> <dt>**GL\_GREEN\_BITS**</dt> </dl>                                                             | The *params* parameter returns one value: the number of green bitplanes in each color buffer.<br/>                                                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_GREEN_SCALE"></span><span id="gl_green_scale"></span><dl> <dt>**GL\_GREEN\_SCALE**</dt> </dl>                                                          | The *params* parameter returns one value: the green scale factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_INDEX_ARRAY"></span><span id="gl_index_array"></span><dl> <dt>**GL\_INDEX\_ARRAY**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether the color index array is enabled. See [**glIndexPointer**](glindexpointer.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_INDEX_ARRAY_STRIDE"></span><span id="gl_index_array_stride"></span><dl> <dt>**GL\_INDEX\_ARRAY\_STRIDE**</dt> </dl>                                    | The *params* parameter returns one value, the byte offset between consecutive color indexes in the color index array. See [**glIndexPointer**](glindexpointer.md).<br/>                                                                                                                                                                                                                                                             |
     * | <span id="GL_INDEX_ARRAY_TYPE"></span><span id="gl_index_array_type"></span><dl> <dt>**GL\_INDEX\_ARRAY\_TYPE**</dt> </dl>                                          | The *params* parameter returns one value, the data type of indexes in the color index array. The initial value is GL\_FLOAT. See [**glIndexPointer**](glindexpointer.md).<br/>                                                                                                                                                                                                                                                      |
     * | <span id="GL_INDEX_BITS"></span><span id="gl_index_bits"></span><dl> <dt>**GL\_INDEX\_BITS**</dt> </dl>                                                             | The *params* parameter returns one value: the number of bitplanes in each color-index buffer.<br/>                                                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_INDEX_CLEAR_VALUE"></span><span id="gl_index_clear_value"></span><dl> <dt>**GL\_INDEX\_CLEAR\_VALUE**</dt> </dl>                                       | The *params* parameter returns one value: the color index used to clear the color-index buffers. See [**glClearIndex**](glclearindex.md).<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_INDEX_LOGIC_OP"></span><span id="gl_index_logic_op"></span><dl> <dt>**GL\_INDEX\_LOGIC\_OP**</dt> </dl>                                                | The *params* parameter returns a single Boolean value indicating whether a fragment's index values are merged into the framebuffer using a logical operation. See [**glLogicOp**](gllogicop.md).<br/>                                                                                                                                                                                                                               |
     * | <span id="GL_INDEX_MODE"></span><span id="gl_index_mode"></span><dl> <dt>**GL\_INDEX\_MODE**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether OpenGL is in color-index mode (TRUE) or RGBA mode (FALSE).<br/>                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_INDEX_OFFSET"></span><span id="gl_index_offset"></span><dl> <dt>**GL\_INDEX\_OFFSET**</dt> </dl>                                                       | The *params* parameter returns one value: the offset added to color and stencil indexes during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                 |
     * | <span id="GL_INDEX_SHIFT"></span><span id="gl_index_shift"></span><dl> <dt>**GL\_INDEX\_SHIFT**</dt> </dl>                                                          | The *params* parameter returns one value: the amount that color and stencil indexes are shifted during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                         |
     * | <span id="GL_INDEX_WRITEMASK"></span><span id="gl_index_writemask"></span><dl> <dt>**GL\_INDEX\_WRITEMASK**</dt> </dl>                                              | The *params* parameter returns one value: a mask indicating which bitplanes of each color-index buffer can be written. See [**glIndexMask**](glindexmask.md).<br/>                                                                                                                                                                                                                                                                  |
     * | <span id="GL_LIGHTi"></span><span id="gl_lighti"></span><span id="GL_LIGHTI"></span><dl> <dt>**GL\_LIGHT*i***</dt> </dl>                                            | The *params* parameter returns a single Boolean value indicating whether the specified light is enabled. See [**glLight**](gllight-functions.md) and [**glLightModel**](gllightmodel-functions.md).<br/>                                                                                                                                                                                                                           |
     * | <span id="GL_LIGHTING"></span><span id="gl_lighting"></span><dl> <dt>**GL\_LIGHTING**</dt> </dl>                                                                    | The *params* parameter returns a single Boolean value indicating whether lighting is enabled. See [**glLightModel**](gllightmodel-functions.md).<br/>                                                                                                                                                                                                                                                                               |
     * | <span id="GL_LIGHT_MODEL_AMBIENT"></span><span id="gl_light_model_ambient"></span><dl> <dt>**GL\_LIGHT\_MODEL\_AMBIENT**</dt> </dl>                                 | The *params* parameter returns four values: the red, green, blue, and alpha components of the ambient intensity of the entire scene. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glLightModel**](gllightmodel-functions.md).<br/> |
     * | <span id="GL_LIGHT_MODEL_LOCAL_VIEWER"></span><span id="gl_light_model_local_viewer"></span><dl> <dt>**GL\_LIGHT\_MODEL\_LOCAL\_VIEWER**</dt> </dl>                 | The *params* parameter returns a single Boolean value indicating whether specular reflection calculations treat the viewer as being local to the scene. See [**glLightModel**](gllightmodel-functions.md).<br/>                                                                                                                                                                                                                     |
     * | <span id="GL_LIGHT_MODEL_TWO_SIDE"></span><span id="gl_light_model_two_side"></span><dl> <dt>**GL\_LIGHT\_MODEL\_TWO\_SIDE**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether separate materials are used to compute lighting for front-facing and back-facing polygons. See [**glLightModel**](gllightmodel-functions.md).<br/>                                                                                                                                                                                                         |
     * | <span id="GL_LINE_SMOOTH"></span><span id="gl_line_smooth"></span><dl> <dt>**GL\_LINE\_SMOOTH**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether antialiasing of lines is enabled. See [**glLineWidth**](gllinewidth.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_LINE_SMOOTH_HINT"></span><span id="gl_line_smooth_hint"></span><dl> <dt>**GL\_LINE\_SMOOTH\_HINT**</dt> </dl>                                          | The *params* parameter returns one value: a symbolic constant indicating the mode of the line antialiasing hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_LINE_STIPPLE"></span><span id="gl_line_stipple"></span><dl> <dt>**GL\_LINE\_STIPPLE**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether stippling of lines is enabled. See [**glLineStipple**](gllinestipple.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_LINE_STIPPLE_PATTERN"></span><span id="gl_line_stipple_pattern"></span><dl> <dt>**GL\_LINE\_STIPPLE\_PATTERN**</dt> </dl>                              | The *params* parameter returns one value: the 16-bit line stipple pattern. See [**glLineStipple**](gllinestipple.md).<br/>                                                                                                                                                                                                                                                                                                          |
     * | <span id="GL_LINE_STIPPLE_REPEAT"></span><span id="gl_line_stipple_repeat"></span><dl> <dt>**GL\_LINE\_STIPPLE\_REPEAT**</dt> </dl>                                 | The *params* parameter returns one value: the line stipple repeat factor. See [**glLineStipple**](gllinestipple.md).<br/>                                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_LINE_WIDTH"></span><span id="gl_line_width"></span><dl> <dt>**GL\_LINE\_WIDTH**</dt> </dl>                                                             | The *params* parameter returns one value: the line width as specified with [**glLineWidth**](gllinewidth.md).<br/>                                                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_LINE_WIDTH_GRANULARITY"></span><span id="gl_line_width_granularity"></span><dl> <dt>**GL\_LINE\_WIDTH\_GRANULARITY**</dt> </dl>                        | The *params* parameter returns one value: the width difference between adjacent supported widths for antialiased lines. See [**glLineWidth**](gllinewidth.md).<br/>                                                                                                                                                                                                                                                                 |
     * | <span id="GL_LINE_WIDTH_RANGE"></span><span id="gl_line_width_range"></span><dl> <dt>**GL\_LINE\_WIDTH\_RANGE**</dt> </dl>                                          | The *params* parameter returns two values: the smallest and largest supported widths for antialiased lines. See [**glLineWidth**](gllinewidth.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_LIST_BASE"></span><span id="gl_list_base"></span><dl> <dt>**GL\_LIST\_BASE**</dt> </dl>                                                                | The *params* parameter returns one value: the base offset added to all names in arrays presented to [**glCallLists**](glcalllists.md). See [**glListBase**](gllistbase.md).<br/>                                                                                                                                                                                                                                                   |
     * | <span id="GL_LIST_INDEX"></span><span id="gl_list_index"></span><dl> <dt>**GL\_LIST\_INDEX**</dt> </dl>                                                             | The *params* parameter returns one value: the name of the display list currently under construction. Zero is returned if no display list is currently under construction. See [**glNewList**](glnewlist.md).<br/>                                                                                                                                                                                                                   |
     * | <span id="GL_LIST_MODE"></span><span id="gl_list_mode"></span><dl> <dt>**GL\_LIST\_MODE**</dt> </dl>                                                                | The *params* parameter returns one value: a symbolic constant indicating the construction mode of the display list currently being constructed. See [**glNewList**](glnewlist.md).<br/>                                                                                                                                                                                                                                             |
     * | <span id="GL_LOGIC_OP"></span><span id="gl_logic_op"></span><dl> <dt>**GL\_LOGIC\_OP**</dt> </dl>                                                                   | The *params* parameter returns a single Boolean value indicating whether fragment indexes are merged into the framebuffer using a logical operation. See [**glLogicOp**](gllogicop.md).<br/>                                                                                                                                                                                                                                        |
     * | <span id="GL_LOGIC_OP_MODE"></span><span id="gl_logic_op_mode"></span><dl> <dt>**GL\_LOGIC\_OP\_MODE**</dt> </dl>                                                   | The *params* parameter returns one value: a symbolic constant indicating the selected logic operational mode. See [**glLogicOp**](gllogicop.md).<br/>                                                                                                                                                                                                                                                                               |
     * | <span id="GL_MAP1_COLOR_4"></span><span id="gl_map1_color_4"></span><dl> <dt>**GL\_MAP1\_COLOR\_4**</dt> </dl>                                                      | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates colors. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP1_GRID_DOMAIN"></span><span id="gl_map1_grid_domain"></span><dl> <dt>**GL\_MAP1\_GRID\_DOMAIN**</dt> </dl>                                          | The *params* parameter returns two values: the endpoints of the 1-D maps grid domain. See [glMapGrid](glmapgrid-functions.md).<br/>                                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_MAP1_GRID_SEGMENTS"></span><span id="gl_map1_grid_segments"></span><dl> <dt>**GL\_MAP1\_GRID\_SEGMENTS**</dt> </dl>                                    | The *params* parameter returns one value: the number of partitions in the 1-D maps grid domain. See [glMapGrid](glmapgrid-functions.md).<br/>                                                                                                                                                                                                                                                                                       |
     * | <span id="GL_MAP1_INDEX"></span><span id="gl_map1_index"></span><dl> <dt>**GL\_MAP1\_INDEX**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates color indexes. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_MAP1_NORMAL"></span><span id="gl_map1_normal"></span><dl> <dt>**GL\_MAP1\_NORMAL**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates normals. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_TEXTURE_COORD_1"></span><span id="gl_map1_texture_coord_1"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_1**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 1-D texture coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_TEXTURE_COORD_2"></span><span id="gl_map1_texture_coord_2"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_2**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 2-D texture coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_TEXTURE_COORD_3"></span><span id="gl_map1_texture_coord_3"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_3**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 3-D texture coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_TEXTURE_COORD_4"></span><span id="gl_map1_texture_coord_4"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_4**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 4-D texture coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_VERTEX_3"></span><span id="gl_map1_vertex_3"></span><dl> <dt>**GL\_MAP1\_VERTEX\_3**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 3-D vertex coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP1_VERTEX_4"></span><span id="gl_map1_vertex_4"></span><dl> <dt>**GL\_MAP1\_VERTEX\_4**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 4-D vertex coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP2_COLOR_4"></span><span id="gl_map2_color_4"></span><dl> <dt>**GL\_MAP2\_COLOR\_4**</dt> </dl>                                                      | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates colors. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP2_GRID_DOMAIN"></span><span id="gl_map2_grid_domain"></span><dl> <dt>**GL\_MAP2\_GRID\_DOMAIN**</dt> </dl>                                          | The *params* parameter returns four values: the endpoints of the 2-D maps *i* and *j* grid domains. See [glMapGrid](glmapgrid-functions.md).<br/>                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_MAP2_GRID_SEGMENTS"></span><span id="gl_map2_grid_segments"></span><dl> <dt>**GL\_MAP2\_GRID\_SEGMENTS**</dt> </dl>                                    | The *params* parameter returns two values: the number of partitions in the 2-D maps *i* and *j* grid domains. See [glMapGrid](glmapgrid-functions.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP2_INDEX"></span><span id="gl_map2_index"></span><dl> <dt>**GL\_MAP2\_INDEX**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates color indexes. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_MAP2_NORMAL"></span><span id="gl_map2_normal"></span><dl> <dt>**GL\_MAP2\_NORMAL**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates normals. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_TEXTURE_COORD_1"></span><span id="gl_map2_texture_coord_1"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_1**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 1-D texture coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_TEXTURE_COORD_2"></span><span id="gl_map2_texture_coord_2"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_2**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 2-D texture coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_TEXTURE_COORD_3"></span><span id="gl_map2_texture_coord_3"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_3**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 3-D texture coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_TEXTURE_COORD_4"></span><span id="gl_map2_texture_coord_4"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_4**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 4-D texture coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_VERTEX_3"></span><span id="gl_map2_vertex_3"></span><dl> <dt>**GL\_MAP2\_VERTEX\_3**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 3-D vertex coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP2_VERTEX_4"></span><span id="gl_map2_vertex_4"></span><dl> <dt>**GL\_MAP2\_VERTEX\_4**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 4-D vertex coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP_COLOR"></span><span id="gl_map_color"></span><dl> <dt>**GL\_MAP\_COLOR**</dt> </dl>                                                                | The *params* parameter returns a single Boolean value indicating whether colors and color indexes are to be replaced by table lookup during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                    |
     * | <span id="GL_MAP_STENCIL"></span><span id="gl_map_stencil"></span><dl> <dt>**GL\_MAP\_STENCIL**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether stencil indexes are to be replaced by table lookup during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                             |
     * | <span id="GL_MATRIX_MODE"></span><span id="gl_matrix_mode"></span><dl> <dt>**GL\_MATRIX\_MODE**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating which matrix stack is currently the target of all matrix operations. See [**glMatrixMode**](glmatrixmode.md).<br/>                                                                                                                                                                                                                                         |
     * | <span id="GL_MAX_CLIENT_ATTRIB_STACK_DEPTH"></span><span id="gl_max_client_attrib_stack_depth"></span><dl> <dt>**GL\_MAX\_CLIENT\_ATTRIB\_STACK\_DEPTH**</dt> </dl> | The *params* parameter returns one value indicating the maximum supported depth of the client attribute stack. See [**glPushClientAttrib**](glpushclientattrib.md).<br/>                                                                                                                                                                                                                                                            |
     * | <span id="GL_MAX_ATTRIB_STACK_DEPTH"></span><span id="gl_max_attrib_stack_depth"></span><dl> <dt>**GL\_MAX\_ATTRIB\_STACK\_DEPTH**</dt> </dl>                       | The *params* parameter returns one value: the maximum supported depth of the attribute stack. See [**glPushAttrib**](glpushattrib.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAX_CLIP_PLANES"></span><span id="gl_max_clip_planes"></span><dl> <dt>**GL\_MAX\_CLIP\_PLANES**</dt> </dl>                                             | The *params* parameter returns one value: the maximum number of application-defined clipping planes. See [**glClipPlane**](glclipplane.md).<br/>                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_MAX_EVAL_ORDER"></span><span id="gl_max_eval_order"></span><dl> <dt>**GL\_MAX\_EVAL\_ORDER**</dt> </dl>                                                | The *params* parameter returns one value: the maximum equation order supported by 1-D and 2-D evaluators. See [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                            |
     * | <span id="GL_MAX_LIGHTS"></span><span id="gl_max_lights"></span><dl> <dt>**GL\_MAX\_LIGHTS**</dt> </dl>                                                             | The *params* parameter returns one value: the maximum number of lights. See [glLight](gllight-functions.md).<br/>                                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_MAX_LIST_NESTING"></span><span id="gl_max_list_nesting"></span><dl> <dt>**GL\_MAX\_LIST\_NESTING**</dt> </dl>                                          | The *params* parameter returns one value: the maximum recursion depth allowed during display-list traversal. See [**glCallList**](glcalllist.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_MAX_MODELVIEW_STACK_DEPTH"></span><span id="gl_max_modelview_stack_depth"></span><dl> <dt>**GL\_MAX\_MODELVIEW\_STACK\_DEPTH**</dt> </dl>              | The *params* parameter returns one value: the maximum supported depth of the modelview matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_MAX_NAME_STACK_DEPTH"></span><span id="gl_max_name_stack_depth"></span><dl> <dt>**GL\_MAX\_NAME\_STACK\_DEPTH**</dt> </dl>                             | The *params* parameter returns one value: the maximum supported depth of the selection name stack. See [**glPushName**](glpushname.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAX_PIXEL_MAP_TABLE"></span><span id="gl_max_pixel_map_table"></span><dl> <dt>**GL\_MAX\_PIXEL\_MAP\_TABLE**</dt> </dl>                                | The *params* parameter returns one value: the maximum supported size of a [**glPixelMap**](glpixelmap.md) lookup table.<br/>                                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAX_PROJECTION_STACK_DEPTH"></span><span id="gl_max_projection_stack_depth"></span><dl> <dt>**GL\_MAX\_PROJECTION\_STACK\_DEPTH**</dt> </dl>           | The *params* parameter returns one value: the maximum supported depth of the projection matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_MAX_TEXTURE_SIZE"></span><span id="gl_max_texture_size"></span><dl> <dt>**GL\_MAX\_TEXTURE\_SIZE**</dt> </dl>                                          | The *params* parameter returns one value: the maximum width or height of any texture image (without borders). See [**glTexImage1D**](glteximage1d.md) and [**glTexImage2D**](glteximage2d.md).<br/>                                                                                                                                                                                                                                |
     * | <span id="GL_MAX_TEXTURE_STACK_DEPTH"></span><span id="gl_max_texture_stack_depth"></span><dl> <dt>**GL\_MAX\_TEXTURE\_STACK\_DEPTH**</dt> </dl>                    | The *params* parameter returns one value: the maximum supported depth of the texture matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_MAX_VIEWPORT_DIMS"></span><span id="gl_max_viewport_dims"></span><dl> <dt>**GL\_MAX\_VIEWPORT\_DIMS**</dt> </dl>                                       | The *params* parameter returns two values: the maximum supported width and height of the viewport. See [**glViewport**](glviewport.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MODELVIEW_MATRIX"></span><span id="gl_modelview_matrix"></span><dl> <dt>**GL\_MODELVIEW\_MATRIX**</dt> </dl>                                           | The *params* parameter returns 16 values: the modelview matrix on the top of the modelview matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_MODELVIEW_STACK_DEPTH"></span><span id="gl_modelview_stack_depth"></span><dl> <dt>**GL\_MODELVIEW\_STACK\_DEPTH**</dt> </dl>                           | The *params* parameter returns one value: the number of matrices on the modelview matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                       |
     * | <span id="GL_NAME_STACK_DEPTH"></span><span id="gl_name_stack_depth"></span><dl> <dt>**GL\_NAME\_STACK\_DEPTH**</dt> </dl>                                          | The *params* parameter returns one value: the number of names on the selection name stack. See [**glPushName**](glpushname.md).<br/>                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_NORMAL_ARRAY"></span><span id="gl_normal_array"></span><dl> <dt>**GL\_NORMAL\_ARRAY**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value, indicating whether the normal array is enabled. See [**glNormalPointer**](glnormalpointer.md).<br/>                                                                                                                                                                                                                                                                          |
     * | <span id="GL_NORMAL_ARRAY_STRIDE"></span><span id="gl_normal_array_stride"></span><dl> <dt>**GL\_NORMAL\_ARRAY\_STRIDE**</dt> </dl>                                 | The *params* parameter returns one value, the byte offset between consecutive normals in the normal array. See [**glNormalPointer**](glnormalpointer.md).<br/>                                                                                                                                                                                                                                                                      |
     * | <span id="GL_NORMAL_ARRAY_TYPE"></span><span id="gl_normal_array_type"></span><dl> <dt>**GL\_NORMAL\_ARRAY\_TYPE**</dt> </dl>                                       | The *params* parameter returns one value, the data type of each coordinate in the normal array. See [**glNormalPointer**](glnormalpointer.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_NORMALIZE"></span><span id="gl_normalize"></span><dl> <dt>**GL\_NORMALIZE**</dt> </dl>                                                                 | The *params* parameter returns a single Boolean value indicating whether normals are automatically scaled to unit length after they have been transformed to eye coordinates. See [glNormal](glnormal-functions.md).<br/>                                                                                                                                                                                                           |
     * | <span id="GL_PACK_ALIGNMENT"></span><span id="gl_pack_alignment"></span><dl> <dt>**GL\_PACK\_ALIGNMENT**</dt> </dl>                                                 | The *params* parameter returns one value: the byte alignment used for writing pixel data to memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_PACK_LSB_FIRST"></span><span id="gl_pack_lsb_first"></span><dl> <dt>**GL\_PACK\_LSB\_FIRST**</dt> </dl>                                                | The *params* parameter returns a single Boolean value indicating whether single-bit pixels being written to memory are written first to the least significant bit of each unsigned byte. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                        |
     * | <span id="GL_PACK_ROW_LENGTH"></span><span id="gl_pack_row_length"></span><dl> <dt>**GL\_PACK\_ROW\_LENGTH**</dt> </dl>                                             | The *params* parameter returns one value: the row length used for writing pixel data to memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_PACK_SKIP_PIXELS"></span><span id="gl_pack_skip_pixels"></span><dl> <dt>**GL\_PACK\_SKIP\_PIXELS**</dt> </dl>                                          | The *params* parameter returns one value: the number of pixel locations skipped before the first pixel is written into memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                  |
     * | <span id="GL_PACK_SKIP_ROWS"></span><span id="gl_pack_skip_rows"></span><dl> <dt>**GL\_PACK\_SKIP\_ROWS**</dt> </dl>                                                | The *params* parameter returns one value: the number of rows of pixel locations skipped before the first pixel is written into memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                          |
     * | <span id="GL_PACK_SWAP_BYTES"></span><span id="gl_pack_swap_bytes"></span><dl> <dt>**GL\_PACK\_SWAP\_BYTES**</dt> </dl>                                             | The *params* parameter returns a single Boolean value indicating whether the bytes of 2-byte and 4-byte pixel indexes and components are swapped before being written to memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                |
     * | <span id="GL_PERSPECTIVE_CORRECTION_HINT"></span><span id="gl_perspective_correction_hint"></span><dl> <dt>**GL\_PERSPECTIVE\_CORRECTION\_HINT**</dt> </dl>         | The *params* parameter returns one value: a symbolic constant indicating the mode of the perspective correction hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_PIXEL_MAP_A_TO_A_SIZE"></span><span id="gl_pixel_map_a_to_a_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_A\_TO\_A\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the alpha-to-alpha pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_B_TO_B_SIZE"></span><span id="gl_pixel_map_b_to_b_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_B\_TO\_B\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the blue-to-blue pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_PIXEL_MAP_G_TO_G_SIZE"></span><span id="gl_pixel_map_g_to_g_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_G\_TO\_G\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the green-to-green pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_I_TO_A_SIZE"></span><span id="gl_pixel_map_i_to_a_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_A\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-alpha pixel translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_I_TO_B_SIZE"></span><span id="gl_pixel_map_i_to_b_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_B\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-blue pixel translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                          |
     * | <span id="GL_PIXEL_MAP_I_TO_G_SIZE"></span><span id="gl_pixel_map_i_to_g_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_G\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-green pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_I_TO_I_SIZE"></span><span id="gl_pixel_map_i_to_i_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_I\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-index pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_I_TO_R_SIZE"></span><span id="gl_pixel_map_i_to_r_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_R\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-red pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_PIXEL_MAP_R_TO_R_SIZE"></span><span id="gl_pixel_map_r_to_r_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_R\_TO\_R\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the red-to-red pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_PIXEL_MAP_S_TO_S_SIZE"></span><span id="gl_pixel_map_s_to_s_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_S\_TO\_S\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the stencil-to-stencil pixel translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_POINT_SIZE"></span><span id="gl_point_size"></span><dl> <dt>**GL\_POINT\_SIZE**</dt> </dl>                                                             | The *params* parameter returns one value: the point size as specified by [**glPointSize**](glpointsize.md).<br/>                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_POINT_SIZE_GRANULARITY"></span><span id="gl_point_size_granularity"></span><dl> <dt>**GL\_POINT\_SIZE\_GRANULARITY**</dt> </dl>                        | The *params* parameter returns one value: the size difference between adjacent supported sizes for antialiased points. See [**glPointSize**](glpointsize.md).<br/>                                                                                                                                                                                                                                                                  |
     * | <span id="GL_POINT_SIZE_RANGE"></span><span id="gl_point_size_range"></span><dl> <dt>**GL\_POINT\_SIZE\_RANGE**</dt> </dl>                                          | The *params* parameter returns two values: the smallest and largest supported sizes for antialiased points. See [**glPointSize**](glpointsize.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_POINT_SMOOTH"></span><span id="gl_point_smooth"></span><dl> <dt>**GL\_POINT\_SMOOTH**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether antialiasing of points is enabled. See [**glPointSize**](glpointsize.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_POINT_SMOOTH_HINT"></span><span id="gl_point_smooth_hint"></span><dl> <dt>**GL\_POINT\_SMOOTH\_HINT**</dt> </dl>                                       | The *params* parameter returns one value: a symbolic constant indicating the mode of the point antialiasing hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_POLYGON_MODE"></span><span id="gl_polygon_mode"></span><dl> <dt>**GL\_POLYGON\_MODE**</dt> </dl>                                                       | The *params* parameter returns two values: symbolic constants indicating whether front-facing and back-facing polygons are rasterized as points, lines, or filled polygons. See [**glPolygonMode**](glpolygonmode.md).<br/>                                                                                                                                                                                                         |
     * | <span id="GL_POLYGON_OFFSET_FACTOR"></span><span id="gl_polygon_offset_factor"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_FACTOR**</dt> </dl>                           | The *params* parameter returns one value, the scaling factor used to determine the variable offset that is added to the depth value of each fragment generated when a polygon is rasterized. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                                    |
     * | <span id="GL_POLYGON_OFFSET_UNITS"></span><span id="gl_polygon_offset_units"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_UNITS**</dt> </dl>                              | The *params* parameter returns one value. This value is multiplied by an implementation-specific value and then added to the depth value of each fragment generated when a polygon is rasterized. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                               |
     * | <span id="GL_POLYGON_OFFSET_FILL"></span><span id="gl_polygon_offset_fill"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_FILL**</dt> </dl>                                 | The *params* parameter returns a single Boolean value indicating whether polygon offset is enabled for polygons in fill mode. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                                                                                                   |
     * | <span id="GL_POLYGON_OFFSET_LINE"></span><span id="gl_polygon_offset_line"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_LINE**</dt> </dl>                                 | The *params* parameter returns a single Boolean value indicating whether polygon offset is enabled for polygons in line mode. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                                                                                                   |
     * | <span id="GL_POLYGON_OFFSET_POINT"></span><span id="gl_polygon_offset_point"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_POINT**</dt> </dl>                              | The *params* parameter returns a single Boolean value indicating whether polygon offset is enabled for polygons in point mode. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                                                                                                  |
     * | <span id="GL_POLYGON_SMOOTH"></span><span id="gl_polygon_smooth"></span><dl> <dt>**GL\_POLYGON\_SMOOTH**</dt> </dl>                                                 | The *params* parameter returns a single Boolean value indicating whether antialiasing of polygons is enabled. See [**glPolygonMode**](glpolygonmode.md).<br/>                                                                                                                                                                                                                                                                       |
     * | <span id="GL_POLYGON_SMOOTH_HINT"></span><span id="gl_polygon_smooth_hint"></span><dl> <dt>**GL\_POLYGON\_SMOOTH\_HINT**</dt> </dl>                                 | The *params* parameter returns one value: a symbolic constant indicating the mode of the polygon antialiasing hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                               |
     * | <span id="GL_POLYGON_STIPPLE"></span><span id="gl_polygon_stipple"></span><dl> <dt>**GL\_POLYGON\_STIPPLE**</dt> </dl>                                              | The *params* parameter returns a single Boolean value indicating whether stippling of polygons is enabled. See [**glPolygonStipple**](glpolygonstipple.md).<br/>                                                                                                                                                                                                                                                                    |
     * | <span id="GL_PROJECTION_MATRIX"></span><span id="gl_projection_matrix"></span><dl> <dt>**GL\_PROJECTION\_MATRIX**</dt> </dl>                                        | The *params* parameter returns 16 values: the projection matrix on the top of the projection matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                            |
     * | <span id="GL_PROJECTION_STACK_DEPTH"></span><span id="gl_projection_stack_depth"></span><dl> <dt>**GL\_PROJECTION\_STACK\_DEPTH**</dt> </dl>                        | The *params* parameter returns one value: the number of matrices on the projection matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_READ_BUFFER"></span><span id="gl_read_buffer"></span><dl> <dt>**GL\_READ\_BUFFER**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating which color buffer is selected for reading. See [**glReadPixels**](glreadpixels.md) and [**glAccum**](glaccum.md).<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_RED_BIAS"></span><span id="gl_red_bias"></span><dl> <dt>**GL\_RED\_BIAS**</dt> </dl>                                                                   | The *params* parameter returns one value: the red bias factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_RED_BITS"></span><span id="gl_red_bits"></span><dl> <dt>**GL\_RED\_BITS**</dt> </dl>                                                                   | The *params* parameter returns one value: the number of red bitplanes in each color buffer.<br/>                                                                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_RED_SCALE"></span><span id="gl_red_scale"></span><dl> <dt>**GL\_RED\_SCALE**</dt> </dl>                                                                | The *params* parameter returns one value: the red scale factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_RENDER_MODE"></span><span id="gl_render_mode"></span><dl> <dt>**GL\_RENDER\_MODE**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating whether OpenGL is in render, select, or feedback mode. See [**glRenderMode**](glrendermode.md).<br/>                                                                                                                                                                                                                                                       |
     * | <span id="GL_RGBA_MODE"></span><span id="gl_rgba_mode"></span><dl> <dt>**GL\_RGBA\_MODE**</dt> </dl>                                                                | The *params* parameter returns a single Boolean value indicating whether OpenGL is in RGBA mode (TRUE) or color-index mode (FALSE). See [glColor](glcolor-functions.md).<br/>                                                                                                                                                                                                                                                       |
     * | <span id="GL_SCISSOR_BOX"></span><span id="gl_scissor_box"></span><dl> <dt>**GL\_SCISSOR\_BOX**</dt> </dl>                                                          | The *params* parameter returns four values: the *x* and *y* window coordinates of the scissor box, followed by its width and height. See [**glScissor**](glscissor.md).<br/>                                                                                                                                                                                                                                                        |
     * | <span id="GL_SCISSOR_TEST"></span><span id="gl_scissor_test"></span><dl> <dt>**GL\_SCISSOR\_TEST**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether scissoring is enabled. See [**glScissor**](glscissor.md).<br/>                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_SHADE_MODEL"></span><span id="gl_shade_model"></span><dl> <dt>**GL\_SHADE\_MODEL**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating whether the shading mode is flat or smooth. See [**glShadeModel**](glshademodel.md).<br/>                                                                                                                                                                                                                                                                  |
     * | <span id="GL_STENCIL_BITS"></span><span id="gl_stencil_bits"></span><dl> <dt>**GL\_STENCIL\_BITS**</dt> </dl>                                                       | The *params* parameter returns one value: the number of bitplanes in the stencil buffer.<br/>                                                                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_STENCIL_CLEAR_VALUE"></span><span id="gl_stencil_clear_value"></span><dl> <dt>**GL\_STENCIL\_CLEAR\_VALUE**</dt> </dl>                                 | The *params* parameter returns one value: the index to which the stencil bitplanes are cleared. See [**glClearStencil**](glclearstencil.md).<br/>                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_STENCIL_FAIL"></span><span id="gl_stencil_fail"></span><dl> <dt>**GL\_STENCIL\_FAIL**</dt> </dl>                                                       | The *params* parameter returns one value: a symbolic constant indicating what action is taken when the stencil test fails. See [**glStencilOp**](glstencilop.md).<br/>                                                                                                                                                                                                                                                              |
     * | <span id="GL_STENCIL_FUNC"></span><span id="gl_stencil_func"></span><dl> <dt>**GL\_STENCIL\_FUNC**</dt> </dl>                                                       | The *params* parameter returns one value: a symbolic constant indicating what function is used to compare the stencil reference value with the stencil buffer value. See [**glStencilFunc**](glstencilfunc.md).<br/>                                                                                                                                                                                                                |
     * | <span id="GL_STENCIL_PASS_DEPTH_FAIL"></span><span id="gl_stencil_pass_depth_fail"></span><dl> <dt>**GL\_STENCIL\_PASS\_DEPTH\_FAIL**</dt> </dl>                    | The *params* parameter returns one value: a symbolic constant indicating what action is taken when the stencil test passes, but the depth test fails. See [**glStencilOp**](glstencilop.md).<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_STENCIL_PASS_DEPTH_PASS"></span><span id="gl_stencil_pass_depth_pass"></span><dl> <dt>**GL\_STENCIL\_PASS\_DEPTH\_PASS**</dt> </dl>                    | The *params* parameter returns one value: a symbolic constant indicating what action is taken when the stencil test passes and the depth test passes. See [**glStencilOp**](glstencilop.md).<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_STENCIL_REF"></span><span id="gl_stencil_ref"></span><dl> <dt>**GL\_STENCIL\_REF**</dt> </dl>                                                          | The *params* parameter returns one value: the reference value that is compared with the contents of the stencil buffer. See [**glStencilFunc**](glstencilfunc.md).<br/>                                                                                                                                                                                                                                                             |
     * | <span id="GL_STENCIL_TEST"></span><span id="gl_stencil_test"></span><dl> <dt>**GL\_STENCIL\_TEST**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether stencil testing of fragments is enabled. See [**glStencilFunc**](glstencilfunc.md) and [**glStencilOp**](glstencilop.md).<br/>                                                                                                                                                                                                                            |
     * | <span id="GL_STENCIL_VALUE_MASK"></span><span id="gl_stencil_value_mask"></span><dl> <dt>**GL\_STENCIL\_VALUE\_MASK**</dt> </dl>                                    | The *params* parameter returns one value: the mask that is used to mask both the stencil reference value and the stencil buffer value before they are compared. See [**glStencilFunc**](glstencilfunc.md).<br/>                                                                                                                                                                                                                     |
     * | <span id="GL_STENCIL_WRITEMASK"></span><span id="gl_stencil_writemask"></span><dl> <dt>**GL\_STENCIL\_WRITEMASK**</dt> </dl>                                        | The *params* parameter returns one value: the mask that controls writing of the stencil bitplanes. See [**glStencilMask**](glstencilmask.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_STEREO"></span><span id="gl_stereo"></span><dl> <dt>**GL\_STEREO**</dt> </dl>                                                                          | The *params* parameter returns a single Boolean value indicating whether stereo buffers (left and right) are supported.<br/>                                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_SUBPIXEL_BITS"></span><span id="gl_subpixel_bits"></span><dl> <dt>**GL\_SUBPIXEL\_BITS**</dt> </dl>                                                    | The *params* parameter returns one value: an estimate of the number of bits of subpixel resolution that are used to position rasterized geometry in window coordinates.<br/>                                                                                                                                                                                                                                                         |
     * | <span id="GL_TEXTURE_1D"></span><span id="gl_texture_1d"></span><dl> <dt>**GL\_TEXTURE\_1D**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether 1-D texture mapping is enabled. See [**glTexImage1D**](glteximage1d.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_TEXTURE_2D"></span><span id="gl_texture_2d"></span><dl> <dt>**GL\_TEXTURE\_2D**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether 2-D texture mapping is enabled. See [**glTexImage2D**](glteximage2d.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_TEXTURE_COORD_ARRAY"></span><span id="gl_texture_coord_array"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY**</dt> </dl>                                 | The *params* parameter returns a single Boolean value indicating whether the texture coordinate array is enabled. See [**glTexCoordPointer**](gltexcoordpointer.md).<br/>                                                                                                                                                                                                                                                           |
     * | <span id="GL_TEXTURE_COORD_ARRAY_SIZE"></span><span id="gl_texture_coord_array_size"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY\_SIZE**</dt> </dl>                 | The *params* parameter returns one value, the number of coordinates per element in the texture coordinate array. See [**glTexCoordPointer**](gltexcoordpointer.md).<br/>                                                                                                                                                                                                                                                            |
     * | <span id="GL_TEXTURE_COORD_ARRAY_STRIDE"></span><span id="gl_texture_coord_array_stride"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY\_STRIDE**</dt> </dl>           | The *params* parameter returns one value, the byte offset between consecutive elements in the texture coordinate array. See [**glTexCoordPointer**](gltexcoordpointer.md).<br/>                                                                                                                                                                                                                                                     |
     * | <span id="GL_TEXTURE_COORD_ARRAY_TYPE"></span><span id="gl_texture_coord_array_type"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY\_TYPE**</dt> </dl>                 | The *params* parameter params returns one value, the data type of the coordinates in the texture coordinate array. See [**glTexCoordPointer**](gltexcoordpointer.md).<br/>                                                                                                                                                                                                                                                          |
     * | <span id="GL_TEXTURE_ENV_COLOR"></span><span id="gl_texture_env_color"></span><dl> <dt>**GL\_TEXTURE\_ENV\_COLOR**</dt> </dl>                                       | The *params* parameter returns four values: the red, green, blue, and alpha values of the texture environment color. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and 1.0 returns the most negative representable integer value. See [glTexEnv](gltexenv-functions.md).<br/>                              |
     * | <span id="GL_TEXTURE_ENV_MODE"></span><span id="gl_texture_env_mode"></span><dl> <dt>**GL\_TEXTURE\_ENV\_MODE**</dt> </dl>                                          | The *params* parameter returns one value: a symbolic constant indicating which texture environment function is currently selected. See [glTexEnv](gltexenv-functions.md).<br/>                                                                                                                                                                                                                                                      |
     * | <span id="GL_TEXTURE_GEN_Q"></span><span id="gl_texture_gen_q"></span><dl> <dt>**GL\_TEXTURE\_GEN\_Q**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether automatic generation of the Q texture coordinate is enabled. See [**glTexGen**](gltexgen-functions.md).<br/>                                                                                                                                                                                                                                               |
     * | <span id="GL_TEXTURE_GEN_R"></span><span id="gl_texture_gen_r"></span><dl> <dt>**GL\_TEXTURE\_GEN\_R**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether automatic generation of the R texture coordinate is enabled. See [**glTexGen**](gltexgen-functions.md).<br/>                                                                                                                                                                                                                                               |
     * | <span id="GL_TEXTURE_GEN_S"></span><span id="gl_texture_gen_s"></span><dl> <dt>**GL\_TEXTURE\_GEN\_S**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether automatic generation of the S texture coordinate is enabled. See [**glTexGen**](gltexgen-functions.md).<br/>                                                                                                                                                                                                                                               |
     * | <span id="GL_TEXTURE_GEN_T"></span><span id="gl_texture_gen_t"></span><dl> <dt>**GL\_TEXTURE\_GEN\_T**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether automatic generation of the T texture coordinate is enabled. See [**glTexGen**](gltexgen-functions.md).<br/>                                                                                                                                                                                                                                               |
     * | <span id="GL_TEXTURE_MATRIX"></span><span id="gl_texture_matrix"></span><dl> <dt>**GL\_TEXTURE\_MATRIX**</dt> </dl>                                                 | The *params* parameter returns 16 values: the texture matrix on the top of the texture matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_TEXTURE_STACK_DEPTH"></span><span id="gl_texture_stack_depth"></span><dl> <dt>**GL\_TEXTURE\_STACK\_DEPTH**</dt> </dl>                                 | The *params* parameter returns one value: the number of matrices on the texture matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_UNPACK_ALIGNMENT"></span><span id="gl_unpack_alignment"></span><dl> <dt>**GL\_UNPACK\_ALIGNMENT**</dt> </dl>                                           | The *params* parameter returns one value: the byte alignment used for reading pixel data from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                                           |
     * | <span id="GL_UNPACK_LSB_FIRST"></span><span id="gl_unpack_lsb_first"></span><dl> <dt>**GL\_UNPACK\_LSB\_FIRST**</dt> </dl>                                          | The *params* parameter returns a single Boolean value indicating whether single-bit pixels being read from memory are read first from the least significant bit of each unsigned byte. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                          |
     * | <span id="GL_UNPACK_ROW_LENGTH"></span><span id="gl_unpack_row_length"></span><dl> <dt>**GL\_UNPACK\_ROW\_LENGTH**</dt> </dl>                                       | The *params* parameter returns one value: the row length used for reading pixel data from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                                               |
     * | <span id="GL_UNPACK_SKIP_PIXELS"></span><span id="gl_unpack_skip_pixels"></span><dl> <dt>**GL\_UNPACK\_SKIP\_PIXELS**</dt> </dl>                                    | The *params* parameter returns one value: the number of pixel locations skipped before the first pixel is read from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                     |
     * | <span id="GL_UNPACK_SKIP_ROWS"></span><span id="gl_unpack_skip_rows"></span><dl> <dt>**GL\_UNPACK\_SKIP\_ROWS**</dt> </dl>                                          | The *params* parameter returns one value: the number of rows of pixel locations skipped before the first pixel is read from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                             |
     * | <span id="GL_UNPACK_SWAP_BYTES"></span><span id="gl_unpack_swap_bytes"></span><dl> <dt>**GL\_UNPACK\_SWAP\_BYTES**</dt> </dl>                                       | The *params* parameter returns a single Boolean value indicating whether the bytes of 2-byte and 4-byte pixel indexes and components are swapped after being read from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                  |
     * | <span id="GL_VERTEX_ARRAY"></span><span id="gl_vertex_array"></span><dl> <dt>**GL\_VERTEX\_ARRAY**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether the vertex array is enabled. See [**glVertexPointer**](glvertexpointer.md).<br/>                                                                                                                                                                                                                                                                           |
     * | <span id="GL_VERTEX_ARRAY_SIZE"></span><span id="gl_vertex_array_size"></span><dl> <dt>**GL\_VERTEX\_ARRAY\_SIZE**</dt> </dl>                                       | The *params* parameter returns one value, the number of coordinates per vertex in the vertex array. See [**glVertexPointer**](glvertexpointer.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_VERTEX_ARRAY_STRIDE"></span><span id="gl_vertex_array_stride"></span><dl> <dt>**GL\_VERTEX\_ARRAY\_STRIDE**</dt> </dl>                                 | The *params* parameter returns one value, the byte offset between consecutive vertexes in the vertex array. See [**glVertexPointer**](glvertexpointer.md).<br/>                                                                                                                                                                                                                                                                     |
     * | <span id="GL_VERTEX_ARRAY_TYPE"></span><span id="gl_vertex_array_type"></span><dl> <dt>**GL\_VERTEX\_ARRAY\_TYPE**</dt> </dl>                                       | The *params* parameter returns one value, the data type of each coordinate in the vertex array. See [**glVertexPointer**](glvertexpointer.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_VIEWPORT"></span><span id="gl_viewport"></span><dl> <dt>**GL\_VIEWPORT**</dt> </dl>                                                                    | The *params* parameter returns four values: the *x* and *y* window coordinates of the viewport, followed by its width and height. See [**glViewport**](glviewport.md).<br/>                                                                                                                                                                                                                                                         |
     * | <span id="GL_ZOOM_X"></span><span id="gl_zoom_x"></span><dl> <dt>**GL\_ZOOM\_X**</dt> </dl>                                                                         | The *params* parameter returns one value: the *x* pixel zoom factor. See [**glPixelZoom**](glpixelzoom.md).<br/>                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_ZOOM_Y"></span><span id="gl_zoom_y"></span><dl> <dt>**GL\_ZOOM\_Y**</dt> </dl>                                                                         | The *params* parameter returns one value: the *y* pixel zoom factor. See [**glPixelZoom**](glpixelzoom.md).<br/>                                                                                                                                                                                                                                                                                                                    |
     * @param {Pointer<Byte>} params Returns the value or values of the specified parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetbooleanv
     */
    static glGetBooleanv(pname, params) {
        DllCall("OPENGL32.dll\glGetBooleanv", "uint", pname, "ptr", params)
    }

    /**
     * The glGetClipPlane function returns the coefficients of the specified clipping plane.
     * @remarks
     * The **glGetClipPlane** function returns in *equation* the four coefficients of the plane equation for *plane*.
     * 
     * It is always the case that GL\_CLIP\_PLANE*i* = GL\_CLIP\_PLANE0 + *i*.
     * 
     * If an error is generated, no change is made to the contents of *equation*.
     * @param {Integer} plane A clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. They are identified by symbolic names of the form GL\_CLIP\_PLANE *i* where 0 = *i* < GL\_MAX\_CLIP\_PLANES.
     * @param {Pointer<Double>} equation Returns four double-precision values that are the coefficients of the plane equation of *plane* in eye coordinates.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetclipplane
     */
    static glGetClipPlane(plane, equation) {
        DllCall("OPENGL32.dll\glGetClipPlane", "uint", plane, "ptr", equation)
    }

    /**
     * The glGetDoublev function returns the value or values of a selected parameter.
     * @remarks
     * This function returns values for simple state variables in OpenGL. The *pname* parameter is a symbolic constant indicating the state variable to be returned, and *params* is a pointer to an array of the indicated type in which to place the returned data.
     * 
     * Type conversion is performed if *params* has a different type from the state variable value being requested. If you call [**glGetBooleanv**](glgetbooleanv.md), a floating-point or integer value is converted to GL\_FALSE if and only if it is zero. Otherwise, it is converted to GL\_TRUE.
     * 
     * If you call [**glGetIntegerv**](glgetintegerv.md), Boolean values are returned as GL\_TRUE or GL\_FALSE, and most floating-point values are rounded to the nearest integer value. Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most positive representable integer value and 1.0 to the most negative representable integer value.
     * 
     * If you call [**glGetFloatv**](glgetfloatv.md) or **glGetDoublev**, Boolean values are returned as GL\_TRUE or GL\_FALSE, and integer values are converted to floating-point values.
     * 
     * You can query many of the Boolean parameters more easily with [**glIsEnabled**](glisenabled.md).
     * @param {Integer} pname The parameter value to be returned. The following symbolic constants are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                    |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_ACCUM_ALPHA_BITS"></span><span id="gl_accum_alpha_bits"></span><dl> <dt>**GL\_ACCUM\_ALPHA\_BITS**</dt> </dl>                                          | The *params* parameter returns one value: the number of alpha bitplanes in the accumulation buffer.<br/>                                                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_ACCUM_BLUE_BITS"></span><span id="gl_accum_blue_bits"></span><dl> <dt>**GL\_ACCUM\_BLUE\_BITS**</dt> </dl>                                             | The *params* parameter returns one value: the number of blue bitplanes in the accumulation buffer.<br/>                                                                                                                                                                                                                                                                                                                              |
     * | <span id="GL_ACCUM_CLEAR_VALUE"></span><span id="gl_accum_clear_value"></span><dl> <dt>**GL\_ACCUM\_CLEAR\_VALUE**</dt> </dl>                                       | The *params* parameter returns four values: the red, green, blue, and alpha values used to clear the accumulation buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glClearAccum**](glclearaccum.md).<br/>                      |
     * | <span id="GL_ACCUM_GREEN_BITS"></span><span id="gl_accum_green_bits"></span><dl> <dt>**GL\_ACCUM\_GREEN\_BITS**</dt> </dl>                                          | The *params* parameter returns one value: the number of green bitplanes in the accumulation buffer.<br/>                                                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_ACCUM_RED_BITS"></span><span id="gl_accum_red_bits"></span><dl> <dt>**GL\_ACCUM\_RED\_BITS**</dt> </dl>                                                | The *params* parameter returns one value: the number of red bitplanes in the accumulation buffer.<br/>                                                                                                                                                                                                                                                                                                                               |
     * | <span id="GL_ALPHA_BIAS"></span><span id="gl_alpha_bias"></span><dl> <dt>**GL\_ALPHA\_BIAS**</dt> </dl>                                                             | The *params* parameter returns one value: the alpha bias factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_ALPHA_BITS"></span><span id="gl_alpha_bits"></span><dl> <dt>**GL\_ALPHA\_BITS**</dt> </dl>                                                             | The *params* parameter returns one value: the number of alpha bitplanes in each color buffer.<br/>                                                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_ALPHA_SCALE"></span><span id="gl_alpha_scale"></span><dl> <dt>**GL\_ALPHA\_SCALE**</dt> </dl>                                                          | The *params* parameter returns one value: the alpha scale factor used during pixel transfers. See [glPixelTransfer](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                       |
     * | <span id="GL_ALPHA_TEST"></span><span id="gl_alpha_test"></span><dl> <dt>**GL\_ALPHA\_TEST**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether alpha testing of fragments is enabled. See [**glAlphaFunc**](glalphafunc.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_ALPHA_TEST_FUNC"></span><span id="gl_alpha_test_func"></span><dl> <dt>**GL\_ALPHA\_TEST\_FUNC**</dt> </dl>                                             | The *params* parameter returns one value: the symbolic name of the alpha test function. See [**glAlphaFunc**](glalphafunc.md).<br/>                                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_ALPHA_TEST_REF"></span><span id="gl_alpha_test_ref"></span><dl> <dt>**GL\_ALPHA\_TEST\_REF**</dt> </dl>                                                | The *params* parameter returns one value: the reference value for the alpha test. See [**glAlphaFunc**](glalphafunc.md). An integer value, if requested, is linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value.<br/>                                                               |
     * | <span id="GL_ATTRIB_STACK_DEPTH"></span><span id="gl_attrib_stack_depth"></span><dl> <dt>**GL\_ATTRIB\_STACK\_DEPTH**</dt> </dl>                                    | The *params* parameter returns one value: the depth of the attribute stack. If the stack is empty, zero is returned. See [**glPushAttrib**](glpushattrib.md).<br/>                                                                                                                                                                                                                                                                  |
     * | <span id="GL_AUTO_NORMAL"></span><span id="gl_auto_normal"></span><dl> <dt>**GL\_AUTO\_NORMAL**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether 2-D map evaluation automatically generates surface normals. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                              |
     * | <span id="GL_AUX_BUFFERS"></span><span id="gl_aux_buffers"></span><dl> <dt>**GL\_AUX\_BUFFERS**</dt> </dl>                                                          | The *params* parameter returns one value: the number of auxiliary color buffers.<br/>                                                                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_BLEND"></span><span id="gl_blend"></span><dl> <dt>**GL\_BLEND**</dt> </dl>                                                                             | The *params* parameter returns a single Boolean value indicating whether blending is enabled. See [**glBlendFunc**](glblendfunc.md).<br/>                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_BLEND_DST"></span><span id="gl_blend_dst"></span><dl> <dt>**GL\_BLEND\_DST**</dt> </dl>                                                                | The *params* parameter returns one value: the symbolic constant identifying the destination blend function. See [**glBlendFunc**](glblendfunc.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_BLEND_SRC"></span><span id="gl_blend_src"></span><dl> <dt>**GL\_BLEND\_SRC**</dt> </dl>                                                                | The *params* parameter returns one value: the symbolic constant identifying the source blend function. See [**glBlendFunc**](glblendfunc.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_BLUE_BIAS"></span><span id="gl_blue_bias"></span><dl> <dt>**GL\_BLUE\_BIAS**</dt> </dl>                                                                | The *params* parameter returns one value: the blue bias factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_BLUE_BITS"></span><span id="gl_blue_bits"></span><dl> <dt>**GL\_BLUE\_BITS**</dt> </dl>                                                                | The *params* parameter returns one value: the number of blue bitplanes in each color buffer.<br/>                                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_BLUE_SCALE"></span><span id="gl_blue_scale"></span><dl> <dt>**GL\_BLUE\_SCALE**</dt> </dl>                                                             | The *params* parameter returns one value: the blue scale factor used during pixel transfers. See [glPixelTransfer](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_CLIENT_ATTRIB_STACK_DEPTH"></span><span id="gl_client_attrib_stack_depth"></span><dl> <dt>**GL\_CLIENT\_ATTRIB\_STACK\_DEPTH**</dt> </dl>              | The *params* parameter returns one value indicating the depth of the attribute stack. The initial value is zero. See [**glPushClientAttrib**](glpushclientattrib.md).<br/>                                                                                                                                                                                                                                                          |
     * | <span id="GL_CLIP_PLANEi"></span><span id="gl_clip_planei"></span><span id="GL_CLIP_PLANEI"></span><dl> <dt>**GL\_CLIP\_PLANE*i***</dt> </dl>                       | The *params* parameter returns a single Boolean value indicating whether the specified clipping plane is enabled. See [**glClipPlane**](glclipplane.md).<br/>                                                                                                                                                                                                                                                                       |
     * | <span id="GL_COLOR_ARRAY"></span><span id="gl_color_array"></span><dl> <dt>**GL\_COLOR\_ARRAY**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether the specified color array is defined. See [**glColorPointer**](glcolorpointer.md).<br/>                                                                                                                                                                                                                                                                    |
     * | <span id="GL_COLOR_ARRAY_SIZE"></span><span id="gl_color_array_size"></span><dl> <dt>**GL\_COLOR\_ARRAY\_SIZE**</dt> </dl>                                          | The *params* parameter returns one value, the number of components per color in the color array. See [**glColorPointer**](glcolorpointer.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_COLOR_ARRAY_STRIDE"></span><span id="gl_color_array_stride"></span><dl> <dt>**GL\_COLOR\_ARRAY\_STRIDE**</dt> </dl>                                    | The *params* parameter returns one value, the byte offset between consecutive colors in the color array. See [**glColorPointer**](glcolorpointer.md).<br/>                                                                                                                                                                                                                                                                          |
     * | <span id="GL_COLOR_ARRAY_TYPE"></span><span id="gl_color_array_type"></span><dl> <dt>**GL\_COLOR\_ARRAY\_TYPE**</dt> </dl>                                          | The *params* parameter returns one value, the data type of each component in the color array. See [**glColorPointer**](glcolorpointer.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_COLOR_CLEAR_VALUE"></span><span id="gl_color_clear_value"></span><dl> <dt>**GL\_COLOR\_CLEAR\_VALUE**</dt> </dl>                                       | The *params* parameter returns four values: the red, green, blue, and alpha values used to clear the color buffers. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glClearColor**](glclearcolor.md).<br/>                            |
     * | <span id="GL_COLOR_LOGIC_OP"></span><span id="gl_color_logic_op"></span><dl> <dt>**GL\_COLOR\_LOGIC\_OP**</dt> </dl>                                                | The *params* parameter returns a single Boolean value indicating whether a fragment's RGBA color values are merged into the framebuffer using a logical operation. See [**glLogicOp**](gllogicop.md).<br/>                                                                                                                                                                                                                          |
     * | <span id="GL_COLOR_MATERIAL"></span><span id="gl_color_material"></span><dl> <dt>**GL\_COLOR\_MATERIAL**</dt> </dl>                                                 | The *params* parameter returns a single Boolean value indicating whether one or more material parameters are tracking the current color. See [**glColorMaterial**](glcolormaterial.md).<br/>                                                                                                                                                                                                                                        |
     * | <span id="GL_COLOR_MATERIAL_FACE"></span><span id="gl_color_material_face"></span><dl> <dt>**GL\_COLOR\_MATERIAL\_FACE**</dt> </dl>                                 | The *params* parameter returns one value: a symbolic constant indicating which materials have a parameter that is tracking the current color. See [**glColorMaterial**](glcolormaterial.md).<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_COLOR_MATERIAL_PARAMETER"></span><span id="gl_color_material_parameter"></span><dl> <dt>**GL\_COLOR\_MATERIAL\_PARAMETER**</dt> </dl>                  | The *params* parameter returns one value: a symbolic constant indicating which material parameters are tracking the current color. See [**glColorMaterial**](glcolormaterial.md).<br/>                                                                                                                                                                                                                                              |
     * | <span id="GL_COLOR_WRITEMASK"></span><span id="gl_color_writemask"></span><dl> <dt>**GL\_COLOR\_WRITEMASK**</dt> </dl>                                              | The *params* parameter returns four Boolean values: the red, green, blue, and alpha write enables for the color buffers. See [**glColorMask**](glcolormask.md).<br/>                                                                                                                                                                                                                                                                |
     * | <span id="GL_CULL_FACE"></span><span id="gl_cull_face"></span><dl> <dt>**GL\_CULL\_FACE**</dt> </dl>                                                                | The *params* parameter returns a single Boolean value indicating whether polygon culling is enabled. See [**glCullFace**](glcullface.md).<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_CULL_FACE_MODE"></span><span id="gl_cull_face_mode"></span><dl> <dt>**GL\_CULL\_FACE\_MODE**</dt> </dl>                                                | The *params* parameter returns one value: a symbolic constant indicating which polygon faces are to be culled. See [**glCullFace**](glcullface.md).<br/>                                                                                                                                                                                                                                                                            |
     * | <span id="GL_CURRENT_COLOR"></span><span id="gl_current_color"></span><dl> <dt>**GL\_CURRENT\_COLOR**</dt> </dl>                                                    | The *params* parameter returns four values: the red, green, blue, and alpha values of the current color. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glColor**](glcolor-functions.md).<br/>                                       |
     * | <span id="GL_CURRENT_INDEX"></span><span id="gl_current_index"></span><dl> <dt>**GL\_CURRENT\_INDEX**</dt> </dl>                                                    | The *params* parameter returns one value: the current color index. See [**glIndex**](glindex-functions.md).<br/>                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_CURRENT_NORMAL"></span><span id="gl_current_normal"></span><dl> <dt>**GL\_CURRENT\_NORMAL**</dt> </dl>                                                 | The *params* parameter returns three values: the *x*, *y*, and *z* values of the current normal. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glNormal**](glnormal-functions.md).<br/>                                             |
     * | <span id="GL_CURRENT_RASTER_COLOR"></span><span id="gl_current_raster_color"></span><dl> <dt>**GL\_CURRENT\_RASTER\_COLOR**</dt> </dl>                              | The *params* parameter returns four values: the red, green, blue, and alpha values of the current raster position. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glRasterPos**](glrasterpos-functions.md).<br/>                     |
     * | <span id="GL_CURRENT_RASTER_DISTANCE"></span><span id="gl_current_raster_distance"></span><dl> <dt>**GL\_CURRENT\_RASTER\_DISTANCE**</dt> </dl>                     | The *params* parameter returns one value: the distance from the eye to the current raster position. See [**glRasterPos**](glrasterpos-functions.md).<br/>                                                                                                                                                                                                                                                                           |
     * | <span id="GL_CURRENT_RASTER_INDEX"></span><span id="gl_current_raster_index"></span><dl> <dt>**GL\_CURRENT\_RASTER\_INDEX**</dt> </dl>                              | The *params* parameter returns one value: the color index of the current raster position. See [**glRasterPos**](glrasterpos-functions.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_CURRENT_RASTER_POSITION"></span><span id="gl_current_raster_position"></span><dl> <dt>**GL\_CURRENT\_RASTER\_POSITION**</dt> </dl>                     | The *params* parameter returns four values: the *x*, *y*, *z*, and *w* components of the current raster position. The *x*, *y*, and *z* components are in window coordinates, and *w* is in clip coordinates. See [glRasterPos](glrasterpos-functions.md).<br/>                                                                                                                                                                     |
     * | <span id="GL_CURRENT_RASTER_POSITION_VALID"></span><span id="gl_current_raster_position_valid"></span><dl> <dt>**GL\_CURRENT\_RASTER\_POSITION\_VALID**</dt> </dl>  | The *params* parameter returns a single Boolean value indicating whether the current raster position is valid. See [**glRasterPos**](glrasterpos-functions.md).<br/>                                                                                                                                                                                                                                                                |
     * | <span id="GL_CURRENT_RASTER_TEXTURE_COORDS"></span><span id="gl_current_raster_texture_coords"></span><dl> <dt>**GL\_CURRENT\_RASTER\_TEXTURE\_COORDS**</dt> </dl>  | The *params* parameter returns four values: the *s*, *t*, *r*, and *q* current raster texture coordinates. See [**glRasterPos**](glrasterpos-functions.md) and [**glTexCoord**](gltexcoord-functions.md).<br/>                                                                                                                                                                                                                     |
     * | <span id="GL_CURRENT_TEXTURE_COORDS"></span><span id="gl_current_texture_coords"></span><dl> <dt>**GL\_CURRENT\_TEXTURE\_COORDS**</dt> </dl>                        | The *params* parameter returns four values: the *s*, *t*, *r*, and *q* current texture coordinates. See [**glTexCoord**](gltexcoord-functions.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_DEPTH_BIAS"></span><span id="gl_depth_bias"></span><dl> <dt>**GL\_DEPTH\_BIAS**</dt> </dl>                                                             | The *params* parameter returns one value: the depth bias factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_DEPTH_BITS"></span><span id="gl_depth_bits"></span><dl> <dt>**GL\_DEPTH\_BITS**</dt> </dl>                                                             | The *params* parameter returns one value: the number of bitplanes in the depth buffer.<br/>                                                                                                                                                                                                                                                                                                                                          |
     * | <span id="GL_DEPTH_CLEAR_VALUE"></span><span id="gl_depth_clear_value"></span><dl> <dt>**GL\_DEPTH\_CLEAR\_VALUE**</dt> </dl>                                       | The *params* parameter returns one value: the value that is used to clear the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glClearDepth**](glcleardepth.md).<br/>                                                    |
     * | <span id="GL_DEPTH_FUNC"></span><span id="gl_depth_func"></span><dl> <dt>**GL\_DEPTH\_FUNC**</dt> </dl>                                                             | The *params* parameter returns one value: the symbolic constant that indicates the depth comparison function. See [**glDepthFunc**](gldepthfunc.md).<br/>                                                                                                                                                                                                                                                                           |
     * | <span id="GL_DEPTH_RANGE"></span><span id="gl_depth_range"></span><dl> <dt>**GL\_DEPTH\_RANGE**</dt> </dl>                                                          | The *params* parameter returns two values: the near and far mapping limits for the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glDepthRange**](gldepthrange.md).<br/>                                               |
     * | <span id="GL_DEPTH_SCALE"></span><span id="gl_depth_scale"></span><dl> <dt>**GL\_DEPTH\_SCALE**</dt> </dl>                                                          | The *params* parameter returns one value: the depth scale factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_DEPTH_TEST"></span><span id="gl_depth_test"></span><dl> <dt>**GL\_DEPTH\_TEST**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether depth testing of fragments is enabled. See [**glDepthFunc**](gldepthfunc.md) and [**glDepthRange**](gldepthrange.md).<br/>                                                                                                                                                                                                                                |
     * | <span id="GL_DEPTH_WRITEMASK"></span><span id="gl_depth_writemask"></span><dl> <dt>**GL\_DEPTH\_WRITEMASK**</dt> </dl>                                              | The *params* parameter returns a single Boolean value indicating if the depth buffer is enabled for writing. See [**glDepthMask**](gldepthmask.md).<br/>                                                                                                                                                                                                                                                                            |
     * | <span id="GL_DITHER"></span><span id="gl_dither"></span><dl> <dt>**GL\_DITHER**</dt> </dl>                                                                          | The *params* parameter returns a single Boolean value indicating whether dithering of fragment colors and indexes is enabled.<br/>                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_DOUBLEBUFFER"></span><span id="gl_doublebuffer"></span><dl> <dt>**GL\_DOUBLEBUFFER**</dt> </dl>                                                        | The *params* parameter returns a single Boolean value indicating whether double buffering is supported.<br/>                                                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_DRAW_BUFFER"></span><span id="gl_draw_buffer"></span><dl> <dt>**GL\_DRAW\_BUFFER**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating which buffers are being drawn to. See [**glDrawBuffer**](gldrawbuffer.md).<br/>                                                                                                                                                                                                                                                                            |
     * | <span id="GL_EDGE_FLAG"></span><span id="gl_edge_flag"></span><dl> <dt>**GL\_EDGE\_FLAG**</dt> </dl>                                                                | The *params* parameter returns a single Boolean value indicating whether the current edge flag is true or false. See [glEdgeFlag](gledgeflag-functions.md).<br/>                                                                                                                                                                                                                                                                    |
     * | <span id="GL_EDGE_FLAG_ARRAY"></span><span id="gl_edge_flag_array"></span><dl> <dt>**GL\_EDGE\_FLAG\_ARRAY**</dt> </dl>                                             | The *params* parameter returns a single Boolean value indicating whether the edge flag array is enabled. See [**glEdgeFlagPointer**](gledgeflagpointer.md).<br/>                                                                                                                                                                                                                                                                    |
     * | <span id="GL_EDGE_FLAG_ARRAY_STRIDE"></span><span id="gl_edge_flag_array_stride"></span><dl> <dt>**GL\_EDGE\_FLAG\_ARRAY\_STRIDE**</dt> </dl>                       | The *params* parameter returns one value, the byte offset between consecutive edge flags in the edge flag array. See [**glEdgeFlagPointer**](gledgeflagpointer.md).<br/>                                                                                                                                                                                                                                                            |
     * | <span id="GL_FOG"></span><span id="gl_fog"></span><dl> <dt>**GL\_FOG**</dt> </dl>                                                                                   | The *params* parameter returns a single Boolean value indicating whether fogging is enabled. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_FOG_COLOR"></span><span id="gl_fog_color"></span><dl> <dt>**GL\_FOG\_COLOR**</dt> </dl>                                                                | The *params* parameter returns four values: the red, green, blue, and alpha components of the fog color. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glFog**](glfog.md).<br/>                                                     |
     * | <span id="GL_FOG_DENSITY"></span><span id="gl_fog_density"></span><dl> <dt>**GL\_FOG\_DENSITY**</dt> </dl>                                                          | The *params* parameter returns one value: the fog density parameter. See [glFog](glfog.md).<br/>                                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_FOG_END"></span><span id="gl_fog_end"></span><dl> <dt>**GL\_FOG\_END**</dt> </dl>                                                                      | The *params* parameter returns one value: the end factor for the linear fog equation. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                                               |
     * | <span id="GL_FOG_HINT"></span><span id="gl_fog_hint"></span><dl> <dt>**GL\_FOG\_HINT**</dt> </dl>                                                                   | The *params* parameter returns one value: a symbolic constant indicating the mode of the fog hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_FOG_INDEX"></span><span id="gl_fog_index"></span><dl> <dt>**GL\_FOG\_INDEX**</dt> </dl>                                                                | The *params* parameter returns one value: the fog color index. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_FOG_MODE"></span><span id="gl_fog_mode"></span><dl> <dt>**GL\_FOG\_MODE**</dt> </dl>                                                                   | The *params* parameter returns one value: a symbolic constant indicating which fog equation is selected. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_FOG_START"></span><span id="gl_fog_start"></span><dl> <dt>**GL\_FOG\_START**</dt> </dl>                                                                | The *params* parameter returns one value: the start factor for the linear fog equation. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_FRONT_FACE"></span><span id="gl_front_face"></span><dl> <dt>**GL\_FRONT\_FACE**</dt> </dl>                                                             | The *params* parameter returns one value: a symbolic constant indicating whether clockwise or counterclockwise polygon winding is treated as front-facing. See [**glFrontFace**](glfrontface.md).<br/>                                                                                                                                                                                                                              |
     * | <span id="GL_GREEN_BIAS"></span><span id="gl_green_bias"></span><dl> <dt>**GL\_GREEN\_BIAS**</dt> </dl>                                                             | The *params* parameter returns one value: the green bias factor used during pixel transfers.<br/>                                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_GREEN_BITS"></span><span id="gl_green_bits"></span><dl> <dt>**GL\_GREEN\_BITS**</dt> </dl>                                                             | The *params* parameter returns one value: the number of green bitplanes in each color buffer.<br/>                                                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_GREEN_SCALE"></span><span id="gl_green_scale"></span><dl> <dt>**GL\_GREEN\_SCALE**</dt> </dl>                                                          | The *params* parameter returns one value: the green scale factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_INDEX_ARRAY"></span><span id="gl_index_array"></span><dl> <dt>**GL\_INDEX\_ARRAY**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether the color index array is enabled. See [**glIndexPointer**](glindexpointer.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_INDEX_ARRAY_STRIDE"></span><span id="gl_index_array_stride"></span><dl> <dt>**GL\_INDEX\_ARRAY\_STRIDE**</dt> </dl>                                    | The *params* parameter returns one value, the byte offset between consecutive color indexes in the color index array. See [**glIndexPointer**](glindexpointer.md).<br/>                                                                                                                                                                                                                                                             |
     * | <span id="GL_INDEX_ARRAY_TYPE"></span><span id="gl_index_array_type"></span><dl> <dt>**GL\_INDEX\_ARRAY\_TYPE**</dt> </dl>                                          | The *params* parameter returns one value, the data type of indexes in the color index array. The initial value is GL\_FLOAT. See [**glIndexPointer**](glindexpointer.md).<br/>                                                                                                                                                                                                                                                      |
     * | <span id="GL_INDEX_BITS"></span><span id="gl_index_bits"></span><dl> <dt>**GL\_INDEX\_BITS**</dt> </dl>                                                             | The *params* parameter returns one value: the number of bitplanes in each color-index buffer.<br/>                                                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_INDEX_CLEAR_VALUE"></span><span id="gl_index_clear_value"></span><dl> <dt>**GL\_INDEX\_CLEAR\_VALUE**</dt> </dl>                                       | The *params* parameter returns one value: the color index used to clear the color-index buffers. See [**glClearIndex**](glclearindex.md).<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_INDEX_LOGIC_OP"></span><span id="gl_index_logic_op"></span><dl> <dt>**GL\_INDEX\_LOGIC\_OP**</dt> </dl>                                                | The *params* parameter returns a single Boolean value indicating whether a fragment's index values are merged into the framebuffer using a logical operation. See [**glLogicOp**](gllogicop.md).<br/>                                                                                                                                                                                                                               |
     * | <span id="GL_INDEX_MODE"></span><span id="gl_index_mode"></span><dl> <dt>**GL\_INDEX\_MODE**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether OpenGL is in color-index mode (TRUE) or RGBA mode (FALSE).<br/>                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_INDEX_OFFSET"></span><span id="gl_index_offset"></span><dl> <dt>**GL\_INDEX\_OFFSET**</dt> </dl>                                                       | The *params* parameter returns one value: the offset added to color and stencil indexes during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                 |
     * | <span id="GL_INDEX_SHIFT"></span><span id="gl_index_shift"></span><dl> <dt>**GL\_INDEX\_SHIFT**</dt> </dl>                                                          | The *params* parameter returns one value: the amount that color and stencil indexes are shifted during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                         |
     * | <span id="GL_INDEX_WRITEMASK"></span><span id="gl_index_writemask"></span><dl> <dt>**GL\_INDEX\_WRITEMASK**</dt> </dl>                                              | The *params* parameter returns one value: a mask indicating which bitplanes of each color-index buffer can be written. See [**glIndexMask**](glindexmask.md).<br/>                                                                                                                                                                                                                                                                  |
     * | <span id="GL_LIGHTi"></span><span id="gl_lighti"></span><span id="GL_LIGHTI"></span><dl> <dt>**GL\_LIGHT*i***</dt> </dl>                                            | The *params* parameter returns a single Boolean value indicating whether the specified light is enabled. See [**glLight**](gllight-functions.md) and [**glLightModel**](gllightmodel-functions.md).<br/>                                                                                                                                                                                                                           |
     * | <span id="GL_LIGHTING"></span><span id="gl_lighting"></span><dl> <dt>**GL\_LIGHTING**</dt> </dl>                                                                    | The *params* parameter returns a single Boolean value indicating whether lighting is enabled. See [**glLightModel**](gllightmodel-functions.md).<br/>                                                                                                                                                                                                                                                                               |
     * | <span id="GL_LIGHT_MODEL_AMBIENT"></span><span id="gl_light_model_ambient"></span><dl> <dt>**GL\_LIGHT\_MODEL\_AMBIENT**</dt> </dl>                                 | The *params* parameter returns four values: the red, green, blue, and alpha components of the ambient intensity of the entire scene. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glLightModel**](gllightmodel-functions.md).<br/> |
     * | <span id="GL_LIGHT_MODEL_LOCAL_VIEWER"></span><span id="gl_light_model_local_viewer"></span><dl> <dt>**GL\_LIGHT\_MODEL\_LOCAL\_VIEWER**</dt> </dl>                 | The *params* parameter returns a single Boolean value indicating whether specular reflection calculations treat the viewer as being local to the scene. See [**glLightModel**](gllightmodel-functions.md).<br/>                                                                                                                                                                                                                     |
     * | <span id="GL_LIGHT_MODEL_TWO_SIDE"></span><span id="gl_light_model_two_side"></span><dl> <dt>**GL\_LIGHT\_MODEL\_TWO\_SIDE**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether separate materials are used to compute lighting for front-facing and back-facing polygons. See [**glLightModel**](gllightmodel-functions.md).<br/>                                                                                                                                                                                                         |
     * | <span id="GL_LINE_SMOOTH"></span><span id="gl_line_smooth"></span><dl> <dt>**GL\_LINE\_SMOOTH**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether antialiasing of lines is enabled. See [**glLineWidth**](gllinewidth.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_LINE_SMOOTH_HINT"></span><span id="gl_line_smooth_hint"></span><dl> <dt>**GL\_LINE\_SMOOTH\_HINT**</dt> </dl>                                          | The *params* parameter returns one value: a symbolic constant indicating the mode of the line antialiasing hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_LINE_STIPPLE"></span><span id="gl_line_stipple"></span><dl> <dt>**GL\_LINE\_STIPPLE**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether stippling of lines is enabled. See [**glLineStipple**](gllinestipple.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_LINE_STIPPLE_PATTERN"></span><span id="gl_line_stipple_pattern"></span><dl> <dt>**GL\_LINE\_STIPPLE\_PATTERN**</dt> </dl>                              | The *params* parameter returns one value: the 16-bit line stipple pattern. See [**glLineStipple**](gllinestipple.md).<br/>                                                                                                                                                                                                                                                                                                          |
     * | <span id="GL_LINE_STIPPLE_REPEAT"></span><span id="gl_line_stipple_repeat"></span><dl> <dt>**GL\_LINE\_STIPPLE\_REPEAT**</dt> </dl>                                 | The *params* parameter returns one value: the line stipple repeat factor. See [**glLineStipple**](gllinestipple.md).<br/>                                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_LINE_WIDTH"></span><span id="gl_line_width"></span><dl> <dt>**GL\_LINE\_WIDTH**</dt> </dl>                                                             | The *params* parameter returns one value: the line width as specified with [**glLineWidth**](gllinewidth.md).<br/>                                                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_LINE_WIDTH_GRANULARITY"></span><span id="gl_line_width_granularity"></span><dl> <dt>**GL\_LINE\_WIDTH\_GRANULARITY**</dt> </dl>                        | The *params* parameter returns one value: the width difference between adjacent supported widths for antialiased lines. See [**glLineWidth**](gllinewidth.md).<br/>                                                                                                                                                                                                                                                                 |
     * | <span id="GL_LINE_WIDTH_RANGE"></span><span id="gl_line_width_range"></span><dl> <dt>**GL\_LINE\_WIDTH\_RANGE**</dt> </dl>                                          | The *params* parameter returns two values: the smallest and largest supported widths for antialiased lines. See [**glLineWidth**](gllinewidth.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_LIST_BASE"></span><span id="gl_list_base"></span><dl> <dt>**GL\_LIST\_BASE**</dt> </dl>                                                                | The *params* parameter returns one value: the base offset added to all names in arrays presented to [**glCallLists**](glcalllists.md). See [**glListBase**](gllistbase.md).<br/>                                                                                                                                                                                                                                                   |
     * | <span id="GL_LIST_INDEX"></span><span id="gl_list_index"></span><dl> <dt>**GL\_LIST\_INDEX**</dt> </dl>                                                             | The *params* parameter returns one value: the name of the display list currently under construction. Zero is returned if no display list is currently under construction. See [**glNewList**](glnewlist.md).<br/>                                                                                                                                                                                                                   |
     * | <span id="GL_LIST_MODE"></span><span id="gl_list_mode"></span><dl> <dt>**GL\_LIST\_MODE**</dt> </dl>                                                                | The *params* parameter returns one value: a symbolic constant indicating the construction mode of the display list currently being constructed. See [**glNewList**](glnewlist.md).<br/>                                                                                                                                                                                                                                             |
     * | <span id="GL_LOGIC_OP"></span><span id="gl_logic_op"></span><dl> <dt>**GL\_LOGIC\_OP**</dt> </dl>                                                                   | The *params* parameter returns a single Boolean value indicating whether fragment indexes are merged into the framebuffer using a logical operation. See [**glLogicOp**](gllogicop.md).<br/>                                                                                                                                                                                                                                        |
     * | <span id="GL_LOGIC_OP_MODE"></span><span id="gl_logic_op_mode"></span><dl> <dt>**GL\_LOGIC\_OP\_MODE**</dt> </dl>                                                   | The *params* parameter returns one value: a symbolic constant indicating the selected logic operational mode. See [**glLogicOp**](gllogicop.md).<br/>                                                                                                                                                                                                                                                                               |
     * | <span id="GL_MAP1_COLOR_4"></span><span id="gl_map1_color_4"></span><dl> <dt>**GL\_MAP1\_COLOR\_4**</dt> </dl>                                                      | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates colors. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP1_GRID_DOMAIN"></span><span id="gl_map1_grid_domain"></span><dl> <dt>**GL\_MAP1\_GRID\_DOMAIN**</dt> </dl>                                          | The *params* parameter returns two values: the endpoints of the 1-D maps grid domain. See [glMapGrid](glmapgrid-functions.md).<br/>                                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_MAP1_GRID_SEGMENTS"></span><span id="gl_map1_grid_segments"></span><dl> <dt>**GL\_MAP1\_GRID\_SEGMENTS**</dt> </dl>                                    | The *params* parameter returns one value: the number of partitions in the 1-D maps grid domain. See [glMapGrid](glmapgrid-functions.md).<br/>                                                                                                                                                                                                                                                                                       |
     * | <span id="GL_MAP1_INDEX"></span><span id="gl_map1_index"></span><dl> <dt>**GL\_MAP1\_INDEX**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates color indexes. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_MAP1_NORMAL"></span><span id="gl_map1_normal"></span><dl> <dt>**GL\_MAP1\_NORMAL**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates normals. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_TEXTURE_COORD_1"></span><span id="gl_map1_texture_coord_1"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_1**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 1-D texture coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_TEXTURE_COORD_2"></span><span id="gl_map1_texture_coord_2"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_2**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 2-D texture coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_TEXTURE_COORD_3"></span><span id="gl_map1_texture_coord_3"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_3**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 3-D texture coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_TEXTURE_COORD_4"></span><span id="gl_map1_texture_coord_4"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_4**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 4-D texture coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_VERTEX_3"></span><span id="gl_map1_vertex_3"></span><dl> <dt>**GL\_MAP1\_VERTEX\_3**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 3-D vertex coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP1_VERTEX_4"></span><span id="gl_map1_vertex_4"></span><dl> <dt>**GL\_MAP1\_VERTEX\_4**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 4-D vertex coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP2_COLOR_4"></span><span id="gl_map2_color_4"></span><dl> <dt>**GL\_MAP2\_COLOR\_4**</dt> </dl>                                                      | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates colors. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP2_GRID_DOMAIN"></span><span id="gl_map2_grid_domain"></span><dl> <dt>**GL\_MAP2\_GRID\_DOMAIN**</dt> </dl>                                          | The *params* parameter returns four values: the endpoints of the 2-D maps *i* and *j* grid domains. See [glMapGrid](glmapgrid-functions.md).<br/>                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_MAP2_GRID_SEGMENTS"></span><span id="gl_map2_grid_segments"></span><dl> <dt>**GL\_MAP2\_GRID\_SEGMENTS**</dt> </dl>                                    | The *params* parameter returns two values: the number of partitions in the 2-D maps *i* and *j* grid domains. See [glMapGrid](glmapgrid-functions.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP2_INDEX"></span><span id="gl_map2_index"></span><dl> <dt>**GL\_MAP2\_INDEX**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates color indexes. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_MAP2_NORMAL"></span><span id="gl_map2_normal"></span><dl> <dt>**GL\_MAP2\_NORMAL**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates normals. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_TEXTURE_COORD_1"></span><span id="gl_map2_texture_coord_1"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_1**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 1-D texture coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_TEXTURE_COORD_2"></span><span id="gl_map2_texture_coord_2"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_2**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 2-D texture coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_TEXTURE_COORD_3"></span><span id="gl_map2_texture_coord_3"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_3**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 3-D texture coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_TEXTURE_COORD_4"></span><span id="gl_map2_texture_coord_4"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_4**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 4-D texture coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_VERTEX_3"></span><span id="gl_map2_vertex_3"></span><dl> <dt>**GL\_MAP2\_VERTEX\_3**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 3-D vertex coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP2_VERTEX_4"></span><span id="gl_map2_vertex_4"></span><dl> <dt>**GL\_MAP2\_VERTEX\_4**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 4-D vertex coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP_COLOR"></span><span id="gl_map_color"></span><dl> <dt>**GL\_MAP\_COLOR**</dt> </dl>                                                                | The *params* parameter returns a single Boolean value indicating whether colors and color indexes are to be replaced by table lookup during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                    |
     * | <span id="GL_MAP_STENCIL"></span><span id="gl_map_stencil"></span><dl> <dt>**GL\_MAP\_STENCIL**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether stencil indexes are to be replaced by table lookup during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                             |
     * | <span id="GL_MATRIX_MODE"></span><span id="gl_matrix_mode"></span><dl> <dt>**GL\_MATRIX\_MODE**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating which matrix stack is currently the target of all matrix operations. See [**glMatrixMode**](glmatrixmode.md).<br/>                                                                                                                                                                                                                                         |
     * | <span id="GL_MAX_CLIENT_ATTRIB_STACK_DEPTH"></span><span id="gl_max_client_attrib_stack_depth"></span><dl> <dt>**GL\_MAX\_CLIENT\_ATTRIB\_STACK\_DEPTH**</dt> </dl> | The *params* parameter returns one value indicating the maximum supported depth of the client attribute stack. See [**glPushClientAttrib**](glpushclientattrib.md).<br/>                                                                                                                                                                                                                                                            |
     * | <span id="GL_MAX_ATTRIB_STACK_DEPTH"></span><span id="gl_max_attrib_stack_depth"></span><dl> <dt>**GL\_MAX\_ATTRIB\_STACK\_DEPTH**</dt> </dl>                       | The *params* parameter returns one value: the maximum supported depth of the attribute stack. See [**glPushAttrib**](glpushattrib.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAX_CLIP_PLANES"></span><span id="gl_max_clip_planes"></span><dl> <dt>**GL\_MAX\_CLIP\_PLANES**</dt> </dl>                                             | The *params* parameter returns one value: the maximum number of application-defined clipping planes. See [**glClipPlane**](glclipplane.md).<br/>                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_MAX_EVAL_ORDER"></span><span id="gl_max_eval_order"></span><dl> <dt>**GL\_MAX\_EVAL\_ORDER**</dt> </dl>                                                | The *params* parameter returns one value: the maximum equation order supported by 1-D and 2-D evaluators. See [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                            |
     * | <span id="GL_MAX_LIGHTS"></span><span id="gl_max_lights"></span><dl> <dt>**GL\_MAX\_LIGHTS**</dt> </dl>                                                             | The *params* parameter returns one value: the maximum number of lights. See [glLight](gllight-functions.md).<br/>                                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_MAX_LIST_NESTING"></span><span id="gl_max_list_nesting"></span><dl> <dt>**GL\_MAX\_LIST\_NESTING**</dt> </dl>                                          | The *params* parameter returns one value: the maximum recursion depth allowed during display-list traversal. See [**glCallList**](glcalllist.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_MAX_MODELVIEW_STACK_DEPTH"></span><span id="gl_max_modelview_stack_depth"></span><dl> <dt>**GL\_MAX\_MODELVIEW\_STACK\_DEPTH**</dt> </dl>              | The *params* parameter returns one value: the maximum supported depth of the modelview matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_MAX_NAME_STACK_DEPTH"></span><span id="gl_max_name_stack_depth"></span><dl> <dt>**GL\_MAX\_NAME\_STACK\_DEPTH**</dt> </dl>                             | The *params* parameter returns one value: the maximum supported depth of the selection name stack. See [**glPushName**](glpushname.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAX_PIXEL_MAP_TABLE"></span><span id="gl_max_pixel_map_table"></span><dl> <dt>**GL\_MAX\_PIXEL\_MAP\_TABLE**</dt> </dl>                                | The *params* parameter returns one value: the maximum supported size of a [**glPixelMap**](glpixelmap.md) lookup table.<br/>                                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAX_PROJECTION_STACK_DEPTH"></span><span id="gl_max_projection_stack_depth"></span><dl> <dt>**GL\_MAX\_PROJECTION\_STACK\_DEPTH**</dt> </dl>           | The *params* parameter returns one value: the maximum supported depth of the projection matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_MAX_TEXTURE_SIZE"></span><span id="gl_max_texture_size"></span><dl> <dt>**GL\_MAX\_TEXTURE\_SIZE**</dt> </dl>                                          | The *params* parameter returns one value: the maximum width or height of any texture image (without borders). See [**glTexImage1D**](glteximage1d.md) and [**glTexImage2D**](glteximage2d.md).<br/>                                                                                                                                                                                                                                |
     * | <span id="GL_MAX_TEXTURE_STACK_DEPTH"></span><span id="gl_max_texture_stack_depth"></span><dl> <dt>**GL\_MAX\_TEXTURE\_STACK\_DEPTH**</dt> </dl>                    | The *params* parameter returns one value: the maximum supported depth of the texture matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_MAX_VIEWPORT_DIMS"></span><span id="gl_max_viewport_dims"></span><dl> <dt>**GL\_MAX\_VIEWPORT\_DIMS**</dt> </dl>                                       | The *params* parameter returns two values: the maximum supported width and height of the viewport. See [**glViewport**](glviewport.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MODELVIEW_MATRIX"></span><span id="gl_modelview_matrix"></span><dl> <dt>**GL\_MODELVIEW\_MATRIX**</dt> </dl>                                           | The *params* parameter returns 16 values: the modelview matrix on the top of the modelview matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_MODELVIEW_STACK_DEPTH"></span><span id="gl_modelview_stack_depth"></span><dl> <dt>**GL\_MODELVIEW\_STACK\_DEPTH**</dt> </dl>                           | The *params* parameter returns one value: the number of matrices on the modelview matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                       |
     * | <span id="GL_NAME_STACK_DEPTH"></span><span id="gl_name_stack_depth"></span><dl> <dt>**GL\_NAME\_STACK\_DEPTH**</dt> </dl>                                          | The *params* parameter returns one value: the number of names on the selection name stack. See [**glPushName**](glpushname.md).<br/>                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_NORMAL_ARRAY"></span><span id="gl_normal_array"></span><dl> <dt>**GL\_NORMAL\_ARRAY**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value, indicating whether the normal array is enabled. See [**glNormalPointer**](glnormalpointer.md).<br/>                                                                                                                                                                                                                                                                          |
     * | <span id="GL_NORMAL_ARRAY_STRIDE"></span><span id="gl_normal_array_stride"></span><dl> <dt>**GL\_NORMAL\_ARRAY\_STRIDE**</dt> </dl>                                 | The *params* parameter returns one value, the byte offset between consecutive normals in the normal array. See [**glNormalPointer**](glnormalpointer.md).<br/>                                                                                                                                                                                                                                                                      |
     * | <span id="GL_NORMAL_ARRAY_TYPE"></span><span id="gl_normal_array_type"></span><dl> <dt>**GL\_NORMAL\_ARRAY\_TYPE**</dt> </dl>                                       | The *params* parameter returns one value, the data type of each coordinate in the normal array. See [**glNormalPointer**](glnormalpointer.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_NORMALIZE"></span><span id="gl_normalize"></span><dl> <dt>**GL\_NORMALIZE**</dt> </dl>                                                                 | The *params* parameter returns a single Boolean value indicating whether normals are automatically scaled to unit length after they have been transformed to eye coordinates. See [glNormal](glnormal-functions.md).<br/>                                                                                                                                                                                                           |
     * | <span id="GL_PACK_ALIGNMENT"></span><span id="gl_pack_alignment"></span><dl> <dt>**GL\_PACK\_ALIGNMENT**</dt> </dl>                                                 | The *params* parameter returns one value: the byte alignment used for writing pixel data to memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_PACK_LSB_FIRST"></span><span id="gl_pack_lsb_first"></span><dl> <dt>**GL\_PACK\_LSB\_FIRST**</dt> </dl>                                                | The *params* parameter returns a single Boolean value indicating whether single-bit pixels being written to memory are written first to the least significant bit of each unsigned byte. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                        |
     * | <span id="GL_PACK_ROW_LENGTH"></span><span id="gl_pack_row_length"></span><dl> <dt>**GL\_PACK\_ROW\_LENGTH**</dt> </dl>                                             | The *params* parameter returns one value: the row length used for writing pixel data to memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_PACK_SKIP_PIXELS"></span><span id="gl_pack_skip_pixels"></span><dl> <dt>**GL\_PACK\_SKIP\_PIXELS**</dt> </dl>                                          | The *params* parameter returns one value: the number of pixel locations skipped before the first pixel is written into memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                  |
     * | <span id="GL_PACK_SKIP_ROWS"></span><span id="gl_pack_skip_rows"></span><dl> <dt>**GL\_PACK\_SKIP\_ROWS**</dt> </dl>                                                | The *params* parameter returns one value: the number of rows of pixel locations skipped before the first pixel is written into memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                          |
     * | <span id="GL_PACK_SWAP_BYTES"></span><span id="gl_pack_swap_bytes"></span><dl> <dt>**GL\_PACK\_SWAP\_BYTES**</dt> </dl>                                             | The *params* parameter returns a single Boolean value indicating whether the bytes of 2-byte and 4-byte pixel indexes and components are swapped before being written to memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                |
     * | <span id="GL_PERSPECTIVE_CORRECTION_HINT"></span><span id="gl_perspective_correction_hint"></span><dl> <dt>**GL\_PERSPECTIVE\_CORRECTION\_HINT**</dt> </dl>         | The *params* parameter returns one value: a symbolic constant indicating the mode of the perspective correction hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_PIXEL_MAP_A_TO_A_SIZE"></span><span id="gl_pixel_map_a_to_a_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_A\_TO\_A\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the alpha-to-alpha pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_B_TO_B_SIZE"></span><span id="gl_pixel_map_b_to_b_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_B\_TO\_B\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the blue-to-blue pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_PIXEL_MAP_G_TO_G_SIZE"></span><span id="gl_pixel_map_g_to_g_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_G\_TO\_G\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the green-to-green pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_I_TO_A_SIZE"></span><span id="gl_pixel_map_i_to_a_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_A\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-alpha pixel translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_I_TO_B_SIZE"></span><span id="gl_pixel_map_i_to_b_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_B\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-blue pixel translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                          |
     * | <span id="GL_PIXEL_MAP_I_TO_G_SIZE"></span><span id="gl_pixel_map_i_to_g_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_G\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-green pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_I_TO_I_SIZE"></span><span id="gl_pixel_map_i_to_i_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_I\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-index pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_I_TO_R_SIZE"></span><span id="gl_pixel_map_i_to_r_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_R\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-red pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_PIXEL_MAP_R_TO_R_SIZE"></span><span id="gl_pixel_map_r_to_r_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_R\_TO\_R\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the red-to-red pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_PIXEL_MAP_S_TO_S_SIZE"></span><span id="gl_pixel_map_s_to_s_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_S\_TO\_S\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the stencil-to-stencil pixel translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_POINT_SIZE"></span><span id="gl_point_size"></span><dl> <dt>**GL\_POINT\_SIZE**</dt> </dl>                                                             | The *params* parameter returns one value: the point size as specified by [**glPointSize**](glpointsize.md).<br/>                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_POINT_SIZE_GRANULARITY"></span><span id="gl_point_size_granularity"></span><dl> <dt>**GL\_POINT\_SIZE\_GRANULARITY**</dt> </dl>                        | The *params* parameter returns one value: the size difference between adjacent supported sizes for antialiased points. See [**glPointSize**](glpointsize.md).<br/>                                                                                                                                                                                                                                                                  |
     * | <span id="GL_POINT_SIZE_RANGE"></span><span id="gl_point_size_range"></span><dl> <dt>**GL\_POINT\_SIZE\_RANGE**</dt> </dl>                                          | The *params* parameter returns two values: the smallest and largest supported sizes for antialiased points. See [**glPointSize**](glpointsize.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_POINT_SMOOTH"></span><span id="gl_point_smooth"></span><dl> <dt>**GL\_POINT\_SMOOTH**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether antialiasing of points is enabled. See [**glPointSize**](glpointsize.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_POINT_SMOOTH_HINT"></span><span id="gl_point_smooth_hint"></span><dl> <dt>**GL\_POINT\_SMOOTH\_HINT**</dt> </dl>                                       | The *params* parameter returns one value: a symbolic constant indicating the mode of the point antialiasing hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_POLYGON_MODE"></span><span id="gl_polygon_mode"></span><dl> <dt>**GL\_POLYGON\_MODE**</dt> </dl>                                                       | The *params* parameter returns two values: symbolic constants indicating whether front-facing and back-facing polygons are rasterized as points, lines, or filled polygons. See [**glPolygonMode**](glpolygonmode.md).<br/>                                                                                                                                                                                                         |
     * | <span id="GL_POLYGON_OFFSET_FACTOR"></span><span id="gl_polygon_offset_factor"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_FACTOR**</dt> </dl>                           | The *params* parameter returns one value, the scaling factor used to determine the variable offset that is added to the depth value of each fragment generated when a polygon is rasterized. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                                    |
     * | <span id="GL_POLYGON_OFFSET_UNITS"></span><span id="gl_polygon_offset_units"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_UNITS**</dt> </dl>                              | The *params* parameter returns one value. This value is multiplied by an implementation-specific value and then added to the depth value of each fragment generated when a polygon is rasterized. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                               |
     * | <span id="GL_POLYGON_OFFSET_FILL"></span><span id="gl_polygon_offset_fill"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_FILL**</dt> </dl>                                 | The *params* parameter returns a single Boolean value indicating whether polygon offset is enabled for polygons in fill mode. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                                                                                                   |
     * | <span id="GL_POLYGON_OFFSET_LINE"></span><span id="gl_polygon_offset_line"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_LINE**</dt> </dl>                                 | The *params* parameter returns a single Boolean value indicating whether polygon offset is enabled for polygons in line mode. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                                                                                                   |
     * | <span id="GL_POLYGON_OFFSET_POINT"></span><span id="gl_polygon_offset_point"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_POINT**</dt> </dl>                              | The *params* parameter returns a single Boolean value indicating whether polygon offset is enabled for polygons in point mode. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                                                                                                  |
     * | <span id="GL_POLYGON_SMOOTH"></span><span id="gl_polygon_smooth"></span><dl> <dt>**GL\_POLYGON\_SMOOTH**</dt> </dl>                                                 | The *params* parameter returns a single Boolean value indicating whether antialiasing of polygons is enabled. See [**glPolygonMode**](glpolygonmode.md).<br/>                                                                                                                                                                                                                                                                       |
     * | <span id="GL_POLYGON_SMOOTH_HINT"></span><span id="gl_polygon_smooth_hint"></span><dl> <dt>**GL\_POLYGON\_SMOOTH\_HINT**</dt> </dl>                                 | The *params* parameter returns one value: a symbolic constant indicating the mode of the polygon antialiasing hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                               |
     * | <span id="GL_POLYGON_STIPPLE"></span><span id="gl_polygon_stipple"></span><dl> <dt>**GL\_POLYGON\_STIPPLE**</dt> </dl>                                              | The *params* parameter returns a single Boolean value indicating whether stippling of polygons is enabled. See [**glPolygonStipple**](glpolygonstipple.md).<br/>                                                                                                                                                                                                                                                                    |
     * | <span id="GL_PROJECTION_MATRIX"></span><span id="gl_projection_matrix"></span><dl> <dt>**GL\_PROJECTION\_MATRIX**</dt> </dl>                                        | The *params* parameter returns 16 values: the projection matrix on the top of the projection matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                            |
     * | <span id="GL_PROJECTION_STACK_DEPTH"></span><span id="gl_projection_stack_depth"></span><dl> <dt>**GL\_PROJECTION\_STACK\_DEPTH**</dt> </dl>                        | The *params* parameter returns one value: the number of matrices on the projection matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_READ_BUFFER"></span><span id="gl_read_buffer"></span><dl> <dt>**GL\_READ\_BUFFER**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating which color buffer is selected for reading. See [**glReadPixels**](glreadpixels.md) and [**glAccum**](glaccum.md).<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_RED_BIAS"></span><span id="gl_red_bias"></span><dl> <dt>**GL\_RED\_BIAS**</dt> </dl>                                                                   | The *params* parameter returns one value: the red bias factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_RED_BITS"></span><span id="gl_red_bits"></span><dl> <dt>**GL\_RED\_BITS**</dt> </dl>                                                                   | The *params* parameter returns one value: the number of red bitplanes in each color buffer.<br/>                                                                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_RED_SCALE"></span><span id="gl_red_scale"></span><dl> <dt>**GL\_RED\_SCALE**</dt> </dl>                                                                | The *params* parameter returns one value: the red scale factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_RENDER_MODE"></span><span id="gl_render_mode"></span><dl> <dt>**GL\_RENDER\_MODE**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating whether OpenGL is in render, select, or feedback mode. See [**glRenderMode**](glrendermode.md).<br/>                                                                                                                                                                                                                                                       |
     * | <span id="GL_RGBA_MODE"></span><span id="gl_rgba_mode"></span><dl> <dt>**GL\_RGBA\_MODE**</dt> </dl>                                                                | The *params* parameter returns a single Boolean value indicating whether OpenGL is in RGBA mode (TRUE) or color-index mode (FALSE). See [glColor](glcolor-functions.md).<br/>                                                                                                                                                                                                                                                       |
     * | <span id="GL_SCISSOR_BOX"></span><span id="gl_scissor_box"></span><dl> <dt>**GL\_SCISSOR\_BOX**</dt> </dl>                                                          | The *params* parameter returns four values: the *x* and *y* window coordinates of the scissor box, followed by its width and height. See [**glScissor**](glscissor.md).<br/>                                                                                                                                                                                                                                                        |
     * | <span id="GL_SCISSOR_TEST"></span><span id="gl_scissor_test"></span><dl> <dt>**GL\_SCISSOR\_TEST**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether scissoring is enabled. See [**glScissor**](glscissor.md).<br/>                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_SHADE_MODEL"></span><span id="gl_shade_model"></span><dl> <dt>**GL\_SHADE\_MODEL**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating whether the shading mode is flat or smooth. See [**glShadeModel**](glshademodel.md).<br/>                                                                                                                                                                                                                                                                  |
     * | <span id="GL_STENCIL_BITS"></span><span id="gl_stencil_bits"></span><dl> <dt>**GL\_STENCIL\_BITS**</dt> </dl>                                                       | The *params* parameter returns one value: the number of bitplanes in the stencil buffer.<br/>                                                                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_STENCIL_CLEAR_VALUE"></span><span id="gl_stencil_clear_value"></span><dl> <dt>**GL\_STENCIL\_CLEAR\_VALUE**</dt> </dl>                                 | The *params* parameter returns one value: the index to which the stencil bitplanes are cleared. See [**glClearStencil**](glclearstencil.md).<br/>                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_STENCIL_FAIL"></span><span id="gl_stencil_fail"></span><dl> <dt>**GL\_STENCIL\_FAIL**</dt> </dl>                                                       | The *params* parameter returns one value: a symbolic constant indicating what action is taken when the stencil test fails. See [**glStencilOp**](glstencilop.md).<br/>                                                                                                                                                                                                                                                              |
     * | <span id="GL_STENCIL_FUNC"></span><span id="gl_stencil_func"></span><dl> <dt>**GL\_STENCIL\_FUNC**</dt> </dl>                                                       | The *params* parameter returns one value: a symbolic constant indicating what function is used to compare the stencil reference value with the stencil buffer value. See [**glStencilFunc**](glstencilfunc.md).<br/>                                                                                                                                                                                                                |
     * | <span id="GL_STENCIL_PASS_DEPTH_FAIL"></span><span id="gl_stencil_pass_depth_fail"></span><dl> <dt>**GL\_STENCIL\_PASS\_DEPTH\_FAIL**</dt> </dl>                    | The *params* parameter returns one value: a symbolic constant indicating what action is taken when the stencil test passes, but the depth test fails. See [**glStencilOp**](glstencilop.md).<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_STENCIL_PASS_DEPTH_PASS"></span><span id="gl_stencil_pass_depth_pass"></span><dl> <dt>**GL\_STENCIL\_PASS\_DEPTH\_PASS**</dt> </dl>                    | The *params* parameter returns one value: a symbolic constant indicating what action is taken when the stencil test passes and the depth test passes. See [**glStencilOp**](glstencilop.md).<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_STENCIL_REF"></span><span id="gl_stencil_ref"></span><dl> <dt>**GL\_STENCIL\_REF**</dt> </dl>                                                          | The *params* parameter returns one value: the reference value that is compared with the contents of the stencil buffer. See [**glStencilFunc**](glstencilfunc.md).<br/>                                                                                                                                                                                                                                                             |
     * | <span id="GL_STENCIL_TEST"></span><span id="gl_stencil_test"></span><dl> <dt>**GL\_STENCIL\_TEST**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether stencil testing of fragments is enabled. See [**glStencilFunc**](glstencilfunc.md) and [**glStencilOp**](glstencilop.md).<br/>                                                                                                                                                                                                                            |
     * | <span id="GL_STENCIL_VALUE_MASK"></span><span id="gl_stencil_value_mask"></span><dl> <dt>**GL\_STENCIL\_VALUE\_MASK**</dt> </dl>                                    | The *params* parameter returns one value: the mask that is used to mask both the stencil reference value and the stencil buffer value before they are compared. See [**glStencilFunc**](glstencilfunc.md).<br/>                                                                                                                                                                                                                     |
     * | <span id="GL_STENCIL_WRITEMASK"></span><span id="gl_stencil_writemask"></span><dl> <dt>**GL\_STENCIL\_WRITEMASK**</dt> </dl>                                        | The *params* parameter returns one value: the mask that controls writing of the stencil bitplanes. See [**glStencilMask**](glstencilmask.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_STEREO"></span><span id="gl_stereo"></span><dl> <dt>**GL\_STEREO**</dt> </dl>                                                                          | The *params* parameter returns a single Boolean value indicating whether stereo buffers (left and right) are supported.<br/>                                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_SUBPIXEL_BITS"></span><span id="gl_subpixel_bits"></span><dl> <dt>**GL\_SUBPIXEL\_BITS**</dt> </dl>                                                    | The *params* parameter returns one value: an estimate of the number of bits of subpixel resolution that are used to position rasterized geometry in window coordinates.<br/>                                                                                                                                                                                                                                                         |
     * | <span id="GL_TEXTURE_1D"></span><span id="gl_texture_1d"></span><dl> <dt>**GL\_TEXTURE\_1D**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether 1-D texture mapping is enabled. See [**glTexImage1D**](glteximage1d.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_TEXTURE_2D"></span><span id="gl_texture_2d"></span><dl> <dt>**GL\_TEXTURE\_2D**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether 2-D texture mapping is enabled. See [**glTexImage2D**](glteximage2d.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_TEXTURE_COORD_ARRAY"></span><span id="gl_texture_coord_array"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY**</dt> </dl>                                 | The *params* parameter returns a single Boolean value indicating whether the texture coordinate array is enabled. See [**glTexCoordPointer**](gltexcoordpointer.md).<br/>                                                                                                                                                                                                                                                           |
     * | <span id="GL_TEXTURE_COORD_ARRAY_SIZE"></span><span id="gl_texture_coord_array_size"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY\_SIZE**</dt> </dl>                 | The *params* parameter returns one value, the number of coordinates per element in the texture coordinate array. See [**glTexCoordPointer**](gltexcoordpointer.md).<br/>                                                                                                                                                                                                                                                            |
     * | <span id="GL_TEXTURE_COORD_ARRAY_STRIDE"></span><span id="gl_texture_coord_array_stride"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY\_STRIDE**</dt> </dl>           | The *params* parameter returns one value, the byte offset between consecutive elements in the texture coordinate array. See [**glTexCoordPointer**](gltexcoordpointer.md).<br/>                                                                                                                                                                                                                                                     |
     * | <span id="GL_TEXTURE_COORD_ARRAY_TYPE"></span><span id="gl_texture_coord_array_type"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY\_TYPE**</dt> </dl>                 | The *params* parameter params returns one value, the data type of the coordinates in the texture coordinate array. See [**glTexCoordPointer**](gltexcoordpointer.md).<br/>                                                                                                                                                                                                                                                          |
     * | <span id="GL_TEXTURE_ENV_COLOR"></span><span id="gl_texture_env_color"></span><dl> <dt>**GL\_TEXTURE\_ENV\_COLOR**</dt> </dl>                                       | The *params* parameter returns four values: the red, green, blue, and alpha values of the texture environment color. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and 1.0 returns the most negative representable integer value. See [glTexEnv](gltexenv-functions.md).<br/>                              |
     * | <span id="GL_TEXTURE_ENV_MODE"></span><span id="gl_texture_env_mode"></span><dl> <dt>**GL\_TEXTURE\_ENV\_MODE**</dt> </dl>                                          | The *params* parameter returns one value: a symbolic constant indicating which texture environment function is currently selected. See [glTexEnv](gltexenv-functions.md).<br/>                                                                                                                                                                                                                                                      |
     * | <span id="GL_TEXTURE_GEN_Q"></span><span id="gl_texture_gen_q"></span><dl> <dt>**GL\_TEXTURE\_GEN\_Q**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether automatic generation of the Q texture coordinate is enabled. See [**glTexGen**](gltexgen-functions.md).<br/>                                                                                                                                                                                                                                               |
     * | <span id="GL_TEXTURE_GEN_R"></span><span id="gl_texture_gen_r"></span><dl> <dt>**GL\_TEXTURE\_GEN\_R**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether automatic generation of the R texture coordinate is enabled. See [**glTexGen**](gltexgen-functions.md).<br/>                                                                                                                                                                                                                                               |
     * | <span id="GL_TEXTURE_GEN_S"></span><span id="gl_texture_gen_s"></span><dl> <dt>**GL\_TEXTURE\_GEN\_S**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether automatic generation of the S texture coordinate is enabled. See [**glTexGen**](gltexgen-functions.md).<br/>                                                                                                                                                                                                                                               |
     * | <span id="GL_TEXTURE_GEN_T"></span><span id="gl_texture_gen_t"></span><dl> <dt>**GL\_TEXTURE\_GEN\_T**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether automatic generation of the T texture coordinate is enabled. See [**glTexGen**](gltexgen-functions.md).<br/>                                                                                                                                                                                                                                               |
     * | <span id="GL_TEXTURE_MATRIX"></span><span id="gl_texture_matrix"></span><dl> <dt>**GL\_TEXTURE\_MATRIX**</dt> </dl>                                                 | The *params* parameter returns 16 values: the texture matrix on the top of the texture matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_TEXTURE_STACK_DEPTH"></span><span id="gl_texture_stack_depth"></span><dl> <dt>**GL\_TEXTURE\_STACK\_DEPTH**</dt> </dl>                                 | The *params* parameter returns one value: the number of matrices on the texture matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_UNPACK_ALIGNMENT"></span><span id="gl_unpack_alignment"></span><dl> <dt>**GL\_UNPACK\_ALIGNMENT**</dt> </dl>                                           | The *params* parameter returns one value: the byte alignment used for reading pixel data from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                                           |
     * | <span id="GL_UNPACK_LSB_FIRST"></span><span id="gl_unpack_lsb_first"></span><dl> <dt>**GL\_UNPACK\_LSB\_FIRST**</dt> </dl>                                          | The *params* parameter returns a single Boolean value indicating whether single-bit pixels being read from memory are read first from the least significant bit of each unsigned byte. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                          |
     * | <span id="GL_UNPACK_ROW_LENGTH"></span><span id="gl_unpack_row_length"></span><dl> <dt>**GL\_UNPACK\_ROW\_LENGTH**</dt> </dl>                                       | The *params* parameter returns one value: the row length used for reading pixel data from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                                               |
     * | <span id="GL_UNPACK_SKIP_PIXELS"></span><span id="gl_unpack_skip_pixels"></span><dl> <dt>**GL\_UNPACK\_SKIP\_PIXELS**</dt> </dl>                                    | The *params* parameter returns one value: the number of pixel locations skipped before the first pixel is read from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                     |
     * | <span id="GL_UNPACK_SKIP_ROWS"></span><span id="gl_unpack_skip_rows"></span><dl> <dt>**GL\_UNPACK\_SKIP\_ROWS**</dt> </dl>                                          | The *params* parameter returns one value: the number of rows of pixel locations skipped before the first pixel is read from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                             |
     * | <span id="GL_UNPACK_SWAP_BYTES"></span><span id="gl_unpack_swap_bytes"></span><dl> <dt>**GL\_UNPACK\_SWAP\_BYTES**</dt> </dl>                                       | The *params* parameter returns a single Boolean value indicating whether the bytes of 2-byte and 4-byte pixel indexes and components are swapped after being read from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                  |
     * | <span id="GL_VERTEX_ARRAY"></span><span id="gl_vertex_array"></span><dl> <dt>**GL\_VERTEX\_ARRAY**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether the vertex array is enabled. See [**glVertexPointer**](glvertexpointer.md).<br/>                                                                                                                                                                                                                                                                           |
     * | <span id="GL_VERTEX_ARRAY_SIZE"></span><span id="gl_vertex_array_size"></span><dl> <dt>**GL\_VERTEX\_ARRAY\_SIZE**</dt> </dl>                                       | The *params* parameter returns one value, the number of coordinates per vertex in the vertex array. See [**glVertexPointer**](glvertexpointer.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_VERTEX_ARRAY_STRIDE"></span><span id="gl_vertex_array_stride"></span><dl> <dt>**GL\_VERTEX\_ARRAY\_STRIDE**</dt> </dl>                                 | The *params* parameter returns one value, the byte offset between consecutive vertexes in the vertex array. See [**glVertexPointer**](glvertexpointer.md).<br/>                                                                                                                                                                                                                                                                     |
     * | <span id="GL_VERTEX_ARRAY_TYPE"></span><span id="gl_vertex_array_type"></span><dl> <dt>**GL\_VERTEX\_ARRAY\_TYPE**</dt> </dl>                                       | The *params* parameter returns one value, the data type of each coordinate in the vertex array. See [**glVertexPointer**](glvertexpointer.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_VIEWPORT"></span><span id="gl_viewport"></span><dl> <dt>**GL\_VIEWPORT**</dt> </dl>                                                                    | The *params* parameter returns four values: the *x* and *y* window coordinates of the viewport, followed by its width and height. See [**glViewport**](glviewport.md).<br/>                                                                                                                                                                                                                                                         |
     * | <span id="GL_ZOOM_X"></span><span id="gl_zoom_x"></span><dl> <dt>**GL\_ZOOM\_X**</dt> </dl>                                                                         | The *params* parameter returns one value: the *x* pixel zoom factor. See [**glPixelZoom**](glpixelzoom.md).<br/>                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_ZOOM_Y"></span><span id="gl_zoom_y"></span><dl> <dt>**GL\_ZOOM\_Y**</dt> </dl>                                                                         | The *params* parameter returns one value: the *y* pixel zoom factor. See [**glPixelZoom**](glpixelzoom.md).<br/>                                                                                                                                                                                                                                                                                                                    |
     * @param {Pointer<Double>} params Returns the value or values of the specified parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetdoublev
     */
    static glGetDoublev(pname, params) {
        DllCall("OPENGL32.dll\glGetDoublev", "uint", pname, "ptr", params)
    }

    /**
     * The glGetError function returns error information.
     * @remarks
     * Each detectable error is assigned a numeric code and symbolic name. When an error occurs, the error flag is set to the appropriate error code value. No other errors are recorded until **glGetError** is called, the error code is returned, and the flag is reset to GL\_NO\_ERROR. If a call to **glGetError** returns GL\_NO\_ERROR, there has been no detectable error since the last call to **glGetError**, or since OpenGL was initialized.
     * 
     * To allow for distributed implementations, there may be several error flags. If any single error flag has recorded an error, the value of that flag is returned and that flag is reset to GL\_NO\_ERROR when **glGetError** is called. If more than one flag has recorded an error, **glGetError** returns and clears an arbitrary error flag value. If all error flags are to be reset, you should always call **glGetError** in a loop until it returns GL\_NO\_ERROR.
     * 
     * Initially, all error flags are set to GL\_NO\_ERROR.
     * 
     * When an error flag is set, results of an OpenGL operation are undefined only if GL\_OUT\_OF\_MEMORY has occurred. In all other cases, the function generating the error is ignored and has no effect on the OpenGL state or framebuffer contents.
     * @returns {Integer} This function has no parameters.
     * 
     * 
     * The **glGetError** function returns one of the following error codes.
     * 
     * 
     * 
     * | Return code                                                                                           | Description                                                                                                                                                                  |
     * |-------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <dl> <dt>**GL\_INVALID\_ENUM**</dt> </dl>      | An unacceptable value is specified for an enumerated argument. The offending function is ignored, having no side effect other than to set the error flag.<br/>         |
     * | <dl> <dt>**GL\_INVALID\_VALUE**</dt> </dl>     | A numeric argument is out of range. The offending function is ignored, having no side effect other than to set the error flag.<br/>                                    |
     * | <dl> <dt>**GL\_INVALID\_OPERATION**</dt> </dl> | The specified operation is not allowed in the current state. The offending function is ignored, having no side effect other than to set the error flag.<br/>           |
     * | <dl> <dt>**GL\_NO\_ERROR**</dt> </dl>          | No error has been recorded. The value of this symbolic constant is guaranteed to be zero.<br/>                                                                         |
     * | <dl> <dt>**GL\_STACK\_OVERFLOW**</dt> </dl>    | This function would cause a stack overflow. The offending function is ignored, having no side effect other than to set the error flag.<br/>                            |
     * | <dl> <dt>**GL\_STACK\_UNDERFLOW**</dt> </dl>   | This function would cause a stack underflow. The offending function is ignored, having no side effect other than to set the error flag.<br/>                           |
     * | <dl> <dt>**GL\_OUT\_OF\_MEMORY**</dt> </dl>    | There is not enough memory left to execute the function. The state of OpenGL is undefined, except for the state of the error flags, after this error is recorded.<br/> |
     * 
     * 
     * 
     *  
     * 
     * Note that **glGetError** returns GL\_INVALID\_OPERATION if it is called between a call to [**glBegin**](glbegin.md) and its corresponding call to [**glEnd**](glend.md).
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgeterror
     */
    static glGetError() {
        result := DllCall("OPENGL32.dll\glGetError", "uint")
        return result
    }

    /**
     * The glGetFloatv function returns the value or values of a selected parameter.
     * @remarks
     * This function returns values for simple state variables in OpenGL. The *pname* parameter is a symbolic constant indicating the state variable to be returned, and *params* is a pointer to an array of the indicated type in which to place the returned data.
     * 
     * Type conversion is performed if *params* has a different type from the state variable value being requested. If you call [**glGetBooleanv**](glgetbooleanv.md), a floating-point or integer value is converted to GL\_FALSE if and only if it is zero. Otherwise, it is converted to GL\_TRUE.
     * 
     * If you call [**glGetIntegerv**](glgetintegerv.md), Boolean values are returned as GL\_TRUE or GL\_FALSE, and most floating-point values are rounded to the nearest integer value. Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most positive representable integer value and 1.0 to the most negative representable integer value.
     * 
     * If you call **glGetFloatv** or [**glGetDoublev**](glgetdoublev.md), Boolean values are returned as GL\_TRUE or GL\_FALSE, and integer values are converted to floating-point values.
     * 
     * You can query many of the Boolean parameters more easily with [**glIsEnabled**](glisenabled.md).
     * @param {Integer} pname The parameter value to be returned. The following symbolic constants are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                    |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_ACCUM_ALPHA_BITS"></span><span id="gl_accum_alpha_bits"></span><dl> <dt>**GL\_ACCUM\_ALPHA\_BITS**</dt> </dl>                                          | The *params* parameter returns one value: the number of alpha bitplanes in the accumulation buffer.<br/>                                                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_ACCUM_BLUE_BITS"></span><span id="gl_accum_blue_bits"></span><dl> <dt>**GL\_ACCUM\_BLUE\_BITS**</dt> </dl>                                             | The *params* parameter returns one value: the number of blue bitplanes in the accumulation buffer.<br/>                                                                                                                                                                                                                                                                                                                              |
     * | <span id="GL_ACCUM_CLEAR_VALUE"></span><span id="gl_accum_clear_value"></span><dl> <dt>**GL\_ACCUM\_CLEAR\_VALUE**</dt> </dl>                                       | The *params* parameter returns four values: the red, green, blue, and alpha values used to clear the accumulation buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glClearAccum**](glclearaccum.md).<br/>                      |
     * | <span id="GL_ACCUM_GREEN_BITS"></span><span id="gl_accum_green_bits"></span><dl> <dt>**GL\_ACCUM\_GREEN\_BITS**</dt> </dl>                                          | The *params* parameter returns one value: the number of green bitplanes in the accumulation buffer.<br/>                                                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_ACCUM_RED_BITS"></span><span id="gl_accum_red_bits"></span><dl> <dt>**GL\_ACCUM\_RED\_BITS**</dt> </dl>                                                | The *params* parameter returns one value: the number of red bitplanes in the accumulation buffer.<br/>                                                                                                                                                                                                                                                                                                                               |
     * | <span id="GL_ALPHA_BIAS"></span><span id="gl_alpha_bias"></span><dl> <dt>**GL\_ALPHA\_BIAS**</dt> </dl>                                                             | The *params* parameter returns one value: the alpha bias factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_ALPHA_BITS"></span><span id="gl_alpha_bits"></span><dl> <dt>**GL\_ALPHA\_BITS**</dt> </dl>                                                             | The *params* parameter returns one value: the number of alpha bitplanes in each color buffer.<br/>                                                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_ALPHA_SCALE"></span><span id="gl_alpha_scale"></span><dl> <dt>**GL\_ALPHA\_SCALE**</dt> </dl>                                                          | The *params* parameter returns one value: the alpha scale factor used during pixel transfers. See [glPixelTransfer](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                       |
     * | <span id="GL_ALPHA_TEST"></span><span id="gl_alpha_test"></span><dl> <dt>**GL\_ALPHA\_TEST**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether alpha testing of fragments is enabled. See [**glAlphaFunc**](glalphafunc.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_ALPHA_TEST_FUNC"></span><span id="gl_alpha_test_func"></span><dl> <dt>**GL\_ALPHA\_TEST\_FUNC**</dt> </dl>                                             | The *params* parameter returns one value: the symbolic name of the alpha test function. See [**glAlphaFunc**](glalphafunc.md).<br/>                                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_ALPHA_TEST_REF"></span><span id="gl_alpha_test_ref"></span><dl> <dt>**GL\_ALPHA\_TEST\_REF**</dt> </dl>                                                | The *params* parameter returns one value: the reference value for the alpha test. See [**glAlphaFunc**](glalphafunc.md). An integer value, if requested, is linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value.<br/>                                                               |
     * | <span id="GL_ATTRIB_STACK_DEPTH"></span><span id="gl_attrib_stack_depth"></span><dl> <dt>**GL\_ATTRIB\_STACK\_DEPTH**</dt> </dl>                                    | The *params* parameter returns one value: the depth of the attribute stack. If the stack is empty, zero is returned. See [**glPushAttrib**](glpushattrib.md).<br/>                                                                                                                                                                                                                                                                  |
     * | <span id="GL_AUTO_NORMAL"></span><span id="gl_auto_normal"></span><dl> <dt>**GL\_AUTO\_NORMAL**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether 2-D map evaluation automatically generates surface normals. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                              |
     * | <span id="GL_AUX_BUFFERS"></span><span id="gl_aux_buffers"></span><dl> <dt>**GL\_AUX\_BUFFERS**</dt> </dl>                                                          | The *params* parameter returns one value: the number of auxiliary color buffers.<br/>                                                                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_BLEND"></span><span id="gl_blend"></span><dl> <dt>**GL\_BLEND**</dt> </dl>                                                                             | The *params* parameter returns a single Boolean value indicating whether blending is enabled. See [**glBlendFunc**](glblendfunc.md).<br/>                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_BLEND_DST"></span><span id="gl_blend_dst"></span><dl> <dt>**GL\_BLEND\_DST**</dt> </dl>                                                                | The *params* parameter returns one value: the symbolic constant identifying the destination blend function. See [**glBlendFunc**](glblendfunc.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_BLEND_SRC"></span><span id="gl_blend_src"></span><dl> <dt>**GL\_BLEND\_SRC**</dt> </dl>                                                                | The *params* parameter returns one value: the symbolic constant identifying the source blend function. See [**glBlendFunc**](glblendfunc.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_BLUE_BIAS"></span><span id="gl_blue_bias"></span><dl> <dt>**GL\_BLUE\_BIAS**</dt> </dl>                                                                | The *params* parameter returns one value: the blue bias factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_BLUE_BITS"></span><span id="gl_blue_bits"></span><dl> <dt>**GL\_BLUE\_BITS**</dt> </dl>                                                                | The *params* parameter returns one value: the number of blue bitplanes in each color buffer.<br/>                                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_BLUE_SCALE"></span><span id="gl_blue_scale"></span><dl> <dt>**GL\_BLUE\_SCALE**</dt> </dl>                                                             | The *params* parameter returns one value: the blue scale factor used during pixel transfers. See [glPixelTransfer](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_CLIENT_ATTRIB_STACK_DEPTH"></span><span id="gl_client_attrib_stack_depth"></span><dl> <dt>**GL\_CLIENT\_ATTRIB\_STACK\_DEPTH**</dt> </dl>              | The *params* parameter returns one value indicating the depth of the attribute stack. The initial value is zero. See [**glPushClientAttrib**](glpushclientattrib.md).<br/>                                                                                                                                                                                                                                                          |
     * | <span id="GL_CLIP_PLANEi"></span><span id="gl_clip_planei"></span><span id="GL_CLIP_PLANEI"></span><dl> <dt>**GL\_CLIP\_PLANE*i***</dt> </dl>                       | The *params* parameter returns a single Boolean value indicating whether the specified clipping plane is enabled. See [**glClipPlane**](glclipplane.md).<br/>                                                                                                                                                                                                                                                                       |
     * | <span id="GL_COLOR_ARRAY"></span><span id="gl_color_array"></span><dl> <dt>**GL\_COLOR\_ARRAY**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether the specified color array is defined. See [**glColorPointer**](glcolorpointer.md).<br/>                                                                                                                                                                                                                                                                    |
     * | <span id="GL_COLOR_ARRAY_SIZE"></span><span id="gl_color_array_size"></span><dl> <dt>**GL\_COLOR\_ARRAY\_SIZE**</dt> </dl>                                          | The *params* parameter returns one value, the number of components per color in the color array. See [**glColorPointer**](glcolorpointer.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_COLOR_ARRAY_STRIDE"></span><span id="gl_color_array_stride"></span><dl> <dt>**GL\_COLOR\_ARRAY\_STRIDE**</dt> </dl>                                    | The *params* parameter returns one value, the byte offset between consecutive colors in the color array. See [**glColorPointer**](glcolorpointer.md).<br/>                                                                                                                                                                                                                                                                          |
     * | <span id="GL_COLOR_ARRAY_TYPE"></span><span id="gl_color_array_type"></span><dl> <dt>**GL\_COLOR\_ARRAY\_TYPE**</dt> </dl>                                          | The *params* parameter returns one value, the data type of each component in the color array. See [**glColorPointer**](glcolorpointer.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_COLOR_CLEAR_VALUE"></span><span id="gl_color_clear_value"></span><dl> <dt>**GL\_COLOR\_CLEAR\_VALUE**</dt> </dl>                                       | The *params* parameter returns four values: the red, green, blue, and alpha values used to clear the color buffers. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glClearColor**](glclearcolor.md).<br/>                            |
     * | <span id="GL_COLOR_LOGIC_OP"></span><span id="gl_color_logic_op"></span><dl> <dt>**GL\_COLOR\_LOGIC\_OP**</dt> </dl>                                                | The *params* parameter returns a single Boolean value indicating whether a fragment's RGBA color values are merged into the framebuffer using a logical operation. See [**glLogicOp**](gllogicop.md).<br/>                                                                                                                                                                                                                          |
     * | <span id="GL_COLOR_MATERIAL"></span><span id="gl_color_material"></span><dl> <dt>**GL\_COLOR\_MATERIAL**</dt> </dl>                                                 | The *params* parameter returns a single Boolean value indicating whether one or more material parameters are tracking the current color. See [**glColorMaterial**](glcolormaterial.md).<br/>                                                                                                                                                                                                                                        |
     * | <span id="GL_COLOR_MATERIAL_FACE"></span><span id="gl_color_material_face"></span><dl> <dt>**GL\_COLOR\_MATERIAL\_FACE**</dt> </dl>                                 | The *params* parameter returns one value: a symbolic constant indicating which materials have a parameter that is tracking the current color. See [**glColorMaterial**](glcolormaterial.md).<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_COLOR_MATERIAL_PARAMETER"></span><span id="gl_color_material_parameter"></span><dl> <dt>**GL\_COLOR\_MATERIAL\_PARAMETER**</dt> </dl>                  | The *params* parameter returns one value: a symbolic constant indicating which material parameters are tracking the current color. See [**glColorMaterial**](glcolormaterial.md).<br/>                                                                                                                                                                                                                                              |
     * | <span id="GL_COLOR_WRITEMASK"></span><span id="gl_color_writemask"></span><dl> <dt>**GL\_COLOR\_WRITEMASK**</dt> </dl>                                              | The *params* parameter returns four Boolean values: the red, green, blue, and alpha write enables for the color buffers. See [**glColorMask**](glcolormask.md).<br/>                                                                                                                                                                                                                                                                |
     * | <span id="GL_CULL_FACE"></span><span id="gl_cull_face"></span><dl> <dt>**GL\_CULL\_FACE**</dt> </dl>                                                                | The *params* parameter returns a single Boolean value indicating whether polygon culling is enabled. See [**glCullFace**](glcullface.md).<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_CULL_FACE_MODE"></span><span id="gl_cull_face_mode"></span><dl> <dt>**GL\_CULL\_FACE\_MODE**</dt> </dl>                                                | The *params* parameter returns one value: a symbolic constant indicating which polygon faces are to be culled. See [**glCullFace**](glcullface.md).<br/>                                                                                                                                                                                                                                                                            |
     * | <span id="GL_CURRENT_COLOR"></span><span id="gl_current_color"></span><dl> <dt>**GL\_CURRENT\_COLOR**</dt> </dl>                                                    | The *params* parameter returns four values: the red, green, blue, and alpha values of the current color. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glColor**](glcolor-functions.md).<br/>                                       |
     * | <span id="GL_CURRENT_INDEX"></span><span id="gl_current_index"></span><dl> <dt>**GL\_CURRENT\_INDEX**</dt> </dl>                                                    | The *params* parameter returns one value: the current color index. See [**glIndex**](glindex-functions.md).<br/>                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_CURRENT_NORMAL"></span><span id="gl_current_normal"></span><dl> <dt>**GL\_CURRENT\_NORMAL**</dt> </dl>                                                 | The *params* parameter returns three values: the *x*, *y*, and *z* values of the current normal. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glNormal**](glnormal-functions.md).<br/>                                             |
     * | <span id="GL_CURRENT_RASTER_COLOR"></span><span id="gl_current_raster_color"></span><dl> <dt>**GL\_CURRENT\_RASTER\_COLOR**</dt> </dl>                              | The *params* parameter returns four values: the red, green, blue, and alpha values of the current raster position. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glRasterPos**](glrasterpos-functions.md).<br/>                     |
     * | <span id="GL_CURRENT_RASTER_DISTANCE"></span><span id="gl_current_raster_distance"></span><dl> <dt>**GL\_CURRENT\_RASTER\_DISTANCE**</dt> </dl>                     | The *params* parameter returns one value: the distance from the eye to the current raster position. See [**glRasterPos**](glrasterpos-functions.md).<br/>                                                                                                                                                                                                                                                                           |
     * | <span id="GL_CURRENT_RASTER_INDEX"></span><span id="gl_current_raster_index"></span><dl> <dt>**GL\_CURRENT\_RASTER\_INDEX**</dt> </dl>                              | The *params* parameter returns one value: the color index of the current raster position. See [**glRasterPos**](glrasterpos-functions.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_CURRENT_RASTER_POSITION"></span><span id="gl_current_raster_position"></span><dl> <dt>**GL\_CURRENT\_RASTER\_POSITION**</dt> </dl>                     | The *params* parameter returns four values: the *x*, *y*, *z*, and *w* components of the current raster position. The *x*, *y*, and *z* components are in window coordinates, and *w* is in clip coordinates. See [glRasterPos](glrasterpos-functions.md).<br/>                                                                                                                                                                     |
     * | <span id="GL_CURRENT_RASTER_POSITION_VALID"></span><span id="gl_current_raster_position_valid"></span><dl> <dt>**GL\_CURRENT\_RASTER\_POSITION\_VALID**</dt> </dl>  | The *params* parameter returns a single Boolean value indicating whether the current raster position is valid. See [**glRasterPos**](glrasterpos-functions.md).<br/>                                                                                                                                                                                                                                                                |
     * | <span id="GL_CURRENT_RASTER_TEXTURE_COORDS"></span><span id="gl_current_raster_texture_coords"></span><dl> <dt>**GL\_CURRENT\_RASTER\_TEXTURE\_COORDS**</dt> </dl>  | The *params* parameter returns four values: the *s*, *t*, *r*, and *q* current raster texture coordinates. See [**glRasterPos**](glrasterpos-functions.md) and [**glTexCoord**](gltexcoord-functions.md).<br/>                                                                                                                                                                                                                     |
     * | <span id="GL_CURRENT_TEXTURE_COORDS"></span><span id="gl_current_texture_coords"></span><dl> <dt>**GL\_CURRENT\_TEXTURE\_COORDS**</dt> </dl>                        | The *params* parameter returns four values: the *s*, *t*, *r*, and *q* current texture coordinates. See [**glTexCoord**](gltexcoord-functions.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_DEPTH_BIAS"></span><span id="gl_depth_bias"></span><dl> <dt>**GL\_DEPTH\_BIAS**</dt> </dl>                                                             | The *params* parameter returns one value: the depth bias factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_DEPTH_BITS"></span><span id="gl_depth_bits"></span><dl> <dt>**GL\_DEPTH\_BITS**</dt> </dl>                                                             | The *params* parameter returns one value: the number of bitplanes in the depth buffer.<br/>                                                                                                                                                                                                                                                                                                                                          |
     * | <span id="GL_DEPTH_CLEAR_VALUE"></span><span id="gl_depth_clear_value"></span><dl> <dt>**GL\_DEPTH\_CLEAR\_VALUE**</dt> </dl>                                       | The *params* parameter returns one value: the value that is used to clear the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glClearDepth**](glcleardepth.md).<br/>                                                    |
     * | <span id="GL_DEPTH_FUNC"></span><span id="gl_depth_func"></span><dl> <dt>**GL\_DEPTH\_FUNC**</dt> </dl>                                                             | The *params* parameter returns one value: the symbolic constant that indicates the depth comparison function. See [**glDepthFunc**](gldepthfunc.md).<br/>                                                                                                                                                                                                                                                                           |
     * | <span id="GL_DEPTH_RANGE"></span><span id="gl_depth_range"></span><dl> <dt>**GL\_DEPTH\_RANGE**</dt> </dl>                                                          | The *params* parameter returns two values: the near and far mapping limits for the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glDepthRange**](gldepthrange.md).<br/>                                               |
     * | <span id="GL_DEPTH_SCALE"></span><span id="gl_depth_scale"></span><dl> <dt>**GL\_DEPTH\_SCALE**</dt> </dl>                                                          | The *params* parameter returns one value: the depth scale factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_DEPTH_TEST"></span><span id="gl_depth_test"></span><dl> <dt>**GL\_DEPTH\_TEST**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether depth testing of fragments is enabled. See [**glDepthFunc**](gldepthfunc.md) and [**glDepthRange**](gldepthrange.md).<br/>                                                                                                                                                                                                                                |
     * | <span id="GL_DEPTH_WRITEMASK"></span><span id="gl_depth_writemask"></span><dl> <dt>**GL\_DEPTH\_WRITEMASK**</dt> </dl>                                              | The *params* parameter returns a single Boolean value indicating if the depth buffer is enabled for writing. See [**glDepthMask**](gldepthmask.md).<br/>                                                                                                                                                                                                                                                                            |
     * | <span id="GL_DITHER"></span><span id="gl_dither"></span><dl> <dt>**GL\_DITHER**</dt> </dl>                                                                          | The *params* parameter returns a single Boolean value indicating whether dithering of fragment colors and indexes is enabled.<br/>                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_DOUBLEBUFFER"></span><span id="gl_doublebuffer"></span><dl> <dt>**GL\_DOUBLEBUFFER**</dt> </dl>                                                        | The *params* parameter returns a single Boolean value indicating whether double buffering is supported.<br/>                                                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_DRAW_BUFFER"></span><span id="gl_draw_buffer"></span><dl> <dt>**GL\_DRAW\_BUFFER**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating which buffers are being drawn to. See [**glDrawBuffer**](gldrawbuffer.md).<br/>                                                                                                                                                                                                                                                                            |
     * | <span id="GL_EDGE_FLAG"></span><span id="gl_edge_flag"></span><dl> <dt>**GL\_EDGE\_FLAG**</dt> </dl>                                                                | The *params* parameter returns a single Boolean value indicating whether the current edge flag is true or false. See [glEdgeFlag](gledgeflag-functions.md).<br/>                                                                                                                                                                                                                                                                    |
     * | <span id="GL_EDGE_FLAG_ARRAY"></span><span id="gl_edge_flag_array"></span><dl> <dt>**GL\_EDGE\_FLAG\_ARRAY**</dt> </dl>                                             | The *params* parameter returns a single Boolean value indicating whether the edge flag array is enabled. See [**glEdgeFlagPointer**](gledgeflagpointer.md).<br/>                                                                                                                                                                                                                                                                    |
     * | <span id="GL_EDGE_FLAG_ARRAY_STRIDE"></span><span id="gl_edge_flag_array_stride"></span><dl> <dt>**GL\_EDGE\_FLAG\_ARRAY\_STRIDE**</dt> </dl>                       | The *params* parameter returns one value, the byte offset between consecutive edge flags in the edge flag array. See [**glEdgeFlagPointer**](gledgeflagpointer.md).<br/>                                                                                                                                                                                                                                                            |
     * | <span id="GL_FOG"></span><span id="gl_fog"></span><dl> <dt>**GL\_FOG**</dt> </dl>                                                                                   | The *params* parameter returns a single Boolean value indicating whether fogging is enabled. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_FOG_COLOR"></span><span id="gl_fog_color"></span><dl> <dt>**GL\_FOG\_COLOR**</dt> </dl>                                                                | The *params* parameter returns four values: the red, green, blue, and alpha components of the fog color. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glFog**](glfog.md).<br/>                                                     |
     * | <span id="GL_FOG_DENSITY"></span><span id="gl_fog_density"></span><dl> <dt>**GL\_FOG\_DENSITY**</dt> </dl>                                                          | The *params* parameter returns one value: the fog density parameter. See [glFog](glfog.md).<br/>                                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_FOG_END"></span><span id="gl_fog_end"></span><dl> <dt>**GL\_FOG\_END**</dt> </dl>                                                                      | The *params* parameter returns one value: the end factor for the linear fog equation. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                                               |
     * | <span id="GL_FOG_HINT"></span><span id="gl_fog_hint"></span><dl> <dt>**GL\_FOG\_HINT**</dt> </dl>                                                                   | The *params* parameter returns one value: a symbolic constant indicating the mode of the fog hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_FOG_INDEX"></span><span id="gl_fog_index"></span><dl> <dt>**GL\_FOG\_INDEX**</dt> </dl>                                                                | The *params* parameter returns one value: the fog color index. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_FOG_MODE"></span><span id="gl_fog_mode"></span><dl> <dt>**GL\_FOG\_MODE**</dt> </dl>                                                                   | The *params* parameter returns one value: a symbolic constant indicating which fog equation is selected. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_FOG_START"></span><span id="gl_fog_start"></span><dl> <dt>**GL\_FOG\_START**</dt> </dl>                                                                | The *params* parameter returns one value: the start factor for the linear fog equation. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_FRONT_FACE"></span><span id="gl_front_face"></span><dl> <dt>**GL\_FRONT\_FACE**</dt> </dl>                                                             | The *params* parameter returns one value: a symbolic constant indicating whether clockwise or counterclockwise polygon winding is treated as front-facing. See [**glFrontFace**](glfrontface.md).<br/>                                                                                                                                                                                                                              |
     * | <span id="GL_GREEN_BIAS"></span><span id="gl_green_bias"></span><dl> <dt>**GL\_GREEN\_BIAS**</dt> </dl>                                                             | The *params* parameter returns one value: the green bias factor used during pixel transfers.<br/>                                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_GREEN_BITS"></span><span id="gl_green_bits"></span><dl> <dt>**GL\_GREEN\_BITS**</dt> </dl>                                                             | The *params* parameter returns one value: the number of green bitplanes in each color buffer.<br/>                                                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_GREEN_SCALE"></span><span id="gl_green_scale"></span><dl> <dt>**GL\_GREEN\_SCALE**</dt> </dl>                                                          | The *params* parameter returns one value: the green scale factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_INDEX_ARRAY"></span><span id="gl_index_array"></span><dl> <dt>**GL\_INDEX\_ARRAY**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether the color index array is enabled. See [**glIndexPointer**](glindexpointer.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_INDEX_ARRAY_STRIDE"></span><span id="gl_index_array_stride"></span><dl> <dt>**GL\_INDEX\_ARRAY\_STRIDE**</dt> </dl>                                    | The *params* parameter returns one value, the byte offset between consecutive color indexes in the color index array. See [**glIndexPointer**](glindexpointer.md).<br/>                                                                                                                                                                                                                                                             |
     * | <span id="GL_INDEX_ARRAY_TYPE"></span><span id="gl_index_array_type"></span><dl> <dt>**GL\_INDEX\_ARRAY\_TYPE**</dt> </dl>                                          | The *params* parameter returns one value, the data type of indexes in the color index array. The initial value is GL\_FLOAT. See [**glIndexPointer**](glindexpointer.md).<br/>                                                                                                                                                                                                                                                      |
     * | <span id="GL_INDEX_BITS"></span><span id="gl_index_bits"></span><dl> <dt>**GL\_INDEX\_BITS**</dt> </dl>                                                             | The *params* parameter returns one value: the number of bitplanes in each color-index buffer.<br/>                                                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_INDEX_CLEAR_VALUE"></span><span id="gl_index_clear_value"></span><dl> <dt>**GL\_INDEX\_CLEAR\_VALUE**</dt> </dl>                                       | The *params* parameter returns one value: the color index used to clear the color-index buffers. See [**glClearIndex**](glclearindex.md).<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_INDEX_LOGIC_OP"></span><span id="gl_index_logic_op"></span><dl> <dt>**GL\_INDEX\_LOGIC\_OP**</dt> </dl>                                                | The *params* parameter returns a single Boolean value indicating whether a fragment's index values are merged into the framebuffer using a logical operation. See [**glLogicOp**](gllogicop.md).<br/>                                                                                                                                                                                                                               |
     * | <span id="GL_INDEX_MODE"></span><span id="gl_index_mode"></span><dl> <dt>**GL\_INDEX\_MODE**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether OpenGL is in color-index mode (TRUE) or RGBA mode (FALSE).<br/>                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_INDEX_OFFSET"></span><span id="gl_index_offset"></span><dl> <dt>**GL\_INDEX\_OFFSET**</dt> </dl>                                                       | The *params* parameter returns one value: the offset added to color and stencil indexes during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                 |
     * | <span id="GL_INDEX_SHIFT"></span><span id="gl_index_shift"></span><dl> <dt>**GL\_INDEX\_SHIFT**</dt> </dl>                                                          | The *params* parameter returns one value: the amount that color and stencil indexes are shifted during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                         |
     * | <span id="GL_INDEX_WRITEMASK"></span><span id="gl_index_writemask"></span><dl> <dt>**GL\_INDEX\_WRITEMASK**</dt> </dl>                                              | The *params* parameter returns one value: a mask indicating which bitplanes of each color-index buffer can be written. See [**glIndexMask**](glindexmask.md).<br/>                                                                                                                                                                                                                                                                  |
     * | <span id="GL_LIGHTi"></span><span id="gl_lighti"></span><span id="GL_LIGHTI"></span><dl> <dt>**GL\_LIGHT*i***</dt> </dl>                                            | The *params* parameter returns a single Boolean value indicating whether the specified light is enabled. See [**glLight**](gllight-functions.md) and [**glLightModel**](gllightmodel-functions.md).<br/>                                                                                                                                                                                                                           |
     * | <span id="GL_LIGHTING"></span><span id="gl_lighting"></span><dl> <dt>**GL\_LIGHTING**</dt> </dl>                                                                    | The *params* parameter returns a single Boolean value indicating whether lighting is enabled. See [**glLightModel**](gllightmodel-functions.md).<br/>                                                                                                                                                                                                                                                                               |
     * | <span id="GL_LIGHT_MODEL_AMBIENT"></span><span id="gl_light_model_ambient"></span><dl> <dt>**GL\_LIGHT\_MODEL\_AMBIENT**</dt> </dl>                                 | The *params* parameter returns four values: the red, green, blue, and alpha components of the ambient intensity of the entire scene. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glLightModel**](gllightmodel-functions.md).<br/> |
     * | <span id="GL_LIGHT_MODEL_LOCAL_VIEWER"></span><span id="gl_light_model_local_viewer"></span><dl> <dt>**GL\_LIGHT\_MODEL\_LOCAL\_VIEWER**</dt> </dl>                 | The *params* parameter returns a single Boolean value indicating whether specular reflection calculations treat the viewer as being local to the scene. See [**glLightModel**](gllightmodel-functions.md).<br/>                                                                                                                                                                                                                     |
     * | <span id="GL_LIGHT_MODEL_TWO_SIDE"></span><span id="gl_light_model_two_side"></span><dl> <dt>**GL\_LIGHT\_MODEL\_TWO\_SIDE**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether separate materials are used to compute lighting for front-facing and back-facing polygons. See [**glLightModel**](gllightmodel-functions.md).<br/>                                                                                                                                                                                                         |
     * | <span id="GL_LINE_SMOOTH"></span><span id="gl_line_smooth"></span><dl> <dt>**GL\_LINE\_SMOOTH**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether antialiasing of lines is enabled. See [**glLineWidth**](gllinewidth.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_LINE_SMOOTH_HINT"></span><span id="gl_line_smooth_hint"></span><dl> <dt>**GL\_LINE\_SMOOTH\_HINT**</dt> </dl>                                          | The *params* parameter returns one value: a symbolic constant indicating the mode of the line antialiasing hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_LINE_STIPPLE"></span><span id="gl_line_stipple"></span><dl> <dt>**GL\_LINE\_STIPPLE**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether stippling of lines is enabled. See [**glLineStipple**](gllinestipple.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_LINE_STIPPLE_PATTERN"></span><span id="gl_line_stipple_pattern"></span><dl> <dt>**GL\_LINE\_STIPPLE\_PATTERN**</dt> </dl>                              | The *params* parameter returns one value: the 16-bit line stipple pattern. See [**glLineStipple**](gllinestipple.md).<br/>                                                                                                                                                                                                                                                                                                          |
     * | <span id="GL_LINE_STIPPLE_REPEAT"></span><span id="gl_line_stipple_repeat"></span><dl> <dt>**GL\_LINE\_STIPPLE\_REPEAT**</dt> </dl>                                 | The *params* parameter returns one value: the line stipple repeat factor. See [**glLineStipple**](gllinestipple.md).<br/>                                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_LINE_WIDTH"></span><span id="gl_line_width"></span><dl> <dt>**GL\_LINE\_WIDTH**</dt> </dl>                                                             | The *params* parameter returns one value: the line width as specified with [**glLineWidth**](gllinewidth.md).<br/>                                                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_LINE_WIDTH_GRANULARITY"></span><span id="gl_line_width_granularity"></span><dl> <dt>**GL\_LINE\_WIDTH\_GRANULARITY**</dt> </dl>                        | The *params* parameter returns one value: the width difference between adjacent supported widths for antialiased lines. See [**glLineWidth**](gllinewidth.md).<br/>                                                                                                                                                                                                                                                                 |
     * | <span id="GL_LINE_WIDTH_RANGE"></span><span id="gl_line_width_range"></span><dl> <dt>**GL\_LINE\_WIDTH\_RANGE**</dt> </dl>                                          | The *params* parameter returns two values: the smallest and largest supported widths for antialiased lines. See [**glLineWidth**](gllinewidth.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_LIST_BASE"></span><span id="gl_list_base"></span><dl> <dt>**GL\_LIST\_BASE**</dt> </dl>                                                                | The *params* parameter returns one value: the base offset added to all names in arrays presented to [**glCallLists**](glcalllists.md). See [**glListBase**](gllistbase.md).<br/>                                                                                                                                                                                                                                                   |
     * | <span id="GL_LIST_INDEX"></span><span id="gl_list_index"></span><dl> <dt>**GL\_LIST\_INDEX**</dt> </dl>                                                             | The *params* parameter returns one value: the name of the display list currently under construction. Zero is returned if no display list is currently under construction. See [**glNewList**](glnewlist.md).<br/>                                                                                                                                                                                                                   |
     * | <span id="GL_LIST_MODE"></span><span id="gl_list_mode"></span><dl> <dt>**GL\_LIST\_MODE**</dt> </dl>                                                                | The *params* parameter returns one value: a symbolic constant indicating the construction mode of the display list currently being constructed. See [**glNewList**](glnewlist.md).<br/>                                                                                                                                                                                                                                             |
     * | <span id="GL_LOGIC_OP"></span><span id="gl_logic_op"></span><dl> <dt>**GL\_LOGIC\_OP**</dt> </dl>                                                                   | The *params* parameter returns a single Boolean value indicating whether fragment indexes are merged into the framebuffer using a logical operation. See [**glLogicOp**](gllogicop.md).<br/>                                                                                                                                                                                                                                        |
     * | <span id="GL_LOGIC_OP_MODE"></span><span id="gl_logic_op_mode"></span><dl> <dt>**GL\_LOGIC\_OP\_MODE**</dt> </dl>                                                   | The *params* parameter returns one value: a symbolic constant indicating the selected logic operational mode. See [**glLogicOp**](gllogicop.md).<br/>                                                                                                                                                                                                                                                                               |
     * | <span id="GL_MAP1_COLOR_4"></span><span id="gl_map1_color_4"></span><dl> <dt>**GL\_MAP1\_COLOR\_4**</dt> </dl>                                                      | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates colors. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP1_GRID_DOMAIN"></span><span id="gl_map1_grid_domain"></span><dl> <dt>**GL\_MAP1\_GRID\_DOMAIN**</dt> </dl>                                          | The *params* parameter returns two values: the endpoints of the 1-D maps grid domain. See [glMapGrid](glmapgrid-functions.md).<br/>                                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_MAP1_GRID_SEGMENTS"></span><span id="gl_map1_grid_segments"></span><dl> <dt>**GL\_MAP1\_GRID\_SEGMENTS**</dt> </dl>                                    | The *params* parameter returns one value: the number of partitions in the 1-D maps grid domain. See [glMapGrid](glmapgrid-functions.md).<br/>                                                                                                                                                                                                                                                                                       |
     * | <span id="GL_MAP1_INDEX"></span><span id="gl_map1_index"></span><dl> <dt>**GL\_MAP1\_INDEX**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates color indexes. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_MAP1_NORMAL"></span><span id="gl_map1_normal"></span><dl> <dt>**GL\_MAP1\_NORMAL**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates normals. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_TEXTURE_COORD_1"></span><span id="gl_map1_texture_coord_1"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_1**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 1-D texture coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_TEXTURE_COORD_2"></span><span id="gl_map1_texture_coord_2"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_2**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 2-D texture coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_TEXTURE_COORD_3"></span><span id="gl_map1_texture_coord_3"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_3**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 3-D texture coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_TEXTURE_COORD_4"></span><span id="gl_map1_texture_coord_4"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_4**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 4-D texture coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_VERTEX_3"></span><span id="gl_map1_vertex_3"></span><dl> <dt>**GL\_MAP1\_VERTEX\_3**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 3-D vertex coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP1_VERTEX_4"></span><span id="gl_map1_vertex_4"></span><dl> <dt>**GL\_MAP1\_VERTEX\_4**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 4-D vertex coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP2_COLOR_4"></span><span id="gl_map2_color_4"></span><dl> <dt>**GL\_MAP2\_COLOR\_4**</dt> </dl>                                                      | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates colors. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP2_GRID_DOMAIN"></span><span id="gl_map2_grid_domain"></span><dl> <dt>**GL\_MAP2\_GRID\_DOMAIN**</dt> </dl>                                          | The *params* parameter returns four values: the endpoints of the 2-D maps *i* and *j* grid domains. See [glMapGrid](glmapgrid-functions.md).<br/>                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_MAP2_GRID_SEGMENTS"></span><span id="gl_map2_grid_segments"></span><dl> <dt>**GL\_MAP2\_GRID\_SEGMENTS**</dt> </dl>                                    | The *params* parameter returns two values: the number of partitions in the 2-D maps *i* and *j* grid domains. See [glMapGrid](glmapgrid-functions.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP2_INDEX"></span><span id="gl_map2_index"></span><dl> <dt>**GL\_MAP2\_INDEX**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates color indexes. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_MAP2_NORMAL"></span><span id="gl_map2_normal"></span><dl> <dt>**GL\_MAP2\_NORMAL**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates normals. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_TEXTURE_COORD_1"></span><span id="gl_map2_texture_coord_1"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_1**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 1-D texture coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_TEXTURE_COORD_2"></span><span id="gl_map2_texture_coord_2"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_2**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 2-D texture coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_TEXTURE_COORD_3"></span><span id="gl_map2_texture_coord_3"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_3**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 3-D texture coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_TEXTURE_COORD_4"></span><span id="gl_map2_texture_coord_4"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_4**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 4-D texture coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_VERTEX_3"></span><span id="gl_map2_vertex_3"></span><dl> <dt>**GL\_MAP2\_VERTEX\_3**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 3-D vertex coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP2_VERTEX_4"></span><span id="gl_map2_vertex_4"></span><dl> <dt>**GL\_MAP2\_VERTEX\_4**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 4-D vertex coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP_COLOR"></span><span id="gl_map_color"></span><dl> <dt>**GL\_MAP\_COLOR**</dt> </dl>                                                                | The *params* parameter returns a single Boolean value indicating whether colors and color indexes are to be replaced by table lookup during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                    |
     * | <span id="GL_MAP_STENCIL"></span><span id="gl_map_stencil"></span><dl> <dt>**GL\_MAP\_STENCIL**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether stencil indexes are to be replaced by table lookup during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                             |
     * | <span id="GL_MATRIX_MODE"></span><span id="gl_matrix_mode"></span><dl> <dt>**GL\_MATRIX\_MODE**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating which matrix stack is currently the target of all matrix operations. See [**glMatrixMode**](glmatrixmode.md).<br/>                                                                                                                                                                                                                                         |
     * | <span id="GL_MAX_CLIENT_ATTRIB_STACK_DEPTH"></span><span id="gl_max_client_attrib_stack_depth"></span><dl> <dt>**GL\_MAX\_CLIENT\_ATTRIB\_STACK\_DEPTH**</dt> </dl> | The *params* parameter returns one value indicating the maximum supported depth of the client attribute stack. See [**glPushClientAttrib**](glpushclientattrib.md).<br/>                                                                                                                                                                                                                                                            |
     * | <span id="GL_MAX_ATTRIB_STACK_DEPTH"></span><span id="gl_max_attrib_stack_depth"></span><dl> <dt>**GL\_MAX\_ATTRIB\_STACK\_DEPTH**</dt> </dl>                       | The *params* parameter returns one value: the maximum supported depth of the attribute stack. See [**glPushAttrib**](glpushattrib.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAX_CLIP_PLANES"></span><span id="gl_max_clip_planes"></span><dl> <dt>**GL\_MAX\_CLIP\_PLANES**</dt> </dl>                                             | The *params* parameter returns one value: the maximum number of application-defined clipping planes. See [**glClipPlane**](glclipplane.md).<br/>                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_MAX_EVAL_ORDER"></span><span id="gl_max_eval_order"></span><dl> <dt>**GL\_MAX\_EVAL\_ORDER**</dt> </dl>                                                | The *params* parameter returns one value: the maximum equation order supported by 1-D and 2-D evaluators. See [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                            |
     * | <span id="GL_MAX_LIGHTS"></span><span id="gl_max_lights"></span><dl> <dt>**GL\_MAX\_LIGHTS**</dt> </dl>                                                             | The *params* parameter returns one value: the maximum number of lights. See [glLight](gllight-functions.md).<br/>                                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_MAX_LIST_NESTING"></span><span id="gl_max_list_nesting"></span><dl> <dt>**GL\_MAX\_LIST\_NESTING**</dt> </dl>                                          | The *params* parameter returns one value: the maximum recursion depth allowed during display-list traversal. See [**glCallList**](glcalllist.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_MAX_MODELVIEW_STACK_DEPTH"></span><span id="gl_max_modelview_stack_depth"></span><dl> <dt>**GL\_MAX\_MODELVIEW\_STACK\_DEPTH**</dt> </dl>              | The *params* parameter returns one value: the maximum supported depth of the modelview matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_MAX_NAME_STACK_DEPTH"></span><span id="gl_max_name_stack_depth"></span><dl> <dt>**GL\_MAX\_NAME\_STACK\_DEPTH**</dt> </dl>                             | The *params* parameter returns one value: the maximum supported depth of the selection name stack. See [**glPushName**](glpushname.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAX_PIXEL_MAP_TABLE"></span><span id="gl_max_pixel_map_table"></span><dl> <dt>**GL\_MAX\_PIXEL\_MAP\_TABLE**</dt> </dl>                                | The *params* parameter returns one value: the maximum supported size of a [**glPixelMap**](glpixelmap.md) lookup table.<br/>                                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAX_PROJECTION_STACK_DEPTH"></span><span id="gl_max_projection_stack_depth"></span><dl> <dt>**GL\_MAX\_PROJECTION\_STACK\_DEPTH**</dt> </dl>           | The *params* parameter returns one value: the maximum supported depth of the projection matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_MAX_TEXTURE_SIZE"></span><span id="gl_max_texture_size"></span><dl> <dt>**GL\_MAX\_TEXTURE\_SIZE**</dt> </dl>                                          | The *params* parameter returns one value: the maximum width or height of any texture image (without borders). See [**glTexImage1D**](glteximage1d.md) and [**glTexImage2D**](glteximage2d.md).<br/>                                                                                                                                                                                                                                |
     * | <span id="GL_MAX_TEXTURE_STACK_DEPTH"></span><span id="gl_max_texture_stack_depth"></span><dl> <dt>**GL\_MAX\_TEXTURE\_STACK\_DEPTH**</dt> </dl>                    | The *params* parameter returns one value: the maximum supported depth of the texture matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_MAX_VIEWPORT_DIMS"></span><span id="gl_max_viewport_dims"></span><dl> <dt>**GL\_MAX\_VIEWPORT\_DIMS**</dt> </dl>                                       | The *params* parameter returns two values: the maximum supported width and height of the viewport. See [**glViewport**](glviewport.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MODELVIEW_MATRIX"></span><span id="gl_modelview_matrix"></span><dl> <dt>**GL\_MODELVIEW\_MATRIX**</dt> </dl>                                           | The *params* parameter returns 16 values: the modelview matrix on the top of the modelview matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_MODELVIEW_STACK_DEPTH"></span><span id="gl_modelview_stack_depth"></span><dl> <dt>**GL\_MODELVIEW\_STACK\_DEPTH**</dt> </dl>                           | The *params* parameter returns one value: the number of matrices on the modelview matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                       |
     * | <span id="GL_NAME_STACK_DEPTH"></span><span id="gl_name_stack_depth"></span><dl> <dt>**GL\_NAME\_STACK\_DEPTH**</dt> </dl>                                          | The *params* parameter returns one value: the number of names on the selection name stack. See [**glPushName**](glpushname.md).<br/>                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_NORMAL_ARRAY"></span><span id="gl_normal_array"></span><dl> <dt>**GL\_NORMAL\_ARRAY**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value, indicating whether the normal array is enabled. See [**glNormalPointer**](glnormalpointer.md).<br/>                                                                                                                                                                                                                                                                          |
     * | <span id="GL_NORMAL_ARRAY_STRIDE"></span><span id="gl_normal_array_stride"></span><dl> <dt>**GL\_NORMAL\_ARRAY\_STRIDE**</dt> </dl>                                 | The *params* parameter returns one value, the byte offset between consecutive normals in the normal array. See [**glNormalPointer**](glnormalpointer.md).<br/>                                                                                                                                                                                                                                                                      |
     * | <span id="GL_NORMAL_ARRAY_TYPE"></span><span id="gl_normal_array_type"></span><dl> <dt>**GL\_NORMAL\_ARRAY\_TYPE**</dt> </dl>                                       | The *params* parameter returns one value, the data type of each coordinate in the normal array. See [**glNormalPointer**](glnormalpointer.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_NORMALIZE"></span><span id="gl_normalize"></span><dl> <dt>**GL\_NORMALIZE**</dt> </dl>                                                                 | The *params* parameter returns a single Boolean value indicating whether normals are automatically scaled to unit length after they have been transformed to eye coordinates. See [glNormal](glnormal-functions.md).<br/>                                                                                                                                                                                                           |
     * | <span id="GL_PACK_ALIGNMENT"></span><span id="gl_pack_alignment"></span><dl> <dt>**GL\_PACK\_ALIGNMENT**</dt> </dl>                                                 | The *params* parameter returns one value: the byte alignment used for writing pixel data to memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_PACK_LSB_FIRST"></span><span id="gl_pack_lsb_first"></span><dl> <dt>**GL\_PACK\_LSB\_FIRST**</dt> </dl>                                                | The *params* parameter returns a single Boolean value indicating whether single-bit pixels being written to memory are written first to the least significant bit of each unsigned byte. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                        |
     * | <span id="GL_PACK_ROW_LENGTH"></span><span id="gl_pack_row_length"></span><dl> <dt>**GL\_PACK\_ROW\_LENGTH**</dt> </dl>                                             | The *params* parameter returns one value: the row length used for writing pixel data to memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_PACK_SKIP_PIXELS"></span><span id="gl_pack_skip_pixels"></span><dl> <dt>**GL\_PACK\_SKIP\_PIXELS**</dt> </dl>                                          | The *params* parameter returns one value: the number of pixel locations skipped before the first pixel is written into memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                  |
     * | <span id="GL_PACK_SKIP_ROWS"></span><span id="gl_pack_skip_rows"></span><dl> <dt>**GL\_PACK\_SKIP\_ROWS**</dt> </dl>                                                | The *params* parameter returns one value: the number of rows of pixel locations skipped before the first pixel is written into memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                          |
     * | <span id="GL_PACK_SWAP_BYTES"></span><span id="gl_pack_swap_bytes"></span><dl> <dt>**GL\_PACK\_SWAP\_BYTES**</dt> </dl>                                             | The *params* parameter returns a single Boolean value indicating whether the bytes of 2-byte and 4-byte pixel indexes and components are swapped before being written to memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                |
     * | <span id="GL_PERSPECTIVE_CORRECTION_HINT"></span><span id="gl_perspective_correction_hint"></span><dl> <dt>**GL\_PERSPECTIVE\_CORRECTION\_HINT**</dt> </dl>         | The *params* parameter returns one value: a symbolic constant indicating the mode of the perspective correction hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_PIXEL_MAP_A_TO_A_SIZE"></span><span id="gl_pixel_map_a_to_a_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_A\_TO\_A\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the alpha-to-alpha pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_B_TO_B_SIZE"></span><span id="gl_pixel_map_b_to_b_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_B\_TO\_B\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the blue-to-blue pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_PIXEL_MAP_G_TO_G_SIZE"></span><span id="gl_pixel_map_g_to_g_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_G\_TO\_G\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the green-to-green pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_I_TO_A_SIZE"></span><span id="gl_pixel_map_i_to_a_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_A\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-alpha pixel translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_I_TO_B_SIZE"></span><span id="gl_pixel_map_i_to_b_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_B\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-blue pixel translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                          |
     * | <span id="GL_PIXEL_MAP_I_TO_G_SIZE"></span><span id="gl_pixel_map_i_to_g_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_G\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-green pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_I_TO_I_SIZE"></span><span id="gl_pixel_map_i_to_i_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_I\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-index pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_I_TO_R_SIZE"></span><span id="gl_pixel_map_i_to_r_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_R\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-red pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_PIXEL_MAP_R_TO_R_SIZE"></span><span id="gl_pixel_map_r_to_r_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_R\_TO\_R\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the red-to-red pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_PIXEL_MAP_S_TO_S_SIZE"></span><span id="gl_pixel_map_s_to_s_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_S\_TO\_S\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the stencil-to-stencil pixel translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_POINT_SIZE"></span><span id="gl_point_size"></span><dl> <dt>**GL\_POINT\_SIZE**</dt> </dl>                                                             | The *params* parameter returns one value: the point size as specified by [**glPointSize**](glpointsize.md).<br/>                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_POINT_SIZE_GRANULARITY"></span><span id="gl_point_size_granularity"></span><dl> <dt>**GL\_POINT\_SIZE\_GRANULARITY**</dt> </dl>                        | The *params* parameter returns one value: the size difference between adjacent supported sizes for antialiased points. See [**glPointSize**](glpointsize.md).<br/>                                                                                                                                                                                                                                                                  |
     * | <span id="GL_POINT_SIZE_RANGE"></span><span id="gl_point_size_range"></span><dl> <dt>**GL\_POINT\_SIZE\_RANGE**</dt> </dl>                                          | The *params* parameter returns two values: the smallest and largest supported sizes for antialiased points. See [**glPointSize**](glpointsize.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_POINT_SMOOTH"></span><span id="gl_point_smooth"></span><dl> <dt>**GL\_POINT\_SMOOTH**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether antialiasing of points is enabled. See [**glPointSize**](glpointsize.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_POINT_SMOOTH_HINT"></span><span id="gl_point_smooth_hint"></span><dl> <dt>**GL\_POINT\_SMOOTH\_HINT**</dt> </dl>                                       | The *params* parameter returns one value: a symbolic constant indicating the mode of the point antialiasing hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_POLYGON_MODE"></span><span id="gl_polygon_mode"></span><dl> <dt>**GL\_POLYGON\_MODE**</dt> </dl>                                                       | The *params* parameter returns two values: symbolic constants indicating whether front-facing and back-facing polygons are rasterized as points, lines, or filled polygons. See [**glPolygonMode**](glpolygonmode.md).<br/>                                                                                                                                                                                                         |
     * | <span id="GL_POLYGON_OFFSET_FACTOR"></span><span id="gl_polygon_offset_factor"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_FACTOR**</dt> </dl>                           | The *params* parameter returns one value, the scaling factor used to determine the variable offset that is added to the depth value of each fragment generated when a polygon is rasterized. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                                    |
     * | <span id="GL_POLYGON_OFFSET_UNITS"></span><span id="gl_polygon_offset_units"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_UNITS**</dt> </dl>                              | The *params* parameter returns one value. This value is multiplied by an implementation-specific value and then added to the depth value of each fragment generated when a polygon is rasterized. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                               |
     * | <span id="GL_POLYGON_OFFSET_FILL"></span><span id="gl_polygon_offset_fill"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_FILL**</dt> </dl>                                 | The *params* parameter returns a single Boolean value indicating whether polygon offset is enabled for polygons in fill mode. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                                                                                                   |
     * | <span id="GL_POLYGON_OFFSET_LINE"></span><span id="gl_polygon_offset_line"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_LINE**</dt> </dl>                                 | The *params* parameter returns a single Boolean value indicating whether polygon offset is enabled for polygons in line mode. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                                                                                                   |
     * | <span id="GL_POLYGON_OFFSET_POINT"></span><span id="gl_polygon_offset_point"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_POINT**</dt> </dl>                              | The *params* parameter returns a single Boolean value indicating whether polygon offset is enabled for polygons in point mode. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                                                                                                  |
     * | <span id="GL_POLYGON_SMOOTH"></span><span id="gl_polygon_smooth"></span><dl> <dt>**GL\_POLYGON\_SMOOTH**</dt> </dl>                                                 | The *params* parameter returns a single Boolean value indicating whether antialiasing of polygons is enabled. See [**glPolygonMode**](glpolygonmode.md).<br/>                                                                                                                                                                                                                                                                       |
     * | <span id="GL_POLYGON_SMOOTH_HINT"></span><span id="gl_polygon_smooth_hint"></span><dl> <dt>**GL\_POLYGON\_SMOOTH\_HINT**</dt> </dl>                                 | The *params* parameter returns one value: a symbolic constant indicating the mode of the polygon antialiasing hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                               |
     * | <span id="GL_POLYGON_STIPPLE"></span><span id="gl_polygon_stipple"></span><dl> <dt>**GL\_POLYGON\_STIPPLE**</dt> </dl>                                              | The *params* parameter returns a single Boolean value indicating whether stippling of polygons is enabled. See [**glPolygonStipple**](glpolygonstipple.md).<br/>                                                                                                                                                                                                                                                                    |
     * | <span id="GL_PROJECTION_MATRIX"></span><span id="gl_projection_matrix"></span><dl> <dt>**GL\_PROJECTION\_MATRIX**</dt> </dl>                                        | The *params* parameter returns 16 values: the projection matrix on the top of the projection matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                            |
     * | <span id="GL_PROJECTION_STACK_DEPTH"></span><span id="gl_projection_stack_depth"></span><dl> <dt>**GL\_PROJECTION\_STACK\_DEPTH**</dt> </dl>                        | The *params* parameter returns one value: the number of matrices on the projection matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_READ_BUFFER"></span><span id="gl_read_buffer"></span><dl> <dt>**GL\_READ\_BUFFER**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating which color buffer is selected for reading. See [**glReadPixels**](glreadpixels.md) and [**glAccum**](glaccum.md).<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_RED_BIAS"></span><span id="gl_red_bias"></span><dl> <dt>**GL\_RED\_BIAS**</dt> </dl>                                                                   | The *params* parameter returns one value: the red bias factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_RED_BITS"></span><span id="gl_red_bits"></span><dl> <dt>**GL\_RED\_BITS**</dt> </dl>                                                                   | The *params* parameter returns one value: the number of red bitplanes in each color buffer.<br/>                                                                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_RED_SCALE"></span><span id="gl_red_scale"></span><dl> <dt>**GL\_RED\_SCALE**</dt> </dl>                                                                | The *params* parameter returns one value: the red scale factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_RENDER_MODE"></span><span id="gl_render_mode"></span><dl> <dt>**GL\_RENDER\_MODE**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating whether OpenGL is in render, select, or feedback mode. See [**glRenderMode**](glrendermode.md).<br/>                                                                                                                                                                                                                                                       |
     * | <span id="GL_RGBA_MODE"></span><span id="gl_rgba_mode"></span><dl> <dt>**GL\_RGBA\_MODE**</dt> </dl>                                                                | The *params* parameter returns a single Boolean value indicating whether OpenGL is in RGBA mode (TRUE) or color-index mode (FALSE). See [glColor](glcolor-functions.md).<br/>                                                                                                                                                                                                                                                       |
     * | <span id="GL_SCISSOR_BOX"></span><span id="gl_scissor_box"></span><dl> <dt>**GL\_SCISSOR\_BOX**</dt> </dl>                                                          | The *params* parameter returns four values: the *x* and *y* window coordinates of the scissor box, followed by its width and height. See [**glScissor**](glscissor.md).<br/>                                                                                                                                                                                                                                                        |
     * | <span id="GL_SCISSOR_TEST"></span><span id="gl_scissor_test"></span><dl> <dt>**GL\_SCISSOR\_TEST**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether scissoring is enabled. See [**glScissor**](glscissor.md).<br/>                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_SHADE_MODEL"></span><span id="gl_shade_model"></span><dl> <dt>**GL\_SHADE\_MODEL**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating whether the shading mode is flat or smooth. See [**glShadeModel**](glshademodel.md).<br/>                                                                                                                                                                                                                                                                  |
     * | <span id="GL_STENCIL_BITS"></span><span id="gl_stencil_bits"></span><dl> <dt>**GL\_STENCIL\_BITS**</dt> </dl>                                                       | The *params* parameter returns one value: the number of bitplanes in the stencil buffer.<br/>                                                                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_STENCIL_CLEAR_VALUE"></span><span id="gl_stencil_clear_value"></span><dl> <dt>**GL\_STENCIL\_CLEAR\_VALUE**</dt> </dl>                                 | The *params* parameter returns one value: the index to which the stencil bitplanes are cleared. See [**glClearStencil**](glclearstencil.md).<br/>                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_STENCIL_FAIL"></span><span id="gl_stencil_fail"></span><dl> <dt>**GL\_STENCIL\_FAIL**</dt> </dl>                                                       | The *params* parameter returns one value: a symbolic constant indicating what action is taken when the stencil test fails. See [**glStencilOp**](glstencilop.md).<br/>                                                                                                                                                                                                                                                              |
     * | <span id="GL_STENCIL_FUNC"></span><span id="gl_stencil_func"></span><dl> <dt>**GL\_STENCIL\_FUNC**</dt> </dl>                                                       | The *params* parameter returns one value: a symbolic constant indicating what function is used to compare the stencil reference value with the stencil buffer value. See [**glStencilFunc**](glstencilfunc.md).<br/>                                                                                                                                                                                                                |
     * | <span id="GL_STENCIL_PASS_DEPTH_FAIL"></span><span id="gl_stencil_pass_depth_fail"></span><dl> <dt>**GL\_STENCIL\_PASS\_DEPTH\_FAIL**</dt> </dl>                    | The *params* parameter returns one value: a symbolic constant indicating what action is taken when the stencil test passes, but the depth test fails. See [**glStencilOp**](glstencilop.md).<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_STENCIL_PASS_DEPTH_PASS"></span><span id="gl_stencil_pass_depth_pass"></span><dl> <dt>**GL\_STENCIL\_PASS\_DEPTH\_PASS**</dt> </dl>                    | The *params* parameter returns one value: a symbolic constant indicating what action is taken when the stencil test passes and the depth test passes. See [**glStencilOp**](glstencilop.md).<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_STENCIL_REF"></span><span id="gl_stencil_ref"></span><dl> <dt>**GL\_STENCIL\_REF**</dt> </dl>                                                          | The *params* parameter returns one value: the reference value that is compared with the contents of the stencil buffer. See [**glStencilFunc**](glstencilfunc.md).<br/>                                                                                                                                                                                                                                                             |
     * | <span id="GL_STENCIL_TEST"></span><span id="gl_stencil_test"></span><dl> <dt>**GL\_STENCIL\_TEST**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether stencil testing of fragments is enabled. See [**glStencilFunc**](glstencilfunc.md) and [**glStencilOp**](glstencilop.md).<br/>                                                                                                                                                                                                                            |
     * | <span id="GL_STENCIL_VALUE_MASK"></span><span id="gl_stencil_value_mask"></span><dl> <dt>**GL\_STENCIL\_VALUE\_MASK**</dt> </dl>                                    | The *params* parameter returns one value: the mask that is used to mask both the stencil reference value and the stencil buffer value before they are compared. See [**glStencilFunc**](glstencilfunc.md).<br/>                                                                                                                                                                                                                     |
     * | <span id="GL_STENCIL_WRITEMASK"></span><span id="gl_stencil_writemask"></span><dl> <dt>**GL\_STENCIL\_WRITEMASK**</dt> </dl>                                        | The *params* parameter returns one value: the mask that controls writing of the stencil bitplanes. See [**glStencilMask**](glstencilmask.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_STEREO"></span><span id="gl_stereo"></span><dl> <dt>**GL\_STEREO**</dt> </dl>                                                                          | The *params* parameter returns a single Boolean value indicating whether stereo buffers (left and right) are supported.<br/>                                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_SUBPIXEL_BITS"></span><span id="gl_subpixel_bits"></span><dl> <dt>**GL\_SUBPIXEL\_BITS**</dt> </dl>                                                    | The *params* parameter returns one value: an estimate of the number of bits of subpixel resolution that are used to position rasterized geometry in window coordinates.<br/>                                                                                                                                                                                                                                                         |
     * | <span id="GL_TEXTURE_1D"></span><span id="gl_texture_1d"></span><dl> <dt>**GL\_TEXTURE\_1D**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether 1-D texture mapping is enabled. See [**glTexImage1D**](glteximage1d.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_TEXTURE_2D"></span><span id="gl_texture_2d"></span><dl> <dt>**GL\_TEXTURE\_2D**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether 2-D texture mapping is enabled. See [**glTexImage2D**](glteximage2d.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_TEXTURE_COORD_ARRAY"></span><span id="gl_texture_coord_array"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY**</dt> </dl>                                 | The *params* parameter returns a single Boolean value indicating whether the texture coordinate array is enabled. See [**glTexCoordPointer**](gltexcoordpointer.md).<br/>                                                                                                                                                                                                                                                           |
     * | <span id="GL_TEXTURE_COORD_ARRAY_SIZE"></span><span id="gl_texture_coord_array_size"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY\_SIZE**</dt> </dl>                 | The *params* parameter returns one value, the number of coordinates per element in the texture coordinate array. See [**glTexCoordPointer**](gltexcoordpointer.md).<br/>                                                                                                                                                                                                                                                            |
     * | <span id="GL_TEXTURE_COORD_ARRAY_STRIDE"></span><span id="gl_texture_coord_array_stride"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY\_STRIDE**</dt> </dl>           | The *params* parameter returns one value, the byte offset between consecutive elements in the texture coordinate array. See [**glTexCoordPointer**](gltexcoordpointer.md).<br/>                                                                                                                                                                                                                                                     |
     * | <span id="GL_TEXTURE_COORD_ARRAY_TYPE"></span><span id="gl_texture_coord_array_type"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY\_TYPE**</dt> </dl>                 | The *params* parameter params returns one value, the data type of the coordinates in the texture coordinate array. See [**glTexCoordPointer**](gltexcoordpointer.md).<br/>                                                                                                                                                                                                                                                          |
     * | <span id="GL_TEXTURE_ENV_COLOR"></span><span id="gl_texture_env_color"></span><dl> <dt>**GL\_TEXTURE\_ENV\_COLOR**</dt> </dl>                                       | The *params* parameter returns four values: the red, green, blue, and alpha values of the texture environment color. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and 1.0 returns the most negative representable integer value. See [glTexEnv](gltexenv-functions.md).<br/>                              |
     * | <span id="GL_TEXTURE_ENV_MODE"></span><span id="gl_texture_env_mode"></span><dl> <dt>**GL\_TEXTURE\_ENV\_MODE**</dt> </dl>                                          | The *params* parameter returns one value: a symbolic constant indicating which texture environment function is currently selected. See [glTexEnv](gltexenv-functions.md).<br/>                                                                                                                                                                                                                                                      |
     * | <span id="GL_TEXTURE_GEN_Q"></span><span id="gl_texture_gen_q"></span><dl> <dt>**GL\_TEXTURE\_GEN\_Q**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether automatic generation of the Q texture coordinate is enabled. See [**glTexGen**](gltexgen-functions.md).<br/>                                                                                                                                                                                                                                               |
     * | <span id="GL_TEXTURE_GEN_R"></span><span id="gl_texture_gen_r"></span><dl> <dt>**GL\_TEXTURE\_GEN\_R**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether automatic generation of the R texture coordinate is enabled. See [**glTexGen**](gltexgen-functions.md).<br/>                                                                                                                                                                                                                                               |
     * | <span id="GL_TEXTURE_GEN_S"></span><span id="gl_texture_gen_s"></span><dl> <dt>**GL\_TEXTURE\_GEN\_S**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether automatic generation of the S texture coordinate is enabled. See [**glTexGen**](gltexgen-functions.md).<br/>                                                                                                                                                                                                                                               |
     * | <span id="GL_TEXTURE_GEN_T"></span><span id="gl_texture_gen_t"></span><dl> <dt>**GL\_TEXTURE\_GEN\_T**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether automatic generation of the T texture coordinate is enabled. See [**glTexGen**](gltexgen-functions.md).<br/>                                                                                                                                                                                                                                               |
     * | <span id="GL_TEXTURE_MATRIX"></span><span id="gl_texture_matrix"></span><dl> <dt>**GL\_TEXTURE\_MATRIX**</dt> </dl>                                                 | The *params* parameter returns 16 values: the texture matrix on the top of the texture matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_TEXTURE_STACK_DEPTH"></span><span id="gl_texture_stack_depth"></span><dl> <dt>**GL\_TEXTURE\_STACK\_DEPTH**</dt> </dl>                                 | The *params* parameter returns one value: the number of matrices on the texture matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_UNPACK_ALIGNMENT"></span><span id="gl_unpack_alignment"></span><dl> <dt>**GL\_UNPACK\_ALIGNMENT**</dt> </dl>                                           | The *params* parameter returns one value: the byte alignment used for reading pixel data from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                                           |
     * | <span id="GL_UNPACK_LSB_FIRST"></span><span id="gl_unpack_lsb_first"></span><dl> <dt>**GL\_UNPACK\_LSB\_FIRST**</dt> </dl>                                          | The *params* parameter returns a single Boolean value indicating whether single-bit pixels being read from memory are read first from the least significant bit of each unsigned byte. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                          |
     * | <span id="GL_UNPACK_ROW_LENGTH"></span><span id="gl_unpack_row_length"></span><dl> <dt>**GL\_UNPACK\_ROW\_LENGTH**</dt> </dl>                                       | The *params* parameter returns one value: the row length used for reading pixel data from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                                               |
     * | <span id="GL_UNPACK_SKIP_PIXELS"></span><span id="gl_unpack_skip_pixels"></span><dl> <dt>**GL\_UNPACK\_SKIP\_PIXELS**</dt> </dl>                                    | The *params* parameter returns one value: the number of pixel locations skipped before the first pixel is read from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                     |
     * | <span id="GL_UNPACK_SKIP_ROWS"></span><span id="gl_unpack_skip_rows"></span><dl> <dt>**GL\_UNPACK\_SKIP\_ROWS**</dt> </dl>                                          | The *params* parameter returns one value: the number of rows of pixel locations skipped before the first pixel is read from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                             |
     * | <span id="GL_UNPACK_SWAP_BYTES"></span><span id="gl_unpack_swap_bytes"></span><dl> <dt>**GL\_UNPACK\_SWAP\_BYTES**</dt> </dl>                                       | The *params* parameter returns a single Boolean value indicating whether the bytes of 2-byte and 4-byte pixel indexes and components are swapped after being read from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                  |
     * | <span id="GL_VERTEX_ARRAY"></span><span id="gl_vertex_array"></span><dl> <dt>**GL\_VERTEX\_ARRAY**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether the vertex array is enabled. See [**glVertexPointer**](glvertexpointer.md).<br/>                                                                                                                                                                                                                                                                           |
     * | <span id="GL_VERTEX_ARRAY_SIZE"></span><span id="gl_vertex_array_size"></span><dl> <dt>**GL\_VERTEX\_ARRAY\_SIZE**</dt> </dl>                                       | The *params* parameter returns one value, the number of coordinates per vertex in the vertex array. See [**glVertexPointer**](glvertexpointer.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_VERTEX_ARRAY_STRIDE"></span><span id="gl_vertex_array_stride"></span><dl> <dt>**GL\_VERTEX\_ARRAY\_STRIDE**</dt> </dl>                                 | The *params* parameter returns one value, the byte offset between consecutive vertexes in the vertex array. See [**glVertexPointer**](glvertexpointer.md).<br/>                                                                                                                                                                                                                                                                     |
     * | <span id="GL_VERTEX_ARRAY_TYPE"></span><span id="gl_vertex_array_type"></span><dl> <dt>**GL\_VERTEX\_ARRAY\_TYPE**</dt> </dl>                                       | The *params* parameter returns one value, the data type of each coordinate in the vertex array. See [**glVertexPointer**](glvertexpointer.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_VIEWPORT"></span><span id="gl_viewport"></span><dl> <dt>**GL\_VIEWPORT**</dt> </dl>                                                                    | The *params* parameter returns four values: the *x* and *y* window coordinates of the viewport, followed by its width and height. See [**glViewport**](glviewport.md).<br/>                                                                                                                                                                                                                                                         |
     * | <span id="GL_ZOOM_X"></span><span id="gl_zoom_x"></span><dl> <dt>**GL\_ZOOM\_X**</dt> </dl>                                                                         | The *params* parameter returns one value: the *x* pixel zoom factor. See [**glPixelZoom**](glpixelzoom.md).<br/>                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_ZOOM_Y"></span><span id="gl_zoom_y"></span><dl> <dt>**GL\_ZOOM\_Y**</dt> </dl>                                                                         | The *params* parameter returns one value: the *y* pixel zoom factor. See [**glPixelZoom**](glpixelzoom.md).<br/>                                                                                                                                                                                                                                                                                                                    |
     * @param {Pointer<Single>} params Returns the value or values of the specified parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetfloatv
     */
    static glGetFloatv(pname, params) {
        DllCall("OPENGL32.dll\glGetFloatv", "uint", pname, "ptr", params)
    }

    /**
     * The glGetIntegerv function returns the value or values of a selected parameter.
     * @remarks
     * This function returns values for simple state variables in OpenGL. The *pname* parameter is a symbolic constant indicating the state variable to be returned, and *params* is a pointer to an array of the indicated type in which to place the returned data.
     * 
     * Type conversion is performed if *params* has a different type from the state variable value being requested. If you call [**glGetBooleanv**](glgetbooleanv.md), a floating-point or integer value is converted to GL\_FALSE if and only if it is zero. Otherwise, it is converted to GL\_TRUE.
     * 
     * If you call **glGetIntegerv**, Boolean values are returned as GL\_TRUE or GL\_FALSE, and most floating-point values are rounded to the nearest integer value. Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most positive representable integer value and 1.0 to the most negative representable integer value.
     * 
     * If you call [**glGetFloatv**](glgetfloatv.md) or [**glGetDoublev**](glgetdoublev.md), Boolean values are returned as GL\_TRUE or GL\_FALSE, and integer values are converted to floating-point values.
     * 
     * You can query many of the Boolean parameters more easily with [**glIsEnabled**](glisenabled.md).
     * @param {Integer} pname The parameter value to be returned. The following symbolic constants are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                    |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_ACCUM_ALPHA_BITS"></span><span id="gl_accum_alpha_bits"></span><dl> <dt>**GL\_ACCUM\_ALPHA\_BITS**</dt> </dl>                                          | The *params* parameter returns one value: the number of alpha bitplanes in the accumulation buffer.<br/>                                                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_ACCUM_BLUE_BITS"></span><span id="gl_accum_blue_bits"></span><dl> <dt>**GL\_ACCUM\_BLUE\_BITS**</dt> </dl>                                             | The *params* parameter returns one value: the number of blue bitplanes in the accumulation buffer.<br/>                                                                                                                                                                                                                                                                                                                              |
     * | <span id="GL_ACCUM_CLEAR_VALUE"></span><span id="gl_accum_clear_value"></span><dl> <dt>**GL\_ACCUM\_CLEAR\_VALUE**</dt> </dl>                                       | The *params* parameter returns four values: the red, green, blue, and alpha values used to clear the accumulation buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glClearAccum**](glclearaccum.md).<br/>                      |
     * | <span id="GL_ACCUM_GREEN_BITS"></span><span id="gl_accum_green_bits"></span><dl> <dt>**GL\_ACCUM\_GREEN\_BITS**</dt> </dl>                                          | The *params* parameter returns one value: the number of green bitplanes in the accumulation buffer.<br/>                                                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_ACCUM_RED_BITS"></span><span id="gl_accum_red_bits"></span><dl> <dt>**GL\_ACCUM\_RED\_BITS**</dt> </dl>                                                | The *params* parameter returns one value: the number of red bitplanes in the accumulation buffer.<br/>                                                                                                                                                                                                                                                                                                                               |
     * | <span id="GL_ALPHA_BIAS"></span><span id="gl_alpha_bias"></span><dl> <dt>**GL\_ALPHA\_BIAS**</dt> </dl>                                                             | The *params* parameter returns one value: the alpha bias factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_ALPHA_BITS"></span><span id="gl_alpha_bits"></span><dl> <dt>**GL\_ALPHA\_BITS**</dt> </dl>                                                             | The *params* parameter returns one value: the number of alpha bitplanes in each color buffer.<br/>                                                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_ALPHA_SCALE"></span><span id="gl_alpha_scale"></span><dl> <dt>**GL\_ALPHA\_SCALE**</dt> </dl>                                                          | The *params* parameter returns one value: the alpha scale factor used during pixel transfers. See [glPixelTransfer](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                       |
     * | <span id="GL_ALPHA_TEST"></span><span id="gl_alpha_test"></span><dl> <dt>**GL\_ALPHA\_TEST**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether alpha testing of fragments is enabled. See [**glAlphaFunc**](glalphafunc.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_ALPHA_TEST_FUNC"></span><span id="gl_alpha_test_func"></span><dl> <dt>**GL\_ALPHA\_TEST\_FUNC**</dt> </dl>                                             | The *params* parameter returns one value: the symbolic name of the alpha test function. See [**glAlphaFunc**](glalphafunc.md).<br/>                                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_ALPHA_TEST_REF"></span><span id="gl_alpha_test_ref"></span><dl> <dt>**GL\_ALPHA\_TEST\_REF**</dt> </dl>                                                | The *params* parameter returns one value: the reference value for the alpha test. See [**glAlphaFunc**](glalphafunc.md). An integer value, if requested, is linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value.<br/>                                                               |
     * | <span id="GL_ATTRIB_STACK_DEPTH"></span><span id="gl_attrib_stack_depth"></span><dl> <dt>**GL\_ATTRIB\_STACK\_DEPTH**</dt> </dl>                                    | The *params* parameter returns one value: the depth of the attribute stack. If the stack is empty, zero is returned. See [**glPushAttrib**](glpushattrib.md).<br/>                                                                                                                                                                                                                                                                  |
     * | <span id="GL_AUTO_NORMAL"></span><span id="gl_auto_normal"></span><dl> <dt>**GL\_AUTO\_NORMAL**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether 2-D map evaluation automatically generates surface normals. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                              |
     * | <span id="GL_AUX_BUFFERS"></span><span id="gl_aux_buffers"></span><dl> <dt>**GL\_AUX\_BUFFERS**</dt> </dl>                                                          | The *params* parameter returns one value: the number of auxiliary color buffers.<br/>                                                                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_BLEND"></span><span id="gl_blend"></span><dl> <dt>**GL\_BLEND**</dt> </dl>                                                                             | The *params* parameter returns a single Boolean value indicating whether blending is enabled. See [**glBlendFunc**](glblendfunc.md).<br/>                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_BLEND_DST"></span><span id="gl_blend_dst"></span><dl> <dt>**GL\_BLEND\_DST**</dt> </dl>                                                                | The *params* parameter returns one value: the symbolic constant identifying the destination blend function. See [**glBlendFunc**](glblendfunc.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_BLEND_SRC"></span><span id="gl_blend_src"></span><dl> <dt>**GL\_BLEND\_SRC**</dt> </dl>                                                                | The *params* parameter returns one value: the symbolic constant identifying the source blend function. See [**glBlendFunc**](glblendfunc.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_BLUE_BIAS"></span><span id="gl_blue_bias"></span><dl> <dt>**GL\_BLUE\_BIAS**</dt> </dl>                                                                | The *params* parameter returns one value: the blue bias factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_BLUE_BITS"></span><span id="gl_blue_bits"></span><dl> <dt>**GL\_BLUE\_BITS**</dt> </dl>                                                                | The *params* parameter returns one value: the number of blue bitplanes in each color buffer.<br/>                                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_BLUE_SCALE"></span><span id="gl_blue_scale"></span><dl> <dt>**GL\_BLUE\_SCALE**</dt> </dl>                                                             | The *params* parameter returns one value: the blue scale factor used during pixel transfers. See [glPixelTransfer](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_CLIENT_ATTRIB_STACK_DEPTH"></span><span id="gl_client_attrib_stack_depth"></span><dl> <dt>**GL\_CLIENT\_ATTRIB\_STACK\_DEPTH**</dt> </dl>              | The *params* parameter returns one value indicating the depth of the attribute stack. The initial value is zero. See [**glPushClientAttrib**](glpushclientattrib.md).<br/>                                                                                                                                                                                                                                                          |
     * | <span id="GL_CLIP_PLANEi"></span><span id="gl_clip_planei"></span><span id="GL_CLIP_PLANEI"></span><dl> <dt>**GL\_CLIP\_PLANE*i***</dt> </dl>                       | The *params* parameter returns a single Boolean value indicating whether the specified clipping plane is enabled. See [**glClipPlane**](glclipplane.md).<br/>                                                                                                                                                                                                                                                                       |
     * | <span id="GL_COLOR_ARRAY"></span><span id="gl_color_array"></span><dl> <dt>**GL\_COLOR\_ARRAY**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether the specified color array is defined. See [**glColorPointer**](glcolorpointer.md).<br/>                                                                                                                                                                                                                                                                    |
     * | <span id="GL_COLOR_ARRAY_SIZE"></span><span id="gl_color_array_size"></span><dl> <dt>**GL\_COLOR\_ARRAY\_SIZE**</dt> </dl>                                          | The *params* parameter returns one value, the number of components per color in the color array. See [**glColorPointer**](glcolorpointer.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_COLOR_ARRAY_STRIDE"></span><span id="gl_color_array_stride"></span><dl> <dt>**GL\_COLOR\_ARRAY\_STRIDE**</dt> </dl>                                    | The *params* parameter returns one value, the byte offset between consecutive colors in the color array. See [**glColorPointer**](glcolorpointer.md).<br/>                                                                                                                                                                                                                                                                          |
     * | <span id="GL_COLOR_ARRAY_TYPE"></span><span id="gl_color_array_type"></span><dl> <dt>**GL\_COLOR\_ARRAY\_TYPE**</dt> </dl>                                          | The *params* parameter returns one value, the data type of each component in the color array. See [**glColorPointer**](glcolorpointer.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_COLOR_CLEAR_VALUE"></span><span id="gl_color_clear_value"></span><dl> <dt>**GL\_COLOR\_CLEAR\_VALUE**</dt> </dl>                                       | The *params* parameter returns four values: the red, green, blue, and alpha values used to clear the color buffers. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glClearColor**](glclearcolor.md).<br/>                            |
     * | <span id="GL_COLOR_LOGIC_OP"></span><span id="gl_color_logic_op"></span><dl> <dt>**GL\_COLOR\_LOGIC\_OP**</dt> </dl>                                                | The *params* parameter returns a single Boolean value indicating whether a fragment's RGBA color values are merged into the framebuffer using a logical operation. See [**glLogicOp**](gllogicop.md).<br/>                                                                                                                                                                                                                          |
     * | <span id="GL_COLOR_MATERIAL"></span><span id="gl_color_material"></span><dl> <dt>**GL\_COLOR\_MATERIAL**</dt> </dl>                                                 | The *params* parameter returns a single Boolean value indicating whether one or more material parameters are tracking the current color. See [**glColorMaterial**](glcolormaterial.md).<br/>                                                                                                                                                                                                                                        |
     * | <span id="GL_COLOR_MATERIAL_FACE"></span><span id="gl_color_material_face"></span><dl> <dt>**GL\_COLOR\_MATERIAL\_FACE**</dt> </dl>                                 | The *params* parameter returns one value: a symbolic constant indicating which materials have a parameter that is tracking the current color. See [**glColorMaterial**](glcolormaterial.md).<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_COLOR_MATERIAL_PARAMETER"></span><span id="gl_color_material_parameter"></span><dl> <dt>**GL\_COLOR\_MATERIAL\_PARAMETER**</dt> </dl>                  | The *params* parameter returns one value: a symbolic constant indicating which material parameters are tracking the current color. See [**glColorMaterial**](glcolormaterial.md).<br/>                                                                                                                                                                                                                                              |
     * | <span id="GL_COLOR_WRITEMASK"></span><span id="gl_color_writemask"></span><dl> <dt>**GL\_COLOR\_WRITEMASK**</dt> </dl>                                              | The *params* parameter returns four Boolean values: the red, green, blue, and alpha write enables for the color buffers. See [**glColorMask**](glcolormask.md).<br/>                                                                                                                                                                                                                                                                |
     * | <span id="GL_CULL_FACE"></span><span id="gl_cull_face"></span><dl> <dt>**GL\_CULL\_FACE**</dt> </dl>                                                                | The *params* parameter returns a single Boolean value indicating whether polygon culling is enabled. See [**glCullFace**](glcullface.md).<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_CULL_FACE_MODE"></span><span id="gl_cull_face_mode"></span><dl> <dt>**GL\_CULL\_FACE\_MODE**</dt> </dl>                                                | The *params* parameter returns one value: a symbolic constant indicating which polygon faces are to be culled. See [**glCullFace**](glcullface.md).<br/>                                                                                                                                                                                                                                                                            |
     * | <span id="GL_CURRENT_COLOR"></span><span id="gl_current_color"></span><dl> <dt>**GL\_CURRENT\_COLOR**</dt> </dl>                                                    | The *params* parameter returns four values: the red, green, blue, and alpha values of the current color. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glColor**](glcolor-functions.md).<br/>                                       |
     * | <span id="GL_CURRENT_INDEX"></span><span id="gl_current_index"></span><dl> <dt>**GL\_CURRENT\_INDEX**</dt> </dl>                                                    | The *params* parameter returns one value: the current color index. See [**glIndex**](glindex-functions.md).<br/>                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_CURRENT_NORMAL"></span><span id="gl_current_normal"></span><dl> <dt>**GL\_CURRENT\_NORMAL**</dt> </dl>                                                 | The *params* parameter returns three values: the *x*, *y*, and *z* values of the current normal. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glNormal**](glnormal-functions.md).<br/>                                             |
     * | <span id="GL_CURRENT_RASTER_COLOR"></span><span id="gl_current_raster_color"></span><dl> <dt>**GL\_CURRENT\_RASTER\_COLOR**</dt> </dl>                              | The *params* parameter returns four values: the red, green, blue, and alpha values of the current raster position. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glRasterPos**](glrasterpos-functions.md).<br/>                     |
     * | <span id="GL_CURRENT_RASTER_DISTANCE"></span><span id="gl_current_raster_distance"></span><dl> <dt>**GL\_CURRENT\_RASTER\_DISTANCE**</dt> </dl>                     | The *params* parameter returns one value: the distance from the eye to the current raster position. See [**glRasterPos**](glrasterpos-functions.md).<br/>                                                                                                                                                                                                                                                                           |
     * | <span id="GL_CURRENT_RASTER_INDEX"></span><span id="gl_current_raster_index"></span><dl> <dt>**GL\_CURRENT\_RASTER\_INDEX**</dt> </dl>                              | The *params* parameter returns one value: the color index of the current raster position. See [**glRasterPos**](glrasterpos-functions.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_CURRENT_RASTER_POSITION"></span><span id="gl_current_raster_position"></span><dl> <dt>**GL\_CURRENT\_RASTER\_POSITION**</dt> </dl>                     | The *params* parameter returns four values: the *x*, *y*, *z*, and *w* components of the current raster position. The *x*, *y*, and *z* components are in window coordinates, and *w* is in clip coordinates. See [glRasterPos](glrasterpos-functions.md).<br/>                                                                                                                                                                     |
     * | <span id="GL_CURRENT_RASTER_POSITION_VALID"></span><span id="gl_current_raster_position_valid"></span><dl> <dt>**GL\_CURRENT\_RASTER\_POSITION\_VALID**</dt> </dl>  | The *params* parameter returns a single Boolean value indicating whether the current raster position is valid. See [**glRasterPos**](glrasterpos-functions.md).<br/>                                                                                                                                                                                                                                                                |
     * | <span id="GL_CURRENT_RASTER_TEXTURE_COORDS"></span><span id="gl_current_raster_texture_coords"></span><dl> <dt>**GL\_CURRENT\_RASTER\_TEXTURE\_COORDS**</dt> </dl>  | The *params* parameter returns four values: the *s*, *t*, *r*, and *q* current raster texture coordinates. See [**glRasterPos**](glrasterpos-functions.md) and [**glTexCoord**](gltexcoord-functions.md).<br/>                                                                                                                                                                                                                     |
     * | <span id="GL_CURRENT_TEXTURE_COORDS"></span><span id="gl_current_texture_coords"></span><dl> <dt>**GL\_CURRENT\_TEXTURE\_COORDS**</dt> </dl>                        | The *params* parameter returns four values: the *s*, *t*, *r*, and *q* current texture coordinates. See [**glTexCoord**](gltexcoord-functions.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_DEPTH_BIAS"></span><span id="gl_depth_bias"></span><dl> <dt>**GL\_DEPTH\_BIAS**</dt> </dl>                                                             | The *params* parameter returns one value: the depth bias factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_DEPTH_BITS"></span><span id="gl_depth_bits"></span><dl> <dt>**GL\_DEPTH\_BITS**</dt> </dl>                                                             | The *params* parameter returns one value: the number of bitplanes in the depth buffer.<br/>                                                                                                                                                                                                                                                                                                                                          |
     * | <span id="GL_DEPTH_CLEAR_VALUE"></span><span id="gl_depth_clear_value"></span><dl> <dt>**GL\_DEPTH\_CLEAR\_VALUE**</dt> </dl>                                       | The *params* parameter returns one value: the value that is used to clear the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glClearDepth**](glcleardepth.md).<br/>                                                    |
     * | <span id="GL_DEPTH_FUNC"></span><span id="gl_depth_func"></span><dl> <dt>**GL\_DEPTH\_FUNC**</dt> </dl>                                                             | The *params* parameter returns one value: the symbolic constant that indicates the depth comparison function. See [**glDepthFunc**](gldepthfunc.md).<br/>                                                                                                                                                                                                                                                                           |
     * | <span id="GL_DEPTH_RANGE"></span><span id="gl_depth_range"></span><dl> <dt>**GL\_DEPTH\_RANGE**</dt> </dl>                                                          | The *params* parameter returns two values: the near and far mapping limits for the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glDepthRange**](gldepthrange.md).<br/>                                               |
     * | <span id="GL_DEPTH_SCALE"></span><span id="gl_depth_scale"></span><dl> <dt>**GL\_DEPTH\_SCALE**</dt> </dl>                                                          | The *params* parameter returns one value: the depth scale factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_DEPTH_TEST"></span><span id="gl_depth_test"></span><dl> <dt>**GL\_DEPTH\_TEST**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether depth testing of fragments is enabled. See [**glDepthFunc**](gldepthfunc.md) and [**glDepthRange**](gldepthrange.md).<br/>                                                                                                                                                                                                                                |
     * | <span id="GL_DEPTH_WRITEMASK"></span><span id="gl_depth_writemask"></span><dl> <dt>**GL\_DEPTH\_WRITEMASK**</dt> </dl>                                              | The *params* parameter returns a single Boolean value indicating if the depth buffer is enabled for writing. See [**glDepthMask**](gldepthmask.md).<br/>                                                                                                                                                                                                                                                                            |
     * | <span id="GL_DITHER"></span><span id="gl_dither"></span><dl> <dt>**GL\_DITHER**</dt> </dl>                                                                          | The *params* parameter returns a single Boolean value indicating whether dithering of fragment colors and indexes is enabled.<br/>                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_DOUBLEBUFFER"></span><span id="gl_doublebuffer"></span><dl> <dt>**GL\_DOUBLEBUFFER**</dt> </dl>                                                        | The *params* parameter returns a single Boolean value indicating whether double buffering is supported.<br/>                                                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_DRAW_BUFFER"></span><span id="gl_draw_buffer"></span><dl> <dt>**GL\_DRAW\_BUFFER**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating which buffers are being drawn to. See [**glDrawBuffer**](gldrawbuffer.md).<br/>                                                                                                                                                                                                                                                                            |
     * | <span id="GL_EDGE_FLAG"></span><span id="gl_edge_flag"></span><dl> <dt>**GL\_EDGE\_FLAG**</dt> </dl>                                                                | The *params* parameter returns a single Boolean value indicating whether the current edge flag is true or false. See [glEdgeFlag](gledgeflag-functions.md).<br/>                                                                                                                                                                                                                                                                    |
     * | <span id="GL_EDGE_FLAG_ARRAY"></span><span id="gl_edge_flag_array"></span><dl> <dt>**GL\_EDGE\_FLAG\_ARRAY**</dt> </dl>                                             | The *params* parameter returns a single Boolean value indicating whether the edge flag array is enabled. See [**glEdgeFlagPointer**](gledgeflagpointer.md).<br/>                                                                                                                                                                                                                                                                    |
     * | <span id="GL_EDGE_FLAG_ARRAY_STRIDE"></span><span id="gl_edge_flag_array_stride"></span><dl> <dt>**GL\_EDGE\_FLAG\_ARRAY\_STRIDE**</dt> </dl>                       | The *params* parameter returns one value, the byte offset between consecutive edge flags in the edge flag array. See [**glEdgeFlagPointer**](gledgeflagpointer.md).<br/>                                                                                                                                                                                                                                                            |
     * | <span id="GL_FOG"></span><span id="gl_fog"></span><dl> <dt>**GL\_FOG**</dt> </dl>                                                                                   | The *params* parameter returns a single Boolean value indicating whether fogging is enabled. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_FOG_COLOR"></span><span id="gl_fog_color"></span><dl> <dt>**GL\_FOG\_COLOR**</dt> </dl>                                                                | The *params* parameter returns four values: the red, green, blue, and alpha components of the fog color. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glFog**](glfog.md).<br/>                                                     |
     * | <span id="GL_FOG_DENSITY"></span><span id="gl_fog_density"></span><dl> <dt>**GL\_FOG\_DENSITY**</dt> </dl>                                                          | The *params* parameter returns one value: the fog density parameter. See [glFog](glfog.md).<br/>                                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_FOG_END"></span><span id="gl_fog_end"></span><dl> <dt>**GL\_FOG\_END**</dt> </dl>                                                                      | The *params* parameter returns one value: the end factor for the linear fog equation. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                                               |
     * | <span id="GL_FOG_HINT"></span><span id="gl_fog_hint"></span><dl> <dt>**GL\_FOG\_HINT**</dt> </dl>                                                                   | The *params* parameter returns one value: a symbolic constant indicating the mode of the fog hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_FOG_INDEX"></span><span id="gl_fog_index"></span><dl> <dt>**GL\_FOG\_INDEX**</dt> </dl>                                                                | The *params* parameter returns one value: the fog color index. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_FOG_MODE"></span><span id="gl_fog_mode"></span><dl> <dt>**GL\_FOG\_MODE**</dt> </dl>                                                                   | The *params* parameter returns one value: a symbolic constant indicating which fog equation is selected. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_FOG_START"></span><span id="gl_fog_start"></span><dl> <dt>**GL\_FOG\_START**</dt> </dl>                                                                | The *params* parameter returns one value: the start factor for the linear fog equation. See [**glFog**](glfog.md).<br/>                                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_FRONT_FACE"></span><span id="gl_front_face"></span><dl> <dt>**GL\_FRONT\_FACE**</dt> </dl>                                                             | The *params* parameter returns one value: a symbolic constant indicating whether clockwise or counterclockwise polygon winding is treated as front-facing. See [**glFrontFace**](glfrontface.md).<br/>                                                                                                                                                                                                                              |
     * | <span id="GL_GREEN_BIAS"></span><span id="gl_green_bias"></span><dl> <dt>**GL\_GREEN\_BIAS**</dt> </dl>                                                             | The *params* parameter returns one value: the green bias factor used during pixel transfers.<br/>                                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_GREEN_BITS"></span><span id="gl_green_bits"></span><dl> <dt>**GL\_GREEN\_BITS**</dt> </dl>                                                             | The *params* parameter returns one value: the number of green bitplanes in each color buffer.<br/>                                                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_GREEN_SCALE"></span><span id="gl_green_scale"></span><dl> <dt>**GL\_GREEN\_SCALE**</dt> </dl>                                                          | The *params* parameter returns one value: the green scale factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_INDEX_ARRAY"></span><span id="gl_index_array"></span><dl> <dt>**GL\_INDEX\_ARRAY**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether the color index array is enabled. See [**glIndexPointer**](glindexpointer.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_INDEX_ARRAY_STRIDE"></span><span id="gl_index_array_stride"></span><dl> <dt>**GL\_INDEX\_ARRAY\_STRIDE**</dt> </dl>                                    | The *params* parameter returns one value, the byte offset between consecutive color indexes in the color index array. See [**glIndexPointer**](glindexpointer.md).<br/>                                                                                                                                                                                                                                                             |
     * | <span id="GL_INDEX_ARRAY_TYPE"></span><span id="gl_index_array_type"></span><dl> <dt>**GL\_INDEX\_ARRAY\_TYPE**</dt> </dl>                                          | The *params* parameter returns one value, the data type of indexes in the color index array. The initial value is GL\_FLOAT. See [**glIndexPointer**](glindexpointer.md).<br/>                                                                                                                                                                                                                                                      |
     * | <span id="GL_INDEX_BITS"></span><span id="gl_index_bits"></span><dl> <dt>**GL\_INDEX\_BITS**</dt> </dl>                                                             | The *params* parameter returns one value: the number of bitplanes in each color-index buffer.<br/>                                                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_INDEX_CLEAR_VALUE"></span><span id="gl_index_clear_value"></span><dl> <dt>**GL\_INDEX\_CLEAR\_VALUE**</dt> </dl>                                       | The *params* parameter returns one value: the color index used to clear the color-index buffers. See [**glClearIndex**](glclearindex.md).<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_INDEX_LOGIC_OP"></span><span id="gl_index_logic_op"></span><dl> <dt>**GL\_INDEX\_LOGIC\_OP**</dt> </dl>                                                | The *params* parameter returns a single Boolean value indicating whether a fragment's index values are merged into the framebuffer using a logical operation. See [**glLogicOp**](gllogicop.md).<br/>                                                                                                                                                                                                                               |
     * | <span id="GL_INDEX_MODE"></span><span id="gl_index_mode"></span><dl> <dt>**GL\_INDEX\_MODE**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether OpenGL is in color-index mode (TRUE) or RGBA mode (FALSE).<br/>                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_INDEX_OFFSET"></span><span id="gl_index_offset"></span><dl> <dt>**GL\_INDEX\_OFFSET**</dt> </dl>                                                       | The *params* parameter returns one value: the offset added to color and stencil indexes during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                 |
     * | <span id="GL_INDEX_SHIFT"></span><span id="gl_index_shift"></span><dl> <dt>**GL\_INDEX\_SHIFT**</dt> </dl>                                                          | The *params* parameter returns one value: the amount that color and stencil indexes are shifted during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                         |
     * | <span id="GL_INDEX_WRITEMASK"></span><span id="gl_index_writemask"></span><dl> <dt>**GL\_INDEX\_WRITEMASK**</dt> </dl>                                              | The *params* parameter returns one value: a mask indicating which bitplanes of each color-index buffer can be written. See [**glIndexMask**](glindexmask.md).<br/>                                                                                                                                                                                                                                                                  |
     * | <span id="GL_LIGHTi"></span><span id="gl_lighti"></span><span id="GL_LIGHTI"></span><dl> <dt>**GL\_LIGHT*i***</dt> </dl>                                            | The *params* parameter returns a single Boolean value indicating whether the specified light is enabled. See [**glLight**](gllight-functions.md) and [**glLightModel**](gllightmodel-functions.md).<br/>                                                                                                                                                                                                                           |
     * | <span id="GL_LIGHTING"></span><span id="gl_lighting"></span><dl> <dt>**GL\_LIGHTING**</dt> </dl>                                                                    | The *params* parameter returns a single Boolean value indicating whether lighting is enabled. See [**glLightModel**](gllightmodel-functions.md).<br/>                                                                                                                                                                                                                                                                               |
     * | <span id="GL_LIGHT_MODEL_AMBIENT"></span><span id="gl_light_model_ambient"></span><dl> <dt>**GL\_LIGHT\_MODEL\_AMBIENT**</dt> </dl>                                 | The *params* parameter returns four values: the red, green, blue, and alpha components of the ambient intensity of the entire scene. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. See [**glLightModel**](gllightmodel-functions.md).<br/> |
     * | <span id="GL_LIGHT_MODEL_LOCAL_VIEWER"></span><span id="gl_light_model_local_viewer"></span><dl> <dt>**GL\_LIGHT\_MODEL\_LOCAL\_VIEWER**</dt> </dl>                 | The *params* parameter returns a single Boolean value indicating whether specular reflection calculations treat the viewer as being local to the scene. See [**glLightModel**](gllightmodel-functions.md).<br/>                                                                                                                                                                                                                     |
     * | <span id="GL_LIGHT_MODEL_TWO_SIDE"></span><span id="gl_light_model_two_side"></span><dl> <dt>**GL\_LIGHT\_MODEL\_TWO\_SIDE**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether separate materials are used to compute lighting for front-facing and back-facing polygons. See [**glLightModel**](gllightmodel-functions.md).<br/>                                                                                                                                                                                                         |
     * | <span id="GL_LINE_SMOOTH"></span><span id="gl_line_smooth"></span><dl> <dt>**GL\_LINE\_SMOOTH**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether antialiasing of lines is enabled. See [**glLineWidth**](gllinewidth.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_LINE_SMOOTH_HINT"></span><span id="gl_line_smooth_hint"></span><dl> <dt>**GL\_LINE\_SMOOTH\_HINT**</dt> </dl>                                          | The *params* parameter returns one value: a symbolic constant indicating the mode of the line antialiasing hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_LINE_STIPPLE"></span><span id="gl_line_stipple"></span><dl> <dt>**GL\_LINE\_STIPPLE**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether stippling of lines is enabled. See [**glLineStipple**](gllinestipple.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_LINE_STIPPLE_PATTERN"></span><span id="gl_line_stipple_pattern"></span><dl> <dt>**GL\_LINE\_STIPPLE\_PATTERN**</dt> </dl>                              | The *params* parameter returns one value: the 16-bit line stipple pattern. See [**glLineStipple**](gllinestipple.md).<br/>                                                                                                                                                                                                                                                                                                          |
     * | <span id="GL_LINE_STIPPLE_REPEAT"></span><span id="gl_line_stipple_repeat"></span><dl> <dt>**GL\_LINE\_STIPPLE\_REPEAT**</dt> </dl>                                 | The *params* parameter returns one value: the line stipple repeat factor. See [**glLineStipple**](gllinestipple.md).<br/>                                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_LINE_WIDTH"></span><span id="gl_line_width"></span><dl> <dt>**GL\_LINE\_WIDTH**</dt> </dl>                                                             | The *params* parameter returns one value: the line width as specified with [**glLineWidth**](gllinewidth.md).<br/>                                                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_LINE_WIDTH_GRANULARITY"></span><span id="gl_line_width_granularity"></span><dl> <dt>**GL\_LINE\_WIDTH\_GRANULARITY**</dt> </dl>                        | The *params* parameter returns one value: the width difference between adjacent supported widths for antialiased lines. See [**glLineWidth**](gllinewidth.md).<br/>                                                                                                                                                                                                                                                                 |
     * | <span id="GL_LINE_WIDTH_RANGE"></span><span id="gl_line_width_range"></span><dl> <dt>**GL\_LINE\_WIDTH\_RANGE**</dt> </dl>                                          | The *params* parameter returns two values: the smallest and largest supported widths for antialiased lines. See [**glLineWidth**](gllinewidth.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_LIST_BASE"></span><span id="gl_list_base"></span><dl> <dt>**GL\_LIST\_BASE**</dt> </dl>                                                                | The *params* parameter returns one value: the base offset added to all names in arrays presented to [**glCallLists**](glcalllists.md). See [**glListBase**](gllistbase.md).<br/>                                                                                                                                                                                                                                                   |
     * | <span id="GL_LIST_INDEX"></span><span id="gl_list_index"></span><dl> <dt>**GL\_LIST\_INDEX**</dt> </dl>                                                             | The *params* parameter returns one value: the name of the display list currently under construction. Zero is returned if no display list is currently under construction. See [**glNewList**](glnewlist.md).<br/>                                                                                                                                                                                                                   |
     * | <span id="GL_LIST_MODE"></span><span id="gl_list_mode"></span><dl> <dt>**GL\_LIST\_MODE**</dt> </dl>                                                                | The *params* parameter returns one value: a symbolic constant indicating the construction mode of the display list currently being constructed. See [**glNewList**](glnewlist.md).<br/>                                                                                                                                                                                                                                             |
     * | <span id="GL_LOGIC_OP"></span><span id="gl_logic_op"></span><dl> <dt>**GL\_LOGIC\_OP**</dt> </dl>                                                                   | The *params* parameter returns a single Boolean value indicating whether fragment indexes are merged into the framebuffer using a logical operation. See [**glLogicOp**](gllogicop.md).<br/>                                                                                                                                                                                                                                        |
     * | <span id="GL_LOGIC_OP_MODE"></span><span id="gl_logic_op_mode"></span><dl> <dt>**GL\_LOGIC\_OP\_MODE**</dt> </dl>                                                   | The *params* parameter returns one value: a symbolic constant indicating the selected logic operational mode. See [**glLogicOp**](gllogicop.md).<br/>                                                                                                                                                                                                                                                                               |
     * | <span id="GL_MAP1_COLOR_4"></span><span id="gl_map1_color_4"></span><dl> <dt>**GL\_MAP1\_COLOR\_4**</dt> </dl>                                                      | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates colors. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP1_GRID_DOMAIN"></span><span id="gl_map1_grid_domain"></span><dl> <dt>**GL\_MAP1\_GRID\_DOMAIN**</dt> </dl>                                          | The *params* parameter returns two values: the endpoints of the 1-D maps grid domain. See [glMapGrid](glmapgrid-functions.md).<br/>                                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_MAP1_GRID_SEGMENTS"></span><span id="gl_map1_grid_segments"></span><dl> <dt>**GL\_MAP1\_GRID\_SEGMENTS**</dt> </dl>                                    | The *params* parameter returns one value: the number of partitions in the 1-D maps grid domain. See [glMapGrid](glmapgrid-functions.md).<br/>                                                                                                                                                                                                                                                                                       |
     * | <span id="GL_MAP1_INDEX"></span><span id="gl_map1_index"></span><dl> <dt>**GL\_MAP1\_INDEX**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates color indexes. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_MAP1_NORMAL"></span><span id="gl_map1_normal"></span><dl> <dt>**GL\_MAP1\_NORMAL**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates normals. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_TEXTURE_COORD_1"></span><span id="gl_map1_texture_coord_1"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_1**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 1-D texture coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_TEXTURE_COORD_2"></span><span id="gl_map1_texture_coord_2"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_2**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 2-D texture coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_TEXTURE_COORD_3"></span><span id="gl_map1_texture_coord_3"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_3**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 3-D texture coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_TEXTURE_COORD_4"></span><span id="gl_map1_texture_coord_4"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_4**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 4-D texture coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP1_VERTEX_3"></span><span id="gl_map1_vertex_3"></span><dl> <dt>**GL\_MAP1\_VERTEX\_3**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 3-D vertex coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP1_VERTEX_4"></span><span id="gl_map1_vertex_4"></span><dl> <dt>**GL\_MAP1\_VERTEX\_4**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether 1-D evaluation generates 4-D vertex coordinates. See [**glMap1**](glmap1.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP2_COLOR_4"></span><span id="gl_map2_color_4"></span><dl> <dt>**GL\_MAP2\_COLOR\_4**</dt> </dl>                                                      | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates colors. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP2_GRID_DOMAIN"></span><span id="gl_map2_grid_domain"></span><dl> <dt>**GL\_MAP2\_GRID\_DOMAIN**</dt> </dl>                                          | The *params* parameter returns four values: the endpoints of the 2-D maps *i* and *j* grid domains. See [glMapGrid](glmapgrid-functions.md).<br/>                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_MAP2_GRID_SEGMENTS"></span><span id="gl_map2_grid_segments"></span><dl> <dt>**GL\_MAP2\_GRID\_SEGMENTS**</dt> </dl>                                    | The *params* parameter returns two values: the number of partitions in the 2-D maps *i* and *j* grid domains. See [glMapGrid](glmapgrid-functions.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP2_INDEX"></span><span id="gl_map2_index"></span><dl> <dt>**GL\_MAP2\_INDEX**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates color indexes. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_MAP2_NORMAL"></span><span id="gl_map2_normal"></span><dl> <dt>**GL\_MAP2\_NORMAL**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates normals. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_TEXTURE_COORD_1"></span><span id="gl_map2_texture_coord_1"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_1**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 1-D texture coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_TEXTURE_COORD_2"></span><span id="gl_map2_texture_coord_2"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_2**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 2-D texture coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_TEXTURE_COORD_3"></span><span id="gl_map2_texture_coord_3"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_3**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 3-D texture coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_TEXTURE_COORD_4"></span><span id="gl_map2_texture_coord_4"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_4**</dt> </dl>                             | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 4-D texture coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAP2_VERTEX_3"></span><span id="gl_map2_vertex_3"></span><dl> <dt>**GL\_MAP2\_VERTEX\_3**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 3-D vertex coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP2_VERTEX_4"></span><span id="gl_map2_vertex_4"></span><dl> <dt>**GL\_MAP2\_VERTEX\_4**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether 2-D evaluation generates 4-D vertex coordinates. See [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAP_COLOR"></span><span id="gl_map_color"></span><dl> <dt>**GL\_MAP\_COLOR**</dt> </dl>                                                                | The *params* parameter returns a single Boolean value indicating whether colors and color indexes are to be replaced by table lookup during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                    |
     * | <span id="GL_MAP_STENCIL"></span><span id="gl_map_stencil"></span><dl> <dt>**GL\_MAP\_STENCIL**</dt> </dl>                                                          | The *params* parameter returns a single Boolean value indicating whether stencil indexes are to be replaced by table lookup during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                             |
     * | <span id="GL_MATRIX_MODE"></span><span id="gl_matrix_mode"></span><dl> <dt>**GL\_MATRIX\_MODE**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating which matrix stack is currently the target of all matrix operations. See [**glMatrixMode**](glmatrixmode.md).<br/>                                                                                                                                                                                                                                         |
     * | <span id="GL_MAX_CLIENT_ATTRIB_STACK_DEPTH"></span><span id="gl_max_client_attrib_stack_depth"></span><dl> <dt>**GL\_MAX\_CLIENT\_ATTRIB\_STACK\_DEPTH**</dt> </dl> | The *params* parameter returns one value indicating the maximum supported depth of the client attribute stack. See [**glPushClientAttrib**](glpushclientattrib.md).<br/>                                                                                                                                                                                                                                                            |
     * | <span id="GL_MAX_ATTRIB_STACK_DEPTH"></span><span id="gl_max_attrib_stack_depth"></span><dl> <dt>**GL\_MAX\_ATTRIB\_STACK\_DEPTH**</dt> </dl>                       | The *params* parameter returns one value: the maximum supported depth of the attribute stack. See [**glPushAttrib**](glpushattrib.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_MAX_CLIP_PLANES"></span><span id="gl_max_clip_planes"></span><dl> <dt>**GL\_MAX\_CLIP\_PLANES**</dt> </dl>                                             | The *params* parameter returns one value: the maximum number of application-defined clipping planes. See [**glClipPlane**](glclipplane.md).<br/>                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_MAX_EVAL_ORDER"></span><span id="gl_max_eval_order"></span><dl> <dt>**GL\_MAX\_EVAL\_ORDER**</dt> </dl>                                                | The *params* parameter returns one value: the maximum equation order supported by 1-D and 2-D evaluators. See [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md).<br/>                                                                                                                                                                                                                                                            |
     * | <span id="GL_MAX_LIGHTS"></span><span id="gl_max_lights"></span><dl> <dt>**GL\_MAX\_LIGHTS**</dt> </dl>                                                             | The *params* parameter returns one value: the maximum number of lights. See [glLight](gllight-functions.md).<br/>                                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_MAX_LIST_NESTING"></span><span id="gl_max_list_nesting"></span><dl> <dt>**GL\_MAX\_LIST\_NESTING**</dt> </dl>                                          | The *params* parameter returns one value: the maximum recursion depth allowed during display-list traversal. See [**glCallList**](glcalllist.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_MAX_MODELVIEW_STACK_DEPTH"></span><span id="gl_max_modelview_stack_depth"></span><dl> <dt>**GL\_MAX\_MODELVIEW\_STACK\_DEPTH**</dt> </dl>              | The *params* parameter returns one value: the maximum supported depth of the modelview matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_MAX_NAME_STACK_DEPTH"></span><span id="gl_max_name_stack_depth"></span><dl> <dt>**GL\_MAX\_NAME\_STACK\_DEPTH**</dt> </dl>                             | The *params* parameter returns one value: the maximum supported depth of the selection name stack. See [**glPushName**](glpushname.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAX_PIXEL_MAP_TABLE"></span><span id="gl_max_pixel_map_table"></span><dl> <dt>**GL\_MAX\_PIXEL\_MAP\_TABLE**</dt> </dl>                                | The *params* parameter returns one value: the maximum supported size of a [**glPixelMap**](glpixelmap.md) lookup table.<br/>                                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MAX_PROJECTION_STACK_DEPTH"></span><span id="gl_max_projection_stack_depth"></span><dl> <dt>**GL\_MAX\_PROJECTION\_STACK\_DEPTH**</dt> </dl>           | The *params* parameter returns one value: the maximum supported depth of the projection matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_MAX_TEXTURE_SIZE"></span><span id="gl_max_texture_size"></span><dl> <dt>**GL\_MAX\_TEXTURE\_SIZE**</dt> </dl>                                          | The *params* parameter returns one value: the maximum width or height of any texture image (without borders). See [**glTexImage1D**](glteximage1d.md) and [**glTexImage2D**](glteximage2d.md).<br/>                                                                                                                                                                                                                                |
     * | <span id="GL_MAX_TEXTURE_STACK_DEPTH"></span><span id="gl_max_texture_stack_depth"></span><dl> <dt>**GL\_MAX\_TEXTURE\_STACK\_DEPTH**</dt> </dl>                    | The *params* parameter returns one value: the maximum supported depth of the texture matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_MAX_VIEWPORT_DIMS"></span><span id="gl_max_viewport_dims"></span><dl> <dt>**GL\_MAX\_VIEWPORT\_DIMS**</dt> </dl>                                       | The *params* parameter returns two values: the maximum supported width and height of the viewport. See [**glViewport**](glviewport.md).<br/>                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_MODELVIEW_MATRIX"></span><span id="gl_modelview_matrix"></span><dl> <dt>**GL\_MODELVIEW\_MATRIX**</dt> </dl>                                           | The *params* parameter returns 16 values: the modelview matrix on the top of the modelview matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_MODELVIEW_STACK_DEPTH"></span><span id="gl_modelview_stack_depth"></span><dl> <dt>**GL\_MODELVIEW\_STACK\_DEPTH**</dt> </dl>                           | The *params* parameter returns one value: the number of matrices on the modelview matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                       |
     * | <span id="GL_NAME_STACK_DEPTH"></span><span id="gl_name_stack_depth"></span><dl> <dt>**GL\_NAME\_STACK\_DEPTH**</dt> </dl>                                          | The *params* parameter returns one value: the number of names on the selection name stack. See [**glPushName**](glpushname.md).<br/>                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_NORMAL_ARRAY"></span><span id="gl_normal_array"></span><dl> <dt>**GL\_NORMAL\_ARRAY**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value, indicating whether the normal array is enabled. See [**glNormalPointer**](glnormalpointer.md).<br/>                                                                                                                                                                                                                                                                          |
     * | <span id="GL_NORMAL_ARRAY_STRIDE"></span><span id="gl_normal_array_stride"></span><dl> <dt>**GL\_NORMAL\_ARRAY\_STRIDE**</dt> </dl>                                 | The *params* parameter returns one value, the byte offset between consecutive normals in the normal array. See [**glNormalPointer**](glnormalpointer.md).<br/>                                                                                                                                                                                                                                                                      |
     * | <span id="GL_NORMAL_ARRAY_TYPE"></span><span id="gl_normal_array_type"></span><dl> <dt>**GL\_NORMAL\_ARRAY\_TYPE**</dt> </dl>                                       | The *params* parameter returns one value, the data type of each coordinate in the normal array. See [**glNormalPointer**](glnormalpointer.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_NORMALIZE"></span><span id="gl_normalize"></span><dl> <dt>**GL\_NORMALIZE**</dt> </dl>                                                                 | The *params* parameter returns a single Boolean value indicating whether normals are automatically scaled to unit length after they have been transformed to eye coordinates. See [glNormal](glnormal-functions.md).<br/>                                                                                                                                                                                                           |
     * | <span id="GL_PACK_ALIGNMENT"></span><span id="gl_pack_alignment"></span><dl> <dt>**GL\_PACK\_ALIGNMENT**</dt> </dl>                                                 | The *params* parameter returns one value: the byte alignment used for writing pixel data to memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_PACK_LSB_FIRST"></span><span id="gl_pack_lsb_first"></span><dl> <dt>**GL\_PACK\_LSB\_FIRST**</dt> </dl>                                                | The *params* parameter returns a single Boolean value indicating whether single-bit pixels being written to memory are written first to the least significant bit of each unsigned byte. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                        |
     * | <span id="GL_PACK_ROW_LENGTH"></span><span id="gl_pack_row_length"></span><dl> <dt>**GL\_PACK\_ROW\_LENGTH**</dt> </dl>                                             | The *params* parameter returns one value: the row length used for writing pixel data to memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_PACK_SKIP_PIXELS"></span><span id="gl_pack_skip_pixels"></span><dl> <dt>**GL\_PACK\_SKIP\_PIXELS**</dt> </dl>                                          | The *params* parameter returns one value: the number of pixel locations skipped before the first pixel is written into memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                  |
     * | <span id="GL_PACK_SKIP_ROWS"></span><span id="gl_pack_skip_rows"></span><dl> <dt>**GL\_PACK\_SKIP\_ROWS**</dt> </dl>                                                | The *params* parameter returns one value: the number of rows of pixel locations skipped before the first pixel is written into memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                          |
     * | <span id="GL_PACK_SWAP_BYTES"></span><span id="gl_pack_swap_bytes"></span><dl> <dt>**GL\_PACK\_SWAP\_BYTES**</dt> </dl>                                             | The *params* parameter returns a single Boolean value indicating whether the bytes of 2-byte and 4-byte pixel indexes and components are swapped before being written to memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                |
     * | <span id="GL_PERSPECTIVE_CORRECTION_HINT"></span><span id="gl_perspective_correction_hint"></span><dl> <dt>**GL\_PERSPECTIVE\_CORRECTION\_HINT**</dt> </dl>         | The *params* parameter returns one value: a symbolic constant indicating the mode of the perspective correction hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_PIXEL_MAP_A_TO_A_SIZE"></span><span id="gl_pixel_map_a_to_a_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_A\_TO\_A\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the alpha-to-alpha pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_B_TO_B_SIZE"></span><span id="gl_pixel_map_b_to_b_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_B\_TO\_B\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the blue-to-blue pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_PIXEL_MAP_G_TO_G_SIZE"></span><span id="gl_pixel_map_g_to_g_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_G\_TO\_G\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the green-to-green pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_I_TO_A_SIZE"></span><span id="gl_pixel_map_i_to_a_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_A\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-alpha pixel translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_I_TO_B_SIZE"></span><span id="gl_pixel_map_i_to_b_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_B\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-blue pixel translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                          |
     * | <span id="GL_PIXEL_MAP_I_TO_G_SIZE"></span><span id="gl_pixel_map_i_to_g_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_G\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-green pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_I_TO_I_SIZE"></span><span id="gl_pixel_map_i_to_i_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_I\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-index pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_PIXEL_MAP_I_TO_R_SIZE"></span><span id="gl_pixel_map_i_to_r_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_R\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the index-to-red pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_PIXEL_MAP_R_TO_R_SIZE"></span><span id="gl_pixel_map_r_to_r_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_R\_TO\_R\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the red-to-red pixel-translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_PIXEL_MAP_S_TO_S_SIZE"></span><span id="gl_pixel_map_s_to_s_size"></span><dl> <dt>**GL\_PIXEL\_MAP\_S\_TO\_S\_SIZE**</dt> </dl>                        | The *params* parameter returns one value: the size of the stencil-to-stencil pixel translation table. See [**glPixelMap**](glpixelmap.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_POINT_SIZE"></span><span id="gl_point_size"></span><dl> <dt>**GL\_POINT\_SIZE**</dt> </dl>                                                             | The *params* parameter returns one value: the point size as specified by [**glPointSize**](glpointsize.md).<br/>                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_POINT_SIZE_GRANULARITY"></span><span id="gl_point_size_granularity"></span><dl> <dt>**GL\_POINT\_SIZE\_GRANULARITY**</dt> </dl>                        | The *params* parameter returns one value: the size difference between adjacent supported sizes for antialiased points. See [**glPointSize**](glpointsize.md).<br/>                                                                                                                                                                                                                                                                  |
     * | <span id="GL_POINT_SIZE_RANGE"></span><span id="gl_point_size_range"></span><dl> <dt>**GL\_POINT\_SIZE\_RANGE**</dt> </dl>                                          | The *params* parameter returns two values: the smallest and largest supported sizes for antialiased points. See [**glPointSize**](glpointsize.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_POINT_SMOOTH"></span><span id="gl_point_smooth"></span><dl> <dt>**GL\_POINT\_SMOOTH**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether antialiasing of points is enabled. See [**glPointSize**](glpointsize.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_POINT_SMOOTH_HINT"></span><span id="gl_point_smooth_hint"></span><dl> <dt>**GL\_POINT\_SMOOTH\_HINT**</dt> </dl>                                       | The *params* parameter returns one value: a symbolic constant indicating the mode of the point antialiasing hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_POLYGON_MODE"></span><span id="gl_polygon_mode"></span><dl> <dt>**GL\_POLYGON\_MODE**</dt> </dl>                                                       | The *params* parameter returns two values: symbolic constants indicating whether front-facing and back-facing polygons are rasterized as points, lines, or filled polygons. See [**glPolygonMode**](glpolygonmode.md).<br/>                                                                                                                                                                                                         |
     * | <span id="GL_POLYGON_OFFSET_FACTOR"></span><span id="gl_polygon_offset_factor"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_FACTOR**</dt> </dl>                           | The *params* parameter returns one value, the scaling factor used to determine the variable offset that is added to the depth value of each fragment generated when a polygon is rasterized. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                                    |
     * | <span id="GL_POLYGON_OFFSET_UNITS"></span><span id="gl_polygon_offset_units"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_UNITS**</dt> </dl>                              | The *params* parameter returns one value. This value is multiplied by an implementation-specific value and then added to the depth value of each fragment generated when a polygon is rasterized. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                               |
     * | <span id="GL_POLYGON_OFFSET_FILL"></span><span id="gl_polygon_offset_fill"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_FILL**</dt> </dl>                                 | The *params* parameter returns a single Boolean value indicating whether polygon offset is enabled for polygons in fill mode. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                                                                                                   |
     * | <span id="GL_POLYGON_OFFSET_LINE"></span><span id="gl_polygon_offset_line"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_LINE**</dt> </dl>                                 | The *params* parameter returns a single Boolean value indicating whether polygon offset is enabled for polygons in line mode. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                                                                                                   |
     * | <span id="GL_POLYGON_OFFSET_POINT"></span><span id="gl_polygon_offset_point"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_POINT**</dt> </dl>                              | The *params* parameter returns a single Boolean value indicating whether polygon offset is enabled for polygons in point mode. See [**glPolygonOffset**](glpolygonoffset.md).<br/>                                                                                                                                                                                                                                                  |
     * | <span id="GL_POLYGON_SMOOTH"></span><span id="gl_polygon_smooth"></span><dl> <dt>**GL\_POLYGON\_SMOOTH**</dt> </dl>                                                 | The *params* parameter returns a single Boolean value indicating whether antialiasing of polygons is enabled. See [**glPolygonMode**](glpolygonmode.md).<br/>                                                                                                                                                                                                                                                                       |
     * | <span id="GL_POLYGON_SMOOTH_HINT"></span><span id="gl_polygon_smooth_hint"></span><dl> <dt>**GL\_POLYGON\_SMOOTH\_HINT**</dt> </dl>                                 | The *params* parameter returns one value: a symbolic constant indicating the mode of the polygon antialiasing hint. See [**glHint**](glhint.md).<br/>                                                                                                                                                                                                                                                                               |
     * | <span id="GL_POLYGON_STIPPLE"></span><span id="gl_polygon_stipple"></span><dl> <dt>**GL\_POLYGON\_STIPPLE**</dt> </dl>                                              | The *params* parameter returns a single Boolean value indicating whether stippling of polygons is enabled. See [**glPolygonStipple**](glpolygonstipple.md).<br/>                                                                                                                                                                                                                                                                    |
     * | <span id="GL_PROJECTION_MATRIX"></span><span id="gl_projection_matrix"></span><dl> <dt>**GL\_PROJECTION\_MATRIX**</dt> </dl>                                        | The *params* parameter returns 16 values: the projection matrix on the top of the projection matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                            |
     * | <span id="GL_PROJECTION_STACK_DEPTH"></span><span id="gl_projection_stack_depth"></span><dl> <dt>**GL\_PROJECTION\_STACK\_DEPTH**</dt> </dl>                        | The *params* parameter returns one value: the number of matrices on the projection matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_READ_BUFFER"></span><span id="gl_read_buffer"></span><dl> <dt>**GL\_READ\_BUFFER**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating which color buffer is selected for reading. See [**glReadPixels**](glreadpixels.md) and [**glAccum**](glaccum.md).<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_RED_BIAS"></span><span id="gl_red_bias"></span><dl> <dt>**GL\_RED\_BIAS**</dt> </dl>                                                                   | The *params* parameter returns one value: the red bias factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_RED_BITS"></span><span id="gl_red_bits"></span><dl> <dt>**GL\_RED\_BITS**</dt> </dl>                                                                   | The *params* parameter returns one value: the number of red bitplanes in each color buffer.<br/>                                                                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_RED_SCALE"></span><span id="gl_red_scale"></span><dl> <dt>**GL\_RED\_SCALE**</dt> </dl>                                                                | The *params* parameter returns one value: the red scale factor used during pixel transfers. See [**glPixelTransfer**](glpixeltransfer.md).<br/>                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_RENDER_MODE"></span><span id="gl_render_mode"></span><dl> <dt>**GL\_RENDER\_MODE**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating whether OpenGL is in render, select, or feedback mode. See [**glRenderMode**](glrendermode.md).<br/>                                                                                                                                                                                                                                                       |
     * | <span id="GL_RGBA_MODE"></span><span id="gl_rgba_mode"></span><dl> <dt>**GL\_RGBA\_MODE**</dt> </dl>                                                                | The *params* parameter returns a single Boolean value indicating whether OpenGL is in RGBA mode (TRUE) or color-index mode (FALSE). See [glColor](glcolor-functions.md).<br/>                                                                                                                                                                                                                                                       |
     * | <span id="GL_SCISSOR_BOX"></span><span id="gl_scissor_box"></span><dl> <dt>**GL\_SCISSOR\_BOX**</dt> </dl>                                                          | The *params* parameter returns four values: the *x* and *y* window coordinates of the scissor box, followed by its width and height. See [**glScissor**](glscissor.md).<br/>                                                                                                                                                                                                                                                        |
     * | <span id="GL_SCISSOR_TEST"></span><span id="gl_scissor_test"></span><dl> <dt>**GL\_SCISSOR\_TEST**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether scissoring is enabled. See [**glScissor**](glscissor.md).<br/>                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_SHADE_MODEL"></span><span id="gl_shade_model"></span><dl> <dt>**GL\_SHADE\_MODEL**</dt> </dl>                                                          | The *params* parameter returns one value: a symbolic constant indicating whether the shading mode is flat or smooth. See [**glShadeModel**](glshademodel.md).<br/>                                                                                                                                                                                                                                                                  |
     * | <span id="GL_STENCIL_BITS"></span><span id="gl_stencil_bits"></span><dl> <dt>**GL\_STENCIL\_BITS**</dt> </dl>                                                       | The *params* parameter returns one value: the number of bitplanes in the stencil buffer.<br/>                                                                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_STENCIL_CLEAR_VALUE"></span><span id="gl_stencil_clear_value"></span><dl> <dt>**GL\_STENCIL\_CLEAR\_VALUE**</dt> </dl>                                 | The *params* parameter returns one value: the index to which the stencil bitplanes are cleared. See [**glClearStencil**](glclearstencil.md).<br/>                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_STENCIL_FAIL"></span><span id="gl_stencil_fail"></span><dl> <dt>**GL\_STENCIL\_FAIL**</dt> </dl>                                                       | The *params* parameter returns one value: a symbolic constant indicating what action is taken when the stencil test fails. See [**glStencilOp**](glstencilop.md).<br/>                                                                                                                                                                                                                                                              |
     * | <span id="GL_STENCIL_FUNC"></span><span id="gl_stencil_func"></span><dl> <dt>**GL\_STENCIL\_FUNC**</dt> </dl>                                                       | The *params* parameter returns one value: a symbolic constant indicating what function is used to compare the stencil reference value with the stencil buffer value. See [**glStencilFunc**](glstencilfunc.md).<br/>                                                                                                                                                                                                                |
     * | <span id="GL_STENCIL_PASS_DEPTH_FAIL"></span><span id="gl_stencil_pass_depth_fail"></span><dl> <dt>**GL\_STENCIL\_PASS\_DEPTH\_FAIL**</dt> </dl>                    | The *params* parameter returns one value: a symbolic constant indicating what action is taken when the stencil test passes, but the depth test fails. See [**glStencilOp**](glstencilop.md).<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_STENCIL_PASS_DEPTH_PASS"></span><span id="gl_stencil_pass_depth_pass"></span><dl> <dt>**GL\_STENCIL\_PASS\_DEPTH\_PASS**</dt> </dl>                    | The *params* parameter returns one value: a symbolic constant indicating what action is taken when the stencil test passes and the depth test passes. See [**glStencilOp**](glstencilop.md).<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_STENCIL_REF"></span><span id="gl_stencil_ref"></span><dl> <dt>**GL\_STENCIL\_REF**</dt> </dl>                                                          | The *params* parameter returns one value: the reference value that is compared with the contents of the stencil buffer. See [**glStencilFunc**](glstencilfunc.md).<br/>                                                                                                                                                                                                                                                             |
     * | <span id="GL_STENCIL_TEST"></span><span id="gl_stencil_test"></span><dl> <dt>**GL\_STENCIL\_TEST**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether stencil testing of fragments is enabled. See [**glStencilFunc**](glstencilfunc.md) and [**glStencilOp**](glstencilop.md).<br/>                                                                                                                                                                                                                            |
     * | <span id="GL_STENCIL_VALUE_MASK"></span><span id="gl_stencil_value_mask"></span><dl> <dt>**GL\_STENCIL\_VALUE\_MASK**</dt> </dl>                                    | The *params* parameter returns one value: the mask that is used to mask both the stencil reference value and the stencil buffer value before they are compared. See [**glStencilFunc**](glstencilfunc.md).<br/>                                                                                                                                                                                                                     |
     * | <span id="GL_STENCIL_WRITEMASK"></span><span id="gl_stencil_writemask"></span><dl> <dt>**GL\_STENCIL\_WRITEMASK**</dt> </dl>                                        | The *params* parameter returns one value: the mask that controls writing of the stencil bitplanes. See [**glStencilMask**](glstencilmask.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_STEREO"></span><span id="gl_stereo"></span><dl> <dt>**GL\_STEREO**</dt> </dl>                                                                          | The *params* parameter returns a single Boolean value indicating whether stereo buffers (left and right) are supported.<br/>                                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_SUBPIXEL_BITS"></span><span id="gl_subpixel_bits"></span><dl> <dt>**GL\_SUBPIXEL\_BITS**</dt> </dl>                                                    | The *params* parameter returns one value: an estimate of the number of bits of subpixel resolution that are used to position rasterized geometry in window coordinates.<br/>                                                                                                                                                                                                                                                         |
     * | <span id="GL_TEXTURE_1D"></span><span id="gl_texture_1d"></span><dl> <dt>**GL\_TEXTURE\_1D**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether 1-D texture mapping is enabled. See [**glTexImage1D**](glteximage1d.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_TEXTURE_2D"></span><span id="gl_texture_2d"></span><dl> <dt>**GL\_TEXTURE\_2D**</dt> </dl>                                                             | The *params* parameter returns a single Boolean value indicating whether 2-D texture mapping is enabled. See [**glTexImage2D**](glteximage2d.md).<br/>                                                                                                                                                                                                                                                                              |
     * | <span id="GL_TEXTURE_COORD_ARRAY"></span><span id="gl_texture_coord_array"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY**</dt> </dl>                                 | The *params* parameter returns a single Boolean value indicating whether the texture coordinate array is enabled. See [**glTexCoordPointer**](gltexcoordpointer.md).<br/>                                                                                                                                                                                                                                                           |
     * | <span id="GL_TEXTURE_COORD_ARRAY_SIZE"></span><span id="gl_texture_coord_array_size"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY\_SIZE**</dt> </dl>                 | The *params* parameter returns one value, the number of coordinates per element in the texture coordinate array. See [**glTexCoordPointer**](gltexcoordpointer.md).<br/>                                                                                                                                                                                                                                                            |
     * | <span id="GL_TEXTURE_COORD_ARRAY_STRIDE"></span><span id="gl_texture_coord_array_stride"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY\_STRIDE**</dt> </dl>           | The *params* parameter returns one value, the byte offset between consecutive elements in the texture coordinate array. See [**glTexCoordPointer**](gltexcoordpointer.md).<br/>                                                                                                                                                                                                                                                     |
     * | <span id="GL_TEXTURE_COORD_ARRAY_TYPE"></span><span id="gl_texture_coord_array_type"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY\_TYPE**</dt> </dl>                 | The *params* parameter params returns one value, the data type of the coordinates in the texture coordinate array. See [**glTexCoordPointer**](gltexcoordpointer.md).<br/>                                                                                                                                                                                                                                                          |
     * | <span id="GL_TEXTURE_ENV_COLOR"></span><span id="gl_texture_env_color"></span><dl> <dt>**GL\_TEXTURE\_ENV\_COLOR**</dt> </dl>                                       | The *params* parameter returns four values: the red, green, blue, and alpha values of the texture environment color. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and 1.0 returns the most negative representable integer value. See [glTexEnv](gltexenv-functions.md).<br/>                              |
     * | <span id="GL_TEXTURE_ENV_MODE"></span><span id="gl_texture_env_mode"></span><dl> <dt>**GL\_TEXTURE\_ENV\_MODE**</dt> </dl>                                          | The *params* parameter returns one value: a symbolic constant indicating which texture environment function is currently selected. See [glTexEnv](gltexenv-functions.md).<br/>                                                                                                                                                                                                                                                      |
     * | <span id="GL_TEXTURE_GEN_Q"></span><span id="gl_texture_gen_q"></span><dl> <dt>**GL\_TEXTURE\_GEN\_Q**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether automatic generation of the Q texture coordinate is enabled. See [**glTexGen**](gltexgen-functions.md).<br/>                                                                                                                                                                                                                                               |
     * | <span id="GL_TEXTURE_GEN_R"></span><span id="gl_texture_gen_r"></span><dl> <dt>**GL\_TEXTURE\_GEN\_R**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether automatic generation of the R texture coordinate is enabled. See [**glTexGen**](gltexgen-functions.md).<br/>                                                                                                                                                                                                                                               |
     * | <span id="GL_TEXTURE_GEN_S"></span><span id="gl_texture_gen_s"></span><dl> <dt>**GL\_TEXTURE\_GEN\_S**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether automatic generation of the S texture coordinate is enabled. See [**glTexGen**](gltexgen-functions.md).<br/>                                                                                                                                                                                                                                               |
     * | <span id="GL_TEXTURE_GEN_T"></span><span id="gl_texture_gen_t"></span><dl> <dt>**GL\_TEXTURE\_GEN\_T**</dt> </dl>                                                   | The *params* parameter returns a single Boolean value indicating whether automatic generation of the T texture coordinate is enabled. See [**glTexGen**](gltexgen-functions.md).<br/>                                                                                                                                                                                                                                               |
     * | <span id="GL_TEXTURE_MATRIX"></span><span id="gl_texture_matrix"></span><dl> <dt>**GL\_TEXTURE\_MATRIX**</dt> </dl>                                                 | The *params* parameter returns 16 values: the texture matrix on the top of the texture matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_TEXTURE_STACK_DEPTH"></span><span id="gl_texture_stack_depth"></span><dl> <dt>**GL\_TEXTURE\_STACK\_DEPTH**</dt> </dl>                                 | The *params* parameter returns one value: the number of matrices on the texture matrix stack. See [**glPushMatrix**](glpushmatrix.md).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_UNPACK_ALIGNMENT"></span><span id="gl_unpack_alignment"></span><dl> <dt>**GL\_UNPACK\_ALIGNMENT**</dt> </dl>                                           | The *params* parameter returns one value: the byte alignment used for reading pixel data from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                                           |
     * | <span id="GL_UNPACK_LSB_FIRST"></span><span id="gl_unpack_lsb_first"></span><dl> <dt>**GL\_UNPACK\_LSB\_FIRST**</dt> </dl>                                          | The *params* parameter returns a single Boolean value indicating whether single-bit pixels being read from memory are read first from the least significant bit of each unsigned byte. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                          |
     * | <span id="GL_UNPACK_ROW_LENGTH"></span><span id="gl_unpack_row_length"></span><dl> <dt>**GL\_UNPACK\_ROW\_LENGTH**</dt> </dl>                                       | The *params* parameter returns one value: the row length used for reading pixel data from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                                               |
     * | <span id="GL_UNPACK_SKIP_PIXELS"></span><span id="gl_unpack_skip_pixels"></span><dl> <dt>**GL\_UNPACK\_SKIP\_PIXELS**</dt> </dl>                                    | The *params* parameter returns one value: the number of pixel locations skipped before the first pixel is read from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                                     |
     * | <span id="GL_UNPACK_SKIP_ROWS"></span><span id="gl_unpack_skip_rows"></span><dl> <dt>**GL\_UNPACK\_SKIP\_ROWS**</dt> </dl>                                          | The *params* parameter returns one value: the number of rows of pixel locations skipped before the first pixel is read from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                                                             |
     * | <span id="GL_UNPACK_SWAP_BYTES"></span><span id="gl_unpack_swap_bytes"></span><dl> <dt>**GL\_UNPACK\_SWAP\_BYTES**</dt> </dl>                                       | The *params* parameter returns a single Boolean value indicating whether the bytes of 2-byte and 4-byte pixel indexes and components are swapped after being read from memory. See [glPixelStore](glpixelstore-functions.md).<br/>                                                                                                                                                                                                  |
     * | <span id="GL_VERTEX_ARRAY"></span><span id="gl_vertex_array"></span><dl> <dt>**GL\_VERTEX\_ARRAY**</dt> </dl>                                                       | The *params* parameter returns a single Boolean value indicating whether the vertex array is enabled. See [**glVertexPointer**](glvertexpointer.md).<br/>                                                                                                                                                                                                                                                                           |
     * | <span id="GL_VERTEX_ARRAY_SIZE"></span><span id="gl_vertex_array_size"></span><dl> <dt>**GL\_VERTEX\_ARRAY\_SIZE**</dt> </dl>                                       | The *params* parameter returns one value, the number of coordinates per vertex in the vertex array. See [**glVertexPointer**](glvertexpointer.md).<br/>                                                                                                                                                                                                                                                                             |
     * | <span id="GL_VERTEX_ARRAY_STRIDE"></span><span id="gl_vertex_array_stride"></span><dl> <dt>**GL\_VERTEX\_ARRAY\_STRIDE**</dt> </dl>                                 | The *params* parameter returns one value, the byte offset between consecutive vertexes in the vertex array. See [**glVertexPointer**](glvertexpointer.md).<br/>                                                                                                                                                                                                                                                                     |
     * | <span id="GL_VERTEX_ARRAY_TYPE"></span><span id="gl_vertex_array_type"></span><dl> <dt>**GL\_VERTEX\_ARRAY\_TYPE**</dt> </dl>                                       | The *params* parameter returns one value, the data type of each coordinate in the vertex array. See [**glVertexPointer**](glvertexpointer.md).<br/>                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_VIEWPORT"></span><span id="gl_viewport"></span><dl> <dt>**GL\_VIEWPORT**</dt> </dl>                                                                    | The *params* parameter returns four values: the *x* and *y* window coordinates of the viewport, followed by its width and height. See [**glViewport**](glviewport.md).<br/>                                                                                                                                                                                                                                                         |
     * | <span id="GL_ZOOM_X"></span><span id="gl_zoom_x"></span><dl> <dt>**GL\_ZOOM\_X**</dt> </dl>                                                                         | The *params* parameter returns one value: the *x* pixel zoom factor. See [**glPixelZoom**](glpixelzoom.md).<br/>                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GL_ZOOM_Y"></span><span id="gl_zoom_y"></span><dl> <dt>**GL\_ZOOM\_Y**</dt> </dl>                                                                         | The *params* parameter returns one value: the *y* pixel zoom factor. See [**glPixelZoom**](glpixelzoom.md).<br/>                                                                                                                                                                                                                                                                                                                    |
     * @param {Pointer<Int32>} params Returns the value or values of the specified parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetintegerv
     */
    static glGetIntegerv(pname, params) {
        DllCall("OPENGL32.dll\glGetIntegerv", "uint", pname, "ptr", params)
    }

    /**
     * The glGetLightfv and glGetLightiv functions return light source parameter values. | glGetLightfv function (Gl.h)
     * @remarks
     * The **glGetLight** function returns in *params* the value or values of a light source parameter. The *light* parameter names the light and is a symbolic name of the form GL\_LIGHT*i* for 0 = *i* < GL\_MAX\_LIGHTS, where GL\_MAX\_LIGHTS is an implementation-dependent constant that is greater than or equal to eight. The *pname* parameter specifies one of ten light source parameters, again by symbolic name.
     * 
     * It is always the case that GL\_LIGHT*i* = GL\_LIGHT0 + *i*.
     * 
     * If an error is generated, no change is made to the contents of *params*.
     * @param {Integer} light A light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL\_LIGHT *i* where 0 = *i* < GL\_MAX\_LIGHTS.
     * @param {Integer} pname A light source parameter for *light*. The following symbolic names are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                           | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_AMBIENT"></span><span id="gl_ambient"></span><dl> <dt>**GL\_AMBIENT**</dt> </dl>                                            | The *params* parameter returns four integer or floating-point values representing the ambient intensity of the light source. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range \[-1,1\], the corresponding integer return value is undefined.<br/>                                                                                                                                                                  |
     * | <span id="GL_DIFFUSE"></span><span id="gl_diffuse"></span><dl> <dt>**GL\_DIFFUSE**</dt> </dl>                                            | The *params* parameter returns four integer or floating-point values representing the diffuse intensity of the light source. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range \[-1,1\], the corresponding integer return value is undefined.<br/>                                                                                                                                                                  |
     * | <span id="GL_SPECULAR"></span><span id="gl_specular"></span><dl> <dt>**GL\_SPECULAR**</dt> </dl>                                         | The *params* parameter returns four integer or floating-point values representing the specular intensity of the light source. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range \[-1,1\], the corresponding integer return value is undefined.<br/>                                                                                                                                                                 |
     * | <span id="GL_POSITION"></span><span id="gl_position"></span><dl> <dt>**GL\_POSITION**</dt> </dl>                                         | The *params* parameter returns four integer or floating-point values representing the position of the light source. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer value. The returned values are those maintained in eye coordinates. They will not be equal to the values specified using [**glLight**](gllight-functions.md), unless the modelview matrix was identified at the time **glLight** was called.<br/>                                                                                                                                                             |
     * | <span id="GL_SPOT_DIRECTION"></span><span id="gl_spot_direction"></span><dl> <dt>**GL\_SPOT\_DIRECTION**</dt> </dl>                      | The *params* parameter returns three integer or floating-point values representing the direction of the light source. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer value. The returned values are those maintained in eye coordinates. They will not be equal to the values specified using **glLight**, unless the modelview matrix was identified at the time **glLight** was called. Although spot direction is normalized before being used in the lighting equation, the returned values are the transformed versions of the specified values prior to normalization.<br/> |
     * | <span id="GL_SPOT_EXPONENT"></span><span id="gl_spot_exponent"></span><dl> <dt>**GL\_SPOT\_EXPONENT**</dt> </dl>                         | The *params* parameter returns a single integer or floating-point value representing the spot exponent of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer.<br/>                                                                                                                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_SPOT_CUTOFF"></span><span id="gl_spot_cutoff"></span><dl> <dt>**GL\_SPOT\_CUTOFF**</dt> </dl>                               | The *params* parameter returns a single integer or floating-point value representing the spot cutoff angle of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer.<br/>                                                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_CONSTANT_ATTENUATION"></span><span id="gl_constant_attenuation"></span><dl> <dt>**GL\_CONSTANT\_ATTENUATION**</dt> </dl>    | The *params* parameter returns a single integer or floating-point value representing the constant (not distance-related) attenuation of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer.<br/>                                                                                                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_LINEAR_ATTENUATION"></span><span id="gl_linear_attenuation"></span><dl> <dt>**GL\_LINEAR\_ATTENUATION**</dt> </dl>          | The *params* parameter returns a single integer or floating-point value representing the linear attenuation of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer.<br/>                                                                                                                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_QUADRATIC_ATTENUATION"></span><span id="gl_quadratic_attenuation"></span><dl> <dt>**GL\_QUADRATIC\_ATTENUATION**</dt> </dl> | The *params* parameter returns a single integer or floating-point value representing the quadratic attenuation of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer.<br/>                                                                                                                                                                                                                                                                                                                                                                                        |
     * @param {Pointer<Single>} params Returns the requested data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetlightfv
     */
    static glGetLightfv(light, pname, params) {
        DllCall("OPENGL32.dll\glGetLightfv", "uint", light, "uint", pname, "ptr", params)
    }

    /**
     * The glGetLightfv and glGetLightiv functions return light source parameter values. | glGetLightiv function (Gl.h)
     * @remarks
     * The **glGetLight** function returns in *params* the value or values of a light source parameter. The *light* parameter names the light and is a symbolic name of the form GL\_LIGHT*i* for 0 = *i* < GL\_MAX\_LIGHTS, where GL\_MAX\_LIGHTS is an implementation-dependent constant that is greater than or equal to eight. The *pname* parameter specifies one of ten light source parameters, again by symbolic name.
     * 
     * It is always the case that GL\_LIGHT*i* = GL\_LIGHT0 + *i*.
     * 
     * If an error is generated, no change is made to the contents of *params*.
     * @param {Integer} light A light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL\_LIGHT *i* where 0 = *i* < GL\_MAX\_LIGHTS.
     * @param {Integer} pname A light source parameter for *light*. The following symbolic names are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                           | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_AMBIENT"></span><span id="gl_ambient"></span><dl> <dt>**GL\_AMBIENT**</dt> </dl>                                            | The *params* parameter returns four integer or floating-point values representing the ambient intensity of the light source. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range \[-1,1\], the corresponding integer return value is undefined.<br/>                                                                                                                                                                  |
     * | <span id="GL_DIFFUSE"></span><span id="gl_diffuse"></span><dl> <dt>**GL\_DIFFUSE**</dt> </dl>                                            | The *params* parameter returns four integer or floating-point values representing the diffuse intensity of the light source. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range \[-1,1\], the corresponding integer return value is undefined.<br/>                                                                                                                                                                  |
     * | <span id="GL_SPECULAR"></span><span id="gl_specular"></span><dl> <dt>**GL\_SPECULAR**</dt> </dl>                                         | The *params* parameter returns four integer or floating-point values representing the specular intensity of the light source. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range \[-1,1\], the corresponding integer return value is undefined.<br/>                                                                                                                                                                 |
     * | <span id="GL_POSITION"></span><span id="gl_position"></span><dl> <dt>**GL\_POSITION**</dt> </dl>                                         | The *params* parameter returns four integer or floating-point values representing the position of the light source. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer value. The returned values are those maintained in eye coordinates. They will not be equal to the values specified using [**glLight**](gllight-functions.md), unless the modelview matrix was identified at the time **glLight** was called.<br/>                                                                                                                                                             |
     * | <span id="GL_SPOT_DIRECTION"></span><span id="gl_spot_direction"></span><dl> <dt>**GL\_SPOT\_DIRECTION**</dt> </dl>                      | The *params* parameter returns three integer or floating-point values representing the direction of the light source. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer value. The returned values are those maintained in eye coordinates. They will not be equal to the values specified using **glLight**, unless the modelview matrix was identified at the time **glLight** was called. Although spot direction is normalized before being used in the lighting equation, the returned values are the transformed versions of the specified values prior to normalization.<br/> |
     * | <span id="GL_SPOT_EXPONENT"></span><span id="gl_spot_exponent"></span><dl> <dt>**GL\_SPOT\_EXPONENT**</dt> </dl>                         | The *params* parameter returns a single integer or floating-point value representing the spot exponent of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer.<br/>                                                                                                                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_SPOT_CUTOFF"></span><span id="gl_spot_cutoff"></span><dl> <dt>**GL\_SPOT\_CUTOFF**</dt> </dl>                               | The *params* parameter returns a single integer or floating-point value representing the spot cutoff angle of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer.<br/>                                                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_CONSTANT_ATTENUATION"></span><span id="gl_constant_attenuation"></span><dl> <dt>**GL\_CONSTANT\_ATTENUATION**</dt> </dl>    | The *params* parameter returns a single integer or floating-point value representing the constant (not distance-related) attenuation of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer.<br/>                                                                                                                                                                                                                                                                                                                                                                  |
     * | <span id="GL_LINEAR_ATTENUATION"></span><span id="gl_linear_attenuation"></span><dl> <dt>**GL\_LINEAR\_ATTENUATION**</dt> </dl>          | The *params* parameter returns a single integer or floating-point value representing the linear attenuation of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer.<br/>                                                                                                                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_QUADRATIC_ATTENUATION"></span><span id="gl_quadratic_attenuation"></span><dl> <dt>**GL\_QUADRATIC\_ATTENUATION**</dt> </dl> | The *params* parameter returns a single integer or floating-point value representing the quadratic attenuation of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer.<br/>                                                                                                                                                                                                                                                                                                                                                                                        |
     * @param {Pointer<Int32>} params Returns the requested data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetlightiv
     */
    static glGetLightiv(light, pname, params) {
        DllCall("OPENGL32.dll\glGetLightiv", "uint", light, "uint", pname, "ptr", params)
    }

    /**
     * The glGetMapdv, glGetMapfv, and glGetMapiv functions return evaluator parameters. | glGetMapdv function (Gl.h)
     * @remarks
     * The **glGetMap** function returns evaluator parameters. (The **glMap1** and **glMap2** functions define evaluators.) The *target* parameter specifies a map, *query* selects a specific parameter, and *v* points to storage where the values will be returned.
     * 
     * The acceptable values for the *target* parameter are described in [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md).
     * 
     * If an error is generated, no change is made to the contents of *v*.
     * @param {Integer} target The symbolic name of a map. The following are accepted values: GL\_MAP1\_COLOR\_4, GL\_MAP1\_INDEX, GL\_MAP1\_NORMAL, GL\_MAP1\_TEXTURE\_COORD\_1, GL\_MAP1\_TEXTURE\_COORD\_2, GL\_MAP1\_TEXTURE\_COORD\_3, GL\_MAP1\_TEXTURE\_COORD\_4, GL\_MAP1\_VERTEX\_3, GL\_MAP1\_VERTEX\_4, GL\_MAP2\_COLOR\_4, GL\_MAP2\_INDEX, GL\_MAP2\_NORMAL, GL\_MAP2\_TEXTURE\_COORD\_1, GL\_MAP2\_TEXTURE\_COORD\_2, GL\_MAP2\_TEXTURE\_COORD\_3, GL\_MAP2\_TEXTURE\_COORD\_4, GL\_MAP2\_VERTEX\_3, and GL\_MAP2\_VERTEX\_4.
     * @param {Integer} query Specifies which parameter to return. The following symbolic names are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                             | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
     * |---------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_COEFF"></span><span id="gl_coeff"></span><dl> <dt>**GL\_COEFF**</dt> </dl>    | The *v* parameter returns the control points for the evaluator function. One-dimensional evaluators return *order* control points, and two-dimensional evaluators return *uorder* *x* *vorder* control points. Each control point consists of one, two, three, or four integer, single-precision floating-point, or double-precision floating-point values, depending on the type of the evaluator. Two-dimensional control points are returned in row-major order, incrementing the *uorder* index quickly, and the *vorder* index after each row. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.<br/> |
     * | <span id="GL_ORDER"></span><span id="gl_order"></span><dl> <dt>**GL\_ORDER**</dt> </dl>    | The *v* parameter returns the order of the evaluator function. One-dimensional evaluators return a single value, *order*. Two-dimensional evaluators return two values, *uorder* and *vorder*.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_DOMAIN"></span><span id="gl_domain"></span><dl> <dt>**GL\_DOMAIN**</dt> </dl> | The *v* parameter returns the linear *u* and *v* mapping parameters. One-dimensional evaluators return two values, *u* 1 and *u* 2, as specified by [**glMap1**](glmap1.md). Two-dimensional evaluators return four values (*u1*, *u2*, *v1*, and *v2*) as specified by [**glMap2**](glmap2.md). Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.<br/>                                                                                                                                                                                                                                                  |
     * @param {Pointer<Double>} v Returns the requested data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetmapdv
     */
    static glGetMapdv(target, query, v) {
        DllCall("OPENGL32.dll\glGetMapdv", "uint", target, "uint", query, "ptr", v)
    }

    /**
     * The glGetMapdv, glGetMapfv, and glGetMapiv functions return evaluator parameters. | glGetMapfv function (Gl.h)
     * @remarks
     * The **glGetMap** function returns evaluator parameters. (The **glMap1** and **glMap2** functions define evaluators.) The *target* parameter specifies a map, *query* selects a specific parameter, and *v* points to storage where the values will be returned.
     * 
     * The acceptable values for the *target* parameter are described in [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md).
     * 
     * If an error is generated, no change is made to the contents of *v*.
     * @param {Integer} target The symbolic name of a map. The following are accepted values: GL\_MAP1\_COLOR\_4, GL\_MAP1\_INDEX, GL\_MAP1\_NORMAL, GL\_MAP1\_TEXTURE\_COORD\_1, GL\_MAP1\_TEXTURE\_COORD\_2, GL\_MAP1\_TEXTURE\_COORD\_3, GL\_MAP1\_TEXTURE\_COORD\_4, GL\_MAP1\_VERTEX\_3, GL\_MAP1\_VERTEX\_4, GL\_MAP2\_COLOR\_4, GL\_MAP2\_INDEX, GL\_MAP2\_NORMAL, GL\_MAP2\_TEXTURE\_COORD\_1, GL\_MAP2\_TEXTURE\_COORD\_2, GL\_MAP2\_TEXTURE\_COORD\_3, GL\_MAP2\_TEXTURE\_COORD\_4, GL\_MAP2\_VERTEX\_3, and GL\_MAP2\_VERTEX\_4.
     * @param {Integer} query Specifies which parameter to return. The following symbolic names are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                             | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
     * |---------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_COEFF"></span><span id="gl_coeff"></span><dl> <dt>**GL\_COEFF**</dt> </dl>    | The *v* parameter returns the control points for the evaluator function. One-dimensional evaluators return *order* control points, and two-dimensional evaluators return *uorder* *x* *vorder* control points. Each control point consists of one, two, three, or four integer, single-precision floating-point, or double-precision floating-point values, depending on the type of the evaluator. Two-dimensional control points are returned in row-major order, incrementing the *uorder* index quickly, and the *vorder* index after each row. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.<br/> |
     * | <span id="GL_ORDER"></span><span id="gl_order"></span><dl> <dt>**GL\_ORDER**</dt> </dl>    | The *v* parameter returns the order of the evaluator function. One-dimensional evaluators return a single value, *order*. Two-dimensional evaluators return two values, *uorder* and *vorder*.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_DOMAIN"></span><span id="gl_domain"></span><dl> <dt>**GL\_DOMAIN**</dt> </dl> | The *v* parameter returns the linear *u* and *v* mapping parameters. One-dimensional evaluators return two values, *u* 1 and *u* 2, as specified by [**glMap1**](glmap1.md). Two-dimensional evaluators return four values (*u1*, *u2*, *v1*, and *v2*) as specified by [**glMap2**](glmap2.md). Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.<br/>                                                                                                                                                                                                                                                  |
     * @param {Pointer<Single>} v Returns the requested data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetmapfv
     */
    static glGetMapfv(target, query, v) {
        DllCall("OPENGL32.dll\glGetMapfv", "uint", target, "uint", query, "ptr", v)
    }

    /**
     * The glGetMapdv, glGetMapfv, and glGetMapiv functions return evaluator parameters. | glGetMapiv function (Gl.h)
     * @remarks
     * The **glGetMap** functions return evaluator parameters. (The **glMap1** and **glMap2** functions define evaluators.) The *target* parameter specifies a map, *query* selects a specific parameter, and *v* points to storage where the values will be returned.
     * 
     * The acceptable values for the *target* parameter are described in [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md).
     * 
     * If an error is generated, no change is made to the contents of *v*.
     * @param {Integer} target The symbolic name of a map. The following are accepted values: GL\_MAP1\_COLOR\_4, GL\_MAP1\_INDEX, GL\_MAP1\_NORMAL, GL\_MAP1\_TEXTURE\_COORD\_1, GL\_MAP1\_TEXTURE\_COORD\_2, GL\_MAP1\_TEXTURE\_COORD\_3, GL\_MAP1\_TEXTURE\_COORD\_4, GL\_MAP1\_VERTEX\_3, GL\_MAP1\_VERTEX\_4, GL\_MAP2\_COLOR\_4, GL\_MAP2\_INDEX, GL\_MAP2\_NORMAL, GL\_MAP2\_TEXTURE\_COORD\_1, GL\_MAP2\_TEXTURE\_COORD\_2, GL\_MAP2\_TEXTURE\_COORD\_3, GL\_MAP2\_TEXTURE\_COORD\_4, GL\_MAP2\_VERTEX\_3, and GL\_MAP2\_VERTEX\_4.
     * @param {Integer} query Specifies which parameter to return. The following symbolic names are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                             | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
     * |---------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_COEFF"></span><span id="gl_coeff"></span><dl> <dt>**GL\_COEFF**</dt> </dl>    | The *v* parameter returns the control points for the evaluator function. One-dimensional evaluators return *order* control points, and two-dimensional evaluators return *uorder* *x* *vorder* control points. Each control point consists of one, two, three, or four integer, single-precision floating-point, or double-precision floating-point values, depending on the type of the evaluator. Two-dimensional control points are returned in row-major order, incrementing the *uorder* index quickly, and the *vorder* index after each row. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.<br/> |
     * | <span id="GL_ORDER"></span><span id="gl_order"></span><dl> <dt>**GL\_ORDER**</dt> </dl>    | The *v* parameter returns the order of the evaluator function. One-dimensional evaluators return a single value, *order*. Two-dimensional evaluators return two values, *uorder* and *vorder*.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_DOMAIN"></span><span id="gl_domain"></span><dl> <dt>**GL\_DOMAIN**</dt> </dl> | The *v* parameter returns the linear *u* and *v* mapping parameters. One-dimensional evaluators return two values, *u* 1 and *u* 2, as specified by [**glMap1**](glmap1.md). Two-dimensional evaluators return four values (*u1*, *u2*, *v1*, and *v2*) as specified by [**glMap2**](glmap2.md). Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.<br/>                                                                                                                                                                                                                                                  |
     * @param {Pointer<Int32>} v Returns the requested data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetmapiv
     */
    static glGetMapiv(target, query, v) {
        DllCall("OPENGL32.dll\glGetMapiv", "uint", target, "uint", query, "ptr", v)
    }

    /**
     * The glGetMaterialfv and glGetMaterialiv functions return material parameters. | glGetMaterialfv function (Gl.h)
     * @remarks
     * The **glGetMaterial** function returns in *params* the value or values of parameter *pname* of material *face*.
     * 
     * If an error is generated, no change is made to the contents of *params*.
     * @param {Integer} face Specifies which of the two materials is being queried. GL\_FRONT or GL\_BACK are accepted, representing the front and back materials, respectively.
     * @param {Integer} pname The material parameter to return. The following values are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                   | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_AMBIENT"></span><span id="gl_ambient"></span><dl> <dt>**GL\_AMBIENT**</dt> </dl>                    | The *params* parameter returns four integer or floating-point values representing the ambient reflectance of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range \[-1,1\], the corresponding integer return value is undefined.<br/>     |
     * | <span id="GL_DIFFUSE"></span><span id="gl_diffuse"></span><dl> <dt>**GL\_DIFFUSE**</dt> </dl>                    | The *params* parameter returns four integer or floating-point values representing the diffuse reflectance of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range \[-1,1\], the corresponding integer return value is undefined.<br/>     |
     * | <span id="GL_SPECULAR"></span><span id="gl_specular"></span><dl> <dt>**GL\_SPECULAR**</dt> </dl>                 | The *params* parameter returns four integer or floating-point values representing the specular reflectance of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range \[-1,1\], the corresponding integer return value is undefined.<br/>    |
     * | <span id="GL_EMISSION"></span><span id="gl_emission"></span><dl> <dt>**GL\_EMISSION**</dt> </dl>                 | The *params* parameter returns four integer or floating-point values representing the emitted light intensity of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range \[-1,1\], the corresponding integer return value is undefined.<br/> |
     * | <span id="GL_SHININESS"></span><span id="gl_shininess"></span><dl> <dt>**GL\_SHININESS**</dt> </dl>              | The *params* parameter returns one integer or floating-point value representing the specular exponent of the material. Integer values, when requested, are computed by rounding the internal floating-point value to the nearest integer value.<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_COLOR_INDEXES"></span><span id="gl_color_indexes"></span><dl> <dt>**GL\_COLOR\_INDEXES**</dt> </dl> | The *params* parameter returns three integer or floating-point values representing the ambient, diffuse, and specular indexes of the material. Use these indexes only for color-index lighting. (The other parameters are all used only for RGBA lighting.) Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.<br/>                                                                                            |
     * @param {Pointer<Single>} params Returns the requested data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetmaterialfv
     */
    static glGetMaterialfv(face, pname, params) {
        DllCall("OPENGL32.dll\glGetMaterialfv", "uint", face, "uint", pname, "ptr", params)
    }

    /**
     * The glGetMaterialfv and glGetMaterialiv functions return material parameters. | glGetMaterialiv function (Gl.h)
     * @remarks
     * The **glGetMaterial** function returns in *params* the value or values of parameter *pname* of material *face*.
     * 
     * If an error is generated, no change is made to the contents of *params*.
     * @param {Integer} face Specifies which of the two materials is being queried. GL\_FRONT or GL\_BACK are accepted, representing the front and back materials, respectively.
     * @param {Integer} pname The material parameter to return. The following values are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                   | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_AMBIENT"></span><span id="gl_ambient"></span><dl> <dt>**GL\_AMBIENT**</dt> </dl>                    | The *params* parameter returns four integer or floating-point values representing the ambient reflectance of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range \[-1,1\], the corresponding integer return value is undefined.<br/>     |
     * | <span id="GL_DIFFUSE"></span><span id="gl_diffuse"></span><dl> <dt>**GL\_DIFFUSE**</dt> </dl>                    | The *params* parameter returns four integer or floating-point values representing the diffuse reflectance of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range \[-1,1\], the corresponding integer return value is undefined.<br/>     |
     * | <span id="GL_SPECULAR"></span><span id="gl_specular"></span><dl> <dt>**GL\_SPECULAR**</dt> </dl>                 | The *params* parameter returns four integer or floating-point values representing the specular reflectance of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range \[-1,1\], the corresponding integer return value is undefined.<br/>    |
     * | <span id="GL_EMISSION"></span><span id="gl_emission"></span><dl> <dt>**GL\_EMISSION**</dt> </dl>                 | The *params* parameter returns four integer or floating-point values representing the emitted light intensity of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value. If the internal value is outside the range \[-1,1\], the corresponding integer return value is undefined.<br/> |
     * | <span id="GL_SHININESS"></span><span id="gl_shininess"></span><dl> <dt>**GL\_SHININESS**</dt> </dl>              | The *params* parameter returns one integer or floating-point value representing the specular exponent of the material. Integer values, when requested, are computed by rounding the internal floating-point value to the nearest integer value.<br/>                                                                                                                                                                                                                                   |
     * | <span id="GL_COLOR_INDEXES"></span><span id="gl_color_indexes"></span><dl> <dt>**GL\_COLOR\_INDEXES**</dt> </dl> | The *params* parameter returns three integer or floating-point values representing the ambient, diffuse, and specular indexes of the material. Use these indexes only for color-index lighting. (The other parameters are all used only for RGBA lighting.) Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.<br/>                                                                                            |
     * @param {Pointer<Int32>} params Returns the requested data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetmaterialiv
     */
    static glGetMaterialiv(face, pname, params) {
        DllCall("OPENGL32.dll\glGetMaterialiv", "uint", face, "uint", pname, "ptr", params)
    }

    /**
     * The glGetPixelMapfv, glGetPixelMapuiv, and glGetPixelMapusv functions return the specified pixel map. | glGetPixelMapfv function (Gl.h)
     * @remarks
     * See [**glPixelMap**](glpixelmap.md) for a description of the acceptable values for the *map* parameter. The **glGetPixelMap** function returns in *values* the contents of the pixel map specified in *map*. Use pixel maps during the execution of [**glReadPixels**](glreadpixels.md), [**glDrawPixels**](gldrawpixels.md), [**glCopyPixels**](glcopypixels.md), [**glTexImage1D**](glteximage1d.md), and [**glTexImage2D**](glteximage2d.md) to map color indexes, stencil indexes, color components, and depth components to other values.
     * 
     * Unsigned integer values, if requested, are linearly mapped from the internal fixed or floating-point representation such that 1.0 maps to the largest representable integer value, and 0.0 maps to zero. Return unsigned integer values are undefined if the map value was not in the range \[0,1\].
     * 
     * To determine the required size of *map*, call [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with the appropriate symbolic constant.
     * 
     * If an error is generated, no change is made to the contents of *values*.
     * 
     * The following functions retrieve information related to **glGetPixelMap**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_PIXEL\_MAP\_I\_TO\_I\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_S\_TO\_S\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_R\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_G\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_B\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_A\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_R\_TO\_R\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_G\_TO\_G\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_B\_TO\_B\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_A\_TO\_A\_SIZE
     * 
     * **glGet** with argument GL\_MAX\_PIXEL\_MAP\_TABLE
     * @param {Integer} map The name of the pixel map to return. Accepted values are GL\_PIXEL\_MAP\_I\_TO\_I, GL\_PIXEL\_MAP\_S\_TO\_S, GL\_PIXEL\_MAP\_I\_TO\_R, GL\_PIXEL\_MAP\_I\_TO\_G, GL\_PIXEL\_MAP\_I\_TO\_B, GL\_PIXEL\_MAP\_I\_TO\_A, GL\_PIXEL\_MAP\_R\_TO\_R, GL\_PIXEL\_MAP\_G\_TO\_G, GL\_PIXEL\_MAP\_B\_TO\_B, and GL\_PIXEL\_MAP\_A\_TO\_A.
     * @param {Pointer<Single>} values Returns the pixel map contents.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetpixelmapfv
     */
    static glGetPixelMapfv(map, values) {
        DllCall("OPENGL32.dll\glGetPixelMapfv", "uint", map, "ptr", values)
    }

    /**
     * The glGetPixelMapfv, glGetPixelMapuiv, and glGetPixelMapusv functions return the specified pixel map. | glGetPixelMapuiv function (Gl.h)
     * @remarks
     * See [**glPixelMap**](glpixelmap.md) for a description of the acceptable values for the *map* parameter. The **glGetPixelMap** function returns in *values* the contents of the pixel map specified in *map*. Use pixel maps during the execution of [**glReadPixels**](glreadpixels.md), [**glDrawPixels**](gldrawpixels.md), [**glCopyPixels**](glcopypixels.md), [**glTexImage1D**](glteximage1d.md), and [**glTexImage2D**](glteximage2d.md) to map color indexes, stencil indexes, color components, and depth components to other values.
     * 
     * Unsigned integer values, if requested, are linearly mapped from the internal fixed or floating-point representation such that 1.0 maps to the largest representable integer value, and 0.0 maps to zero. Return unsigned integer values are undefined if the map value was not in the range \[0,1\].
     * 
     * To determine the required size of *map*, call [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with the appropriate symbolic constant.
     * 
     * If an error is generated, no change is made to the contents of *values*.
     * 
     * The following functions retrieve information related to **glGetPixelMap**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_PIXEL\_MAP\_I\_TO\_I\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_S\_TO\_S\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_R\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_G\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_B\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_A\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_R\_TO\_R\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_G\_TO\_G\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_B\_TO\_B\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_A\_TO\_A\_SIZE
     * 
     * **glGet** with argument GL\_MAX\_PIXEL\_MAP\_TABLE
     * @param {Integer} map The name of the pixel map to return. Accepted values are GL\_PIXEL\_MAP\_I\_TO\_I, GL\_PIXEL\_MAP\_S\_TO\_S, GL\_PIXEL\_MAP\_I\_TO\_R, GL\_PIXEL\_MAP\_I\_TO\_G, GL\_PIXEL\_MAP\_I\_TO\_B, GL\_PIXEL\_MAP\_I\_TO\_A, GL\_PIXEL\_MAP\_R\_TO\_R, GL\_PIXEL\_MAP\_G\_TO\_G, GL\_PIXEL\_MAP\_B\_TO\_B, and GL\_PIXEL\_MAP\_A\_TO\_A.
     * @param {Pointer<UInt32>} values Returns the pixel map contents.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetpixelmapuiv
     */
    static glGetPixelMapuiv(map, values) {
        DllCall("OPENGL32.dll\glGetPixelMapuiv", "uint", map, "ptr", values)
    }

    /**
     * The glGetPixelMapfv, glGetPixelMapuiv, and glGetPixelMapusv functions return the specified pixel map. | glGetPixelMapusv function (Gl.h)
     * @remarks
     * See [**glPixelMap**](glpixelmap.md) for a description of the acceptable values for the *map* parameter. The **glGetPixelMap** function returns in *values* the contents of the pixel map specified in *map*. Use pixel maps during the execution of [**glReadPixels**](glreadpixels.md), [**glDrawPixels**](gldrawpixels.md), [**glCopyPixels**](glcopypixels.md), [**glTexImage1D**](glteximage1d.md), and [**glTexImage2D**](glteximage2d.md) to map color indexes, stencil indexes, color components, and depth components to other values.
     * 
     * Unsigned integer values, if requested, are linearly mapped from the internal fixed or floating-point representation such that 1.0 maps to the largest representable integer value, and 0.0 maps to zero. Return unsigned integer values are undefined if the map value was not in the range \[0,1\].
     * 
     * To determine the required size of *map*, call [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with the appropriate symbolic constant.
     * 
     * If an error is generated, no change is made to the contents of *values*.
     * 
     * The following functions retrieve information related to **glGetPixelMap**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_PIXEL\_MAP\_I\_TO\_I\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_S\_TO\_S\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_R\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_G\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_B\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_A\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_R\_TO\_R\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_G\_TO\_G\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_B\_TO\_B\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_A\_TO\_A\_SIZE
     * 
     * **glGet** with argument GL\_MAX\_PIXEL\_MAP\_TABLE
     * @param {Integer} map The name of the pixel map to return. Accepted values are GL\_PIXEL\_MAP\_I\_TO\_I, GL\_PIXEL\_MAP\_S\_TO\_S, GL\_PIXEL\_MAP\_I\_TO\_R, GL\_PIXEL\_MAP\_I\_TO\_G, GL\_PIXEL\_MAP\_I\_TO\_B, GL\_PIXEL\_MAP\_I\_TO\_A, GL\_PIXEL\_MAP\_R\_TO\_R, GL\_PIXEL\_MAP\_G\_TO\_G, GL\_PIXEL\_MAP\_B\_TO\_B, and GL\_PIXEL\_MAP\_A\_TO\_A.
     * @param {Pointer<UInt16>} values Returns the pixel map contents.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetpixelmapusv
     */
    static glGetPixelMapusv(map, values) {
        DllCall("OPENGL32.dll\glGetPixelMapusv", "uint", map, "ptr", values)
    }

    /**
     * The glGetPointerv function returns the address of a vertex data array.
     * @remarks
     * The **glGetPointerv** function returns array pointer information. The *pname* parameter is a symbolic constant specifying the kind of array pointer to return, and *params* is a pointer to a location to place the returned data.
     * @param {Integer} pname The type of array pointer to return from the following symbolic constants: GL\_COLOR\_ARRAY\_POINTER, GL\_EDGE\_FLAG\_ARRAY\_POINTER, GL\_FEEDBACK\_BUFFER\_POINTER, GL\_INDEX\_ARRAY\_POINTER, GL\_NORMAL\_ARRAY\_POINTER, GL\_TEXTURE\_COORD\_ARRAY\_POINTER, GL\_SELECTION\_BUFFER\_POINTER, and GL\_VERTEX\_ARRAY\_POINTER.
     * @param {Pointer<Void>} params Returns the value of the array pointer specified by *pname*.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetpointerv
     */
    static glGetPointerv(pname, params) {
        DllCall("OPENGL32.dll\glGetPointerv", "uint", pname, "ptr", params)
    }

    /**
     * The glGetPolygonStipple function returns the polygon stipple pattern.
     * @remarks
     * The **glGetPolygonStipple** function returns a 32x32 polygon stipple pattern through the *mask* parameter. The pattern is packed into memory as if [**glReadPixels**](glreadpixels.md) with both *height* and *width* of 32, *type* of GL\_BITMAP, and *format* of GL\_COLOR\_INDEX were called, and the stipple pattern were stored in an internal 32x32 color-index buffer. Unlike **glReadPixels**, however, pixel-transfer operations (shift, offset, and pixel map) are not applied to the returned stipple image.
     * 
     * If an error is generated, no change is made to the contents of *mask*.
     * @param {Pointer<Byte>} mask Returns the stipple pattern.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetpolygonstipple
     */
    static glGetPolygonStipple(mask) {
        DllCall("OPENGL32.dll\glGetPolygonStipple", "ptr", mask)
    }

    /**
     * The glGetString function returns a string describing the current OpenGL connection.
     * @remarks
     * The **glGetString** function returns a pointer to a static string describing some aspect of the current OpenGL connection.
     * 
     * Because OpenGL does not include queries for the performance characteristics of an implementation, it is expected that some applications will be written to recognize known platforms and will modify their OpenGL usage based on known performance characteristics of these platforms. The strings GL\_VENDOR and GL\_RENDERER together uniquely specify a platform, and will not change from release to release. They should be used as such by platform recognition algorithms.
     * 
     * The format and contents of the string that **glGetString** returns depend on the implementation, except that:
     * 
     * -   Extension names will not include space characters and will be separated by space characters in the GL\_EXTENSIONS string.
     * -   The GL\_VERSION string begins with a version number. The version number uses one of these forms:
     * 
     *     *major\_number*.*minor\_number*
     * 
     *     *major\_number*.*minor\_number*.*release\_number*
     * 
     * -   Vendor-specific information may follow the version number. Its format depends on the implementation, but a space always separates the version number and the vendor-specific information.
     * -   All strings are null-terminated.
     * 
     * If an error is generated, **glGetString** returns zero.
     * @param {Integer} name One of the following symbolic constants.
     * 
     * 
     * 
     * | Value                                                                                                                                                         | Meaning                                                                                                                                                                        |
     * |---------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_VENDOR"></span><span id="gl_vendor"></span><dl> <dt>**GL\_VENDOR**</dt> </dl>             | Returns the company responsible for this OpenGL implementation. This name does not change from release to release.<br/>                                                  |
     * | <span id="GL_RENDERER"></span><span id="gl_renderer"></span><dl> <dt>**GL\_RENDERER**</dt> </dl>       | Returns the name of the renderer. This name is typically specific to a particular configuration of a hardware platform. It does not change from release to release.<br/> |
     * | <span id="GL_VERSION"></span><span id="gl_version"></span><dl> <dt>**GL\_VERSION**</dt> </dl>          | Returns a version or release number.<br/>                                                                                                                                |
     * | <span id="GL_EXTENSIONS"></span><span id="gl_extensions"></span><dl> <dt>**GL\_EXTENSIONS**</dt> </dl> | Returns a space-separated list of supported extensions to OpenGL.<br/>                                                                                                   |
     * @returns {Pointer<Byte>} 
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetstring
     */
    static glGetString(name) {
        result := DllCall("OPENGL32.dll\glGetString", "uint", name, "ptr")
        return result
    }

    /**
     * The glGetTexEnvfv and glGetTexEnviv functions return texture environment parameters. | glGetTexEnvfv function (Gl.h)
     * @remarks
     * The **glGetTexEnv** function returns in *params* selected values of a texture environment that was specified with [**glTexEnv**](gltexenv-functions.md). The *target* parameter specifies a texture environment. Currently, only one texture environment is defined and supported: GL\_TEXTURE\_ENV.
     * 
     * The *pname* parameter names a specific texture environment parameter.
     * 
     * If an error is generated, no change is made to the contents of *params*.
     * @param {Integer} target A texture environment. Must be GL\_TEXTURE\_ENV.
     * @param {Integer} pname The symbolic name of a texture environment parameter. The following values are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                | Meaning                                                                                                                                                                                                                                                                                                                                              |
     * |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_TEXTURE_ENV_MODE"></span><span id="gl_texture_env_mode"></span><dl> <dt>**GL\_TEXTURE\_ENV\_MODE**</dt> </dl>    | The *params* parameter returns the single-valued texture environment mode, a symbolic constant.<br/>                                                                                                                                                                                                                                           |
     * | <span id="GL_TEXTURE_ENV_COLOR"></span><span id="gl_texture_env_color"></span><dl> <dt>**GL\_TEXTURE\_ENV\_COLOR**</dt> </dl> | The *params* parameter returns four integer or floating-point values that are the texture environment color. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer, and -1.0 maps to the most negative representable integer.<br/> |
     * @param {Pointer<Single>} params Returns the requested data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgettexenvfv
     */
    static glGetTexEnvfv(target, pname, params) {
        DllCall("OPENGL32.dll\glGetTexEnvfv", "uint", target, "uint", pname, "ptr", params)
    }

    /**
     * The glGetTexEnvfv and glGetTexEnviv functions return texture environment parameters. | glGetTexEnviv function (Gl.h)
     * @remarks
     * The **glGetTexEnv** function returns in *params* selected values of a texture environment that was specified with [**glTexEnv**](gltexenv-functions.md). The *target* parameter specifies a texture environment. Currently, only one texture environment is defined and supported: GL\_TEXTURE\_ENV.
     * 
     * The *pname* parameter names a specific texture environment parameter.
     * 
     * If an error is generated, no change is made to the contents of *params*.
     * @param {Integer} target A texture environment. Must be GL\_TEXTURE\_ENV.
     * @param {Integer} pname The symbolic name of a texture environment parameter. The following values are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                | Meaning                                                                                                                                                                                                                                                                                                                                              |
     * |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_TEXTURE_ENV_MODE"></span><span id="gl_texture_env_mode"></span><dl> <dt>**GL\_TEXTURE\_ENV\_MODE**</dt> </dl>    | The *params* parameter returns the single-valued texture environment mode, a symbolic constant.<br/>                                                                                                                                                                                                                                           |
     * | <span id="GL_TEXTURE_ENV_COLOR"></span><span id="gl_texture_env_color"></span><dl> <dt>**GL\_TEXTURE\_ENV\_COLOR**</dt> </dl> | The *params* parameter returns four integer or floating-point values that are the texture environment color. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer, and -1.0 maps to the most negative representable integer.<br/> |
     * @param {Pointer<Int32>} params Returns the requested data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgettexenviv
     */
    static glGetTexEnviv(target, pname, params) {
        DllCall("OPENGL32.dll\glGetTexEnviv", "uint", target, "uint", pname, "ptr", params)
    }

    /**
     * The glGetTexGendv, glGetTexGenfv, and glGetTexGeniv functions return texture coordinate generation parameters. | glGetTexGendv function (Gl.h)
     * @remarks
     * The **glGetTexGen** function returns in *params* selected parameters of a texture-coordinate generation function that you specified with **glTexGen**. The *coord* parameter names one of the (*s*, *t*, *r*, *q*) texture coordinates, using the symbolic constant GL\_S, GL\_T, GL\_R, or GL\_Q.
     * 
     * If an error is generated, no change is made to the contents of *params*.
     * @param {Integer} coord A texture coordinate. Must be GL\_S, GL\_T, GL\_R, or GL\_Q.
     * @param {Integer} pname The symbolic name of the value(s) to be returned. Must be either GL\_TEXTURE\_GEN\_MODE or the name of one of the texture generation plane equations: GL\_OBJECT\_PLANE or GL\_EYE\_PLANE. These values are as follows.
     * 
     * 
     * 
     * | Value                                                                                                                                                                             | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_TEXTURE_GEN_MODE"></span><span id="gl_texture_gen_mode"></span><dl> <dt>**GL\_TEXTURE\_GEN\_MODE**</dt> </dl> | The *params* parameter returns the single-valued texture generation function, a symbolic constant.<br/>                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_OBJECT_PLANE"></span><span id="gl_object_plane"></span><dl> <dt>**GL\_OBJECT\_PLANE**</dt> </dl>              | The *params* parameter returns the four plane equation coefficients that specify object linear-coordinate generation. Integer values, when requested, are mapped directly from the internal floating-point representation.<br/>                                                                                                                                                                                                                                    |
     * | <span id="GL_EYE_PLANE"></span><span id="gl_eye_plane"></span><dl> <dt>**GL\_EYE\_PLANE**</dt> </dl>                       | The *params* parameter returns the four plane equation coefficients that specify eye linear-coordinate generation. Integer values, when requested, are mapped directly from the internal floating-point representation. The returned values are those maintained in eye coordinates. They are not equal to the values specified using [**glTexGen**](gltexgen-functions.md), unless the modelview matrix was identified at the time **glTexGen** was called.<br/> |
     * @param {Pointer<Double>} params Returns the requested data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgettexgendv
     */
    static glGetTexGendv(coord, pname, params) {
        DllCall("OPENGL32.dll\glGetTexGendv", "uint", coord, "uint", pname, "ptr", params)
    }

    /**
     * The glGetTexGendv, glGetTexGenfv, and glGetTexGeniv functions return texture coordinate generation parameters. | glGetTexGenfv function (Gl.h)
     * @remarks
     * The **glGetTexGen** function returns in *params* selected parameters of a texture-coordinate generation function that you specified with **glTexGen**. The *coord* parameter names one of the (*s*, *t*, *r*, *q*) texture coordinates, using the symbolic constant GL\_S, GL\_T, GL\_R, or GL\_Q.
     * 
     * If an error is generated, no change is made to the contents of *params*.
     * @param {Integer} coord A texture coordinate. Must be GL\_S, GL\_T, GL\_R, or GL\_Q.
     * @param {Integer} pname The symbolic name of the value(s) to be returned. Must be either GL\_TEXTURE\_GEN\_MODE or the name of one of the texture generation plane equations: GL\_OBJECT\_PLANE or GL\_EYE\_PLANE. These values are as follows.
     * 
     * 
     * 
     * | Value                                                                                                                                                                             | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_TEXTURE_GEN_MODE"></span><span id="gl_texture_gen_mode"></span><dl> <dt>**GL\_TEXTURE\_GEN\_MODE**</dt> </dl> | The *params* parameter returns the single-valued texture generation function, a symbolic constant.<br/>                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_OBJECT_PLANE"></span><span id="gl_object_plane"></span><dl> <dt>**GL\_OBJECT\_PLANE**</dt> </dl>              | The *params* parameter returns the four plane equation coefficients that specify object linear-coordinate generation. Integer values, when requested, are mapped directly from the internal floating-point representation.<br/>                                                                                                                                                                                                                                    |
     * | <span id="GL_EYE_PLANE"></span><span id="gl_eye_plane"></span><dl> <dt>**GL\_EYE\_PLANE**</dt> </dl>                       | The *params* parameter returns the four plane equation coefficients that specify eye linear-coordinate generation. Integer values, when requested, are mapped directly from the internal floating-point representation. The returned values are those maintained in eye coordinates. They are not equal to the values specified using [**glTexGen**](gltexgen-functions.md), unless the modelview matrix was identified at the time **glTexGen** was called.<br/> |
     * @param {Pointer<Single>} params Returns the requested data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgettexgenfv
     */
    static glGetTexGenfv(coord, pname, params) {
        DllCall("OPENGL32.dll\glGetTexGenfv", "uint", coord, "uint", pname, "ptr", params)
    }

    /**
     * The glGetTexGendv, glGetTexGenfv, and glGetTexGeniv functions return texture coordinate generation parameters. | glGetTexGeniv function (Gl.h)
     * @remarks
     * The **glGetTexGen** function returns in *params* selected parameters of a texture-coordinate generation function that you specified with **glTexGen**. The *coord* parameter names one of the (*s*, *t*, *r*, *q*) texture coordinates, using the symbolic constant GL\_S, GL\_T, GL\_R, or GL\_Q.
     * 
     * If an error is generated, no change is made to the contents of *params*.
     * @param {Integer} coord A texture coordinate. Must be GL\_S, GL\_T, GL\_R, or GL\_Q.
     * @param {Integer} pname The symbolic name of the value(s) to be returned. Must be either GL\_TEXTURE\_GEN\_MODE or the name of one of the texture generation plane equations: GL\_OBJECT\_PLANE or GL\_EYE\_PLANE. These values are as follows.
     * 
     * 
     * 
     * | Value                                                                                                                                                                             | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_TEXTURE_GEN_MODE"></span><span id="gl_texture_gen_mode"></span><dl> <dt>**GL\_TEXTURE\_GEN\_MODE**</dt> </dl> | The *params* parameter returns the single-valued texture generation function, a symbolic constant.<br/>                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_OBJECT_PLANE"></span><span id="gl_object_plane"></span><dl> <dt>**GL\_OBJECT\_PLANE**</dt> </dl>              | The *params* parameter returns the four plane equation coefficients that specify object linear-coordinate generation. Integer values, when requested, are mapped directly from the internal floating-point representation.<br/>                                                                                                                                                                                                                                    |
     * | <span id="GL_EYE_PLANE"></span><span id="gl_eye_plane"></span><dl> <dt>**GL\_EYE\_PLANE**</dt> </dl>                       | The *params* parameter returns the four plane equation coefficients that specify eye linear-coordinate generation. Integer values, when requested, are mapped directly from the internal floating-point representation. The returned values are those maintained in eye coordinates. They are not equal to the values specified using [**glTexGen**](gltexgen-functions.md), unless the modelview matrix was identified at the time **glTexGen** was called.<br/> |
     * @param {Pointer<Int32>} params Returns the requested data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgettexgeniv
     */
    static glGetTexGeniv(coord, pname, params) {
        DllCall("OPENGL32.dll\glGetTexGeniv", "uint", coord, "uint", pname, "ptr", params)
    }

    /**
     * The glGetTexImage function returns a texture image.
     * @remarks
     * The **glGetTexImage** function returns a texture image into *pixels*. The *target* parameter specifies whether the desired texture image is one specified by [**glTexImage1D**](glteximage1d.md)**(**GL\_TEXTURE\_1D**)** or by [**glTexImage2D**](glteximage2d.md)**(**GL\_TEXTURE\_2D**)**. The *level* parameter specifies the level-of-detail number of the desired image. The *format* and *type* parameters specify the format and type of the desired image array. For a description of the acceptable values for the *format* and *type* parameters, respectively, see **glTexImage1D** and [**glDrawPixels**](gldrawpixels.md).
     * 
     * Operation of **glGetTexImage** is best understood by considering the selected internal four-component texture image to be an RGBA color buffer the size of the image. The semantics of **glGetTexImage** are then identical to those of [**glReadPixels**](glreadpixels.md) called with the same *format* and *type*, with *x* and *y* set to zero, *width* set to the width of the texture image (including border if one was specified), and *height* set to one for 1-D images, or to the height of the texture image (including border, if one was specified) for 2-D images.
     * 
     * Because the internal texture image is an RGBA image, pixel formats GL\_COLOR\_INDEX, GL\_STENCIL\_INDEX, and GL\_DEPTH\_COMPONENT are not accepted, and pixel type GL\_BITMAP is not accepted.
     * 
     * If the selected texture image does not contain four components, the following mappings are applied. Single-component textures are treated as RGBA buffers with red set to the single-component value, and green, blue, and alpha set to zero.
     * 
     * Two-component textures are treated as RGBA buffers, with red set to the value of component zero, alpha set to the value of component one, and green and blue set to zero. Finally, three-component textures are treated as RGBA buffers with red set to component zero, green set to component one, blue set to component two, and alpha set to zero.
     * 
     * To determine the required size of *pixels*, use [**glGetTexLevelParameter**](glgettexlevelparameter.md) to ascertain the dimensions of the internal texture image, and then scale the required number of pixels by the storage required for each pixel, based on *format* and *type*. Be sure to take the pixel-storage parameters into account, especially GL\_PACK\_ALIGNMENT.
     * 
     * If an error is generated, no change is made to the contents of *pixels*.
     * 
     * The following functions retrieve information related to **glGetTexImage**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_PACK\_ALIGNMENT and others
     * 
     * [**glGetTexLevelParameter**](glgettexlevelparameter.md) with argument GL\_TEXTURE\_WIDTH
     * 
     * **glGetTexLevelParameter** with argument GL\_TEXTURE\_HEIGHT
     * 
     * **glGetTexLevelParameter** with argument GL\_TEXTURE\_BORDER
     * 
     * **glGetTexLevelParameter** with argument GL\_TEXTURE\_COMPONENTS
     * @param {Integer} target Specifies which texture is to be obtained. GL\_TEXTURE\_1D and GL\_TEXTURE\_2D are accepted.
     * @param {Integer} level The level-of-detail number of the desired image. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.
     * @param {Integer} format A pixel format for the returned data. The supported formats are GL\_RED, GL\_GREEN, GL\_BLUE, GL\_ALPHA, GL\_RGB, GL\_RGBA, GL\_LUMINANCE, GL\_BGR\_EXT, GL\_BGRA\_EXT, and GL\_LUMINANCE\_ALPHA.
     * @param {Integer} type A pixel type for the returned data. The supported types are GL\_UNSIGNED\_BYTE, GL\_BYTE, GL\_UNSIGNED\_SHORT, GL\_SHORT, GL\_UNSIGNED\_INT, GL\_INT, and GL\_FLOAT.
     * @param {Pointer<Void>} pixels Returns the texture image. Should be a pointer to an array of the type specified by *type*.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgetteximage
     */
    static glGetTexImage(target, level, format, type, pixels) {
        DllCall("OPENGL32.dll\glGetTexImage", "uint", target, "int", level, "uint", format, "uint", type, "ptr", pixels)
    }

    /**
     * The glGetTexLevelParameterfv and glGetTexLevelParameteriv functions return texture parameter values for a specific level of detail. | glGetTexLevelParameterfv function (Gl.h)
     * @remarks
     * The **glGetTexLevelParameter** function returns in *params* texture parameter values for a specific level-of-detail value, specified as *level*. The *target* parameter defines the target texture, either GL\_TEXTURE\_1D, GL\_TEXTURE\_2D, GL\_PROXY\_TEXTURE\_1D, or GL\_PROXY\_TEXTURE\_2D to specify one-dimensional or two-dimensional texturing. The *pname* parameter specifies the texture parameter whose value or values will be returned.
     * 
     * If an error is generated, no change is made to the contents of *params*.
     * @param {Integer} target The symbolic name of the target texture: either GL\_TEXTURE\_1D, GL\_TEXTURE\_2D, GL\_PROXY\_TEXTURE\_1D, or GL\_PROXY\_TEXTURE\_2D.
     * @param {Integer} level The level-of-detail number of the desired image. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.
     * @param {Integer} pname The symbolic name of a texture parameter. The following parameter names are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                  | Meaning                                                                                                                                                                                                                                                                                           |
     * |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_TEXTURE_WIDTH"></span><span id="gl_texture_width"></span><dl> <dt>**GL\_TEXTURE\_WIDTH**</dt> </dl>                                | The *params* parameter returns a single value containing the width of the texture image. This value includes the border of the texture image.<br/>                                                                                                                                          |
     * | <span id="GL_TEXTURE_HEIGHT"></span><span id="gl_texture_height"></span><dl> <dt>**GL\_TEXTURE\_HEIGHT**</dt> </dl>                             | The *params* parameter returns a single value containing the height of the texture image. This value includes the border of the texture image.<br/>                                                                                                                                         |
     * | <span id="GL_TEXTURE_INTERNAL_FORMAT"></span><span id="gl_texture_internal_format"></span><dl> <dt>**GL\_TEXTURE\_INTERNAL\_FORMAT**</dt> </dl> | The *params* parameter returns a single value which describes the texel format of the texture.<br/>                                                                                                                                                                                         |
     * | <span id="GL_TEXTURE_BORDER"></span><span id="gl_texture_border"></span><dl> <dt>**GL\_TEXTURE\_BORDER**</dt> </dl>                             | The *params* parameter returns a single value: the width in pixels of the border of the texture image.<br/>                                                                                                                                                                                 |
     * | <span id="GL_TEXTURE_RED_SIZE"></span><span id="gl_texture_red_size"></span><dl> <dt>**GL\_TEXTURE\_RED\_SIZE**</dt> </dl>                      | The internal storage resolution of the red component of a texel. The resolution chosen by the OpenGL will be a close match for the resolution requested by the user with the component argument of [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md).<br/>       |
     * | <span id="GL_TEXTURE_GREEN_SIZE"></span><span id="gl_texture_green_size"></span><dl> <dt>**GL\_TEXTURE\_GREEN\_SIZE**</dt> </dl>                | The internal storage resolution of the green component of a texel. The resolution chosen by the OpenGL will be a close match for the resolution requested by the user with the component argument of [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md).<br/>     |
     * | <span id="GL_TEXTURE_BLUE_SIZE"></span><span id="gl_texture_blue_size"></span><dl> <dt>**GL\_TEXTURE\_BLUE\_SIZE**</dt> </dl>                   | The internal storage resolution of the blue component of a texel. The resolution chosen by the OpenGL will be a close match for the resolution requested by the user with the component argument of [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md).<br/>      |
     * | <span id="GL_TEXTURE_ALPHA_SIZE"></span><span id="gl_texture_alpha_size"></span><dl> <dt>**GL\_TEXTURE\_ALPHA\_SIZE**</dt> </dl>                | The internal storage resolution of the alpha component of a texel. The resolution chosen by the OpenGL will be a close match for the resolution requested by the user with the component argument of [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md).<br/>     |
     * | <span id="GL_TEXTURE_LUMINANCE_SIZE"></span><span id="gl_texture_luminance_size"></span><dl> <dt>**GL\_TEXTURE\_LUMINANCE\_SIZE**</dt> </dl>    | The internal storage resolution of the luminance component of a texel. The resolution chosen by the OpenGL will be a close match for the resolution requested by the user with the component argument of [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md).<br/> |
     * | <span id="GL_TEXTURE_INTENSITY_SIZE"></span><span id="gl_texture_intensity_size"></span><dl> <dt>**GL\_TEXTURE\_INTENSITY\_SIZE**</dt> </dl>    | The internal storage resolution of the intensity component of a texel. The resolution chosen by the OpenGL will be a close match for the resolution requested by the user with the component argument of [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md).<br/> |
     * | <span id="GL_TEXTURE_COMPONENTS"></span><span id="gl_texture_components"></span><dl> <dt>**GL\_TEXTURE\_COMPONENTS**</dt> </dl>                 | The *params* parameter returns a single value: the number of components in the texture image.<br/>                                                                                                                                                                                          |
     * @param {Pointer<Single>} params Returns the requested data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgettexlevelparameterfv
     */
    static glGetTexLevelParameterfv(target, level, pname, params) {
        DllCall("OPENGL32.dll\glGetTexLevelParameterfv", "uint", target, "int", level, "uint", pname, "ptr", params)
    }

    /**
     * The glGetTexLevelParameterfv and glGetTexLevelParameteriv functions return texture parameter values for a specific level of detail. | glGetTexLevelParameteriv function (Gl.h)
     * @remarks
     * The **glGetTexLevelParameter** function returns in *params* texture parameter values for a specific level-of-detail value, specified as *level*. The *target* parameter defines the target texture, either GL\_TEXTURE\_1D, GL\_TEXTURE\_2D, GL\_PROXY\_TEXTURE\_1D, or GL\_PROXY\_TEXTURE\_2D to specify one-dimensional or two-dimensional texturing. The *pname* parameter specifies the texture parameter whose value or values will be returned.
     * 
     * If an error is generated, no change is made to the contents of *params*.
     * @param {Integer} target The symbolic name of the target texture: either GL\_TEXTURE\_1D, GL\_TEXTURE\_2D, GL\_PROXY\_TEXTURE\_1D, or GL\_PROXY\_TEXTURE\_2D.
     * @param {Integer} level The level-of-detail number of the desired image. Level 0 is the base image level. Level *n* is the *n*th mipmap reduction image.
     * @param {Integer} pname The symbolic name of a texture parameter. The following parameter names are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                  | Meaning                                                                                                                                                                                                                                                                                           |
     * |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_TEXTURE_WIDTH"></span><span id="gl_texture_width"></span><dl> <dt>**GL\_TEXTURE\_WIDTH**</dt> </dl>                                | The *params* parameter returns a single value containing the width of the texture image. This value includes the border of the texture image.<br/>                                                                                                                                          |
     * | <span id="GL_TEXTURE_HEIGHT"></span><span id="gl_texture_height"></span><dl> <dt>**GL\_TEXTURE\_HEIGHT**</dt> </dl>                             | The *params* parameter returns a single value containing the height of the texture image. This value includes the border of the texture image.<br/>                                                                                                                                         |
     * | <span id="GL_TEXTURE_INTERNAL_FORMAT"></span><span id="gl_texture_internal_format"></span><dl> <dt>**GL\_TEXTURE\_INTERNAL\_FORMAT**</dt> </dl> | The *params* parameter returns a single value which describes the texel format of the texture.<br/>                                                                                                                                                                                         |
     * | <span id="GL_TEXTURE_BORDER"></span><span id="gl_texture_border"></span><dl> <dt>**GL\_TEXTURE\_BORDER**</dt> </dl>                             | The *params* parameter returns a single value: the width in pixels of the border of the texture image.<br/>                                                                                                                                                                                 |
     * | <span id="GL_TEXTURE_RED_SIZE"></span><span id="gl_texture_red_size"></span><dl> <dt>**GL\_TEXTURE\_RED\_SIZE**</dt> </dl>                      | The internal storage resolution of the red component of a texel. The resolution chosen by the OpenGL will be a close match for the resolution requested by the user with the component argument of [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md).<br/>       |
     * | <span id="GL_TEXTURE_GREEN_SIZE"></span><span id="gl_texture_green_size"></span><dl> <dt>**GL\_TEXTURE\_GREEN\_SIZE**</dt> </dl>                | The internal storage resolution of the green component of a texel. The resolution chosen by the OpenGL will be a close match for the resolution requested by the user with the component argument of [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md).<br/>     |
     * | <span id="GL_TEXTURE_BLUE_SIZE"></span><span id="gl_texture_blue_size"></span><dl> <dt>**GL\_TEXTURE\_BLUE\_SIZE**</dt> </dl>                   | The internal storage resolution of the blue component of a texel. The resolution chosen by the OpenGL will be a close match for the resolution requested by the user with the component argument of [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md).<br/>      |
     * | <span id="GL_TEXTURE_ALPHA_SIZE"></span><span id="gl_texture_alpha_size"></span><dl> <dt>**GL\_TEXTURE\_ALPHA\_SIZE**</dt> </dl>                | The internal storage resolution of the alpha component of a texel. The resolution chosen by the OpenGL will be a close match for the resolution requested by the user with the component argument of [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md).<br/>     |
     * | <span id="GL_TEXTURE_LUMINANCE_SIZE"></span><span id="gl_texture_luminance_size"></span><dl> <dt>**GL\_TEXTURE\_LUMINANCE\_SIZE**</dt> </dl>    | The internal storage resolution of the luminance component of a texel. The resolution chosen by the OpenGL will be a close match for the resolution requested by the user with the component argument of [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md).<br/> |
     * | <span id="GL_TEXTURE_INTENSITY_SIZE"></span><span id="gl_texture_intensity_size"></span><dl> <dt>**GL\_TEXTURE\_INTENSITY\_SIZE**</dt> </dl>    | The internal storage resolution of the intensity component of a texel. The resolution chosen by the OpenGL will be a close match for the resolution requested by the user with the component argument of [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md).<br/> |
     * | <span id="GL_TEXTURE_COMPONENTS"></span><span id="gl_texture_components"></span><dl> <dt>**GL\_TEXTURE\_COMPONENTS**</dt> </dl>                 | The *params* parameter returns a single value: the number of components in the texture image.<br/>                                                                                                                                                                                          |
     * @param {Pointer<Int32>} params Returns the requested data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgettexlevelparameteriv
     */
    static glGetTexLevelParameteriv(target, level, pname, params) {
        DllCall("OPENGL32.dll\glGetTexLevelParameteriv", "uint", target, "int", level, "uint", pname, "ptr", params)
    }

    /**
     * The glGetTexParameterfv and glGetTexParameteriv functions return texture parameter values. | glGetTexParameterfv function (Gl.h)
     * @remarks
     * The **glGetTexParameter** function returns in *params* the value or values of the texture parameter specified as *pname*. The *target* parameter defines the target texture, either GL\_TEXTURE\_1D or GL\_TEXTURE\_2D, to specify one-dimensional or two-dimensional texturing. The *pname* parameter accepts the same symbols as [**glTexParameter**](gltexparameter-functions.md), with the same interpretations.
     * 
     * If an error is generated, no change is made to the contents of *params*.
     * @param {Integer} target The symbolic name of the target texture. GL\_TEXTURE\_1D and GL\_TEXTURE\_2D are accepted.
     * @param {Integer} pname The symbolic name of a texture parameter. The following values are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                         | Meaning                                                                                                                                                                                                                                                                                                                                                                                      |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_TEXTURE_MAG_FILTER"></span><span id="gl_texture_mag_filter"></span><dl> <dt>**GL\_TEXTURE\_MAG\_FILTER**</dt> </dl>       | Returns the single-valued texture magnification filter, a symbolic constant.<br/>                                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_TEXTURE_MIN_FILTER"></span><span id="gl_texture_min_filter"></span><dl> <dt>**GL\_TEXTURE\_MIN\_FILTER**</dt> </dl>       | Returns the single-valued texture minification filter, a symbolic constant.<br/>                                                                                                                                                                                                                                                                                                       |
     * | <span id="GL_TEXTURE_WRAP_S"></span><span id="gl_texture_wrap_s"></span><dl> <dt>**GL\_TEXTURE\_WRAP\_S**</dt> </dl>                   | Returns the single-valued wrapping function for texture coordinate *s*, a symbolic constant.<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_TEXTURE_WRAP_T"></span><span id="gl_texture_wrap_t"></span><dl> <dt>**GL\_TEXTURE\_WRAP\_T**</dt> </dl>                   | Returns the single-valued wrapping function for texture coordinate *t*, a symbolic constant.<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_TEXTURE_BORDER_COLOR"></span><span id="gl_texture_border_color"></span><dl> <dt>**GL\_TEXTURE\_BORDER\_COLOR**</dt> </dl> | Returns four integer or floating-point numbers that comprise the RGBA color of the texture border. Floating-point values are returned in the range \[0,1\]. Integer values are returned as a linear mapping of the internal floating-point representation such that 1.0 maps to the most positive representable integer and -1.0 maps to the most negative representable integer.<br/> |
     * | <span id="GL_TEXTURE_PRIORITY"></span><span id="gl_texture_priority"></span><dl> <dt>**GL\_TEXTURE\_PRIORITY**</dt> </dl>              | Returns the residence priority of the target texture (or the named texture bound to it). The initial value is 1. See [**glPrioritizeTextures**](glprioritizetextures.md).<br/>                                                                                                                                                                                                        |
     * | <span id="GL_TEXTURE_RESIDENT"></span><span id="gl_texture_resident"></span><dl> <dt>**GL\_TEXTURE\_RESIDENT**</dt> </dl>              | Returns the residence status of the target texture. If the value returned in params is GL\_TRUE, the texture is resident in texture memory. See [**glAreTexturesResident**](glaretexturesresident.md).<br/>                                                                                                                                                                           |
     * @param {Pointer<Single>} params Returns the texture parameters.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgettexparameterfv
     */
    static glGetTexParameterfv(target, pname, params) {
        DllCall("OPENGL32.dll\glGetTexParameterfv", "uint", target, "uint", pname, "ptr", params)
    }

    /**
     * The glGetTexParameterfv and glGetTexParameteriv functions return texture parameter values. | glGetTexParameteriv function (Gl.h)
     * @remarks
     * The **glGetTexParameter** function returns in *params* the value or values of the texture parameter specified as *pname*. The *target* parameter defines the target texture, either GL\_TEXTURE\_1D or GL\_TEXTURE\_2D, to specify one-dimensional or two-dimensional texturing. The *pname* parameter accepts the same symbols as [**glTexParameter**](gltexparameter-functions.md), with the same interpretations.
     * 
     * If an error is generated, no change is made to the contents of *params*.
     * @param {Integer} target The symbolic name of the target texture. GL\_TEXTURE\_1D and GL\_TEXTURE\_2D are accepted.
     * @param {Integer} pname The symbolic name of a texture parameter. The following values are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                         | Meaning                                                                                                                                                                                                                                                                                                                                                                                      |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_TEXTURE_MAG_FILTER"></span><span id="gl_texture_mag_filter"></span><dl> <dt>**GL\_TEXTURE\_MAG\_FILTER**</dt> </dl>       | Returns the single-valued texture magnification filter, a symbolic constant.<br/>                                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_TEXTURE_MIN_FILTER"></span><span id="gl_texture_min_filter"></span><dl> <dt>**GL\_TEXTURE\_MIN\_FILTER**</dt> </dl>       | Returns the single-valued texture minification filter, a symbolic constant.<br/>                                                                                                                                                                                                                                                                                                       |
     * | <span id="GL_TEXTURE_WRAP_S"></span><span id="gl_texture_wrap_s"></span><dl> <dt>**GL\_TEXTURE\_WRAP\_S**</dt> </dl>                   | Returns the single-valued wrapping function for texture coordinate *s*, a symbolic constant.<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_TEXTURE_WRAP_T"></span><span id="gl_texture_wrap_t"></span><dl> <dt>**GL\_TEXTURE\_WRAP\_T**</dt> </dl>                   | Returns the single-valued wrapping function for texture coordinate *t*, a symbolic constant.<br/>                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_TEXTURE_BORDER_COLOR"></span><span id="gl_texture_border_color"></span><dl> <dt>**GL\_TEXTURE\_BORDER\_COLOR**</dt> </dl> | Returns four integer or floating-point numbers that comprise the RGBA color of the texture border. Floating-point values are returned in the range \[0,1\]. Integer values are returned as a linear mapping of the internal floating-point representation such that 1.0 maps to the most positive representable integer and -1.0 maps to the most negative representable integer.<br/> |
     * | <span id="GL_TEXTURE_PRIORITY"></span><span id="gl_texture_priority"></span><dl> <dt>**GL\_TEXTURE\_PRIORITY**</dt> </dl>              | Returns the residence priority of the target texture (or the named texture bound to it). The initial value is 1. See [**glPrioritizeTextures**](glprioritizetextures.md).<br/>                                                                                                                                                                                                        |
     * | <span id="GL_TEXTURE_RESIDENT"></span><span id="gl_texture_resident"></span><dl> <dt>**GL\_TEXTURE\_RESIDENT**</dt> </dl>              | Returns the residence status of the target texture. If the value returned in params is GL\_TRUE, the texture is resident in texture memory. See [**glAreTexturesResident**](glaretexturesresident.md).<br/>                                                                                                                                                                           |
     * @param {Pointer<Int32>} params Returns the texture parameters.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glgettexparameteriv
     */
    static glGetTexParameteriv(target, pname, params) {
        DllCall("OPENGL32.dll\glGetTexParameteriv", "uint", target, "uint", pname, "ptr", params)
    }

    /**
     * The glHint function specifies implementation-specific hints.
     * @remarks
     * When there is room for interpretation, you can control certain aspects of OpenGL behavior with hints. You specify a hint with two arguments. The *target* parameter is a symbolic constant indicating the behavior to be controlled, and *mode* is another symbolic constant indicating the desired behavior.
     * 
     * Though the implementation aspects that can be hinted are well defined, the interpretation of the hints depends on the implementation.
     * 
     * The **glHint** function can be ignored.
     * @param {Integer} target A symbolic constant indicating the behavior to be controlled. The following symbolic constants, along with suggested semantics, are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                              | Meaning                                                                                                                                                                                                                                                                                                           |
     * |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_FOG_HINT"></span><span id="gl_fog_hint"></span><dl> <dt>**GL\_FOG\_HINT**</dt> </dl>                                                           | Indicates the accuracy of fog calculation. If per-pixel fog calculation is not efficiently supported by the OpenGL implementation, hinting GL\_DONT\_CARE or GL\_FASTEST can result in per-vertex calculation of fog effects.<br/>                                                                          |
     * | <span id="GL_LINE_SMOOTH_HINT"></span><span id="gl_line_smooth_hint"></span><dl> <dt>**GL\_LINE\_SMOOTH\_HINT**</dt> </dl>                                  | Indicates the sampling quality of antialiased lines. Hinting GL\_NICEST can result in more pixel fragments being generated during rasterization, if a larger filter function is applied.<br/>                                                                                                               |
     * | <span id="GL_PERSPECTIVE_CORRECTION_HINT"></span><span id="gl_perspective_correction_hint"></span><dl> <dt>**GL\_PERSPECTIVE\_CORRECTION\_HINT**</dt> </dl> | Indicates the quality of color and texture coordinate interpolation. If perspective-corrected parameter interpolation is not efficiently supported by the OpenGL implementation, hinting GL\_DONT\_CARE or GL\_FASTEST can result in simple linear interpolation of colors and/or texture coordinates.<br/> |
     * | <span id="GL_POINT_SMOOTH_HINT"></span><span id="gl_point_smooth_hint"></span><dl> <dt>**GL\_POINT\_SMOOTH\_HINT**</dt> </dl>                               | Indicates the sampling quality of antialiased points. Hinting GL\_NICEST can result in more pixel fragments being generated during rasterization, if a larger filter function is applied.<br/>                                                                                                              |
     * | <span id="GL_POLYGON_SMOOTH_HINT"></span><span id="gl_polygon_smooth_hint"></span><dl> <dt>**GL\_POLYGON\_SMOOTH\_HINT**</dt> </dl>                         | Indicates the sampling quality of antialiased polygons. Hinting GL\_NICEST can result in more pixel fragments being generated during rasterization, if a larger filter function is applied.<br/>                                                                                                            |
     * @param {Integer} mode A symbolic constant indicating the desired behavior. The following symbolic constants are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                       | Meaning                                                                   |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------|
     * | <span id="GL_FASTEST"></span><span id="gl_fastest"></span><dl> <dt>**GL\_FASTEST**</dt> </dl>        | The most efficient option should be chosen.<br/>                    |
     * | <span id="GL_NICEST"></span><span id="gl_nicest"></span><dl> <dt>**GL\_NICEST**</dt> </dl>           | The most correct, or highest quality, option should be chosen.<br/> |
     * | <span id="GL_DONT_CARE"></span><span id="gl_dont_care"></span><dl> <dt>**GL\_DONT\_CARE**</dt> </dl> | The client doesn't have a preference.<br/>                          |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glhint
     */
    static glHint(target, mode) {
        DllCall("OPENGL32.dll\glHint", "uint", target, "uint", mode)
    }

    /**
     * The glIndexMask function controls the writing of individual bits in the color-index buffers.
     * @remarks
     * The **glIndexMask** function controls the writing of individual bits in the color-index buffers. The least significant *n* bits of *mask*, where *1* is the number of bits in a color-index buffer, specify a mask. Wherever a one appears in the mask, the corresponding bit in the color-index buffer (or buffers) is made writable. Where a zero appears, the bit is write-protected.
     * 
     * This mask is used only in color-index mode, and it affects only the buffers currently selected for writing (see [**glDrawBuffer**](gldrawbuffer.md)). Initially, all bits are enabled for writing.
     * 
     * The following function retrieves information related to **glIndexMask**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_INDEX\_WRITEMASK
     * @param {Integer} mask A bit mask to enable and disable the writing of individual bits in the color-index buffers. Initially, the mask is all ones.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glindexmask
     */
    static glIndexMask(mask) {
        DllCall("OPENGL32.dll\glIndexMask", "uint", mask)
    }

    /**
     * The glIndexPointer function defines an array of color indexes.
     * @remarks
     * The **glIndexPointer** function specifies the location and data of an array of color indexes to use when rendering. The *type* parameter specifies the data type of each color index and *stride* determines the byte offset from one color index to the next, enabling the packing of vertices and attributes in a single array or storage in separate arrays. In some implementations, storing the vertices and attributes in a single array can be more efficient than using separate arrays. For more information, see [**glInterleavedArrays**](glinterleavedarrays.md).
     * 
     * A color-index array is enabled when you specify the GL\_INDEX\_ARRAY constant with [**glEnableClientState**](glenableclientstate.md). When enabled, [**glDrawArrays**](gldrawarrays.md) and [**glArrayElement**](glarrayelement.md) use the color-index array. By default the color-index array is disabled.
     * 
     * You cannot include **glIndexPointer** in display lists.
     * 
     * When you specify a color-index array using **glIndexPointer**, the values of all the function's color-index array parameters are saved in a client-side state and static array elements can be cached. Because the color-index array parameters are client-side state, their values are not saved or restored by [**glPushAttrib**](glpushattrib.md) and **glPopAttrib**.
     * 
     * Although no error is generated when you call **glIndexPointer** within [**glBegin**](glbegin.md) and **glEnd** pairs, the results are undefined.
     * 
     * The following functions retrieve information related to **glIndexPointer**:
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_INDEX\_ARRAY
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_INDEX\_ARRAY\_STRIDE
     * 
     * **glGet** with argument GL\_INDEX\_ARRAY\_COUNT
     * 
     * **glGet** with argument GL\_INDEX\_ARRAY\_TYPE
     * 
     * **glGet** with argument GL\_INDEX\_ARRAY\_SIZE
     * 
     * [**glGetPointerv**](glgetpointerv.md) with argument GL\_INDEX\_ARRAY\_POINTER
     * @param {Integer} type The data type of each color index in the array using the following symbolic constants: GL\_SHORT, GL\_INT, GL\_FLOAT, GL\_DOUBLE.
     * @param {Integer} stride The byte offset between consecutive color indexes. When *stride* is zero, the color indexes are tightly packed in the array.
     * @param {Pointer<Void>} pointer A pointer to the first color index in the array.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glindexpointer
     */
    static glIndexPointer(type, stride, pointer) {
        DllCall("OPENGL32.dll\glIndexPointer", "uint", type, "int", stride, "ptr", pointer)
    }

    /**
     * The glIndexd function sets the current color index.
     * @remarks
     * The **glIndexd** function updates the current (single-valued) color index. It takes one argument: the new value for the current color index.
     * 
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping.
     * 
     * Index values outside the representable range of the color-index buffer are not clamped. However, before an index is dithered (if enabled) and written to the framebuffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the framebuffer are masked out.
     * 
     * The current index can be updated at any time. In particular, **glIndexd** can be called between a call to [**glBegin**](/windows/desktop/OpenGL/glbegin) and the corresponding call to [**glEnd**](glend.md).
     * 
     * The following function retrieves information related to **glIndexd**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_INDEX
     * @param {Float} c The new value for the current color index.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glindexd
     */
    static glIndexd(c) {
        DllCall("OPENGL32.dll\glIndexd", "double", c)
    }

    /**
     * The glIndexdv function sets the current color index.
     * @remarks
     * The **glIndexdv** function updates the current (single-valued) color index. It takes one argument: the new value for the current color index.
     * 
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping.
     * 
     * Index values outside the representable range of the color-index buffer are not clamped. However, before an index is dithered (if enabled) and written to the framebuffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the framebuffer are masked out.
     * 
     * The current index can be updated at any time. In particular, **glIndexdv** can be called between a call to [**glBegin**](/windows/desktop/OpenGL/glbegin) and the corresponding call to [**glEnd**](glend.md).
     * 
     * The following function retrieves information related to **glIndexdv**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_INDEX
     * @param {Pointer<Double>} c A pointer to a one-element array that contains the new value for the current color index.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glindexdv
     */
    static glIndexdv(c) {
        DllCall("OPENGL32.dll\glIndexdv", "ptr", c)
    }

    /**
     * The glIndexf function sets the current color index.
     * @remarks
     * The **glIndexf** function updates the current (single-valued) color index. It takes one argument: the new value for the current color index.
     * 
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping.
     * 
     * Index values outside the representable range of the color-index buffer are not clamped. However, before an index is dithered (if enabled) and written to the framebuffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the framebuffer are masked out.
     * 
     * The current index can be updated at any time. In particular, **glIndexf** can be called between a call to [**glBegin**](/windows/desktop/OpenGL/glbegin) and the corresponding call to [**glEnd**](glend.md).
     * 
     * The following function retrieves information related to **glIndexf**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_INDEX
     * @param {Float} c The new value for the current color index.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glindexf
     */
    static glIndexf(c) {
        DllCall("OPENGL32.dll\glIndexf", "float", c)
    }

    /**
     * The glIndexfv function sets the current color index.
     * @remarks
     * The **glIndexfv** function updates the current (single-valued) color index. It takes one argument: the new value for the current color index.
     * 
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping.
     * 
     * Index values outside the representable range of the color-index buffer are not clamped. However, before an index is dithered (if enabled) and written to the framebuffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the framebuffer are masked out.
     * 
     * The current index can be updated at any time. In particular, **glIndexfv** can be called between a call to [**glBegin**](/windows/desktop/OpenGL/glbegin) and the corresponding call to [**glEnd**](glend.md).
     * 
     * The following function retrieves information related to **glIndexfv**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_INDEX
     * @param {Pointer<Single>} c A pointer to a one-element array that contains the new value for the current color index.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glindexfv
     */
    static glIndexfv(c) {
        DllCall("OPENGL32.dll\glIndexfv", "ptr", c)
    }

    /**
     * The glIndexi function sets the current color index.
     * @remarks
     * The **glIndexi** function updates the current (single-valued) color index. It takes one argument: the new value for the current color index.
     * 
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping.
     * 
     * Index values outside the representable range of the color-index buffer are not clamped. However, before an index is dithered (if enabled) and written to the framebuffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the framebuffer are masked out.
     * 
     * The current index can be updated at any time. In particular, **glIndexi** can be called between a call to [**glBegin**](/windows/desktop/OpenGL/glbegin) and the corresponding call to [**glEnd**](glend.md).
     * 
     * The following function retrieves information related to **glIndexi**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_INDEX
     * @param {Integer} c The new value for the current color index.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glindexi
     */
    static glIndexi(c) {
        DllCall("OPENGL32.dll\glIndexi", "int", c)
    }

    /**
     * The glIndexiv function sets the current color index.
     * @remarks
     * The **glIndexiv** function updates the current (single-valued) color index. It takes one argument: the new value for the current color index.
     * 
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping.
     * 
     * Index values outside the representable range of the color-index buffer are not clamped. However, before an index is dithered (if enabled) and written to the framebuffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the framebuffer are masked out.
     * 
     * The current index can be updated at any time. In particular, **glIndexiv** can be called between a call to [**glBegin**](/windows/desktop/OpenGL/glbegin) and the corresponding call to [**glEnd**](glend.md).
     * 
     * The following function retrieves information related to **glIndexiv**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_INDEX
     * @param {Pointer<Int32>} c A pointer to a one-element array that contains the new value for the current color index.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glindexiv
     */
    static glIndexiv(c) {
        DllCall("OPENGL32.dll\glIndexiv", "ptr", c)
    }

    /**
     * The glIndexs function sets the current color index.
     * @remarks
     * The **glIndexs** function updates the current (single-valued) color index. It takes one argument: the new value for the current color index.
     * 
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping.
     * 
     * Index values outside the representable range of the color-index buffer are not clamped. However, before an index is dithered (if enabled) and written to the framebuffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the framebuffer are masked out.
     * 
     * The current index can be updated at any time. In particular, **glIndexs** can be called between a call to [**glBegin**](/windows/desktop/OpenGL/glbegin) and the corresponding call to [**glEnd**](glend.md).
     * 
     * The following function retrieves information related to **glIndexs**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_INDEX
     * @param {Integer} c The new value for the current color index.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glindexs
     */
    static glIndexs(c) {
        DllCall("OPENGL32.dll\glIndexs", "short", c)
    }

    /**
     * The glIndexsv function sets the current color index.
     * @remarks
     * The **glIndexsv** function updates the current (single-valued) color index. It takes one argument: the new value for the current color index.
     * 
     * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping.
     * 
     * Index values outside the representable range of the color-index buffer are not clamped. However, before an index is dithered (if enabled) and written to the framebuffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the framebuffer are masked out.
     * 
     * The current index can be updated at any time. In particular, **glIndexsv** can be called between a call to [**glBegin**](/windows/desktop/OpenGL/glbegin) and the corresponding call to [**glEnd**](glend.md).
     * 
     * The following function retrieves information related to **glIndexsv**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_INDEX
     * @param {Pointer<Int16>} c A pointer to a one-element array that contains the new value for the current color index.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glindexsv
     */
    static glIndexsv(c) {
        DllCall("OPENGL32.dll\glIndexsv", "ptr", c)
    }

    /**
     * 
     * @param {Integer} c 
     * @returns {String} Nothing - always returns an empty string
     */
    static glIndexub(c) {
        DllCall("OPENGL32.dll\glIndexub", "char", c)
    }

    /**
     * 
     * @param {Pointer<Byte>} c 
     * @returns {String} Nothing - always returns an empty string
     */
    static glIndexubv(c) {
        DllCall("OPENGL32.dll\glIndexubv", "ptr", c)
    }

    /**
     * The glInitNames function initializes the name stack.
     * @remarks
     * The **glInitNames** function causes the name stack to be initialized to its default empty state. The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It consists of an ordered set of unsigned integers.
     * 
     * The name stack is always empty while the render mode is not GL\_SELECT. Calls to **glInitNames** while the render mode is not GL\_SELECT are ignored.
     * 
     * The following functions retrieve information related to **glInitNames**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_NAME\_STACK\_DEPTH
     * 
     * **glGet** with argument GL\_MAX\_NAME\_STACK\_DEPTH
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glinitnames
     */
    static glInitNames() {
        DllCall("OPENGL32.dll\glInitNames")
    }

    /**
     * The glInterleavedArrays function simultaneously specifies and enables several interleaved arrays in a larger aggregate array.
     * @remarks
     * With the **glInterleavedArrays** function, you can simultaneously specify and enable several interleaved color, normal, texture, and vertex arrays whose elements are part of a larger aggregate array element. For some memory architectures, this is more efficient than specifying the arrays separately.
     * 
     * If the *stride* parameter is zero then the aggregate array elements are stored consecutively; otherwise *stride* bytes occur between aggregate array elements.
     * 
     * The *format* parameter serves as a key that describes how to extract individual arrays from the aggregate array:
     * 
     * -   If *format* contains a T, then texture coordinates are extracted from the interleaved array.
     * -   If C is present, color values are extracted.
     * -   If N is present, normal coordinates are extracted.
     * -   Vertex coordinates are always extracted.
     * -   The digits 2, 3, and 4 denote how many values are extracted.
     * -   F indicates that values are extracted as floating point values.
     * -   If 4UB follows the C, colors may also be extracted as 4 unsigned bytes. If a color is extracted as 4 unsigned bytes, the vertex array element that follows is located at the first possible floating-point aligned address.
     * 
     * If you call **glInterleavedArrays** while compiling a display list, it is not compiled into the list but is executed immediately.
     * 
     * You cannot include calls to **glInterleavedArrays** in **glDisableClientState** between calls to [**glBegin**](glbegin.md) and the corresponding call to **glEnd**.
     * 
     * > [!Note]  
     * > The **glInterleavedArrays** function is only available in OpenGL version 1.1 or later.
     * 
     *  
     * 
     * The **glInterleavedArrays** function is implemented on the client side with no protocol. Because the vertex array parameters are client-side state, they are not saved or restored by [**glPushAttrib**](glpushattrib.md) and **glPopAttrib**. Use [**glPushClientAttrib**](glpushclientattrib.md) and **glPopClientAttrib** instead.
     * @param {Integer} format The type of array to enable. The parameter can assume one of the following symbolic values: GL\_V2F, GL\_V3F, GL\_C4UB\_V2F, GL\_C4UB\_V3F, GL\_C3F\_V3F, GL\_N3F\_V3F, GL\_C4F\_N3F\_V3F, GL\_T2F\_V3F, GL\_T4F\_V4F, GL\_T2F\_C4UB\_V3F, GL\_T2F\_C3F\_V3F, GL\_T2F\_N3F\_V3F, GL\_T2F\_C4F\_N3F\_V3F, or GL\_T4F\_C4F\_N3F\_V4F.
     * @param {Integer} stride The offset in bytes between each aggregate array element.
     * @param {Pointer<Void>} pointer A pointer to the first element of an aggregate array.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glinterleavedarrays
     */
    static glInterleavedArrays(format, stride, pointer) {
        DllCall("OPENGL32.dll\glInterleavedArrays", "uint", format, "int", stride, "ptr", pointer)
    }

    /**
     * The gllsEnabled function tests whether a capability is enabled.
     * @remarks
     * The **gllsEnabled** function returns GL\_TRUE if *cap* is an enabled capability and returns GL\_FALSE otherwise.
     * @param {Integer} cap A symbolic constant indicating an OpenGL capability. The following capabilities are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                    | Meaning                                                                                                                                             |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_ALPHA_TEST"></span><span id="gl_alpha_test"></span><dl> <dt>**GL\_ALPHA\_TEST**</dt> </dl>                                           | See [**glAlphaFunc**](glalphafunc.md)<br/>                                                                                                   |
     * | <span id="GL_AUTO_NORMAL"></span><span id="gl_auto_normal"></span><dl> <dt>**GL\_AUTO\_NORMAL**</dt> </dl>                                        | See [**glEvalCoord**](glevalcoord-functions.md)<br/>                                                                                         |
     * | <span id="GL_BLEND"></span><span id="gl_blend"></span><dl> <dt>**GL\_BLEND**</dt> </dl>                                                           | See [**glBlendFunc**](glblendfunc.md)<br/>                                                                                                   |
     * | <span id="GL_CLIP_PLANE_i"></span><span id="gl_clip_plane_i"></span><span id="GL_CLIP_PLANE_I"></span><dl> <dt>**GL\_CLIP\_PLANE *i***</dt> </dl> | See [**glClipPlane**](glclipplane.md)<br/>                                                                                                   |
     * | <span id="GL_COLOR_ARRAY"></span><span id="gl_color_array"></span><dl> <dt>**GL\_COLOR\_ARRAY**</dt> </dl>                                        | See [**glColorPointer**](glcolorpointer.md)<br/>                                                                                             |
     * | <span id="GL_COLOR_LOGIC_OP"></span><span id="gl_color_logic_op"></span><dl> <dt>**GL\_COLOR\_LOGIC\_OP**</dt> </dl>                              | See [**glLogicOp**](gllogicop.md)<br/>                                                                                                       |
     * | <span id="GL_COLOR_MATERIAL"></span><span id="gl_color_material"></span><dl> <dt>**GL\_COLOR\_MATERIAL**</dt> </dl>                               | See [**glColorMaterial**](glcolormaterial.md)<br/>                                                                                           |
     * | <span id="GL_CULL_FACE"></span><span id="gl_cull_face"></span><dl> <dt>**GL\_CULL\_FACE**</dt> </dl>                                              | See [**glCullFace**](glcullface.md)<br/>                                                                                                     |
     * | <span id="GL_DEPTH_TEST"></span><span id="gl_depth_test"></span><dl> <dt>**GL\_DEPTH\_TEST**</dt> </dl>                                           | See [**glDepthFunc**](gldepthfunc.md) and [**glDepthRange**](gldepthrange.md)<br/>                                                          |
     * | <span id="GL_DITHER"></span><span id="gl_dither"></span><dl> <dt>**GL\_DITHER**</dt> </dl>                                                        | See [**glEnable**](glenable.md)<br/>                                                                                                         |
     * | <span id="GL_FOG"></span><span id="gl_fog"></span><dl> <dt>**GL\_FOG**</dt> </dl>                                                                 | See [**glFog**](glfog.md)<br/>                                                                                                               |
     * | <span id="GL_INDEX_ARRAY"></span><span id="gl_index_array"></span><dl> <dt>**GL\_INDEX\_ARRAY**</dt> </dl>                                        | See [**glIndexPointer**](glindexpointer.md)<br/>                                                                                             |
     * | <span id="GL_INDEX_LOGIC_OP"></span><span id="gl_index_logic_op"></span><dl> <dt>**GL\_INDEX\_LOGIC\_OP**</dt> </dl>                              | See [**glLogicOp**](gllogicop.md)<br/>                                                                                                       |
     * | <span id="GL_LIGHT_i"></span><span id="gl_light_i"></span><span id="GL_LIGHT_I"></span><dl> <dt>**GL\_LIGHT *i***</dt> </dl>                      | See [**glLightModel**](gllightmodel-functions.md) and [**glLight**](gllight-functions.md)<br/>                                              |
     * | <span id="GL_LIGHTING"></span><span id="gl_lighting"></span><dl> <dt>**GL\_LIGHTING**</dt> </dl>                                                  | See [**glMaterial**](glmaterial-functions.md), [**glLightModel**](gllightmodel-functions.md), and [**glLight**](gllight-functions.md)<br/> |
     * | <span id="GL_LINE_SMOOTH"></span><span id="gl_line_smooth"></span><dl> <dt>**GL\_LINE\_SMOOTH**</dt> </dl>                                        | See [**glLineWidth**](gllinewidth.md)<br/>                                                                                                   |
     * | <span id="GL_LINE_STIPPLE"></span><span id="gl_line_stipple"></span><dl> <dt>**GL\_LINE\_STIPPLE**</dt> </dl>                                     | See [**glLineStipple**](gllinestipple.md)<br/>                                                                                               |
     * | <span id="GL_MAP1_COLOR_4"></span><span id="gl_map1_color_4"></span><dl> <dt>**GL\_MAP1\_COLOR\_4**</dt> </dl>                                    | See [**glMap1**](glmap1.md)<br/>                                                                                                             |
     * | <span id="GL_MAP1_INDEX"></span><span id="gl_map1_index"></span><dl> <dt>**GL\_MAP1\_INDEX**</dt> </dl>                                           | See [**glMap1**](glmap1.md)<br/>                                                                                                             |
     * | <span id="GL_MAP1_NORMAL"></span><span id="gl_map1_normal"></span><dl> <dt>**GL\_MAP1\_NORMAL**</dt> </dl>                                        | See [**glMap1**](glmap1.md)<br/>                                                                                                             |
     * | <span id="GL_MAP1_TEXTURE_COORD_1"></span><span id="gl_map1_texture_coord_1"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_1**</dt> </dl>           | See [**glMap1**](glmap1.md)<br/>                                                                                                             |
     * | <span id="GL_MAP1_TEXTURE_COORD_2"></span><span id="gl_map1_texture_coord_2"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_2**</dt> </dl>           | See [**glMap1**](glmap1.md)<br/>                                                                                                             |
     * | <span id="GL_MAP1_TEXTURE_COORD_3"></span><span id="gl_map1_texture_coord_3"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_3**</dt> </dl>           | See [**glMap1**](glmap1.md)<br/>                                                                                                             |
     * | <span id="GL_MAP1_TEXTURE_COORD_4"></span><span id="gl_map1_texture_coord_4"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_4**</dt> </dl>           | See [**glMap1**](glmap1.md)<br/>                                                                                                             |
     * | <span id="GL_MAP1_VERTEX_3"></span><span id="gl_map1_vertex_3"></span><dl> <dt>**GL\_MAP1\_VERTEX\_3**</dt> </dl>                                 | See [**glMap1**](glmap1.md)<br/>                                                                                                             |
     * | <span id="GL_MAP1_VERTEX_4"></span><span id="gl_map1_vertex_4"></span><dl> <dt>**GL\_MAP1\_VERTEX\_4**</dt> </dl>                                 | See [**glMap1**](glmap1.md)<br/>                                                                                                             |
     * | <span id="GL_MAP2_COLOR_4"></span><span id="gl_map2_color_4"></span><dl> <dt>**GL\_MAP2\_COLOR\_4**</dt> </dl>                                    | See [**glMap2**](glmap2.md)<br/>                                                                                                             |
     * | <span id="GL_MAP2_INDEX"></span><span id="gl_map2_index"></span><dl> <dt>**GL\_MAP2\_INDEX**</dt> </dl>                                           | See [**glMap2**](glmap2.md)<br/>                                                                                                             |
     * | <span id="GL_MAP2_NORMAL"></span><span id="gl_map2_normal"></span><dl> <dt>**GL\_MAP2\_NORMAL**</dt> </dl>                                        | See [**glMap2**](glmap2.md)<br/>                                                                                                             |
     * | <span id="GL_MAP2_TEXTURE_COORD_1"></span><span id="gl_map2_texture_coord_1"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_1**</dt> </dl>           | See [**glMap2**](glmap2.md)<br/>                                                                                                             |
     * | <span id="GL_MAP2_TEXTURE_COORD_2"></span><span id="gl_map2_texture_coord_2"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_2**</dt> </dl>           | See [**glMap2**](glmap2.md)<br/>                                                                                                             |
     * | <span id="GL_MAP2_TEXTURE_COORD_3"></span><span id="gl_map2_texture_coord_3"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_3**</dt> </dl>           | See [**glMap2**](glmap2.md)<br/>                                                                                                             |
     * | <span id="GL_MAP2_TEXTURE_COORD_4"></span><span id="gl_map2_texture_coord_4"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_4**</dt> </dl>           | See [**glMap2**](glmap2.md)<br/>                                                                                                             |
     * | <span id="GL_MAP2_VERTEX_3"></span><span id="gl_map2_vertex_3"></span><dl> <dt>**GL\_MAP2\_VERTEX\_3**</dt> </dl>                                 | See [**glMap2**](glmap2.md)<br/>                                                                                                             |
     * | <span id="GL_MAP2_VERTEX_4"></span><span id="gl_map2_vertex_4"></span><dl> <dt>**GL\_MAP2\_VERTEX\_4**</dt> </dl>                                 | See [**glMap2**](glmap2.md)<br/>                                                                                                             |
     * | <span id="GL_NORMAL_ARRAY"></span><span id="gl_normal_array"></span><dl> <dt>**GL\_NORMAL\_ARRAY**</dt> </dl>                                     | See [**glNormalPointer**](glnormalpointer.md)<br/>                                                                                           |
     * | <span id="GL_NORMALIZE"></span><span id="gl_normalize"></span><dl> <dt>**GL\_NORMALIZE**</dt> </dl>                                               | See [**glNormal**](glnormal-functions.md)<br/>                                                                                               |
     * | <span id="GL_POINT_SMOOTH"></span><span id="gl_point_smooth"></span><dl> <dt>**GL\_POINT\_SMOOTH**</dt> </dl>                                     | See [**glPointSize**](glpointsize.md)<br/>                                                                                                   |
     * | <span id="GL_POLYGON_OFFSET_FILL"></span><span id="gl_polygon_offset_fill"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_FILL**</dt> </dl>               | See [**glPolygonOffset**](glpolygonoffset.md)<br/>                                                                                           |
     * | <span id="GL_POLYGON_OFFSET_LINE"></span><span id="gl_polygon_offset_line"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_LINE**</dt> </dl>               | See [**glPolygonOffset**](glpolygonoffset.md)<br/>                                                                                           |
     * | <span id="GL_POLYGON_OFFSET_POINT"></span><span id="gl_polygon_offset_point"></span><dl> <dt>**GL\_POLYGON\_OFFSET\_POINT**</dt> </dl>            | See [**glPolygonOffset**](glpolygonoffset.md)<br/>                                                                                           |
     * | <span id="GL_POLYGON_SMOOTH"></span><span id="gl_polygon_smooth"></span><dl> <dt>**GL\_POLYGON\_SMOOTH**</dt> </dl>                               | See [**glPolygonMode**](glpolygonmode.md)<br/>                                                                                               |
     * | <span id="GL_POLYGON_STIPPLE"></span><span id="gl_polygon_stipple"></span><dl> <dt>**GL\_POLYGON\_STIPPLE**</dt> </dl>                            | See [**glPolygonStipple**](glpolygonstipple.md)<br/>                                                                                         |
     * | <span id="GL_SCISSOR_TEST"></span><span id="gl_scissor_test"></span><dl> <dt>**GL\_SCISSOR\_TEST**</dt> </dl>                                     | See [**glScissor**](glscissor.md)<br/>                                                                                                       |
     * | <span id="GL_STENCIL_TEST"></span><span id="gl_stencil_test"></span><dl> <dt>**GL\_STENCIL\_TEST**</dt> </dl>                                     | See [**glStencilFunc**](glstencilfunc.md) and [**glStencilOp**](glstencilop.md)<br/>                                                        |
     * | <span id="GL_TEXTURE_1D"></span><span id="gl_texture_1d"></span><dl> <dt>**GL\_TEXTURE\_1D**</dt> </dl>                                           | See [**glTexImage1D**](glteximage1d.md)<br/>                                                                                                 |
     * | <span id="GL_TEXTURE_2D"></span><span id="gl_texture_2d"></span><dl> <dt>**GL\_TEXTURE\_2D**</dt> </dl>                                           | See [**glTexImage2D**](glteximage2d.md)<br/>                                                                                                 |
     * | <span id="GL_TEXTURE_COORD_ARRAY"></span><span id="gl_texture_coord_array"></span><dl> <dt>**GL\_TEXTURE\_COORD\_ARRAY**</dt> </dl>               | See [**glTexCoordPointer**](gltexcoordpointer.md)<br/>                                                                                       |
     * | <span id="GL_TEXTURE_GEN_Q"></span><span id="gl_texture_gen_q"></span><dl> <dt>**GL\_TEXTURE\_GEN\_Q**</dt> </dl>                                 | See [**glTexGen**](gltexgen-functions.md)<br/>                                                                                               |
     * | <span id="GL_TEXTURE_GEN_R"></span><span id="gl_texture_gen_r"></span><dl> <dt>**GL\_TEXTURE\_GEN\_R**</dt> </dl>                                 | See [**glTexGen**](gltexgen-functions.md)<br/>                                                                                               |
     * | <span id="GL_TEXTURE_GEN_S"></span><span id="gl_texture_gen_s"></span><dl> <dt>**GL\_TEXTURE\_GEN\_S**</dt> </dl>                                 | See [**glTexGen**](gltexgen-functions.md)<br/>                                                                                               |
     * | <span id="GL_TEXTURE_GEN_T"></span><span id="gl_texture_gen_t"></span><dl> <dt>**GL\_TEXTURE\_GEN\_T**</dt> </dl>                                 | See [**glTexGen**](gltexgen-functions.md)<br/>                                                                                               |
     * | <span id="GL_VERTEX_ARRAY"></span><span id="gl_vertex_array"></span><dl> <dt>**GL\_VERTEX\_ARRAY**</dt> </dl>                                     | See [**glVertexPointer**](glvertexpointer.md)<br/>                                                                                           |
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glisenabled
     */
    static glIsEnabled(cap) {
        result := DllCall("OPENGL32.dll\glIsEnabled", "uint", cap, "char")
        return result
    }

    /**
     * The gllsList function tests for display list existence.
     * @remarks
     * The **gllsList** function returns GL\_TRUE if *list* is the name of a display list and returns GL\_FALSE otherwise.
     * @param {Integer} list A potential display list name.
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glislist
     */
    static glIsList(list) {
        result := DllCall("OPENGL32.dll\glIsList", "uint", list, "char")
        return result
    }

    /**
     * The glIsTexture function determines if a name corresponds to a texture.
     * @remarks
     * If the *texture* parameter is currently the name of a texture, the **glIsTexture** function returns GL\_TRUE. The **glIsTexture** function returns GL\_FALSE if *texture* is zero. It also returns GL\_FALSE if it is a non-zero value that is not currently the name of a texture, or if an error occurs.
     * 
     * You cannot include calls to **glIsTexture** in display lists.
     * 
     * > [!Note]  
     * > The **glIsTexture** function is only available in OpenGL version 1.1 or later.
     * @param {Integer} texture A value that is the name of a texture.
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glistexture
     */
    static glIsTexture(texture) {
        result := DllCall("OPENGL32.dll\glIsTexture", "uint", texture, "char")
        return result
    }

    /**
     * The glLightModelf function sets lighting model parameters.
     * @remarks
     * The **glLightModelf** function sets lighting model parameter. The *pname* parameter names a parameter and *param* gives the new value.the value or values of individual light source parameters.
     * 
     * In RGBA mode, the lighted color of a vertex is the sum of the material emission intensity, the product of the material ambient reflectance and the lighting model full-scene ambient intensity, and the contribution of each enabled light source. Each light source contributes the sum of three terms: ambient, diffuse, and specular.
     * 
     * -   The ambient light source contribution is the product of the material ambient reflectance and the light's ambient intensity.
     * -   The diffuse light source contribution is the product of the material diffuse reflectance, the light's diffuse intensity, and the dot product of the vertex's normal with the normalized vector from the vertex to the light source.
     * -   The specular light source contribution is the product of the material specular reflectance, the light's specular intensity, and the dot product of the normalized vertex-to-eye and vertex-to-light vectors, raised to the power of the shininess of the material.
     * 
     * All three light source contributions are attenuated equally based on the distance from the vertex to the light source and on light source direction, spread exponent, and spread cutoff angle. All dot products are replaced with zero if they evaluate to a negative value.
     * 
     * The alpha component of the resulting lighted color is set to the alpha value of the material diffuse reflectance.
     * 
     * In color-index mode, the value of the lighted index of a vertex ranges from the ambient to the specular values passed to [**glMaterial**](glmaterial-functions.md) using GL\_COLOR\_INDEXES. Diffuse and specular coefficients, computed with a (.30, .59, .11) weighting of the light's colors, the shininess of the material, and the same reflection and attenuation equations as in the RGBA case, determine how much above ambient the resulting index is.
     * 
     * The following functions retrieve information related to the **glLightModelf** function:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_LIGHT\_MODEL\_LOCAL\_VIEWER
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_LIGHT\_MODEL\_TWO\_SIDE
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_LIGHTING
     * @param {Integer} pname A single-valued lighting model parameter. The following values are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_LIGHT_MODEL_LOCAL_VIEWER"></span><span id="gl_light_model_local_viewer"></span><dl> <dt>**GL\_LIGHT\_MODEL\_LOCAL\_VIEWER**</dt> </dl> | The *param* parameter is a single floating-point value that specifies how specular reflection angles are computed. If *param* is 0 (or 0.0), specular reflection angles take the view direction to be parallel to and in the direction of the -*z* axis, regardless of the location of the vertex in eye coordinates. Otherwise, specular reflections are computed from the origin of the eye coordinate system. The default is 0. <br/>                                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_LIGHT_MODEL_TWO_SIDE"></span><span id="gl_light_model_two_side"></span><dl> <dt>**GL\_LIGHT\_MODEL\_TWO\_SIDE**</dt> </dl>             | The *param* parameter is a single floating-point value that specifies whether one-sided or two-sided lighting calculations are done for polygons. It has no effect on the lighting calculations for points, lines, or bitmaps. If *param* is 0 (or 0.0), one-sided lighting is specified, and only the front material parameters are used in the lighting equation. Otherwise, two-sided lighting is specified. <br/> In this case, vertices of back-facing polygons are lighted using the back material parameters, and have their normals reversed before the lighting equation is evaluated. Vertices of front-facing polygons are always lighted using the front material parameters, with no change to their normals. The default is 0.<br/> |
     * @param {Float} param1 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gllightmodelf
     */
    static glLightModelf(pname, param1) {
        DllCall("OPENGL32.dll\glLightModelf", "uint", pname, "float", param1)
    }

    /**
     * The glLightModelfv function sets lighting model parameters.
     * @remarks
     * The **glLightModelfv** function sets lighting model parameter. The *pname* parameter names a parameter and *param* gives the new value.the value or values of individual light source parameters.
     * 
     * In RGBA mode, the lighted color of a vertex is the sum of the material emission intensity, the product of the material ambient reflectance and the lighting model full-scene ambient intensity, and the contribution of each enabled light source. Each light source contributes the sum of three terms: ambient, diffuse, and specular.
     * 
     * -   The ambient light source contribution is the product of the material ambient reflectance and the light's ambient intensity.
     * -   The diffuse light source contribution is the product of the material diffuse reflectance, the light's diffuse intensity, and the dot product of the vertex's normal with the normalized vector from the vertex to the light source.
     * -   The specular light source contribution is the product of the material specular reflectance, the light's specular intensity, and the dot product of the normalized vertex-to-eye and vertex-to-light vectors, raised to the power of the shininess of the material.
     * 
     * All three light source contributions are attenuated equally based on the distance from the vertex to the light source and on light source direction, spread exponent, and spread cutoff angle. All dot products are replaced with zero if they evaluate to a negative value.
     * 
     * The alpha component of the resulting lighted color is set to the alpha value of the material diffuse reflectance.
     * 
     * In color-index mode, the value of the lighted index of a vertex ranges from the ambient to the specular values passed to [**glMaterial**](glmaterial-functions.md) using GL\_COLOR\_INDEXES. Diffuse and specular coefficients, computed with a (.30, .59, .11) weighting of the light's colors, the shininess of the material, and the same reflection and attenuation equations as in the RGBA case, determine how much above ambient the resulting index is.
     * 
     * The following functions retrieve information related to the **glLightModelfv** function:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_LIGHT\_MODEL\_LOCAL\_VIEWER
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_LIGHT\_MODEL\_TWO\_SIDE
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_LIGHTING
     * @param {Integer} pname A lighting model parameter. The following values are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_LIGHT_MODEL_AMBIENT"></span><span id="gl_light_model_ambient"></span><dl> <dt>**GL\_LIGHT\_MODEL\_AMBIENT**</dt> </dl>                 | The *params* parameter contains four floating-point values that specify the ambient RGBA intensity of the entire scene. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The default ambient scene intensity is (0.2, 0.2, 0.2, 1.0). <br/>                                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_LIGHT_MODEL_LOCAL_VIEWER"></span><span id="gl_light_model_local_viewer"></span><dl> <dt>**GL\_LIGHT\_MODEL\_LOCAL\_VIEWER**</dt> </dl> | The *params* parameter is a single floating-point value that specifies how specular reflection angles are computed. If *param* is 0 (or 0.0), specular reflection angles take the view direction to be parallel to and in the direction of the -*z* axis, regardless of the location of the vertex in eye coordinates. Otherwise, specular reflections are computed from the origin of the eye coordinate system. The default is 0. <br/>                                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_LIGHT_MODEL_TWO_SIDE"></span><span id="gl_light_model_two_side"></span><dl> <dt>**GL\_LIGHT\_MODEL\_TWO\_SIDE**</dt> </dl>             | The *params* parameter is a single floating-point value that specifies whether one-sided or two-sided lighting calculations are done for polygons. It has no effect on the lighting calculations for points, lines, or bitmaps. If *param* is 0 (or 0.0), one-sided lighting is specified, and only the front material parameters are used in the lighting equation. Otherwise, two-sided lighting is specified. <br/> In this case, vertices of back-facing polygons are lighted using the back material parameters, and have their normals reversed before the lighting equation is evaluated. Vertices of front-facing polygons are always lighted using the front material parameters, with no change to their normals. The default is 0.<br/> |
     * @param {Pointer<Single>} params A pointer to the value or values to which *params* will be set.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gllightmodelfv
     */
    static glLightModelfv(pname, params) {
        DllCall("OPENGL32.dll\glLightModelfv", "uint", pname, "ptr", params)
    }

    /**
     * The glLightModeli function sets lighting model parameters.
     * @remarks
     * The **glLightModeli** function sets lighting model parameter. The *pname* parameter names a parameter and *param* gives the new value.the value or values of individual light source parameters.
     * 
     * In RGBA mode, the lighted color of a vertex is the sum of the material emission intensity, the product of the material ambient reflectance and the lighting model full-scene ambient intensity, and the contribution of each enabled light source. Each light source contributes the sum of three terms: ambient, diffuse, and specular.
     * 
     * -   The ambient light source contribution is the product of the material ambient reflectance and the light's ambient intensity.
     * -   The diffuse light source contribution is the product of the material diffuse reflectance, the light's diffuse intensity, and the dot product of the vertex's normal with the normalized vector from the vertex to the light source.
     * -   The specular light source contribution is the product of the material specular reflectance, the light's specular intensity, and the dot product of the normalized vertex-to-eye and vertex-to-light vectors, raised to the power of the shininess of the material.
     * 
     * All three light source contributions are attenuated equally based on the distance from the vertex to the light source and on light source direction, spread exponent, and spread cutoff angle. All dot products are replaced with zero if they evaluate to a negative value.
     * 
     * The alpha component of the resulting lighted color is set to the alpha value of the material diffuse reflectance.
     * 
     * In color-index mode, the value of the lighted index of a vertex ranges from the ambient to the specular values passed to [**glMaterial**](glmaterial-functions.md) using GL\_COLOR\_INDEXES. Diffuse and specular coefficients, computed with a (.30, .59, .11) weighting of the light's colors, the shininess of the material, and the same reflection and attenuation equations as in the RGBA case, determine how much above ambient the resulting index is.
     * 
     * The following functions retrieve information related to the **glLightModeli** function:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_LIGHT\_MODEL\_LOCAL\_VIEWER
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_LIGHT\_MODEL\_TWO\_SIDE
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_LIGHTING
     * @param {Integer} pname A single-valued lighting model parameter. The following values are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_LIGHT_MODEL_LOCAL_VIEWER"></span><span id="gl_light_model_local_viewer"></span><dl> <dt>**GL\_LIGHT\_MODEL\_LOCAL\_VIEWER**</dt> </dl> | The *param* parameter is a single integer value that specifies how specular reflection angles are computed. If *param* is 0 (or 0.0), specular reflection angles take the view direction to be parallel to and in the direction of the -*z* axis, regardless of the location of the vertex in eye coordinates. Otherwise, specular reflections are computed from the origin of the eye coordinate system. The default is 0. <br/>                                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_LIGHT_MODEL_TWO_SIDE"></span><span id="gl_light_model_two_side"></span><dl> <dt>**GL\_LIGHT\_MODEL\_TWO\_SIDE**</dt> </dl>             | The *param* parameter is a single integer value that specifies whether one-sided or two-sided lighting calculations are done for polygons. It has no effect on the lighting calculations for points, lines, or bitmaps. If *param* is 0 (or 0.0), one-sided lighting is specified, and only the front material parameters are used in the lighting equation. Otherwise, two-sided lighting is specified. <br/> In this case, vertices of back-facing polygons are lighted using the back material parameters, and have their normals reversed before the lighting equation is evaluated. Vertices of front-facing polygons are always lighted using the front material parameters, with no change to their normals. The default is 0.<br/> |
     * @param {Integer} param1 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gllightmodeli
     */
    static glLightModeli(pname, param1) {
        DllCall("OPENGL32.dll\glLightModeli", "uint", pname, "int", param1)
    }

    /**
     * The glLightModeliv function sets lighting model parameters.
     * @remarks
     * The **glLightModeliv** function sets lighting model parameter. The *pname* parameter names a parameter and *param* gives the new value.the value or values of individual light source parameters.
     * 
     * In RGBA mode, the lighted color of a vertex is the sum of the material emission intensity, the product of the material ambient reflectance and the lighting model full-scene ambient intensity, and the contribution of each enabled light source. Each light source contributes the sum of three terms: ambient, diffuse, and specular.
     * 
     * -   The ambient light source contribution is the product of the material ambient reflectance and the light's ambient intensity.
     * -   The diffuse light source contribution is the product of the material diffuse reflectance, the light's diffuse intensity, and the dot product of the vertex's normal with the normalized vector from the vertex to the light source.
     * -   The specular light source contribution is the product of the material specular reflectance, the light's specular intensity, and the dot product of the normalized vertex-to-eye and vertex-to-light vectors, raised to the power of the shininess of the material.
     * 
     * All three light source contributions are attenuated equally based on the distance from the vertex to the light source and on light source direction, spread exponent, and spread cutoff angle. All dot products are replaced with zero if they evaluate to a negative value.
     * 
     * The alpha component of the resulting lighted color is set to the alpha value of the material diffuse reflectance.
     * 
     * In color-index mode, the value of the lighted index of a vertex ranges from the ambient to the specular values passed to [**glMaterial**](glmaterial-functions.md) using GL\_COLOR\_INDEXES. Diffuse and specular coefficients, computed with a (.30, .59, .11) weighting of the light's colors, the shininess of the material, and the same reflection and attenuation equations as in the RGBA case, determine how much above ambient the resulting index is.
     * 
     * The following functions retrieve information related to the **glLightModeliv** function:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_LIGHT\_MODEL\_LOCAL\_VIEWER
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_LIGHT\_MODEL\_TWO\_SIDE
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_LIGHTING
     * @param {Integer} pname A lighting model parameter. The following values are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_LIGHT_MODEL_AMBIENT"></span><span id="gl_light_model_ambient"></span><dl> <dt>**GL\_LIGHT\_MODEL\_AMBIENT**</dt> </dl>                 | The *params* parameter contains four integer values that specify the ambient RGBA intensity of the entire scene. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The default ambient scene intensity is (0.2, 0.2, 0.2, 1.0). <br/>                                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_LIGHT_MODEL_LOCAL_VIEWER"></span><span id="gl_light_model_local_viewer"></span><dl> <dt>**GL\_LIGHT\_MODEL\_LOCAL\_VIEWER**</dt> </dl> | The *params* parameter is a single integer value that specifies how specular reflection angles are computed. If *param* is 0 (or 0.0), specular reflection angles take the view direction to be parallel to and in the direction of the -*z* axis, regardless of the location of the vertex in eye coordinates. Otherwise, specular reflections are computed from the origin of the eye coordinate system. The default is 0. <br/>                                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_LIGHT_MODEL_TWO_SIDE"></span><span id="gl_light_model_two_side"></span><dl> <dt>**GL\_LIGHT\_MODEL\_TWO\_SIDE**</dt> </dl>             | The *params* parameter is a single integer value that specifies whether one-sided or two-sided lighting calculations are done for polygons. It has no effect on the lighting calculations for points, lines, or bitmaps. If *param* is 0 (or 0.0), one-sided lighting is specified, and only the front material parameters are used in the lighting equation. Otherwise, two-sided lighting is specified. <br/> In this case, vertices of back-facing polygons are lighted using the back material parameters, and have their normals reversed before the lighting equation is evaluated. Vertices of front-facing polygons are always lighted using the front material parameters, with no change to their normals. The default is 0.<br/> |
     * @param {Pointer<Int32>} params A pointer to the value or values to which *params* will be set.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gllightmodeliv
     */
    static glLightModeliv(pname, params) {
        DllCall("OPENGL32.dll\glLightModeliv", "uint", pname, "ptr", params)
    }

    /**
     * The glLightf function returns light source parameter values.
     * @remarks
     * The **glLightf** function sets the value or values of individual light source parameters. The *light* parameter names the light and is a symbolic name of the form GL\_LIGHT*i*, where 0 = *i* < GL\_MAX\_LIGHTS.
     * 
     * The *pname* parameter specifies one of the light source parameters, again by symbolic name. The *param* parameter is either a single value or a pointer to an array that contains the new values.
     * 
     * Lighting calculation is enabled and disabled using [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with argument GL\_LIGHTING. When lighting is enabled, light sources that are enabled contribute to the lighting calculation. Light source *i* is enabled and disabled using **glEnable** and **glDisable** with argument GL\_LIGHT*i*.
     * 
     * It is always the case that GL\_LIGHT*i* = GL\_LIGHT0 + *i*.
     * 
     * The following functions retrieve information related to the **glLightf** function:
     * 
     * [**glGetLight**](glgetlight.md)
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_LIGHTING
     * @param {Integer} light The identifier of a light. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL\_LIGHT*i* where *i* is a value: 0 to GL\_MAX\_LIGHTS - 1.
     * @param {Integer} pname A single-valued light source parameter for *light*. The following symbolic names are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                                                                                                                                                               | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_SPOT_EXPONENT"></span><span id="gl_spot_exponent"></span><dl> <dt>**GL\_SPOT\_EXPONENT**</dt> </dl>                                                                                                                                                                             | The *param* parameter is a single floating-point value that specifies the intensity distribution of the light. Floating-point values are mapped directly. Only values in the range \[0, 128\] are accepted. <br/> Effective light intensity is attenuated by the cosine of the angle between the direction of the light and the direction from the light to the vertex being lighted, raised to the power of the spot exponent. Thus, higher spot exponents result in a more focused light source, regardless of the spot cutoff angle. The default spot exponent is 0, resulting in uniform light distribution.<br/> |
     * | <span id="GL_SPOT_CUTOFF"></span><span id="gl_spot_cutoff"></span><dl> <dt>**GL\_SPOT\_CUTOFF**</dt> </dl>                                                                                                                                                                                   | The *param* parameter is a single floating-point value that specifies the maximum spread angle of a light source. Floating-point values are mapped directly. Only values in the range \[0, 90\], and the special value 180, are accepted. <br/> If the angle between the direction of the light and the direction from the light to the vertex being lighted is greater than the spot cutoff angle, then the light is completely masked. Otherwise, its intensity is controlled by the spot exponent and the attenuation factors. The default spot cutoff is 180, resulting in uniform light distribution.<br/>       |
     * | <span id="GL_CONSTANT_ATTENUATION__GL_LINEAR_ATTENUATION__GL_QUADRATIC_ATTENUATION"></span><span id="gl_constant_attenuation__gl_linear_attenuation__gl_quadratic_attenuation"></span><dl> <dt>**GL\_CONSTANT\_ATTENUATION, GL\_LINEAR\_ATTENUATION, GL\_QUADRATIC\_ATTENUATION**</dt> </dl> | The *param* parameter is a single floating-point value that specifies one of the three light attenuation factors. Floating-point values are mapped directly. Only nonnegative values are accepted. <br/> If the light is positional, rather than directional, its intensity is attenuated by the reciprocal of the sum of: the constant factor, the linear factor multiplied by the distance between the light and the vertex being lighted, and the quadratic factor multiplied by the square of the same distance. The default attenuation factors are (1,0,0), resulting in no attenuation.<br/>                   |
     * @param {Float} param2 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gllightf
     */
    static glLightf(light, pname, param2) {
        DllCall("OPENGL32.dll\glLightf", "uint", light, "uint", pname, "float", param2)
    }

    /**
     * The glLightfv function returns light source parameter values.
     * @remarks
     * The **glLightfv** function sets the value or values of individual light source parameters. The *light* parameter names the light and is a symbolic name of the form GL\_LIGHT*i*, where 0 = *i* < GL\_MAX\_LIGHTS.
     * 
     * The *pname* parameter specifies one of the light source parameters, again by symbolic name. The *params* parameter is either a single value or a pointer to an array that contains the new values.
     * 
     * Lighting calculation is enabled and disabled using [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with argument GL\_LIGHTING. When lighting is enabled, light sources that are enabled contribute to the lighting calculation. Light source *i* is enabled and disabled using **glEnable** and **glDisable** with argument GL\_LIGHT*i*.
     * 
     * It is always the case that GL\_LIGHT*i* = GL\_LIGHT0 + *i*.
     * 
     * The following functions retrieve information related to the **glLightfv** function:
     * 
     * [**glGetLight**](glgetlight.md)
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_LIGHTING
     * @param {Integer} light The identifier of a light. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL\_LIGHT*i* where *i* is a value: 0 to GL\_MAX\_LIGHTS - 1.
     * @param {Integer} pname A light source parameter for *light*. The following symbolic names are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                                                                                                                                                               | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_AMBIENT"></span><span id="gl_ambient"></span><dl> <dt>**GL\_AMBIENT**</dt> </dl>                                                                                                                                                                                                | The *params* parameter contains four floating-point values that specify the ambient RGBA intensity of the light. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The default ambient light intensity is (0.0, 0.0, 0.0, 1.0). <br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_DIFFUSE"></span><span id="gl_diffuse"></span><dl> <dt>**GL\_DIFFUSE**</dt> </dl>                                                                                                                                                                                                | The *params* parameter contains four floating-point values that specify the diffuse RGBA intensity of the light. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The default diffuse intensity is (0.0, 0.0, 0.0, 1.0) for all lights other than light zero. The default diffuse intensity of light zero is (1.0, 1.0, 1.0, 1.0). <br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_SPECULAR"></span><span id="gl_specular"></span><dl> <dt>**GL\_SPECULAR**</dt> </dl>                                                                                                                                                                                             | The *params* parameter contains four floating-point values that specify the specular RGBA intensity of the light. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The default specular intensity is (0.0, 0.0, 0.0, 1.0) for all lights other than light zero. The default specular intensity of light zero is (1.0, 1.0, 1.0, 1.0).<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
     * | <span id="GL_POSITION"></span><span id="gl_position"></span><dl> <dt>**GL\_POSITION**</dt> </dl>                                                                                                                                                                                             | The *params* parameter contains four floating-point values that specify the position of the light in homogeneous object coordinates. Both integer and floating-point values are mapped directly. Neither integer nor floating-point values are clamped. <br/> The position is transformed by the modelview matrix when **glLightfv** is called (just as if it were a point), and it is stored in eye coordinates. If the *w* component of the position is 0.0, the light is treated as a directional source. Diffuse and specular lighting calculations take the light's direction, but not its actual position, into account, and attenuation is disabled. Otherwise, diffuse and specular lighting calculations are based on the actual location of the light in eye coordinates, and attenuation is enabled. The default position is (0,0,1,0); thus, the default light source is directional, parallel to, and in the direction of the -*z* axis.<br/> |
     * | <span id="GL_SPOT_DIRECTION"></span><span id="gl_spot_direction"></span><dl> <dt>**GL\_SPOT\_DIRECTION**</dt> </dl>                                                                                                                                                                          | The *params* parameter contains three floating-point values that specify the direction of the light in homogeneous object coordinates. Both integer and floating-point values are mapped directly. Neither integer nor floating-point values are clamped. <br/> The spot direction is transformed by the inverse of the modelview matrix when **glLightfv** is called (just as if it were a normal), and it is stored in eye coordinates. It is significant only when GL\_SPOT\_CUTOFF is not 180, which it is by default. The default direction is (0,0,1).<br/>                                                                                                                                                                                                                                                                                                                                                                                          |
     * | <span id="GL_SPOT_EXPONENT"></span><span id="gl_spot_exponent"></span><dl> <dt>**GL\_SPOT\_EXPONENT**</dt> </dl>                                                                                                                                                                             | The *params* parameter is a single floating-point value that specifies the intensity distribution of the light. Integer and floating-point values are mapped directly. Only values in the range \[0, 128\] are accepted. <br/> Effective light intensity is attenuated by the cosine of the angle between the direction of the light and the direction from the light to the vertex being lighted, raised to the power of the spot exponent. Thus, higher spot exponents result in a more focused light source, regardless of the spot cutoff angle. The default spot exponent is 0, resulting in uniform light distribution.<br/>                                                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_SPOT_CUTOFF"></span><span id="gl_spot_cutoff"></span><dl> <dt>**GL\_SPOT\_CUTOFF**</dt> </dl>                                                                                                                                                                                   | The *params* parameter is a single floating-point value that specifies the maximum spread angle of a light source. Integer and floating-point values are mapped directly. Only values in the range \[0, 90\], and the special value 180, are accepted. <br/> If the angle between the direction of the light and the direction from the light to the vertex being lighted is greater than the spot cutoff angle, then the light is completely masked. Otherwise, its intensity is controlled by the spot exponent and the attenuation factors. The default spot cutoff is 180, resulting in uniform light distribution.<br/>                                                                                                                                                                                                                                                                                                                               |
     * | <span id="GL_CONSTANT_ATTENUATION__GL_LINEAR_ATTENUATION__GL_QUADRATIC_ATTENUATION"></span><span id="gl_constant_attenuation__gl_linear_attenuation__gl_quadratic_attenuation"></span><dl> <dt>**GL\_CONSTANT\_ATTENUATION, GL\_LINEAR\_ATTENUATION, GL\_QUADRATIC\_ATTENUATION**</dt> </dl> | The *params* parameter is a single floating-point value that specifies one of the three light attenuation factors. Integer and floating-point values are mapped directly. Only nonnegative values are accepted. <br/> If the light is positional, rather than directional, its intensity is attenuated by the reciprocal of the sum of: the constant factor, the linear factor multiplied by the distance between the light and the vertex being lighted, and the quadratic factor multiplied by the square of the same distance. The default attenuation factors are (1,0,0), resulting in no attenuation.<br/>                                                                                                                                                                                                                                                                                                                                           |
     * @param {Pointer<Single>} params Specifies the value that parameter *pname* of light source *light* will be set to.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gllightfv
     */
    static glLightfv(light, pname, params) {
        DllCall("OPENGL32.dll\glLightfv", "uint", light, "uint", pname, "ptr", params)
    }

    /**
     * The glLighti function returns light source parameter values.
     * @remarks
     * The **glLighti** function sets the value or values of individual light source parameters. The *light* parameter names the light and is a symbolic name of the form GL\_LIGHT*i*, where 0 = *i* < GL\_MAX\_LIGHTS.
     * 
     * The *pname* parameter specifies one of the light source parameters, again by symbolic name. The *param* parameter is either a single value or a pointer to an array that contains the new values.
     * 
     * Lighting calculation is enabled and disabled using [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with argument GL\_LIGHTING. When lighting is enabled, light sources that are enabled contribute to the lighting calculation. Light source *i* is enabled and disabled using **glEnable** and **glDisable** with argument GL\_LIGHT*i*.
     * 
     * It is always the case that GL\_LIGHT*i* = GL\_LIGHT0 + *i*.
     * 
     * The following functions retrieve information related to the **glLighti** function:
     * 
     * [**glGetLight**](glgetlight.md)
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_LIGHTING
     * @param {Integer} light The identifier of a light. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL\_LIGHT*i* where *i* is a value: 0 to GL\_MAX\_LIGHTS - 1.
     * @param {Integer} pname A single-valued light source parameter for *light*. The following symbolic names are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                                                                                                                                                               | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_SPOT_EXPONENT"></span><span id="gl_spot_exponent"></span><dl> <dt>**GL\_SPOT\_EXPONENT**</dt> </dl>                                                                                                                                                                             | The *param* parameter is a single integer value that specifies the intensity distribution of the light. Integer and floating-point values are mapped directly. Only values in the range \[0, 128\] are accepted. <br/> Effective light intensity is attenuated by the cosine of the angle between the direction of the light and the direction from the light to the vertex being lighted, raised to the power of the spot exponent. Thus, higher spot exponents result in a more focused light source, regardless of the spot cutoff angle. The default spot exponent is 0, resulting in uniform light distribution.<br/> |
     * | <span id="GL_SPOT_CUTOFF"></span><span id="gl_spot_cutoff"></span><dl> <dt>**GL\_SPOT\_CUTOFF**</dt> </dl>                                                                                                                                                                                   | The *param* parameter is a single integer value that specifies the maximum spread angle of a light source. Integer and floating-point values are mapped directly. Only values in the range \[0, 90\], and the special value 180, are accepted. <br/> If the angle between the direction of the light and the direction from the light to the vertex being lighted is greater than the spot cutoff angle, then the light is completely masked. Otherwise, its intensity is controlled by the spot exponent and the attenuation factors. The default spot cutoff is 180, resulting in uniform light distribution.<br/>       |
     * | <span id="GL_CONSTANT_ATTENUATION__GL_LINEAR_ATTENUATION__GL_QUADRATIC_ATTENUATION"></span><span id="gl_constant_attenuation__gl_linear_attenuation__gl_quadratic_attenuation"></span><dl> <dt>**GL\_CONSTANT\_ATTENUATION, GL\_LINEAR\_ATTENUATION, GL\_QUADRATIC\_ATTENUATION**</dt> </dl> | The *param* parameter is a single integer value that specifies one of the three light attenuation factors. Integer and floating-point values are mapped directly. Only nonnegative values are accepted. <br/> If the light is positional, rather than directional, its intensity is attenuated by the reciprocal of the sum of: the constant factor, the linear factor multiplied by the distance between the light and the vertex being lighted, and the quadratic factor multiplied by the square of the same distance. The default attenuation factors are (1,0,0), resulting in no attenuation.<br/>                   |
     * @param {Integer} param2 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gllighti
     */
    static glLighti(light, pname, param2) {
        DllCall("OPENGL32.dll\glLighti", "uint", light, "uint", pname, "int", param2)
    }

    /**
     * The glLightiv function returns light source parameter values.
     * @remarks
     * The **glLightiv** function sets the value or values of individual light source parameters. The *light* parameter names the light and is a symbolic name of the form GL\_LIGHT*i*, where 0 = *i* < GL\_MAX\_LIGHTS.
     * 
     * The *pname* parameter specifies one of the light source parameters, again by symbolic name. The *params* parameter is either a single value or a pointer to an array that contains the new values.
     * 
     * Lighting calculation is enabled and disabled using [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with argument GL\_LIGHTING. When lighting is enabled, light sources that are enabled contribute to the lighting calculation. Light source *i* is enabled and disabled using **glEnable** and **glDisable** with argument GL\_LIGHT*i*.
     * 
     * It is always the case that GL\_LIGHT*i* = GL\_LIGHT0 + *i*.
     * 
     * The following functions retrieve information related to the **glLightiv** function:
     * 
     * [**glGetLight**](glgetlight.md)
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_LIGHTING
     * @param {Integer} light The identifier of a light. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL\_LIGHT*i* where *i* is a value: 0 to GL\_MAX\_LIGHTS - 1.
     * @param {Integer} pname A light source parameter for *light*. The following symbolic names are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                                                                                                                                                               | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_AMBIENT"></span><span id="gl_ambient"></span><dl> <dt>**GL\_AMBIENT**</dt> </dl>                                                                                                                                                                                                | The *params* parameter contains four integer values that specify the ambient RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The default ambient light intensity is (0.0, 0.0, 0.0, 1.0). <br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
     * | <span id="GL_DIFFUSE"></span><span id="gl_diffuse"></span><dl> <dt>**GL\_DIFFUSE**</dt> </dl>                                                                                                                                                                                                | The *params* parameter contains four integer values that specify the diffuse RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The default diffuse intensity is (0.0, 0.0, 0.0, 1.0) for all lights other than light zero. The default diffuse intensity of light zero is (1.0, 1.0, 1.0, 1.0). <br/>                                                                                                                                                                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_SPECULAR"></span><span id="gl_specular"></span><dl> <dt>**GL\_SPECULAR**</dt> </dl>                                                                                                                                                                                             | The *params* parameter contains four integer values that specify the specular RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to 1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The default specular intensity is (0.0, 0.0, 0.0, 1.0) for all lights other than light zero. The default specular intensity of light zero is (1.0, 1.0, 1.0, 1.0).<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_POSITION"></span><span id="gl_position"></span><dl> <dt>**GL\_POSITION**</dt> </dl>                                                                                                                                                                                             | The *params* parameter contains four integer values that specify the position of the light in homogeneous object coordinates. Both integer and floating-point values are mapped directly. Neither integer nor floating-point values are clamped. <br/> The position is transformed by the modelview matrix when [**glLightiv**](gllightfv.md) is called (just as if it were a point), and it is stored in eye coordinates. If the *w* component of the position is 0.0, the light is treated as a directional source. Diffuse and specular lighting calculations take the light's direction, but not its actual position, into account, and attenuation is disabled. Otherwise, diffuse and specular lighting calculations are based on the actual location of the light in eye coordinates, and attenuation is enabled. The default position is (0,0,1,0); thus, the default light source is directional, parallel to, and in the direction of the -*z* axis.<br/> |
     * | <span id="GL_SPOT_DIRECTION"></span><span id="gl_spot_direction"></span><dl> <dt>**GL\_SPOT\_DIRECTION**</dt> </dl>                                                                                                                                                                          | The *params* parameter contains three integer values that specify the direction of the light in homogeneous object coordinates. Both integer and floating-point values are mapped directly. Neither integer nor floating-point values are clamped. <br/> The spot direction is transformed by the inverse of the modelview matrix when **glLightiv** is called (just as if it were a normal), and it is stored in eye coordinates. It is significant only when GL\_SPOT\_CUTOFF is not 180, which it is by default. The default direction is (0,0,1).<br/>                                                                                                                                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_SPOT_EXPONENT"></span><span id="gl_spot_exponent"></span><dl> <dt>**GL\_SPOT\_EXPONENT**</dt> </dl>                                                                                                                                                                             | The *params* parameter is a single integer value that specifies the intensity distribution of the light. Integer and floating-point values are mapped directly. Only values in the range \[0, 128\] are accepted. <br/> Effective light intensity is attenuated by the cosine of the angle between the direction of the light and the direction from the light to the vertex being lighted, raised to the power of the spot exponent. Thus, higher spot exponents result in a more focused light source, regardless of the spot cutoff angle. The default spot exponent is 0, resulting in uniform light distribution.<br/>                                                                                                                                                                                                                                                                                                                                          |
     * | <span id="GL_SPOT_CUTOFF"></span><span id="gl_spot_cutoff"></span><dl> <dt>**GL\_SPOT\_CUTOFF**</dt> </dl>                                                                                                                                                                                   | The *params* parameter is a single integer value that specifies the maximum spread angle of a light source. Integer and floating-point values are mapped directly. Only values in the range \[0, 90\], and the special value 180, are accepted. <br/> If the angle between the direction of the light and the direction from the light to the vertex being lighted is greater than the spot cutoff angle, then the light is completely masked. Otherwise, its intensity is controlled by the spot exponent and the attenuation factors. The default spot cutoff is 180, resulting in uniform light distribution.<br/>                                                                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_CONSTANT_ATTENUATION__GL_LINEAR_ATTENUATION__GL_QUADRATIC_ATTENUATION"></span><span id="gl_constant_attenuation__gl_linear_attenuation__gl_quadratic_attenuation"></span><dl> <dt>**GL\_CONSTANT\_ATTENUATION, GL\_LINEAR\_ATTENUATION, GL\_QUADRATIC\_ATTENUATION**</dt> </dl> | The *params* parameter is a single integer value that specifies one of the three light attenuation factors. Integer and floating-point values are mapped directly. Only nonnegative values are accepted. <br/> If the light is positional, rather than directional, its intensity is attenuated by the reciprocal of the sum of: the constant factor, the linear factor multiplied by the distance between the light and the vertex being lighted, and the quadratic factor multiplied by the square of the same distance. The default attenuation factors are (1,0,0), resulting in no attenuation.<br/>                                                                                                                                                                                                                                                                                                                                                            |
     * @param {Pointer<Int32>} params Specifies the value that parameter *pname* of light source *light* will be set to.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gllightiv
     */
    static glLightiv(light, pname, params) {
        DllCall("OPENGL32.dll\glLightiv", "uint", light, "uint", pname, "ptr", params)
    }

    /**
     * The glLineStipple function specifies the line stipple pattern.
     * @remarks
     * The **glLineStipple** function specifies the line stipple pattern. Line stippling masks out certain fragments produced by rasterization; those fragments will not be drawn. The masking is achieved by using three parameters: the 16-bit line stipple pattern *pattern*, the repeat count *factor*, and an integer stipple counter *s*.
     * 
     * Counter *s* is reset to zero whenever [**glBegin**](glbegin.md) is called, and before each line segment of a **glBegin**(GL\_LINES)//*glEnd** sequence is generated. It is incremented after each fragment of a unit width aliased line segment is generated, or after each *i* fragments of an *i* width line segment are generated. The *i* fragments associated with count *s* are masked out if *pattern* bit (*s* / *factor*) mod 16 is zero. Otherwise these fragments are sent to the framebuffer. Bit zero of *pattern* is the least significant bit.
     * 
     * Antialiased lines are treated as a sequence of 1x*width* rectangles for purposes of stippling. Rectangle *s* is rasterized or not based on the fragment rule described for aliased lines; it counts rectangles rather than groups of fragments.
     * 
     * Line stippling is enabled or disabled using [**glEnable**](glenable.md) and **glDisable** with argument GL\_LINE\_STIPPLE. When enabled, the line stipple pattern is applied as described above. When disabled, it is as if the pattern were all ones. Initially, line stippling is disabled.
     * 
     * The following functions retrieve information related to **glLineStipple**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_LINE\_STIPPLE\_PATTERN
     * 
     * **glGet** with argument GL\_LINE\_STIPPLE\_REPEAT
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_LINE\_STIPPLE
     * @param {Integer} factor A multiplier for each bit in the line stipple pattern. If *factor* is 3, for example, each bit in the pattern will be used three times before the next bit in the pattern is used. The *factor* parameter is clamped to the range \[1, 256\] and defaults to one.
     * @param {Integer} pattern A 16-bit integer whose bit pattern determines which fragments of a line will be drawn when the line is rasterized. Bit zero is used first, and the default pattern is all ones.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gllinestipple
     */
    static glLineStipple(factor, pattern) {
        DllCall("OPENGL32.dll\glLineStipple", "int", factor, "ushort", pattern)
    }

    /**
     * The glLineWidth function specifies the width of rasterized lines.
     * @remarks
     * The **glLineWidth** function specifies the rasterized width of both aliased and antialiased lines. Using a line width other than 1.0 has different effects, depending on whether line antialiasing is enabled. Line antialiasing is controlled by calling [**glEnable**](glenable.md) and **glDisable** with argument GL\_LINE\_SMOOTH.
     * 
     * If line antialiasing is disabled, the actual width is determined by rounding the supplied width to the nearest integer. (If the rounding results in the value 0.0, it is as if the line width were 1.0) If \| ? x \| = \| ? y \|, *i* pixels are filled in each column that is rasterized, where *i* is the rounded value of *width*. Otherwise, *i* pixels are filled in each row that is rasterized.
     * 
     * If antialiasing is enabled, line rasterization produces a fragment for each pixel square that intersects the region lying within the rectangle having width equal to the current line width, length equal to the actual length of the line, and centered on the mathematical line segment. The coverage value for each fragment is the window coordinate area of the intersection of the rectangular region with the corresponding pixel square. This value is saved and used in the final rasterization step.
     * 
     * Not all widths can be supported when line antialiasing is enabled. If an unsupported width is requested, the nearest supported width is used. Only width 1.0 is guaranteed to be supported; others depend on the implementation. The range of supported widths and the size difference between supported widths within the range can be queried by calling **glGet** with arguments GL\_LINE\_WIDTH\_RANGE and GL\_LINE\_WIDTH\_GRANULARITY.
     * 
     * The line width specified by **glLineWidth** is always returned when GL\_LINE\_WIDTH is queried. Clamping and rounding for aliased and antialiased lines have no effect on the specified value.
     * 
     * Non-antialiased line width may be clamped to an implementation-dependent maximum. Although this maximum cannot be queried, it must be no less than the maximum value for antialiased lines, rounded to the nearest integer value.
     * 
     * The following functions retrieve information related to **glLineWidth**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_LINE\_WIDTH
     * 
     * **glGet** with argument GL\_LINE\_WIDTH\_RANGE
     * 
     * **glGet** with argument GL\_LINE\_WIDTH\_GRANULARITY
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_LINE\_SMOOTH
     * @param {Float} width The width of rasterized lines. The default is 1.0.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gllinewidth
     */
    static glLineWidth(width) {
        DllCall("OPENGL32.dll\glLineWidth", "float", width)
    }

    /**
     * The glListBase function sets the display list base for glCallLists.
     * @remarks
     * The **glListBase** function specifies an array of offsets. Display list names are generated by adding *base* to each offset. Names that reference valid display lists are executed; others are ignored.
     * 
     * The following function retrieves information related to **glListBase**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_LIST\_BASE
     * @param {Integer} base An integer offset that will be added to [**glCallLists**](glcalllists.md) offsets to generate display list names. Initial value is zero.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gllistbase
     */
    static glListBase(base) {
        DllCall("OPENGL32.dll\glListBase", "uint", base)
    }

    /**
     * The glLoadIdentity function replaces the current matrix with the identity matrix.
     * @remarks
     * The **glLoadIdentity** function replaces the current matrix with the identity matrix. It is semantically equivalent to calling [**glLoadMatrix**](glloadmatrix.md) with the following identity matrix.
     * 
     * ![Diagram showing the identity matrix that glLoadIdentity calls.](images/load01.png)
     * 
     * However, in some cases, it is more efficient.
     * 
     * The following functions retrieve information related to **glLoadIdentity**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * 
     * **glGet** with argument GL\_MODELVIEW\_MATRIX
     * 
     * **glGet** with argument GL\_PROJECTION\_MATRIX
     * 
     * **glGet** with argument GL\_TEXTURE\_MATRIX
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glloadidentity
     */
    static glLoadIdentity() {
        DllCall("OPENGL32.dll\glLoadIdentity")
    }

    /**
     * The glLoadMatrixd function replaces the current matrix with an arbitrary matrix. | glLoadMatrixd function (Gl.h)
     * @remarks
     * The **glLoadMatrix** function replaces the current matrix with the one specified in *m*. The current matrix is the projection matrix, modelview matrix, or texture matrix, determined by the current matrix mode (see [**glMatrixMode**](glmatrixmode.md)).
     * 
     * The *m* parameter points to a 4x4 matrix of single-precision or double-precision floating-point values stored in column-major order. That is, the matrix is stored as shown in the following image.
     * 
     * ![Diagram showing the 4x4 matrix that the m parameter points to.](images/load02.png)
     * 
     * The following functions retrieve information related to **glLoadMatrix**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * 
     * **glGet** with argument GL\_MODELVIEW\_MATRIX
     * 
     * **glGet** with argument GL\_PROJECTION\_MATRIX
     * 
     * **glGet** with argument GL\_TEXTURE\_MATRIX
     * @param {Pointer<Double>} m A pointer to a 4x4 matrix stored in column-major order as 16 consecutive values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glloadmatrixd
     */
    static glLoadMatrixd(m) {
        DllCall("OPENGL32.dll\glLoadMatrixd", "ptr", m)
    }

    /**
     * The glLoadMatrixf function replaces the current matrix with an arbitrary matrix. | glLoadMatrixf function (Gl.h)
     * @remarks
     * The **glLoadMatrix** function replaces the current matrix with the one specified in *m*. The current matrix is the projection matrix, modelview matrix, or texture matrix, determined by the current matrix mode (see [**glMatrixMode**](glmatrixmode.md)).
     * 
     * The *m* parameter points to a 4x4 matrix of single-precision or double-precision floating-point values stored in column-major order. That is, the matrix is stored as shown in the following image.
     * 
     * ![Diagram showing the 4x4 matrix that the m parameter points to.](images/load02.png)
     * 
     * The following functions retrieve information related to **glLoadMatrix**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * 
     * **glGet** with argument GL\_MODELVIEW\_MATRIX
     * 
     * **glGet** with argument GL\_PROJECTION\_MATRIX
     * 
     * **glGet** with argument GL\_TEXTURE\_MATRIX
     * @param {Pointer<Single>} m A pointer to a 4x4 matrix stored in column-major order as 16 consecutive values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glloadmatrixf
     */
    static glLoadMatrixf(m) {
        DllCall("OPENGL32.dll\glLoadMatrixf", "ptr", m)
    }

    /**
     * The glLoadName function loads a name onto the name stack.
     * @remarks
     * The **glLoadName** function causes *name* to replace the value on the top of the name stack, which is initially empty. The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It consists of an ordered set of unsigned integers.
     * 
     * The name stack is always empty while the render mode is not GL\_SELECT. Calls to **glLoadName** while the render mode is not GL\_SELECT are ignored.
     * 
     * The following functions retrieve information related to **glLoadName**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_NAME\_STACK\_DEPTH
     * 
     * **glGet** with argument GL\_MAX\_NAME\_STACK\_DEPTH
     * @param {Integer} name A name that will replace the top value on the name stack.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glloadname
     */
    static glLoadName(name) {
        DllCall("OPENGL32.dll\glLoadName", "uint", name)
    }

    /**
     * The glLogicOp function specifies a logical pixel operation for color index rendering.
     * @remarks
     * The **glLogicOp** function specifies a logical operation that, when enabled, is applied between the incoming color index and the color index at the corresponding location in the framebuffer. The logical operation is enabled or disabled with [**glEnable**](glenable.md) and **glDisable** using the symbolic constant GL\_LOGIC\_OP.
     * 
     * The *opcode* parameter is a symbolic constant chosen from the list below. In the explanation of the logical operations, *s* represents the incoming color index and *d* represents the index in the framebuffer. Standard C-language operators are used. As these bitwise operators suggest, the logical operation is applied independently to each bit pair of the source and destination indexes.
     * 
     * Logical pixel operations are not applied to RGBA color buffers.
     * 
     * When more than one color-index buffer is enabled for drawing, logical operations are done separately for each enabled buffer, using the contents of that buffer for the destination index (see [**glDrawBuffer**](gldrawbuffer.md)).
     * 
     * The *opcode* parameter must be one of the 16 accepted values. Other values result in an error.
     * 
     * The following functions retrieve information related to **glLogicOp**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_LOGIC\_OP\_MODE
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_LOGIC\_OP
     * @param {Integer} opcode A symbolic constant that selects a logical operation. The following symbols are accepted where s equals the value of the source bit and d is the value of the destination bit.
     * 
     * 
     * 
     * | Value                                                                                                                                                                   | Meaning              |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------|
     * | <span id="GL_CLEAR"></span><span id="gl_clear"></span><dl> <dt>**GL\_CLEAR**</dt> </dl>                          | 0<br/>         |
     * | <span id="GL_SET"></span><span id="gl_set"></span><dl> <dt>**GL\_SET**</dt> </dl>                                | 1<br/>         |
     * | <span id="GL_COPY"></span><span id="gl_copy"></span><dl> <dt>**GL\_COPY**</dt> </dl>                             | s<br/>         |
     * | <span id="GL_COPY_INVERTED"></span><span id="gl_copy_inverted"></span><dl> <dt>**GL\_COPY\_INVERTED**</dt> </dl> | !s<br/>        |
     * | <span id="GL_NOOP"></span><span id="gl_noop"></span><dl> <dt>**GL\_NOOP**</dt> </dl>                             | d<br/>         |
     * | <span id="GL_INVERT"></span><span id="gl_invert"></span><dl> <dt>**GL\_INVERT**</dt> </dl>                       | !d<br/>        |
     * | <span id="GL_AND"></span><span id="gl_and"></span><dl> <dt>**GL\_AND**</dt> </dl>                                | s & d<br/>     |
     * | <span id="GL_NAND"></span><span id="gl_nand"></span><dl> <dt>**GL\_NAND**</dt> </dl>                             | !(s & d)<br/>  |
     * | <span id="GL_OR"></span><span id="gl_or"></span><dl> <dt>**GL\_OR**</dt> </dl>                                   | s \| d<br/>    |
     * | <span id="GL_NOR"></span><span id="gl_nor"></span><dl> <dt>**GL\_NOR**</dt> </dl>                                | !(s \| d)<br/> |
     * | <span id="GL_XOR"></span><span id="gl_xor"></span><dl> <dt>**GL\_XOR**</dt> </dl>                                | s ^ d<br/>     |
     * | <span id="GL_EQUIV"></span><span id="gl_equiv"></span><dl> <dt>**GL\_EQUIV**</dt> </dl>                          | !(s ^ d)<br/>  |
     * | <span id="GL_AND_REVERSE"></span><span id="gl_and_reverse"></span><dl> <dt>**GL\_AND\_REVERSE**</dt> </dl>       | s & !d<br/>    |
     * | <span id="GL_AND_INVERTED"></span><span id="gl_and_inverted"></span><dl> <dt>**GL\_AND\_INVERTED**</dt> </dl>    | !s & d<br/>    |
     * | <span id="GL_OR_REVERSE"></span><span id="gl_or_reverse"></span><dl> <dt>**GL\_OR\_REVERSE**</dt> </dl>          | s \| !d<br/>   |
     * | <span id="GL_OR_INVERTED"></span><span id="gl_or_inverted"></span><dl> <dt>**GL\_OR\_INVERTED**</dt> </dl>       | !s \| d<br/>   |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gllogicop
     */
    static glLogicOp(opcode) {
        DllCall("OPENGL32.dll\glLogicOp", "uint", opcode)
    }

    /**
     * The glMap1d function defines a one-dimensional evaluator. | glMap1d function (Gl.h)
     * @remarks
     * Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals, texture coordinates, and colors. The values produced by an evaluator are sent to further stages of OpenGL processing just as if they had been presented using [**glVertex**](glvertex-functions.md), [**glNormal**](glnormal-functions.md), [**glTexCoord**](gltexcoord-functions.md), and [**glColor**](glcolor-functions.md) commands, except that the generated values do not update the current normal, texture coordinates, or color.
     * 
     * All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the OpenGL implementation) can be described using evaluators. These include almost all splines used in computer graphics, including B-splines, Bezier curves, Hermite splines, and so on.
     * 
     * Evaluators define curves based on Bernstein polynomials. Define **p** () as
     * 
     * ![Equation showing the definition of p ().](images/map01.png)
     * 
     * where **R***i* is a control point and () is the *i* the Bernstein polynomial of degree *n* (*order* =*n* + 1):
     * 
     * ![Equation showing the Bernstein polynomial of degree n.](images/map02.png)
     * 
     * Recall that
     * 
     * ![Equations showing equivalence to 1.](images/map03.png)
     * 
     * The **glMap1** function is used to define the basis and to specify what kind of values are produced. Once defined, a map can be enabled and disabled by calling [**glEnable**](glenable.md) and **glDisable** with the map name, one of the nine predefined values for *target* described above. The [glEvalCoord1](glevalcoord-functions.md) function evaluates the one-dimensional maps that are enabled. When **glEvalCoord1** presents a value *u*, the Bernstein functions are evaluated using *u*^, where
     * 
     * ![Equation showing the definition of u^.](images/map04.png)
     * 
     * The *stride*, *order*, and *points* parameters define the array addressing for accessing the control points. The *points* parameter is the location of the first control point, which occupies one, two, three, or four contiguous memory locations, depending on which map is being defined. The *order* parameter is the number of control points in the array. The *stride* parameter tells how many float or double locations to advance the internal memory pointer to reach the next control point.
     * 
     * As is the case with all OpenGL commands that accept pointers to data, it is as if the contents of *points* were copied by **glMap1** before it returned. Changes to the contents of *points* have no effect after **glMap1** is called.
     * 
     * The following functions retrieve information related to **glMap1**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAX\_EVAL\_ORDER
     * 
     * [**glGetMap**](glgetmap.md)
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_3
     * 
     * **glIsEnabled** with argument GL\_MAP1\_VERTEX\_4
     * 
     * **glIsEnabled** with argument GL\_MAP1\_INDEX
     * 
     * **glIsEnabled** with argument GL\_MAP1\_COLOR\_4
     * 
     * **glIsEnabled** with argument GL\_MAP1\_NORMAL
     * 
     * **glIsEnabled** with argument GL\_MAP1\_TEXTURE\_COORD\_1
     * 
     * **glIsEnabled** with argument GL\_MAP1\_TEXTURE\_COORD\_2
     * 
     * **glIsEnabled** with argument GL\_MAP1\_TEXTURE\_COORD\_3
     * 
     * **glIsEnabled** with argument GL\_MAP1\_TEXTURE\_COORD\_4
     * @param {Integer} target The kind of values that are generated by the evaluator. Symbolic constants. The *target* parameter is a symbolic constant that indicates what kind of control points are provided in *points*, and what output is generated when the map is evaluated. It can assume one of nine predefined values.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                          | Meaning                                                                                                                                                                                                                                                                                                                               |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_MAP1_VERTEX_3"></span><span id="gl_map1_vertex_3"></span><dl> <dt>**GL\_MAP1\_VERTEX\_3**</dt> </dl>                       | Each control point is three floating-point values representing *x, y,* and *z*. Internal [**glVertex3**](glvertex-functions.md) commands are generated when the map is evaluated.<br/>                                                                                                                                         |
     * | <span id="GL_MAP1_VERTEX_4"></span><span id="gl_map1_vertex_4"></span><dl> <dt>**GL\_MAP1\_VERTEX\_4**</dt> </dl>                       | Each control point is four floating-point values representing *x, y, z,* and *w*. Internal [**glVertex4**](glvertex-functions.md) commands are generated when the map is evaluated.<br/>                                                                                                                                       |
     * | <span id="GL_MAP1_INDEX"></span><span id="gl_map1_index"></span><dl> <dt>**GL\_MAP1\_INDEX**</dt> </dl>                                 | Each control point is a single floating-point value representing a color index. Internal [**glIndex**](glindex-functions.md) commands are generated when the map is evaluated. However, the current index is not updated with the value of these **glIndex** commands.<br/>                                                    |
     * | <span id="GL_MAP1_COLOR_4"></span><span id="gl_map1_color_4"></span><dl> <dt>**GL\_MAP1\_COLOR\_4**</dt> </dl>                          | Each control point is four floating-point values representing red, green, blue, and alpha. Internal [**glColor4**](glcolor-functions.md) commands are generated when the map is evaluated. However, the current color is not updated with the value of these **glColor4** commands.<br/>                                       |
     * | <span id="GL_MAP1_NORMAL"></span><span id="gl_map1_normal"></span><dl> <dt>**GL\_MAP1\_NORMAL**</dt> </dl>                              | Each control point is three floating-point values representing the *x, y,* and *z* components of a normal vector. Internal [**glNormal**](glnormal-functions.md) commands are generated when the map is evaluated. However, the current normal is not updated with the value of these **glNormal** commands.<br/>              |
     * | <span id="GL_MAP1_TEXTURE_COORD_1"></span><span id="gl_map1_texture_coord_1"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_1**</dt> </dl> | Each control point is a single floating-point value representing the *s* texture coordinate. Internal [**glTexCoord1**](gltexcoord-functions.md) commands are generated when the map is evaluated. However, the current texture coordinates are not updated with the value of these **glTexCoord** commands.<br/>              |
     * | <span id="GL_MAP1_TEXTURE_COORD_2"></span><span id="gl_map1_texture_coord_2"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_2**</dt> </dl> | Each control point is two floating-point values representing the *s* and *t* texture coordinates. Internal [**glTexCoord2**](gltexcoord-functions.md) commands are generated when the map is evaluated. However, the current texture coordinates are not updated with the value of these **glTexCoord** commands.<br/>         |
     * | <span id="GL_MAP1_TEXTURE_COORD_3"></span><span id="gl_map1_texture_coord_3"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_3**</dt> </dl> | Each control point is three floating-point values representing the *s, t,* and *r* texture coordinates. Internal [**glTexCoord3**](gltexcoord-functions.md) commands are generated when the map is evaluated. However, the current texture coordinates are not updated with the value of these **glTexCoord** commands.<br/>   |
     * | <span id="GL_MAP1_TEXTURE_COORD_4"></span><span id="gl_map1_texture_coord_4"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_4**</dt> </dl> | Each control point is four floating-point values representing the *s, t, r,* and *q* texture coordinates. Internal [**glTexCoord4**](gltexcoord-functions.md) commands are generated when the map is evaluated. However, the current texture coordinates are not updated with the value of these **glTexCoord** commands.<br/> |
     * @param {Float} u1 A linear mapping of *u*, as presented to [**glEvalCoord1**](glevalcoord-functions.md), to *u*^, the variable that is evaluated by the equations specified by this command.
     * @param {Float} u2 A linear mapping of *u*, as presented to [**glEvalCoord1**](glevalcoord-functions.md), to *u*^, the variable that is evaluated by the equations specified by this command.
     * @param {Integer} stride The number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in *points*. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations.
     * @param {Integer} order The number of control points. Must be positive.
     * @param {Pointer<Double>} points A pointer to the array of control points.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glmap1d
     */
    static glMap1d(target, u1, u2, stride, order, points) {
        DllCall("OPENGL32.dll\glMap1d", "uint", target, "double", u1, "double", u2, "int", stride, "int", order, "ptr", points)
    }

    /**
     * The glMap1f function defines a one-dimensional evaluator. | glMap1f function (Gl.h)
     * @remarks
     * Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals, texture coordinates, and colors. The values produced by an evaluator are sent to further stages of OpenGL processing just as if they had been presented using [**glVertex**](glvertex-functions.md), [**glNormal**](glnormal-functions.md), [**glTexCoord**](gltexcoord-functions.md), and [**glColor**](glcolor-functions.md) commands, except that the generated values do not update the current normal, texture coordinates, or color.
     * 
     * All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the OpenGL implementation) can be described using evaluators. These include almost all splines used in computer graphics, including B-splines, Bezier curves, Hermite splines, and so on.
     * 
     * Evaluators define curves based on Bernstein polynomials. Define **p** () as
     * 
     * ![Equation showing the definition of p ().](images/map01.png)
     * 
     * where **R***i* is a control point and () is the *i* the Bernstein polynomial of degree *n* (*order* =*n* + 1):
     * 
     * ![Equation showing the Bernstein polynomial of degree n.](images/map02.png)
     * 
     * Recall that
     * 
     * ![Equations showing equivalence to 1.](images/map03.png)
     * 
     * The **glMap1** function is used to define the basis and to specify what kind of values are produced. Once defined, a map can be enabled and disabled by calling [**glEnable**](glenable.md) and **glDisable** with the map name, one of the nine predefined values for *target* described above. The [glEvalCoord1](glevalcoord-functions.md) function evaluates the one-dimensional maps that are enabled. When **glEvalCoord1** presents a value *u*, the Bernstein functions are evaluated using *u*^, where
     * 
     * ![Equation showing the definition of u^.](images/map04.png)
     * 
     * The *stride*, *order*, and *points* parameters define the array addressing for accessing the control points. The *points* parameter is the location of the first control point, which occupies one, two, three, or four contiguous memory locations, depending on which map is being defined. The *order* parameter is the number of control points in the array. The *stride* parameter tells how many float or double locations to advance the internal memory pointer to reach the next control point.
     * 
     * As is the case with all OpenGL commands that accept pointers to data, it is as if the contents of *points* were copied by **glMap1** before it returned. Changes to the contents of *points* have no effect after **glMap1** is called.
     * 
     * The following functions retrieve information related to **glMap1**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAX\_EVAL\_ORDER
     * 
     * [**glGetMap**](glgetmap.md)
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP1\_VERTEX\_3
     * 
     * **glIsEnabled** with argument GL\_MAP1\_VERTEX\_4
     * 
     * **glIsEnabled** with argument GL\_MAP1\_INDEX
     * 
     * **glIsEnabled** with argument GL\_MAP1\_COLOR\_4
     * 
     * **glIsEnabled** with argument GL\_MAP1\_NORMAL
     * 
     * **glIsEnabled** with argument GL\_MAP1\_TEXTURE\_COORD\_1
     * 
     * **glIsEnabled** with argument GL\_MAP1\_TEXTURE\_COORD\_2
     * 
     * **glIsEnabled** with argument GL\_MAP1\_TEXTURE\_COORD\_3
     * 
     * **glIsEnabled** with argument GL\_MAP1\_TEXTURE\_COORD\_4
     * @param {Integer} target The kind of values that are generated by the evaluator. Symbolic constants. The *target* parameter is a symbolic constant that indicates what kind of control points are provided in *points*, and what output is generated when the map is evaluated. It can assume one of nine predefined values.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                          | Meaning                                                                                                                                                                                                                                                                                                                               |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_MAP1_VERTEX_3"></span><span id="gl_map1_vertex_3"></span><dl> <dt>**GL\_MAP1\_VERTEX\_3**</dt> </dl>                       | Each control point is three floating-point values representing *x, y,* and *z*. Internal [**glVertex3**](glvertex-functions.md) commands are generated when the map is evaluated.<br/>                                                                                                                                         |
     * | <span id="GL_MAP1_VERTEX_4"></span><span id="gl_map1_vertex_4"></span><dl> <dt>**GL\_MAP1\_VERTEX\_4**</dt> </dl>                       | Each control point is four floating-point values representing *x, y, z,* and *w*. Internal [**glVertex4**](glvertex-functions.md) commands are generated when the map is evaluated.<br/>                                                                                                                                       |
     * | <span id="GL_MAP1_INDEX"></span><span id="gl_map1_index"></span><dl> <dt>**GL\_MAP1\_INDEX**</dt> </dl>                                 | Each control point is a single floating-point value representing a color index. Internal [**glIndex**](glindex-functions.md) commands are generated when the map is evaluated. However, the current index is not updated with the value of these **glIndex** commands.<br/>                                                    |
     * | <span id="GL_MAP1_COLOR_4"></span><span id="gl_map1_color_4"></span><dl> <dt>**GL\_MAP1\_COLOR\_4**</dt> </dl>                          | Each control point is four floating-point values representing red, green, blue, and alpha. Internal [**glColor4**](glcolor-functions.md) commands are generated when the map is evaluated. However, the current color is not updated with the value of these **glColor4** commands.<br/>                                       |
     * | <span id="GL_MAP1_NORMAL"></span><span id="gl_map1_normal"></span><dl> <dt>**GL\_MAP1\_NORMAL**</dt> </dl>                              | Each control point is three floating-point values representing the *x, y,* and *z* components of a normal vector. Internal [**glNormal**](glnormal-functions.md) commands are generated when the map is evaluated. However, the current normal is not updated with the value of these **glNormal** commands.<br/>              |
     * | <span id="GL_MAP1_TEXTURE_COORD_1"></span><span id="gl_map1_texture_coord_1"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_1**</dt> </dl> | Each control point is a single floating-point value representing the *s* texture coordinate. Internal [**glTexCoord1**](gltexcoord-functions.md) commands are generated when the map is evaluated. However, the current texture coordinates are not updated with the value of these **glTexCoord** commands.<br/>              |
     * | <span id="GL_MAP1_TEXTURE_COORD_2"></span><span id="gl_map1_texture_coord_2"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_2**</dt> </dl> | Each control point is two floating-point values representing the *s* and *t* texture coordinates. Internal [**glTexCoord2**](gltexcoord-functions.md) commands are generated when the map is evaluated. However, the current texture coordinates are not updated with the value of these **glTexCoord** commands.<br/>         |
     * | <span id="GL_MAP1_TEXTURE_COORD_3"></span><span id="gl_map1_texture_coord_3"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_3**</dt> </dl> | Each control point is three floating-point values representing the *s, t,* and *r* texture coordinates. Internal [**glTexCoord3**](gltexcoord-functions.md) commands are generated when the map is evaluated. However, the current texture coordinates are not updated with the value of these **glTexCoord** commands.<br/>   |
     * | <span id="GL_MAP1_TEXTURE_COORD_4"></span><span id="gl_map1_texture_coord_4"></span><dl> <dt>**GL\_MAP1\_TEXTURE\_COORD\_4**</dt> </dl> | Each control point is four floating-point values representing the *s, t, r,* and *q* texture coordinates. Internal [**glTexCoord4**](gltexcoord-functions.md) commands are generated when the map is evaluated. However, the current texture coordinates are not updated with the value of these **glTexCoord** commands.<br/> |
     * @param {Float} u1 A linear mapping of *u*, as presented to [**glEvalCoord1**](glevalcoord-functions.md), to *u*^, the variable that is evaluated by the equations specified by this command.
     * @param {Float} u2 A linear mapping of *u*, as presented to [**glEvalCoord1**](glevalcoord-functions.md), to *u*^, the variable that is evaluated by the equations specified by this command.
     * @param {Integer} stride The number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in *points*. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations.
     * @param {Integer} order The number of control points. Must be positive.
     * @param {Pointer<Single>} points A pointer to the array of control points.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glmap1f
     */
    static glMap1f(target, u1, u2, stride, order, points) {
        DllCall("OPENGL32.dll\glMap1f", "uint", target, "float", u1, "float", u2, "int", stride, "int", order, "ptr", points)
    }

    /**
     * The glMap2d function defines a two-dimensional evaluator. | glMap2d function (Gl.h)
     * @remarks
     * Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals, texture coordinates, and colors. The values produced by an evaluator are sent on to further stages of OpenGL processing just as if they had been presented using [**glVertex**](glvertex-functions.md), [**glNormal**](glnormal-functions.md), [**glTexCoord**](gltexcoord-functions.md), and [**glColor**](glcolor-functions.md) commands, except that the generated values do not update the current normal, texture coordinates, or color.
     * 
     * All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the OpenGL implementation) can be described using evaluators. These include almost all surfaces used in computer graphics, including B-spline surfaces, NURBS surfaces, Bezier surfaces, and so on.
     * 
     * Evaluators define surfaces based on bivariate Bernstein polynomials. Define **p** (*u*^,*v*^) as
     * 
     * ![Equation showing the definition of p ().](images/map05.png)
     * 
     * where **R** *ij* is a control point, () is the *i*th Bernstein polynomial of degree
     * 
     * *n* (*uorder* = *n* + 1)
     * 
     * ![Equation showing the Bernstein polynomial of degree n.](images/map06.png)
     * 
     * and () is the *j*th Bernstein polynomial of degree *m* (*vorder* = *m* + 1)
     * 
     * ![Equation showing the Bernstein polynomial of degree m.](images/map07.png)
     * 
     * Recall that
     * 
     * ![Equations showing equivalence to 1.](images/map08.png)
     * 
     * The **glMap2** function is used to define the basis and to specify what kind of values are produced. Once defined, a map can be enabled and disabled by calling [**glEnable**](glenable.md) and **glDisable** with the map name, one of the nine predefined values for *target*, described above. When [**glEvalCoord2**](glevalcoord-functions.md) presents values *u* and *v*, the bivariate Bernstein polynomials are evaluated using *u*^ and *v*^, where
     * 
     * ![Equation showing the definition of u^.](images/map09.png)
     * 
     * and
     * 
     * ![Equation showing the definition of v^.](images/map10.png)
     * 
     * The *target* parameter is a symbolic constant that indicates what kind of control points are provided in *points*, and what output is generated when the map is evaluated.
     * 
     * The *ustride*, *uorder*, *vstride*, *vorder*, and *points* parameters define the array addressing for accessing the control points. The *points* parameter is the location of the first control point, which occupies one, two, three, or four contiguous memory locations, depending on which map is being defined. There are *uorder* x *vorder* control points in the array. The *ustride* parameter tells how many float or double locations are skipped to advance the internal memory pointer from control point **R** *ij* to control point **R** <sub>(\ i+1\ )j</sub>. The *vstride* parameter tells how many float or double locations are skipped to advance the internal memory pointer from control point **R** *ij* to control point **R**<sub>i(j\ +1\ )</sub>.
     * 
     * As is the case with all OpenGL commands that accept pointers to data, it is as if the contents of *points* were copied by **glMap2** before it returned. Changes to the contents of *points* have no effect after **glMap2** is called.
     * 
     * The following functions retrieve information related to **glMap2**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAX\_EVAL\_ORDER
     * 
     * [**glGetMap**](glgetmap.md)
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_3
     * 
     * **glIsEnabled** with argument GL\_MAP2\_VERTEX\_4
     * 
     * **glIsEnabled** with argument GL\_MAP2\_INDEX
     * 
     * **glIsEnabled** with argument GL\_MAP2\_COLOR\_4
     * 
     * **glIsEnabled** with argument GL\_MAP2\_NORMAL
     * 
     * **glIsEnabled** with argument GL\_MAP2\_TEXTURE\_COORD\_1
     * 
     * **glIsEnabled** with argument GL\_MAP2\_TEXTURE\_COORD\_2
     * 
     * **glIsEnabled** with argument GL\_MAP2\_TEXTURE\_COORD\_3
     * 
     * **glIsEnabled** with argument GL\_MAP2\_TEXTURE\_COORD\_4
     * @param {Integer} target The kind of values that are generated by the evaluator. The following symbolic constants are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                          | Meaning                                                                                                                                                                                                                                                                                                                               |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_MAP2_VERTEX_3"></span><span id="gl_map2_vertex_3"></span><dl> <dt>**GL\_MAP2\_VERTEX\_3**</dt> </dl>                       | Each control point is three floating-point values representing *x, y,* and *z*. Internal [**glVertex3**](glvertex-functions.md) commands are generated when the map is evaluated.<br/>                                                                                                                                         |
     * | <span id="GL_MAP2_VERTEX_4"></span><span id="gl_map2_vertex_4"></span><dl> <dt>**GL\_MAP2\_VERTEX\_4**</dt> </dl>                       | Each control point is four floating-point values representing *x, y, z,* and *w*. Internal [**glVertex4**](glvertex-functions.md) commands are generated when the map is evaluated.<br/>                                                                                                                                       |
     * | <span id="GL_MAP2_INDEX"></span><span id="gl_map2_index"></span><dl> <dt>**GL\_MAP2\_INDEX**</dt> </dl>                                 | Each control point is a single floating-point value representing a color index. Internal [**glIndex**](glindex-functions.md) commands are generated when the map is evaluated. The current index is not updated with the value of these **glIndex** commands, however.<br/>                                                    |
     * | <span id="GL_MAP2_COLOR_4"></span><span id="gl_map2_color_4"></span><dl> <dt>**GL\_MAP2\_COLOR\_4**</dt> </dl>                          | Each control point is four floating-point values representing red, green, blue, and alpha. Internal [**glColor4**](glcolor-functions.md) commands are generated when the map is evaluated. The current color is not updated with the value of these **glColor4** commands, however.<br/>                                       |
     * | <span id="GL_MAP2_NORMAL"></span><span id="gl_map2_normal"></span><dl> <dt>**GL\_MAP2\_NORMAL**</dt> </dl>                              | Each control point is three floating-point values representing the *x, y,* and *z* components of a normal vector. Internal [**glNormal**](glnormal-functions.md) commands are generated when the map is evaluated. The current normal is not updated with the value of these **glNormal** commands, however.<br/>              |
     * | <span id="GL_MAP2_TEXTURE_COORD_1"></span><span id="gl_map2_texture_coord_1"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_1**</dt> </dl> | Each control point is a single floating-point value representing the *s* texture coordinate. Internal [**glTexCoord1**](gltexcoord-functions.md) commands are generated when the map is evaluated. The current texture coordinates are not updated with the value of these **glTexCoord** commands, however.<br/>              |
     * | <span id="GL_MAP2_TEXTURE_COORD_2"></span><span id="gl_map2_texture_coord_2"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_2**</dt> </dl> | Each control point is two floating-point values representing the *s* and *t* texture coordinates. Internal [**glTexCoord2**](gltexcoord-functions.md) commands are generated when the map is evaluated. The current texture coordinates are not updated with the value of these **glTexCoord** commands, however.<br/>         |
     * | <span id="GL_MAP2_TEXTURE_COORD_3"></span><span id="gl_map2_texture_coord_3"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_3**</dt> </dl> | Each control point is three floating-point values representing the *s, t,* and *r* texture coordinates. Internal [**glTexCoord3**](gltexcoord-functions.md) commands are generated when the map is evaluated. The current texture coordinates are not updated with the value of these **glTexCoord** commands, however.<br/>   |
     * | <span id="GL_MAP2_TEXTURE_COORD_4"></span><span id="gl_map2_texture_coord_4"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_4**</dt> </dl> | Each control point is four floating-point values representing the *s, t, r,* and *q* texture coordinates. Internal [**glTexCoord4**](gltexcoord-functions.md) commands are generated when the map is evaluated. The current texture coordinates are not updated with the value of these **glTexCoord** commands, however.<br/> |
     * @param {Float} u1 A linear mapping of *u*, as presented to [**glEvalCoord2**](glevalcoord-functions.md), to *u*^, one of the two variables that is evaluated by the equations specified by this command.
     * @param {Float} u2 A linear mapping of *u*, as presented to [**glEvalCoord2**](glevalcoord-functions.md), to *u*^, one of the two variables that is evaluated by the equations specified by this command.
     * @param {Integer} ustride The number of floats or doubles between the beginning of control point **R** *ij* and the beginning of control point **R** <sub>(i\ +1\ )\ j</sub>, where *i* and *j* are the *u* and *v* control point indexes, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations.
     * @param {Integer} uorder The dimension of the control point array in the *u*-axis. Must be positive.
     * @param {Float} v1 A linear mapping of *v*, as presented to [**glEvalCoord2**](glevalcoord-functions.md), to *v*^, one of the two variables that is evaluated by the equations specified by this command.
     * @param {Float} v2 A linear mapping of *v*, as presented to [**glEvalCoord2**](glevalcoord-functions.md), to *v*^, one of the two variables that is evaluated by the equations specified by this command.
     * @param {Integer} vstride The number of floats or doubles between the beginning of control point **R** *ij* and the beginning of control point **R** <sub>i(j\ +1\ )</sub>, where *i* and *j* are the *u* and *v* control point indexes, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations.
     * @param {Integer} vorder The dimension of the control point array in the *v*-axis. Must be positive.
     * @param {Pointer<Double>} points A pointer to the array of control points.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glmap2d
     */
    static glMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points) {
        DllCall("OPENGL32.dll\glMap2d", "uint", target, "double", u1, "double", u2, "int", ustride, "int", uorder, "double", v1, "double", v2, "int", vstride, "int", vorder, "ptr", points)
    }

    /**
     * The glMap2f function defines a two-dimensional evaluator. | glMap2f function (Gl.h)
     * @remarks
     * Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals, texture coordinates, and colors. The values produced by an evaluator are sent on to further stages of OpenGL processing just as if they had been presented using [**glVertex**](glvertex-functions.md), [**glNormal**](glnormal-functions.md), [**glTexCoord**](gltexcoord-functions.md), and [**glColor**](glcolor-functions.md) commands, except that the generated values do not update the current normal, texture coordinates, or color.
     * 
     * All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the OpenGL implementation) can be described using evaluators. These include almost all surfaces used in computer graphics, including B-spline surfaces, NURBS surfaces, Bezier surfaces, and so on.
     * 
     * Evaluators define surfaces based on bivariate Bernstein polynomials. Define **p** (*u*^,*v*^) as
     * 
     * ![Equation showing the definition of p ().](images/map05.png)
     * 
     * where **R** *ij* is a control point, () is the *i*th Bernstein polynomial of degree
     * 
     * *n* (*uorder* = *n* + 1)
     * 
     * ![Equation showing the Bernstein polynomial of degree n.](images/map06.png)
     * 
     * and () is the *j*th Bernstein polynomial of degree *m* (*vorder* = *m* + 1)
     * 
     * ![Equation showing the Bernstein polynomial of degree m.](images/map07.png)
     * 
     * Recall that
     * 
     * ![Equations showing equivalence to 1.](images/map08.png)
     * 
     * The **glMap2** function is used to define the basis and to specify what kind of values are produced. Once defined, a map can be enabled and disabled by calling [**glEnable**](glenable.md) and **glDisable** with the map name, one of the nine predefined values for *target*, described above. When [**glEvalCoord2**](glevalcoord-functions.md) presents values *u* and *v*, the bivariate Bernstein polynomials are evaluated using *u*^ and *v*^, where
     * 
     * ![Equation showing the definition of u^.](images/map09.png)
     * 
     * and
     * 
     * ![Equation showing the definition of v^.](images/map10.png)
     * 
     * The *target* parameter is a symbolic constant that indicates what kind of control points are provided in *points*, and what output is generated when the map is evaluated.
     * 
     * The *ustride*, *uorder*, *vstride*, *vorder*, and *points* parameters define the array addressing for accessing the control points. The *points* parameter is the location of the first control point, which occupies one, two, three, or four contiguous memory locations, depending on which map is being defined. There are *uorder* x *vorder* control points in the array. The *ustride* parameter tells how many float or double locations are skipped to advance the internal memory pointer from control point **R** *ij* to control point **R** <sub>(\ i+1\ )j</sub>. The *vstride* parameter tells how many float or double locations are skipped to advance the internal memory pointer from control point **R** *ij* to control point **R**<sub>i(j\ +1\ )</sub>.
     * 
     * As is the case with all OpenGL commands that accept pointers to data, it is as if the contents of *points* were copied by **glMap2** before it returned. Changes to the contents of *points* have no effect after **glMap2** is called.
     * 
     * The following functions retrieve information related to **glMap2**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAX\_EVAL\_ORDER
     * 
     * [**glGetMap**](glgetmap.md)
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_MAP2\_VERTEX\_3
     * 
     * **glIsEnabled** with argument GL\_MAP2\_VERTEX\_4
     * 
     * **glIsEnabled** with argument GL\_MAP2\_INDEX
     * 
     * **glIsEnabled** with argument GL\_MAP2\_COLOR\_4
     * 
     * **glIsEnabled** with argument GL\_MAP2\_NORMAL
     * 
     * **glIsEnabled** with argument GL\_MAP2\_TEXTURE\_COORD\_1
     * 
     * **glIsEnabled** with argument GL\_MAP2\_TEXTURE\_COORD\_2
     * 
     * **glIsEnabled** with argument GL\_MAP2\_TEXTURE\_COORD\_3
     * 
     * **glIsEnabled** with argument GL\_MAP2\_TEXTURE\_COORD\_4
     * @param {Integer} target The kind of values that are generated by the evaluator. The following symbolic constants are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                          | Meaning                                                                                                                                                                                                                                                                                                                               |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_MAP2_VERTEX_3"></span><span id="gl_map2_vertex_3"></span><dl> <dt>**GL\_MAP2\_VERTEX\_3**</dt> </dl>                       | Each control point is three floating-point values representing *x, y,* and *z*. Internal [**glVertex3**](glvertex-functions.md) commands are generated when the map is evaluated.<br/>                                                                                                                                         |
     * | <span id="GL_MAP2_VERTEX_4"></span><span id="gl_map2_vertex_4"></span><dl> <dt>**GL\_MAP2\_VERTEX\_4**</dt> </dl>                       | Each control point is four floating-point values representing *x, y, z,* and *w*. Internal [**glVertex4**](glvertex-functions.md) commands are generated when the map is evaluated.<br/>                                                                                                                                       |
     * | <span id="GL_MAP2_INDEX"></span><span id="gl_map2_index"></span><dl> <dt>**GL\_MAP2\_INDEX**</dt> </dl>                                 | Each control point is a single floating-point value representing a color index. Internal [**glIndex**](glindex-functions.md) commands are generated when the map is evaluated. The current index is not updated with the value of these **glIndex** commands, however.<br/>                                                    |
     * | <span id="GL_MAP2_COLOR_4"></span><span id="gl_map2_color_4"></span><dl> <dt>**GL\_MAP2\_COLOR\_4**</dt> </dl>                          | Each control point is four floating-point values representing red, green, blue, and alpha. Internal [**glColor4**](glcolor-functions.md) commands are generated when the map is evaluated. The current color is not updated with the value of these **glColor4** commands, however.<br/>                                       |
     * | <span id="GL_MAP2_NORMAL"></span><span id="gl_map2_normal"></span><dl> <dt>**GL\_MAP2\_NORMAL**</dt> </dl>                              | Each control point is three floating-point values representing the *x, y,* and *z* components of a normal vector. Internal [**glNormal**](glnormal-functions.md) commands are generated when the map is evaluated. The current normal is not updated with the value of these **glNormal** commands, however.<br/>              |
     * | <span id="GL_MAP2_TEXTURE_COORD_1"></span><span id="gl_map2_texture_coord_1"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_1**</dt> </dl> | Each control point is a single floating-point value representing the *s* texture coordinate. Internal [**glTexCoord1**](gltexcoord-functions.md) commands are generated when the map is evaluated. The current texture coordinates are not updated with the value of these **glTexCoord** commands, however.<br/>              |
     * | <span id="GL_MAP2_TEXTURE_COORD_2"></span><span id="gl_map2_texture_coord_2"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_2**</dt> </dl> | Each control point is two floating-point values representing the *s* and *t* texture coordinates. Internal [**glTexCoord2**](gltexcoord-functions.md) commands are generated when the map is evaluated. The current texture coordinates are not updated with the value of these **glTexCoord** commands, however.<br/>         |
     * | <span id="GL_MAP2_TEXTURE_COORD_3"></span><span id="gl_map2_texture_coord_3"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_3**</dt> </dl> | Each control point is three floating-point values representing the *s, t,* and *r* texture coordinates. Internal [**glTexCoord3**](gltexcoord-functions.md) commands are generated when the map is evaluated. The current texture coordinates are not updated with the value of these **glTexCoord** commands, however.<br/>   |
     * | <span id="GL_MAP2_TEXTURE_COORD_4"></span><span id="gl_map2_texture_coord_4"></span><dl> <dt>**GL\_MAP2\_TEXTURE\_COORD\_4**</dt> </dl> | Each control point is four floating-point values representing the *s, t, r,* and *q* texture coordinates. Internal [**glTexCoord4**](gltexcoord-functions.md) commands are generated when the map is evaluated. The current texture coordinates are not updated with the value of these **glTexCoord** commands, however.<br/> |
     * @param {Float} u1 A linear mapping of *u*, as presented to [**glEvalCoord2**](glevalcoord-functions.md), to *u*^, one of the two variables that is evaluated by the equations specified by this command.
     * @param {Float} u2 A linear mapping of *u*, as presented to [**glEvalCoord2**](glevalcoord-functions.md), to *u*^, one of the two variables that is evaluated by the equations specified by this command.
     * @param {Integer} ustride The number of floats or doubles between the beginning of control point **R** *ij* and the beginning of control point **R** <sub>(i\ +1\ )\ j</sub>, where *i* and *j* are the *u* and *v* control point indexes, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations.
     * @param {Integer} uorder The dimension of the control point array in the *u*-axis. Must be positive.
     * @param {Float} v1 A linear mapping of *v*, as presented to [**glEvalCoord2**](glevalcoord-functions.md), to *v*^, one of the two variables that is evaluated by the equations specified by this command.
     * @param {Float} v2 A linear mapping of *v*, as presented to [**glEvalCoord2**](glevalcoord-functions.md), to *v*^, one of the two variables that is evaluated by the equations specified by this command.
     * @param {Integer} vstride The number of floats or doubles between the beginning of control point **R** *ij* and the beginning of control point **R** <sub>i(j\ +1\ )</sub>, where *i* and *j* are the *u* and *v* control point indexes, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations.
     * @param {Integer} vorder The dimension of the control point array in the *v*-axis. Must be positive.
     * @param {Pointer<Single>} points A pointer to the array of control points.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glmap2f
     */
    static glMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points) {
        DllCall("OPENGL32.dll\glMap2f", "uint", target, "float", u1, "float", u2, "int", ustride, "int", uorder, "float", v1, "float", v2, "int", vstride, "int", vorder, "ptr", points)
    }

    /**
     * Defines a one-dimensional mesh. | glMapGrid1d function (Gl.h)
     * @remarks
     * Use the **glMapGrid** and [glEvalMesh](glevalmesh-functions.md) functions togetherto efficiently generate and evaluate a series of evenly spaced map domain values. The glEvalMesh function steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md).
     * 
     * The **glMapGrid1** and [**glMapGrid2**](glmapgrid2d.md) functions specify the linear grid mappings between the i (or i and j) integer grid coordinates, to the u (or u and v) floating-point evaluation map coordinates. See [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md) for details of how u and v coordinates are evaluated.
     * 
     * The **glMapGrid1** function specifies a single linear mapping such that integer grid coordinate 0 maps exactly to u1, and integer grid coordinate *un* maps exactly to *u2*. All other integer grid coordinates *i* are mapped such that:
     * 
     * *u = i(u2 u1)/un + u1*
     * 
     * The [**glMapGrid2**](glmapgrid2d.md) function specifies two such linear mappings. One maps integer grid coordinate *i = 0* exactly to *u1*, and integer grid coordinate *i = un* exactly to *u2*. The other maps integer grid coordinate *j = 0* exactly to *v1*, and integer grid coordinate *j = vn* exactly to *v2*. Other integer grid coordinates i and j are mapped such that
     * 
     * *u = i(u2 u1)/un + u1*
     * 
     * *v = j (v2 v1)/vn + v1*
     * 
     * The mappings specified by **glMapGrid** are used identically by [glEvalMesh](glevalmesh-functions.md) and [**glEvalPoint**](glevalpoint.md).
     * 
     * The following functions retrieve information related to **glMapGrid**:
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP1\_GRID\_DOMAIN  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP2\_GRID\_DOMAIN  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP1\_GRID\_SEGMENTS  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP2\_GRID\_SEGMENTS  
     * </dl>
     * @param {Integer} un The number of partitions in the grid range interval \[u1, u2\]. This value must be positive.
     * @param {Float} u1 A value used as the mapping for integer grid domain value i = 0.
     * @param {Float} u2 A value used as the mapping for integer grid domain value i = un.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glmapgrid1d
     */
    static glMapGrid1d(un, u1, u2) {
        DllCall("OPENGL32.dll\glMapGrid1d", "int", un, "double", u1, "double", u2)
    }

    /**
     * Defines a one-dimensional mesh. | glMapGrid1f function (Gl.h)
     * @remarks
     * The **glMapGrid** and [glEvalMesh](glevalmesh-functions.md) functions are used in tandem to efficiently generate and evaluate a series of evenly spaced map domain values. The glEvalMesh function steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md).
     * 
     * The [**glMapGrid1**](glmapgrid1d.md) and [**glMapGrid2**](glmapgrid2d.md) functions specify the linear grid mappings between the i (or i and j) integer grid coordinates, to the u (or u and v) floating-point evaluation map coordinates. See [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md) for details of how u and v coordinates are evaluated.
     * 
     * The [**glMapGrid1**](glmapgrid1d.md) function specifies a single linear mapping such that integer grid coordinate 0 maps exactly to u1, and integer grid coordinate *un* maps exactly to *u2*. All other integer grid coordinates *i* are mapped such that:
     * 
     * *u = i(u2 u1)/un + u1*
     * 
     * The [**glMapGrid2**](glmapgrid2d.md) function specifies two such linear mappings. One maps integer grid coordinate *i = 0* exactly to *u1*, and integer grid coordinate *i = un* exactly to *u2*. The other maps integer grid coordinate *j = 0* exactly to *v1*, and integer grid coordinate *j = vn* exactly to *v2*. Other integer grid coordinates i and j are mapped such that
     * 
     * *u = i(u2 u1)/un + u1*
     * 
     * *v = j (v2 v1)/vn + v1*
     * 
     * The mappings specified by [**glMapGrid**](glmapgrid1d.md) are used identically by [glEvalMesh](glevalmesh-functions.md) and [**glEvalPoint**](glevalpoint.md).
     * 
     * The following functions retrieve information related to [**glMapGrid**](glmapgrid1d.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP1\_GRID\_DOMAIN  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP2\_GRID\_DOMAIN  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP1\_GRID\_SEGMENTS  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP2\_GRID\_SEGMENTS  
     * </dl>
     * @param {Integer} un The number of partitions in the grid range interval \[u1, u2\]. This value must be positive.
     * @param {Float} u1 A value used as the mapping for integer grid domain value i = 0.
     * @param {Float} u2 A value used as the mapping for integer grid domain value i = un.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glmapgrid1f
     */
    static glMapGrid1f(un, u1, u2) {
        DllCall("OPENGL32.dll\glMapGrid1f", "int", un, "float", u1, "float", u2)
    }

    /**
     * Defines a one-dimensional mesh. | glMapGrid2d function (Gl.h)
     * @remarks
     * The **glMapGrid** and [glEvalMesh](glevalmesh-functions.md) functions are used in tandem to efficiently generate and evaluate a series of evenly spaced map domain values. The glEvalMesh function steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md).
     * 
     * The [**glMapGrid1**](glmapgrid1d.md) and **glMapGrid2** functions specify the linear grid mappings between the i (or i and j) integer grid coordinates, to the u (or u and v) floating-point evaluation map coordinates. See [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md) for details of how u and v coordinates are evaluated.
     * 
     * The [**glMapGrid1**](glmapgrid1d.md) function specifies a single linear mapping such that integer grid coordinate 0 maps exactly to u1, and integer grid coordinate *un* maps exactly to *u2*. All other integer grid coordinates *i* are mapped such that:
     * 
     * *u = i(u2 u1)/un + u1*
     * 
     * The **glMapGrid2** function specifies two such linear mappings. One maps integer grid coordinate *i = 0* exactly to *u1*, and integer grid coordinate *i = un* exactly to *u2*. The other maps integer grid coordinate *j = 0* exactly to *v1*, and integer grid coordinate *j = vn* exactly to *v2*. Other integer grid coordinates i and j are mapped such that
     * 
     * *u = i(u2 u1)/un + u1*
     * 
     * *v = j (v2 v1)/vn + v1*
     * 
     * The mappings specified by [**glMapGrid**](glmapgrid1d.md) are used identically by [glEvalMesh](glevalmesh-functions.md) and [**glEvalPoint**](glevalpoint.md).
     * 
     * The following functions retrieve information related to [**glMapGrid**](glmapgrid1d.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP1\_GRID\_DOMAIN  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP2\_GRID\_DOMAIN  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP1\_GRID\_SEGMENTS  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP2\_GRID\_SEGMENTS  
     * </dl>
     * @param {Integer} un The number of partitions in the grid range interval \[u1, u2\]. This value must be positive.
     * @param {Float} u1 A value used as the mapping for integer grid domain value i = 0.
     * @param {Float} u2 A value used as the mapping for integer grid domain value i = un.
     * @param {Integer} vn The number of partitions in the grid range interval \[v1, v2\].
     * @param {Float} v1 A value used as the mapping for integer grid domain value j = 0.
     * @param {Float} v2 A value used as the mapping for integer grid domain value j = vn.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glmapgrid2d
     */
    static glMapGrid2d(un, u1, u2, vn, v1, v2) {
        DllCall("OPENGL32.dll\glMapGrid2d", "int", un, "double", u1, "double", u2, "int", vn, "double", v1, "double", v2)
    }

    /**
     * Defines a one-dimensional mesh. | glMapGrid2f function (Gl.h)
     * @remarks
     * The **glMapGrid** and [glEvalMesh](glevalmesh-functions.md) functions are used in tandem to efficiently generate and evaluate a series of evenly spaced map domain values. The glEvalMesh function steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md).
     * 
     * The [**glMapGrid1**](glmapgrid1d.md) and [**glMapGrid2**](glmapgrid2d.md) functions specify the linear grid mappings between the i (or i and j) integer grid coordinates, to the u (or u and v) floating-point evaluation map coordinates. See [**glMap1**](glmap1.md) and [**glMap2**](glmap2.md) for details of how u and v coordinates are evaluated.
     * 
     * The [**glMapGrid1**](glmapgrid1d.md) function specifies a single linear mapping such that integer grid coordinate 0 maps exactly to u1, and integer grid coordinate *un* maps exactly to *u2*. All other integer grid coordinates *i* are mapped such that:
     * 
     * *u = i(u2 u1)/un + u1*
     * 
     * The [**glMapGrid2**](glmapgrid2d.md) function specifies two such linear mappings. One maps integer grid coordinate *i = 0* exactly to *u1*, and integer grid coordinate *i = un* exactly to *u2*. The other maps integer grid coordinate *j = 0* exactly to *v1*, and integer grid coordinate *j = vn* exactly to *v2*. Other integer grid coordinates i and j are mapped such that
     * 
     * *u = i(u2 u1)/un + u1*
     * 
     * *v = j (v2 v1)/vn + v1*
     * 
     * The mappings specified by [**glMapGrid**](glmapgrid1d.md) are used identically by [glEvalMesh](glevalmesh-functions.md) and [**glEvalPoint**](glevalpoint.md).
     * 
     * The following functions retrieve information related to [**glMapGrid**](glmapgrid1d.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP1\_GRID\_DOMAIN  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP2\_GRID\_DOMAIN  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP1\_GRID\_SEGMENTS  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP2\_GRID\_SEGMENTS  
     * </dl>
     * @param {Integer} un The number of partitions in the grid range interval \[u1, u2\]. This value must be positive.
     * @param {Float} u1 A value used as the mapping for integer grid domain value i = 0.
     * @param {Float} u2 A value used as the mapping for integer grid domain value i = un.
     * @param {Integer} vn The number of partitions in the grid range interval \[v1, v2\].
     * @param {Float} v1 A value used as the mapping for integer grid domain value j = 0.
     * @param {Float} v2 A value used as the mapping for integer grid domain value j = vn.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glmapgrid2f
     */
    static glMapGrid2f(un, u1, u2, vn, v1, v2) {
        DllCall("OPENGL32.dll\glMapGrid2f", "int", un, "float", u1, "float", u2, "int", vn, "float", v1, "float", v2)
    }

    /**
     * The glMaterialf function specifies material parameters for the lighting model.
     * @remarks
     * The **glMaterialf** function assigns values to material parameters. There are two matched sets of material parameters. One, the *front-facing* set, is used to shade points, lines, bitmaps, and all polygons (when two-sided lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other set, *back-facing*, is used to shade back-facing polygons only when two-sided lighting is enabled. Refer to [**glLightModel**](gllightmodel-functions.md) for details concerning one-sided and two-sided lighting calculations.
     * 
     * The **glMaterialf** function takes three arguments. The first, *face*, specifies whether the GL\_FRONT materials, the GL\_BACK materials, or both GL\_FRONT\_AND\_BACK materials will be modified. The second, *pname*, specifies which of several parameters in one or both sets will be modified. The third, *param*, specifies what value will be assigned to the specified parameter.
     * 
     * Material parameters are used in the lighting equation that is optionally applied to each vertex. The equation is discussed in [**glLightModel**](gllightmodel-functions.md).
     * 
     * The material parameters can be updated at any time. In particular, **glMaterialf** can be called between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). If only a single material parameter is to be changed per vertex, however, [**glColorMaterial**](glcolormaterial.md) is preferred over **glMaterialf**.
     * 
     * The following function retrieves information related to **glMaterialf**:
     * 
     * [**glGetMaterial**](glgetmaterial.md)
     * @param {Integer} face The face or faces that are being updated. Must be one of the following: GL\_FRONT, GL\_BACK, or GL\_FRONT and GL\_BACK.
     * @param {Integer} pname The single-valued material parameter of the face or faces being updated. Must be GL\_SHININESS.
     * 
     * 
     * 
     * | Value                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                                                                 |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_SHININESS"></span><span id="gl_shininess"></span><dl> <dt>**GL\_SHININESS**</dt> </dl> | The *param* parameter is a single floating-point value that specifies the RGBA specular exponent of the material. Integer values are mapped directly. Only values in the range \[0, 128\] are accepted. The default specular exponent for both front-facing and back-facing materials is 0. <br/> |
     * @param {Float} param2 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glmaterialf
     */
    static glMaterialf(face, pname, param2) {
        DllCall("OPENGL32.dll\glMaterialf", "uint", face, "uint", pname, "float", param2)
    }

    /**
     * The glMaterialfv function specifies material parameters for the lighting model.
     * @remarks
     * The [**glMaterialfv**](glmaterialf.md) function assigns values to material parameters. There are two matched sets of material parameters. One, the *front-facing* set, is used to shade points, lines, bitmaps, and all polygons (when two-sided lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other set, *back-facing*, is used to shade back-facing polygons only when two-sided lighting is enabled. Refer to [**glLightModel**](gllightmodel-functions.md) for details concerning one-sided and two-sided lighting calculations.
     * 
     * The [**glMaterialfv**](glmaterialf.md) function takes three arguments. The first, *face*, specifies whether the GL\_FRONT materials, the GL\_BACK materials, or both GL\_FRONT\_AND\_BACK materials will be modified. The second, *pname*, specifies which of several parameters in one or both sets will be modified. The third, *param*, specifies what value will be assigned to the specified parameter.
     * 
     * Material parameters are used in the lighting equation that is optionally applied to each vertex. The equation is discussed in [**glLightModel**](gllightmodel-functions.md).
     * 
     * The material parameters can be updated at any time. In particular, [**glMaterialfv**](glmaterialf.md) can be called between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). If only a single material parameter is to be changed per vertex, however, [**glColorMaterial**](glcolormaterial.md) is preferred over **glMaterialfv**.
     * 
     * The following function retrieves information related to [**glMaterialfv**](glmaterialf.md):
     * 
     * [**glGetMaterial**](glgetmaterial.md)
     * @param {Integer} face The face or faces that are being updated. Must be one of the following: GL\_FRONT, GL\_BACK, or GL\_FRONT and GL\_BACK.
     * @param {Integer} pname The material parameter of the face or faces being updated. The parameters that can be specified using **glMaterialfv**, and their interpretations by the lighting equation, are as follows.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
     * |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_AMBIENT"></span><span id="gl_ambient"></span><dl> <dt>**GL\_AMBIENT**</dt> </dl>                                       | The params parameter contains four floating-point values that specify the ambient RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The default ambient reflectance for both front-facing and back-facing materials is (0.2, 0.2, 0.2, 1.0). <br/>    |
     * | <span id="GL_DIFFUSE"></span><span id="gl_diffuse"></span><dl> <dt>**GL\_DIFFUSE**</dt> </dl>                                       | The params parameter contains four floating-point values that specify the diffuse RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The default diffuse reflectance for both front-facing and back-facing materials is (0.8, 0.8, 0.8, 1.0). <br/>    |
     * | <span id="GL_SPECULAR"></span><span id="gl_specular"></span><dl> <dt>**GL\_SPECULAR**</dt> </dl>                                    | The params parameter contains four floating-point values that specify the specular RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The default specular reflectance for both front-facing and back-facing materials is (0.0, 0.0, 0.0, 1.0). <br/>  |
     * | <span id="GL_EMISSION"></span><span id="gl_emission"></span><dl> <dt>**GL\_EMISSION**</dt> </dl>                                    | The params parameter contains four floating-point values that specify the RGBA emitted light intensity of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The default emission intensity for both front-facing and back-facing materials is (0.0, 0.0, 0.0, 1.0). <br/> |
     * | <span id="GL_SHININESS"></span><span id="gl_shininess"></span><dl> <dt>**GL\_SHININESS**</dt> </dl>                                 | The *param* parameter is a single integer value that specifies the RGBA specular exponent of the material. Integer values are mapped directly. Only values in the range \[0, 128\] are accepted. The default specular exponent for both front-facing and back-facing materials is 0. <br/>                                                                                                                                                                                                      |
     * | <span id="GL_AMBIENT_AND_DIFFUSE"></span><span id="gl_ambient_and_diffuse"></span><dl> <dt>**GL\_AMBIENT\_AND\_DIFFUSE**</dt> </dl> | Equivalent to calling [**glMaterial**](glmaterial-functions.md) twice with the same parameter values, once with GL\_AMBIENT and once with GL\_DIFFUSE. <br/>                                                                                                                                                                                                                                                                                                                                   |
     * | <span id="GL_COLOR_INDEXES"></span><span id="gl_color_indexes"></span><dl> <dt>**GL\_COLOR\_INDEXES**</dt> </dl>                    | The params parameter contains three floating-point values specifying the color indexes for ambient, diffuse, and specular lighting. These three values, and GL\_SHININESS, are the only material values used by the color-index mode lighting equation. Refer to [**glLightModel**](gllightmodel-functions.md) for a discussion of color-index lighting.<br/>                                                                                                                                  |
     * @param {Pointer<Single>} params The value to which parameter GL\_SHININESS will be set.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glmaterialfv
     */
    static glMaterialfv(face, pname, params) {
        DllCall("OPENGL32.dll\glMaterialfv", "uint", face, "uint", pname, "ptr", params)
    }

    /**
     * TheglMateriali function specifies material parameters for the lighting model.
     * @remarks
     * The **glMateriali** function assigns values to material parameters. There are two matched sets of material parameters. One, the *front-facing* set, is used to shade points, lines, bitmaps, and all polygons (when two-sided lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other set, *back-facing*, is used to shade back-facing polygons only when two-sided lighting is enabled. Refer to [**glLightModel**](gllightmodel-functions.md) for details concerning one-sided and two-sided lighting calculations.
     * 
     * The **glMateriali** function takes three arguments. The first, *face*, specifies whether the GL\_FRONT materials, the GL\_BACK materials, or both GL\_FRONT\_AND\_BACK materials will be modified. The second, *pname*, specifies which of several parameters in one or both sets will be modified. The third, *param*, specifies what value will be assigned to the specified parameter.
     * 
     * Material parameters are used in the lighting equation that is optionally applied to each vertex. The equation is discussed in [**glLightModel**](gllightmodel-functions.md).
     * 
     * The material parameters can be updated at any time. In particular, **glMateriali** can be called between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). If only a single material parameter is to be changed per vertex, however, [**glColorMaterial**](glcolormaterial.md) is preferred over **glMateriali**.
     * 
     * The following function retrieves information related to **glMateriali**:
     * 
     * [**glGetMaterial**](glgetmaterial.md)
     * @param {Integer} face The face or faces that are being updated. Must be one of the following: GL\_FRONT, GL\_BACK, or GL\_FRONT and GL\_BACK.
     * @param {Integer} pname The single-valued material parameter of the face or faces being updated. Must be GL\_SHININESS.
     * 
     * 
     * 
     * | Value                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                                                    |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_SHININESS"></span><span id="gl_shininess"></span><dl> <dt>**GL\_SHININESS**</dt> </dl> | The *param* parameter is a single integer that specifies the RGBA specular exponent of the material. Integer values are mapped directly. Only values in the range \[0, 128\] are accepted. The default specular exponent for both front-facing and back-facing materials is 0. <br/> |
     * @param {Integer} param2 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glmateriali
     */
    static glMateriali(face, pname, param2) {
        DllCall("OPENGL32.dll\glMateriali", "uint", face, "uint", pname, "int", param2)
    }

    /**
     * The glMaterialiv function specifies material parameters for the lighting model.
     * @remarks
     * The [**glMaterialiv**](glmaterialf.md) function assigns values to material parameters. There are two matched sets of material parameters. One, the *front-facing* set, is used to shade points, lines, bitmaps, and all polygons (when two-sided lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other set, *back-facing*, is used to shade back-facing polygons only when two-sided lighting is enabled. Refer to [**glLightModel**](gllightmodel-functions.md) for details concerning one-sided and two-sided lighting calculations.
     * 
     * The [**glMaterialiv**](glmaterialf.md) function takes three arguments. The first, *face*, specifies whether the GL\_FRONT materials, the GL\_BACK materials, or both GL\_FRONT\_AND\_BACK materials will be modified. The second, *pname*, specifies which of several parameters in one or both sets will be modified. The third, *param*, specifies what value will be assigned to the specified parameter.
     * 
     * Material parameters are used in the lighting equation that is optionally applied to each vertex. The equation is discussed in [**glLightModel**](gllightmodel-functions.md).
     * 
     * The material parameters can be updated at any time. In particular, [**glMaterialiv**](glmaterialf.md) can be called between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). If only a single material parameter is to be changed per vertex, however, [**glColorMaterial**](glcolormaterial.md) is preferred over **glMaterialiv**.
     * 
     * The following function retrieves information related to [**glMaterialiv**](glmaterialf.md):
     * 
     * [**glGetMaterial**](glgetmaterial.md)
     * @param {Integer} face The face or faces that are being updated. Must be one of the following: GL\_FRONT, GL\_BACK, or GL\_FRONT and GL\_BACK.
     * @param {Integer} pname The material parameter of the face or faces being updated. The parameters that can be specified using [**glMaterialiv**](glmaterialfv.md), and their interpretations by the lighting equation, are as follows.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
     * |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_AMBIENT"></span><span id="gl_ambient"></span><dl> <dt>**GL\_AMBIENT**</dt> </dl>                                       | The params parameter contains four integer values that specify the ambient RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The default ambient reflectance for both front-facing and back-facing materials is (0.2, 0.2, 0.2, 1.0). <br/>    |
     * | <span id="GL_DIFFUSE"></span><span id="gl_diffuse"></span><dl> <dt>**GL\_DIFFUSE**</dt> </dl>                                       | The params parameter contains four integer values that specify the diffuse RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The default diffuse reflectance for both front-facing and back-facing materials is (0.8, 0.8, 0.8, 1.0). <br/>    |
     * | <span id="GL_SPECULAR"></span><span id="gl_specular"></span><dl> <dt>**GL\_SPECULAR**</dt> </dl>                                    | The params parameter contains four integer values that specify the specular RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The default specular reflectance for both front-facing and back-facing materials is (0.0, 0.0, 0.0, 1.0). <br/>  |
     * | <span id="GL_EMISSION"></span><span id="gl_emission"></span><dl> <dt>**GL\_EMISSION**</dt> </dl>                                    | The params parameter contains four integer values that specify the RGBA emitted light intensity of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The default emission intensity for both front-facing and back-facing materials is (0.0, 0.0, 0.0, 1.0). <br/> |
     * | <span id="GL_SHININESS"></span><span id="gl_shininess"></span><dl> <dt>**GL\_SHININESS**</dt> </dl>                                 | The *param* parameter is a single integer that specifies the RGBA specular exponent of the material. Integer values are mapped directly. Only values in the range \[0, 128\] are accepted. The default specular exponent for both front-facing and back-facing materials is 0. <br/>                                                                                                                                                                                                     |
     * | <span id="GL_AMBIENT_AND_DIFFUSE"></span><span id="gl_ambient_and_diffuse"></span><dl> <dt>**GL\_AMBIENT\_AND\_DIFFUSE**</dt> </dl> | Equivalent to calling [**glMaterial**](glmaterial-functions.md) twice with the same parameter values, once with GL\_AMBIENT and once with GL\_DIFFUSE. <br/>                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_COLOR_INDEXES"></span><span id="gl_color_indexes"></span><dl> <dt>**GL\_COLOR\_INDEXES**</dt> </dl>                    | The params parameter contains three integer values specifying the color indexes for ambient, diffuse, and specular lighting. These three values, and GL\_SHININESS, are the only material values used by the color-index mode lighting equation. Refer to [**glLightModel**](gllightmodel-functions.md) for a discussion of color-index lighting.<br/>                                                                                                                                  |
     * @param {Pointer<Int32>} params The value to which parameter GL\_SHININESS will be set.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glmaterialiv
     */
    static glMaterialiv(face, pname, params) {
        DllCall("OPENGL32.dll\glMaterialiv", "uint", face, "uint", pname, "ptr", params)
    }

    /**
     * The glMatrixMode function specifies which matrix is the current matrix.
     * @remarks
     * The **glMatrixMode** function sets the current matrix mode.
     * 
     * The following function retrieves information related to **glMatrixMode**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * @param {Integer} mode The matrix stack that is the target for subsequent matrix operations. The *mode* parameter can assume one of three values.
     * 
     * 
     * 
     * | Value                                                                                                                                                         | Meaning                                                                         |
     * |---------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------|
     * | <span id="GL_MODELVIEW"></span><span id="gl_modelview"></span><dl> <dt>**GL\_MODELVIEW**</dt> </dl>    | Applies subsequent matrix operations to the modelview matrix stack.<br/>  |
     * | <span id="GL_PROJECTION"></span><span id="gl_projection"></span><dl> <dt>**GL\_PROJECTION**</dt> </dl> | Applies subsequent matrix operations to the projection matrix stack.<br/> |
     * | <span id="GL_TEXTURE"></span><span id="gl_texture"></span><dl> <dt>**GL\_TEXTURE**</dt> </dl>          | Applies subsequent matrix operations to the texture matrix stack.<br/>    |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glmatrixmode
     */
    static glMatrixMode(mode) {
        DllCall("OPENGL32.dll\glMatrixMode", "uint", mode)
    }

    /**
     * The glMultMatrixd function multiplies the current matrix by an arbitrary matrix. | glMultMatrixd function (Gl.h)
     * @remarks
     * The **glMultMatrix** function multiplies the current matrix by the one specified in *m*. That is, if M is the current matrix and T is the matrix passed to **glMultMatrix**, then M is replaced with M   T.
     * 
     * The current matrix is the projection matrix, modelview matrix, or texture matrix, determined by the current matrix mode (see [**glMatrixMode**](glmatrixmode.md)).
     * 
     * The *m* parameter points to a 4x4 matrix of single-precision or double-precision floating-point values stored in column-major order. That is, the matrix is stored as shown in the following image.
     * 
     * ![![Diagram showing the 4x4 matrix that the m parameter points to.]](images/multi01.png)
     * 
     * The following functions retrieve information related to **glMultMatrix**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * 
     * **glGet** with argument GL\_MODELVIEW\_MATRIX
     * 
     * **glGet** with argument GL\_PROJECTION\_MATRIX
     * 
     * **glGet** with argument GL\_TEXTURE\_MATRIX
     * @param {Pointer<Double>} m A pointer to a 4x4 matrix stored in column-major order as 16 consecutive values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glmultmatrixd
     */
    static glMultMatrixd(m) {
        DllCall("OPENGL32.dll\glMultMatrixd", "ptr", m)
    }

    /**
     * The glMultMatrixf function multiplies the current matrix by an arbitrary matrix. | glMultMatrixf function (Gl.h)
     * @remarks
     * The **glMultMatrix** function multiplies the current matrix by the one specified in *m*. That is, if M is the current matrix and T is the matrix passed to **glMultMatrix**, then M is replaced with M   T.
     * 
     * The current matrix is the projection matrix, modelview matrix, or texture matrix, determined by the current matrix mode (see [**glMatrixMode**](glmatrixmode.md)).
     * 
     * The *m* parameter points to a 4x4 matrix of single-precision or double-precision floating-point values stored in column-major order. That is, the matrix is stored as shown in the following image.
     * 
     * ![![Diagram showing the 4x4 matrix that the m parameter points to.]](images/multi01.png)
     * 
     * The following functions retrieve information related to **glMultMatrix**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * 
     * **glGet** with argument GL\_MODELVIEW\_MATRIX
     * 
     * **glGet** with argument GL\_PROJECTION\_MATRIX
     * 
     * **glGet** with argument GL\_TEXTURE\_MATRIX
     * @param {Pointer<Single>} m A pointer to a 4x4 matrix stored in column-major order as 16 consecutive values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glmultmatrixf
     */
    static glMultMatrixf(m) {
        DllCall("OPENGL32.dll\glMultMatrixf", "ptr", m)
    }

    /**
     * The glNewList and glEndList functions create or replace a display list. | glNewList function (Gl.h)
     * @remarks
     * Display lists are groups of OpenGL commands that have been stored for subsequent execution. The display lists are created with **glNewList**. All subsequent commands are placed in the display list, in the order issued, until **glEndList** is called.
     * 
     * The **glNewList** function has two parameters. The first parameter, *list*, is a positive integer that becomes the unique name for the display list. Names can be created and reserved with [**glGenLists**](glgenlists.md) and tested for uniqueness with [**glIsList**](glislist.md). The second parameter, *mode*, is a symbolic constant that can assume one of the two preceding values.
     * 
     * Certain commands are not compiled into the display list, but are executed immediately, regardless of the display list mode. These commands are [**glColorPointer**](glcolorpointer.md), [**glDeleteLists**](gldeletelists.md), [**glDisableClientState**](gldisableclientstate.md), [**glEdgeFlagPointer**](gledgeflagpointer.md), [**glEnableClientState**](glenableclientstate.md), [**glFeedbackBuffer**](glfeedbackbuffer.md), [**glFinish**](glfinish.md), [**glFlush**](glflush.md), [**glGenLists**](glgenlists.md), [**glIndexPointer**](glindexpointer.md), [**glInterleavedArrays**](glinterleavedarrays.md), [**glIsEnabled**](glisenabled.md), [**glIsList**](glislist.md), [**glNormalPointer**](glnormalpointer.md), [**glPopClientAttrib**](glpopclientattrib.md), [**glPixelStore**](glpixelstore-functions.md), [**glPushClientAttrib**](glpushclientattrib.md), [**glReadPixels**](glreadpixels.md), [**glRenderMode**](glrendermode.md), [**glSelectBuffer**](glselectbuffer.md), [**glTexCoordPointer**](gltexcoordpointer.md), [**glVertexPointer**](glvertexpointer.md), and all of the [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) routines.
     * 
     * Similarly, [**glTexImage2D**](glteximage2d.md) and [**glTexImage1D**](glteximage1d.md) are executed immediately and not compiled into the display list when their first argument is GL\_PROXY\_TEXTURE\_2D or GL\_PROXY\_TEXTURE\_1D, respectively.
     * 
     * When the **glEndList** function is encountered, the display list definition is completed by associating the list with the unique name *list* (specified in the **glNewList** command). If a display list with name *list* already exists, it is replaced only when **glEndList** is called.
     * 
     * The [**glCallList**](glcalllist.md) and [**glCallLists**](glcalllists.md) functions can be entered into display lists. The commands in the display list or lists executed by **glCallList** or **glCallLists** are not included in the display list being created, even if the list creation mode is GL\_COMPILE\_AND\_EXECUTE.
     * 
     * The following function retrieves information related to **glNewList**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * @param {Integer} list The display list name.
     * @param {Integer} mode The compilation mode. The following values are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                      | Meaning                                                                      |
     * |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------|
     * | <span id="GL_COMPILE"></span><span id="gl_compile"></span><dl> <dt>**GL\_COMPILE**</dt> </dl>                                       | Commands are merely compiled.<br/>                                     |
     * | <span id="GL_COMPILE_AND_EXECUTE"></span><span id="gl_compile_and_execute"></span><dl> <dt>**GL\_COMPILE\_AND\_EXECUTE**</dt> </dl> | Commands are executed as they are compiled into the display list.<br/> |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glnewlist
     */
    static glNewList(list, mode) {
        DllCall("OPENGL32.dll\glNewList", "uint", list, "uint", mode)
    }

    /**
     * Sets the current normal vector. | glNormal3b function (Gl.h)
     * @remarks
     * The current normal is set to the given coordinates whenever you call the **glNormal3b** function.
     * 
     * Byte, short, or integer arguments are converted to floating-point format by using a linear mapping that maps the most positive representable integer value to 1.0, and the most negative representable integer value to -1.0.
     * 
     * Normals specified with **glNormal3b** need not have unit length. If normalization is enabled, then normals specified with **glNormal3b** are normalized after transformation. You can control normalization by using [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with the argument GL\_NORMALIZE. By default, normalization is disabled. You can update the current normal at any time. In particular, you can call**glNormal3b**between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following functions retrieve information related to **glNormal3b**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_NORMAL
     * 
     * [**glIsEnable**](glisenabled.md) with argument GL\_NORMALIZE
     * @param {Integer} nx Specifies the x-coordinate for the new current normal vector.
     * @param {Integer} ny Specifies the y-coordinate for the new current normal vector.
     * @param {Integer} nz Specifies the z-coordinate for the new current normal vector.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glnormal3b
     */
    static glNormal3b(nx, ny, nz) {
        DllCall("OPENGL32.dll\glNormal3b", "char", nx, "char", ny, "char", nz)
    }

    /**
     * Sets the current normal vector. | glNormal3bv function (Gl.h)
     * @remarks
     * The current normal is set to the given coordinates whenever you call the**glNormal3bv**function.
     * 
     * Byte, short, or integer arguments are converted to floating-point format by using a linear mapping that maps the most positive representable integer value to 1.0, and the most negative representable integer value to -1.0.
     * 
     * Normals specified by using**glNormal3bv** need not have unit length. If normalization is enabled, then normals specified by using**glNormal3bv** are normalized after transformation. You can control normalization by using [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with the argument GL\_NORMALIZE. By default, normalization is disabled. You can update the current normal any time. In particular, you can call **glNormal3bv**between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following functions retrieve information related to **glNormal3bv**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_NORMAL
     * 
     * [**glIsEnable**](glisenabled.md) with argument GL\_NORMALIZE
     * @param {Pointer<SByte>} v A pointer to an array of three elements: the x, y, and z coordinates of the new current normal.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glnormal3bv
     */
    static glNormal3bv(v) {
        DllCall("OPENGL32.dll\glNormal3bv", "ptr", v)
    }

    /**
     * Sets the current normal vector. | glNormal3d function (Gl.h)
     * @remarks
     * The current normal is set to the given coordinates whenever you call the **glNormal3d**function.
     * 
     * Byte, short, or integer arguments are converted to floating-point format by using a linear mapping that maps the most positive representable integer value to 1.0, and the most negative representable integer value to -1.0.
     * 
     * Normals specified by using**glNormal3d** need not have unit length. If normalization is enabled, then normals specified with **glNormal3d** are normalized after transformation. You can control normalization by using [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with the argument GL\_NORMALIZE. By default, normalization is disabled. You can update the current normal at any time. In particular, you can call**glNormal3d**between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following functions retrieve information related to **glNormal3d**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_NORMAL
     * 
     * [**glIsEnable**](glisenabled.md) with argument GL\_NORMALIZE
     * @param {Float} nx Specifies the x-coordinate for the new current normal vector.
     * @param {Float} ny Specifies the y-coordinate for the new current normal vector.
     * @param {Float} nz Specifies the z-coordinate for the new current normal vector.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glnormal3d
     */
    static glNormal3d(nx, ny, nz) {
        DllCall("OPENGL32.dll\glNormal3d", "double", nx, "double", ny, "double", nz)
    }

    /**
     * Sets the current normal vector. | glNormal3dv function (Gl.h)
     * @remarks
     * The current normal is set to the given coordinates whenever you call the **glNormal3dv**function.
     * 
     * Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0, and the most negative representable integer value to -1.0.
     * 
     * Normals specified by using**glNormal3dv** need not have unit length. If normalization is enabled, then normals specified with **glNormal3dv** are normalized after transformation. You can control normalization by using [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with the argument GL\_NORMALIZE. By default, normalization is disabled. You can update the current normal at any time. In particular, you can call**glNormal3dv**between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following functions retrieve information related to **glNormal3dv**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_NORMAL
     * 
     * [**glIsEnable**](glisenabled.md) with argument GL\_NORMALIZE
     * @param {Pointer<Double>} v A pointer to an array of three elements: the x, y, and z coordinates of the new current normal.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glnormal3dv
     */
    static glNormal3dv(v) {
        DllCall("OPENGL32.dll\glNormal3dv", "ptr", v)
    }

    /**
     * Sets the current normal vector. | glNormal3f function (Gl.h)
     * @remarks
     * The current normal is set to the given coordinates whenever you call the **glNormal3f** function.
     * 
     * Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0, and the most negative representable integer value to -1.0.
     * 
     * Normals specified by using **glNormal3f** need not have unit length. If normalization is enabled, then normals specified with **glNormal3f** are normalized after transformation. You can control normalization by using [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with the argument GL\_NORMALIZE. By default, normalization is disabled. You can update the current normal at any time. In particular, you can call **glNormal3f** between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following functions retrieve information related to **glNormal3f**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_NORMAL
     * 
     * [**glIsEnable**](glisenabled.md) with argument GL\_NORMALIZE
     * @param {Float} nx Specifies the x-coordinate for the new current normal vector.
     * @param {Float} ny Specifies the y-coordinate for the new current normal vector.
     * @param {Float} nz Specifies the z-coordinate for the new current normal vector.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glnormal3f
     */
    static glNormal3f(nx, ny, nz) {
        DllCall("OPENGL32.dll\glNormal3f", "float", nx, "float", ny, "float", nz)
    }

    /**
     * Sets the current normal vector. | glNormal3fv function (Gl.h)
     * @remarks
     * The current normal is set to the given coordinates whenever you call the**glNormal3fv**function.
     * 
     * Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0, and the most negative representable integer value to -1.0.
     * 
     * Normals specified by using**glNormal3fv** need not have unit length. If normalization is enabled, then normals specified with **glNormal3fv** are normalized after transformation. You can control normalization by using [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with the argument GL\_NORMALIZE. By default, normalization is disabled. You can update the current normal can at any time. In particular, you can call**glNormal3fv** between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following functions retrieve information related to **glNormal3fv**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_NORMAL
     * 
     * [**glIsEnable**](glisenabled.md) with argument GL\_NORMALIZE
     * @param {Pointer<Single>} v A pointer to an array of three elements: the x, y, and z coordinates of the new current normal.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glnormal3fv
     */
    static glNormal3fv(v) {
        DllCall("OPENGL32.dll\glNormal3fv", "ptr", v)
    }

    /**
     * Sets the current normal vector. | glNormal3i function (Gl.h)
     * @remarks
     * The current normal is set to the given coordinates whenever you call the **glNormal3i**function.
     * 
     * Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0, and the most negative representable integer value to -1.0.
     * 
     * Normals specified by using**glNormal3i** need not have unit length. If normalization is enabled, then normals specified with **glNormal3i** are normalized after transformation. You can control normalization by using [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with the argument GL\_NORMALIZE. By default, normalization is disabled. You can update the current normal at any time. In particular, you can call**glNormal3i**between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following functions retrieve information related to **glNormal3i**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_NORMAL
     * 
     * [**glIsEnable**](glisenabled.md) with argument GL\_NORMALIZE
     * @param {Integer} nx Specifies the x-coordinate for the new current normal vector.
     * @param {Integer} ny Specifies the y-coordinate for the new current normal vector.
     * @param {Integer} nz Specifies the z-coordinate for the new current normal vector.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glnormal3i
     */
    static glNormal3i(nx, ny, nz) {
        DllCall("OPENGL32.dll\glNormal3i", "int", nx, "int", ny, "int", nz)
    }

    /**
     * Sets the current normal vector. | glNormal3iv function (Gl.h)
     * @remarks
     * The current normal is set to the given coordinates whenever you call the**glNormal3iv**function.
     * 
     * Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0, and the most negative representable integer value to -1.0.
     * 
     * Normals specified by using**glNormal3iv** need not have unit length. If normalization is enabled, then normals specified with **glNormal3iv** are normalized after transformation. You can control normalization by using [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with the argument GL\_NORMALIZE. By default, normalization is disabled. You can update the current normal at any time. In particular, you can call**glNormal3iv**between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following functions retrieve information related to **glNormal3iv**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_NORMAL
     * 
     * [**glIsEnable**](glisenabled.md) with argument GL\_NORMALIZE
     * @param {Pointer<Int32>} v A pointer to an array of three elements: the x, y, and z coordinates of the new current normal.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glnormal3iv
     */
    static glNormal3iv(v) {
        DllCall("OPENGL32.dll\glNormal3iv", "ptr", v)
    }

    /**
     * Sets the current normal vector. | glNormal3s function (Gl.h)
     * @remarks
     * The current normal is set to the given coordinates whenever you call the**glNormal3s**function.
     * 
     * Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0, and the most negative representable integer value to -1.0.
     * 
     * Normals specified by using**glNormal3s** need not have unit length. If normalization is enabled, then normals specified with **glNormal3s** are normalized after transformation. You can control normalizationby using [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with the argument GL\_NORMALIZE. By default, normalization is disabled. You can update the current normal at any time. In particular, you can call**glNormal3s**between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following functions retrieve information related to **glNormal3s**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_NORMAL
     * 
     * [**glIsEnable**](glisenabled.md) with argument GL\_NORMALIZE
     * @param {Integer} nx Specifies the x-coordinate of the new current normal vector.
     * @param {Integer} ny Specifies the y-coordinate of the new current normal vector.
     * @param {Integer} nz Specifies the z-coordinate of the new current normal vector.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glnormal3s
     */
    static glNormal3s(nx, ny, nz) {
        DllCall("OPENGL32.dll\glNormal3s", "short", nx, "short", ny, "short", nz)
    }

    /**
     * Sets the current normal vector. | glNormal3sv function (Gl.h)
     * @remarks
     * The current normal is set to the given coordinates whenever you call the **glNormal3sv** function.
     * 
     * Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0, and the most negative representable integer value to -1.0.
     * 
     * Normals specified by using **glNormal3sv** need not have unit length. If normalization is enabled, then normals specified with **glNormal3sv** are normalized after transformation. You can control normalization by using [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with the argument GL\_NORMALIZE. By default, normalization is disabled. You can update the current normal at any time. In particular, you can call **glNormal3sv** between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following functions retrieve information related to **glNormal3sv**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_NORMAL
     * 
     * [**glIsEnable**](glisenabled.md) with argument GL\_NORMALIZE
     * @param {Pointer<Int16>} v A pointer to an array of three elements: the x, y, and z coordinates of the new current normal.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glnormal3sv
     */
    static glNormal3sv(v) {
        DllCall("OPENGL32.dll\glNormal3sv", "ptr", v)
    }

    /**
     * The glNormalPointer function defines an array of normals.
     * @remarks
     * The **glNormalPointer** function specifies the location and data of an array of normals to use when rendering. The *type* parameter specifies the data type of each normal coordinate. The *stride* parameter determines the byte offset from one normal to the next, enabling the packing of vertices and attributes in a single array or storage in separate arrays. In some implementations storing the vertices and attributes in a single array can be more efficient than using separate arrays; see [**glInterleavedArrays**](glinterleavedarrays.md) for details.
     * 
     * A normal array is enabled when you specify the GL\_NORMAL\_ARRAY constant with [**glEnableClientState**](glenableclientstate.md). When enabled, [**glDrawArrays**](gldrawarrays.md), [**glDrawElements**](gldrawelements.md) and [**glArrayElement**](glarrayelement.md) use the normal array. By default the normal array is disabled.
     * 
     * You cannot include **glNormalPointer** in display lists.
     * 
     * When you specify a normal array using **glNormalPointer**, the values of all the function's normal array parameters are saved in a client-side state. Because the normal array parameters are saved in a client-side state, their values are not saved or restored by [**glPushAttrib**](glpushattrib.md) and [**glPopAttrib**](glpopattrib.md).
     * 
     * Although no error is generated when you call **glNormalPointer** within [**glBegin**](glbegin.md) and [**glEnd**](glend.md) pairs, the results are undefined.
     * 
     * The following functions are associated with **glNormalPointer**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_NORMAL\_ARRAY\_STRIDE
     * 
     * **glGet** with argument GL\_NORMAL\_ARRAY\_COUNT
     * 
     * **glGet** with argument GL\_NORMAL\_ARRAY\_TYPE
     * 
     * **glGetPointerv** with argument GL\_NORMAL\_ARRAY\_POINTER
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_NORMAL\_ARRAY
     * @param {Integer} type The data type of each coordinate in the array using the following symbolic constants: GL\_BYTE, GL\_SHORT, GL\_INT, GL\_FLOAT, and GL\_DOUBLE.
     * @param {Integer} stride The byte offset between consecutive normals. When *stride* is zero, the normals are tightly packed in the array.
     * @param {Pointer<Void>} pointer A pointer to the first normal in the array.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glnormalpointer
     */
    static glNormalPointer(type, stride, pointer) {
        DllCall("OPENGL32.dll\glNormalPointer", "uint", type, "int", stride, "ptr", pointer)
    }

    /**
     * The glOrtho function multiplies the current matrix by an orthographic matrix.
     * @remarks
     * The **glOrtho** function describes a perspective matrix that produces a parallel projection. The (*left*, *bottom*, *near*) and (*right*, *top*, *near*) parameters specify the points on the near clipping plane that are mapped to the lower-left and upper-right corners of the window, respectively, assuming that the eye is located at (0, 0, 0). The *far* parameter specifies the location of the far clipping plane. Both *zNear* and *zFar* can be either positive or negative. The corresponding matrix is shown in the following image.
     * 
     * ![Diagram showing the perspective matrix the glOrtho function describes.](images/ortho1.png)
     * 
     * where
     * 
     * ![Equations describing the perspective matrix.](images/ortho2.png)
     * 
     * The current matrix is multiplied by this matrix with the result replacing the current matrix. That is, if M is the current matrix and O is the ortho matrix, then M is replaced with M   O.
     * 
     * Use [**glPushMatrix**](glpushmatrix.md) and **glPopMatrix** to save and restore the current matrix stack. Use [**glMatrixMode**](glmatrixmode.md) to set the current matrix.
     * 
     * The following functions retrieve information related to **glOrtho**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * 
     * **glGet** with argument GL\_MODELVIEW\_MATRIX
     * 
     * **glGet** with argument GL\_PROJECTION\_MATRIX
     * 
     * **glGet** with argument GL\_TEXTURE\_MATRIX
     * @param {Float} left The coordinates for the left vertical clipping plane.
     * @param {Float} right The coordinates for theright vertical clipping plane.
     * @param {Float} bottom The coordinates for the bottom horizontal clipping plane.
     * @param {Float} top The coordinates for the top horizontal clipping plans.
     * @param {Float} zNear The distances to the nearer depth clipping plane. This distance is negative if the plane is to be behind the viewer.
     * @param {Float} zFar The distances to the farther depth clipping plane. This distance is negative if the plane is to be behind the viewer.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glortho
     */
    static glOrtho(left, right, bottom, top, zNear, zFar) {
        DllCall("OPENGL32.dll\glOrtho", "double", left, "double", right, "double", bottom, "double", top, "double", zNear, "double", zFar)
    }

    /**
     * The glPassThrough function places a marker in the feedback buffer.
     * @remarks
     * Feedback is an OpenGL render mode selected by calling [**glRenderMode**](glrendermode.md) with GL\_FEEDBACK. When OpenGL is in feedback mode, no pixels are produced by rasterization. Instead, information about primitives that would have been rasterized is fed back to the application by OpenGL. See [**glFeedbackBuffer**](glfeedbackbuffer.md) for a description of the feedback buffer and the values in it.
     * 
     * The **glPassThrough** function inserts a user-defined marker in the feedback buffer when it is executed in feedback mode. The *token* parameter is returned as if it were a primitive.
     * 
     * The **glPassThrough** function is ignored if OpenGL is not in feedback mode.
     * 
     * The following function retrieves information related to **glPassThrough**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_RENDER\_MODE
     * @param {Float} token A marker value to be placed in the feedback buffer. It is indicated with the following unique identifying value.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                   | Meaning                                                                                                                    |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_PASS_THROUGH_TOKEN"></span><span id="gl_pass_through_token"></span><dl> <dt>**GL\_PASS\_THROUGH\_TOKEN**</dt> </dl> | The order of **glPassThrough** commands with respect to the specification of graphics primitives is maintained.<br/> |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpassthrough
     */
    static glPassThrough(token) {
        DllCall("OPENGL32.dll\glPassThrough", "float", token)
    }

    /**
     * The glPixelMapfv function sets up pixel transfer maps.
     * @remarks
     * The **glPixelMap** function sets up translation tables, or *maps*, used by [**glCopyPixels**](glcopypixels.md), [**glCopyTexImage1D**](glcopyteximage1d.md), [**glCopyTexImage2D**](glcopyteximage2d.md), [**glCopyTexSubImage1D**](glcopytexsubimage1d.md), [**glCopyTexSubImage2D**](glcopytexsubimage2d.md), [**glDrawPixels**](gldrawpixels.md), [**glReadPixels**](glreadpixels.md), [**glTexImage1D**](glteximage1d.md), [**glTexImage2D**](glteximage2d.md), [**glTexSubImage1D**](gltexsubimage1d.md), and [**glTexSubImage2D**](gltexsubimage2d.md). Use of these maps is described completely in the [**glPixelTransfer**](glpixeltransfer.md) topic, and partly in the topics for the pixel and texture image commands. Only the specification of the maps is described in this topic.
     * 
     * The *map* parameter is a symbolic map name, indicating one of ten maps to set. The *mapsize* parameter specifies the number of entries in the map, and *values* is a pointer to an array of *mapsize* map values.
     * 
     * The entries in a map can be specified as single-precision floating-point numbers, unsigned short integers, or unsigned long integers. Maps that store color component values (all but GL\_PIXEL\_MAP\_I\_TO\_I and GL\_PIXEL\_MAP\_S\_TO\_S) retain their values in floating-point format, with unspecified mantissa and exponent sizes. Floating-point values specified by [**glPixelMapfv**](glpixelmap.md) are converted directly to the internal floating-point format of these maps, and then clamped to the range \[0,1\]. Unsigned integer values specified by **glPixelMapusv** and **glPixelMapuiv** are converted linearly such that the largest representable integer maps to 1.0, and zero maps to 0.0.
     * 
     * Maps that store indexes, GL\_PIXEL\_MAP\_I\_TO\_I and GL\_PIXEL\_MAP\_S\_TO\_S, retain their values in fixed-point format, with an unspecified number of bits to the right of the binary point. Floating-point values specified by [**glPixelMapfv**](glpixelmap.md) are converted directly to the internal fixed-point format of these maps. Unsigned integer values specified by **glPixelMapusv** and **glPixelMapuiv** specify integer values, with all zeros to the right of the binary point.
     * 
     * The following table shows the initial sizes and values for each of the maps. Maps that are indexed by either color or stencil indexes must have *mapsize* = 2 ^ *n* for some *n* or results are undefined. The maximum allowable size for each map depends on the implementation and can be determined by calling **glGet** with argument GL\_MAX\_PIXEL\_MAP\_TABLE. The single maximum applies to all maps, and it is at least 32.
     * 
     * 
     * 
     * | Map                      | Lookup Index  | Lookup Value  | Initial Size | Initial Value |
     * |--------------------------|---------------|---------------|--------------|---------------|
     * | GL\_PIXEL\_MAP\_I\_TO\_I | color index   | color index   | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_S\_TO\_S | stencil index | stencil index | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_I\_TO\_R | color index   | R             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_I\_TO\_G | color index   | G             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_I\_TO\_B | color index   | B             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_I\_TO\_A | color index   | A             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_R\_TO\_R | R             | R             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_G\_TO\_G | G             | G             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_B\_TO\_B | B             | B             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_A\_TO\_A | A             | A             | 1            | 0.0           |
     * 
     * 
     * 
     *  
     * 
     * The following functions retrieve information related to **glPixelMap**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_PIXEL\_MAP\_I\_TO\_I\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_S\_TO\_S\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_R\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_G\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_B\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_A\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_R\_TO\_R\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_G\_TO\_G\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_B\_TO\_B\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_A\_TO\_A\_SIZE
     * 
     * **glGet** with argument GL\_MAX\_PIXEL\_MAP\_TABLE
     * @param {Integer} map A symbolic map name. The ten maps are as follows.
     * 
     * 
     * 
     * | Value                                                                                                                                                                               | Meaning                                               |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|
     * | <span id="GL_PIXEL_MAP_I_TO_I"></span><span id="gl_pixel_map_i_to_i"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_I**</dt> </dl> | Maps color indexes to color indexes.<br/>       |
     * | <span id="GL_PIXEL_MAP_S_TO_S"></span><span id="gl_pixel_map_s_to_s"></span><dl> <dt>**GL\_PIXEL\_MAP\_S\_TO\_S**</dt> </dl> | Maps stencil indexes to stencil indexes.<br/>   |
     * | <span id="GL_PIXEL_MAP_I_TO_R"></span><span id="gl_pixel_map_i_to_r"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_R**</dt> </dl> | Maps color indexes to red components.<br/>      |
     * | <span id="GL_PIXEL_MAP_I_TO_G"></span><span id="gl_pixel_map_i_to_g"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_G**</dt> </dl> | Maps color indexes to green components.<br/>    |
     * | <span id="GL_PIXEL_MAP_I_TO_B"></span><span id="gl_pixel_map_i_to_b"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_B**</dt> </dl> | Maps color indexes to blue components.<br/>     |
     * | <span id="GL_PIXEL_MAP_I_TO_A"></span><span id="gl_pixel_map_i_to_a"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_A**</dt> </dl> | Maps color indexes to alpha components.<br/>    |
     * | <span id="GL_PIXEL_MAP_R_TO_R"></span><span id="gl_pixel_map_r_to_r"></span><dl> <dt>**GL\_PIXEL\_MAP\_R\_TO\_R**</dt> </dl> | Maps red components to red components.<br/>     |
     * | <span id="GL_PIXEL_MAP_G_TO_G"></span><span id="gl_pixel_map_g_to_g"></span><dl> <dt>**GL\_PIXEL\_MAP\_G\_TO\_G**</dt> </dl> | Maps green components to green components.<br/> |
     * | <span id="GL_PIXEL_MAP_B_TO_B"></span><span id="gl_pixel_map_b_to_b"></span><dl> <dt>**GL\_PIXEL\_MAP\_B\_TO\_B**</dt> </dl> | Maps blue components to blue components.<br/>   |
     * | <span id="GL_PIXEL_MAP_A_TO_A"></span><span id="gl_pixel_map_a_to_a"></span><dl> <dt>**GL\_PIXEL\_MAP\_A\_TO\_A**</dt> </dl> | Maps alpha components to alpha components.<br/> |
     * @param {Integer} mapsize The size of the map being defined.
     * @param {Pointer<Single>} values An array of *mapsize* values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpixelmapfv
     */
    static glPixelMapfv(map, mapsize, values) {
        DllCall("OPENGL32.dll\glPixelMapfv", "uint", map, "int", mapsize, "ptr", values)
    }

    /**
     * The glPixelMapuiv function sets up pixel transfer maps.
     * @remarks
     * The **glPixelMap** function sets up translation tables, or *maps*, used by [**glCopyPixels**](glcopypixels.md), [**glCopyTexImage1D**](glcopyteximage1d.md), [**glCopyTexImage2D**](glcopyteximage2d.md), [**glCopyTexSubImage1D**](glcopytexsubimage1d.md), [**glCopyTexSubImage2D**](glcopytexsubimage2d.md), [**glDrawPixels**](gldrawpixels.md), [**glReadPixels**](glreadpixels.md), [**glTexImage1D**](glteximage1d.md), [**glTexImage2D**](glteximage2d.md), [**glTexSubImage1D**](gltexsubimage1d.md), and [**glTexSubImage2D**](gltexsubimage2d.md). Use of these maps is described completely in the [**glPixelTransfer**](glpixeltransfer.md) topic, and partly in the topics for the pixel and texture image commands. Only the specification of the maps is described in this topic.
     * 
     * The *map* parameter is a symbolic map name, indicating one of ten maps to set. The *mapsize* parameter specifies the number of entries in the map, and *values* is a pointer to an array of *mapsize* map values.
     * 
     * The entries in a map can be specified as single-precision floating-point numbers, unsigned short integers, or unsigned long integers. Maps that store color component values (all but GL\_PIXEL\_MAP\_I\_TO\_I and GL\_PIXEL\_MAP\_S\_TO\_S) retain their values in floating-point format, with unspecified mantissa and exponent sizes. Floating-point values specified by [**glPixelMapfv**](glpixelmap.md) are converted directly to the internal floating-point format of these maps, and then clamped to the range \[0,1\]. Unsigned integer values specified by **glPixelMapusv** and **glPixelMapuiv** are converted linearly such that the largest representable integer maps to 1.0, and zero maps to 0.0.
     * 
     * Maps that store indexes, GL\_PIXEL\_MAP\_I\_TO\_I and GL\_PIXEL\_MAP\_S\_TO\_S, retain their values in fixed-point format, with an unspecified number of bits to the right of the binary point. Floating-point values specified by [**glPixelMapfv**](glpixelmap.md) are converted directly to the internal fixed-point format of these maps. Unsigned integer values specified by **glPixelMapusv** and **glPixelMapuiv** specify integer values, with all zeros to the right of the binary point.
     * 
     * The following table shows the initial sizes and values for each of the maps. Maps that are indexed by either color or stencil indexes must have *mapsize* = 2 ^ *n* for some *n* or results are undefined. The maximum allowable size for each map depends on the implementation and can be determined by calling **glGet** with argument GL\_MAX\_PIXEL\_MAP\_TABLE. The single maximum applies to all maps, and it is at least 32.
     * 
     * 
     * 
     * | Map                      | Lookup Index  | Lookup Value  | Initial Size | Initial Value |
     * |--------------------------|---------------|---------------|--------------|---------------|
     * | GL\_PIXEL\_MAP\_I\_TO\_I | color index   | color index   | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_S\_TO\_S | stencil index | stencil index | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_I\_TO\_R | color index   | R             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_I\_TO\_G | color index   | G             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_I\_TO\_B | color index   | B             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_I\_TO\_A | color index   | A             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_R\_TO\_R | R             | R             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_G\_TO\_G | G             | G             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_B\_TO\_B | B             | B             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_A\_TO\_A | A             | A             | 1            | 0.0           |
     * 
     * 
     * 
     *  
     * 
     * The following functions retrieve information related to **glPixelMap**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_PIXEL\_MAP\_I\_TO\_I\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_S\_TO\_S\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_R\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_G\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_B\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_A\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_R\_TO\_R\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_G\_TO\_G\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_B\_TO\_B\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_A\_TO\_A\_SIZE
     * 
     * **glGet** with argument GL\_MAX\_PIXEL\_MAP\_TABLE
     * @param {Integer} map A symbolic map name. The ten maps are as follows.
     * 
     * 
     * 
     * | Value                                                                                                                                                                               | Meaning                                               |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|
     * | <span id="GL_PIXEL_MAP_I_TO_I"></span><span id="gl_pixel_map_i_to_i"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_I**</dt> </dl> | Maps color indexes to color indexes.<br/>       |
     * | <span id="GL_PIXEL_MAP_S_TO_S"></span><span id="gl_pixel_map_s_to_s"></span><dl> <dt>**GL\_PIXEL\_MAP\_S\_TO\_S**</dt> </dl> | Maps stencil indexes to stencil indexes.<br/>   |
     * | <span id="GL_PIXEL_MAP_I_TO_R"></span><span id="gl_pixel_map_i_to_r"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_R**</dt> </dl> | Maps color indexes to red components.<br/>      |
     * | <span id="GL_PIXEL_MAP_I_TO_G"></span><span id="gl_pixel_map_i_to_g"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_G**</dt> </dl> | Maps color indexes to green components.<br/>    |
     * | <span id="GL_PIXEL_MAP_I_TO_B"></span><span id="gl_pixel_map_i_to_b"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_B**</dt> </dl> | Maps color indexes to blue components.<br/>     |
     * | <span id="GL_PIXEL_MAP_I_TO_A"></span><span id="gl_pixel_map_i_to_a"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_A**</dt> </dl> | Maps color indexes to alpha components.<br/>    |
     * | <span id="GL_PIXEL_MAP_R_TO_R"></span><span id="gl_pixel_map_r_to_r"></span><dl> <dt>**GL\_PIXEL\_MAP\_R\_TO\_R**</dt> </dl> | Maps red components to red components.<br/>     |
     * | <span id="GL_PIXEL_MAP_G_TO_G"></span><span id="gl_pixel_map_g_to_g"></span><dl> <dt>**GL\_PIXEL\_MAP\_G\_TO\_G**</dt> </dl> | Maps green components to green components.<br/> |
     * | <span id="GL_PIXEL_MAP_B_TO_B"></span><span id="gl_pixel_map_b_to_b"></span><dl> <dt>**GL\_PIXEL\_MAP\_B\_TO\_B**</dt> </dl> | Maps blue components to blue components.<br/>   |
     * | <span id="GL_PIXEL_MAP_A_TO_A"></span><span id="gl_pixel_map_a_to_a"></span><dl> <dt>**GL\_PIXEL\_MAP\_A\_TO\_A**</dt> </dl> | Maps alpha components to alpha components.<br/> |
     * @param {Integer} mapsize The size of the map being defined.
     * @param {Pointer<UInt32>} values An array of *mapsize* values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpixelmapuiv
     */
    static glPixelMapuiv(map, mapsize, values) {
        DllCall("OPENGL32.dll\glPixelMapuiv", "uint", map, "int", mapsize, "ptr", values)
    }

    /**
     * The glPixelMapusv function sets up pixel transfer maps.
     * @remarks
     * The **glPixelMap** function sets up translation tables, or *maps*, used by [**glCopyPixels**](glcopypixels.md), [**glCopyTexImage1D**](glcopyteximage1d.md), [**glCopyTexImage2D**](glcopyteximage2d.md), [**glCopyTexSubImage1D**](glcopytexsubimage1d.md), [**glCopyTexSubImage2D**](glcopytexsubimage2d.md), [**glDrawPixels**](gldrawpixels.md), [**glReadPixels**](glreadpixels.md), [**glTexImage1D**](glteximage1d.md), [**glTexImage2D**](glteximage2d.md), [**glTexSubImage1D**](gltexsubimage1d.md), and [**glTexSubImage2D**](gltexsubimage2d.md). Use of these maps is described completely in the [**glPixelTransfer**](glpixeltransfer.md) topic, and partly in the topics for the pixel and texture image commands. Only the specification of the maps is described in this topic.
     * 
     * The *map* parameter is a symbolic map name, indicating one of ten maps to set. The *mapsize* parameter specifies the number of entries in the map, and *values* is a pointer to an array of *mapsize* map values.
     * 
     * The entries in a map can be specified as single-precision floating-point numbers, unsigned short integers, or unsigned long integers. Maps that store color component values (all but GL\_PIXEL\_MAP\_I\_TO\_I and GL\_PIXEL\_MAP\_S\_TO\_S) retain their values in floating-point format, with unspecified mantissa and exponent sizes. Floating-point values specified by [**glPixelMapfv**](glpixelmap.md) are converted directly to the internal floating-point format of these maps, and then clamped to the range \[0,1\]. Unsigned integer values specified by **glPixelMapusv** and **glPixelMapuiv** are converted linearly such that the largest representable integer maps to 1.0, and zero maps to 0.0.
     * 
     * Maps that store indexes, GL\_PIXEL\_MAP\_I\_TO\_I and GL\_PIXEL\_MAP\_S\_TO\_S, retain their values in fixed-point format, with an unspecified number of bits to the right of the binary point. Floating-point values specified by [**glPixelMapfv**](glpixelmap.md) are converted directly to the internal fixed-point format of these maps. Unsigned integer values specified by **glPixelMapusv** and **glPixelMapuiv** specify integer values, with all zeros to the right of the binary point.
     * 
     * The following table shows the initial sizes and values for each of the maps. Maps that are indexed by either color or stencil indexes must have *mapsize* = 2 ^ *n* for some *n* or results are undefined. The maximum allowable size for each map depends on the implementation and can be determined by calling **glGet** with argument GL\_MAX\_PIXEL\_MAP\_TABLE. The single maximum applies to all maps, and it is at least 32.
     * 
     * 
     * 
     * | Map                      | Lookup Index  | Lookup Value  | Initial Size | Initial Value |
     * |--------------------------|---------------|---------------|--------------|---------------|
     * | GL\_PIXEL\_MAP\_I\_TO\_I | color index   | color index   | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_S\_TO\_S | stencil index | stencil index | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_I\_TO\_R | color index   | R             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_I\_TO\_G | color index   | G             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_I\_TO\_B | color index   | B             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_I\_TO\_A | color index   | A             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_R\_TO\_R | R             | R             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_G\_TO\_G | G             | G             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_B\_TO\_B | B             | B             | 1            | 0.0           |
     * | GL\_PIXEL\_MAP\_A\_TO\_A | A             | A             | 1            | 0.0           |
     * 
     * 
     * 
     *  
     * 
     * The following functions retrieve information related to **glPixelMap**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_PIXEL\_MAP\_I\_TO\_I\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_S\_TO\_S\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_R\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_G\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_B\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_I\_TO\_A\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_R\_TO\_R\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_G\_TO\_G\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_B\_TO\_B\_SIZE
     * 
     * **glGet** with argument GL\_PIXEL\_MAP\_A\_TO\_A\_SIZE
     * 
     * **glGet** with argument GL\_MAX\_PIXEL\_MAP\_TABLE
     * @param {Integer} map A symbolic map name. The ten maps are as follows.
     * 
     * 
     * 
     * | Value                                                                                                                                                                               | Meaning                                               |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|
     * | <span id="GL_PIXEL_MAP_I_TO_I"></span><span id="gl_pixel_map_i_to_i"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_I**</dt> </dl> | Maps color indexes to color indexes.<br/>       |
     * | <span id="GL_PIXEL_MAP_S_TO_S"></span><span id="gl_pixel_map_s_to_s"></span><dl> <dt>**GL\_PIXEL\_MAP\_S\_TO\_S**</dt> </dl> | Maps stencil indexes to stencil indexes.<br/>   |
     * | <span id="GL_PIXEL_MAP_I_TO_R"></span><span id="gl_pixel_map_i_to_r"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_R**</dt> </dl> | Maps color indexes to red components.<br/>      |
     * | <span id="GL_PIXEL_MAP_I_TO_G"></span><span id="gl_pixel_map_i_to_g"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_G**</dt> </dl> | Maps color indexes to green components.<br/>    |
     * | <span id="GL_PIXEL_MAP_I_TO_B"></span><span id="gl_pixel_map_i_to_b"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_B**</dt> </dl> | Maps color indexes to blue components.<br/>     |
     * | <span id="GL_PIXEL_MAP_I_TO_A"></span><span id="gl_pixel_map_i_to_a"></span><dl> <dt>**GL\_PIXEL\_MAP\_I\_TO\_A**</dt> </dl> | Maps color indexes to alpha components.<br/>    |
     * | <span id="GL_PIXEL_MAP_R_TO_R"></span><span id="gl_pixel_map_r_to_r"></span><dl> <dt>**GL\_PIXEL\_MAP\_R\_TO\_R**</dt> </dl> | Maps red components to red components.<br/>     |
     * | <span id="GL_PIXEL_MAP_G_TO_G"></span><span id="gl_pixel_map_g_to_g"></span><dl> <dt>**GL\_PIXEL\_MAP\_G\_TO\_G**</dt> </dl> | Maps green components to green components.<br/> |
     * | <span id="GL_PIXEL_MAP_B_TO_B"></span><span id="gl_pixel_map_b_to_b"></span><dl> <dt>**GL\_PIXEL\_MAP\_B\_TO\_B**</dt> </dl> | Maps blue components to blue components.<br/>   |
     * | <span id="GL_PIXEL_MAP_A_TO_A"></span><span id="gl_pixel_map_a_to_a"></span><dl> <dt>**GL\_PIXEL\_MAP\_A\_TO\_A**</dt> </dl> | Maps alpha components to alpha components.<br/> |
     * @param {Integer} mapsize The size of the map being defined.
     * @param {Pointer<UInt16>} values An array of *mapsize* values.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpixelmapusv
     */
    static glPixelMapusv(map, mapsize, values) {
        DllCall("OPENGL32.dll\glPixelMapusv", "uint", map, "int", mapsize, "ptr", values)
    }

    /**
     * Sets pixel storage modes. | glPixelStoref function (Gl.h)
     * @remarks
     * The **glPixelStore** function sets pixel storage modes that affect the operation of subsequent [**glDrawPixels**](gldrawpixels.md) and [**glReadPixels**](glreadpixels.md) as well as the unpacking of polygon stipple patterns (see [**glPolygonStipple**](glpolygonstipple.md)), bitmaps (see [**glBitmap**](glbitmap.md)), and texture patterns (see [**glTexImage1D**](glteximage1d.md), [**glTexImage2D**](glteximage2d.md), [**glTexSubImage1D**](gltexsubimage1d.md), and [**glTexSubImage2D**](gltexsubimage2d.md)).
     * 
     * The following table gives the type, initial value, and range of valid values for each of the storage parameters that can be set with **glPixelStore**.
     * 
     * 
     * 
     * | Pname                    | Type    | Initial Value | Valid Range   |
     * |--------------------------|---------|---------------|---------------|
     * | GL\_PACK\_SWAP\_BYTES    | Boolean | false         | true or false |
     * | GL\_PACK\_SWAP\_BYTES    | Boolean | false         | true or false |
     * | GL\_PACK\_ROW\_LENGTH    | integer | 0             | \[0,?)        |
     * | GL\_PACK\_SKIP\_ROWS     | integer | 0             | \[0,?)        |
     * | GL\_PACK\_SKIP\_PIXELS   | integer | 0             | \[0,?)        |
     * | GL\_PACK\_ALIGNMENT      | integer | 4             | 1, 2, 4, or 8 |
     * | GL\_UNPACK\_SWAP\_BYTES  | Boolean | false         | true or false |
     * | GL\_UNPACK\_LSB\_FIRST   | Boolean | false         | true or false |
     * | GL\_UNPACK\_ROW\_LENGTH  | integer | 0             | \[0,?)        |
     * | GL\_UNPACK\_SKIP\_ROWS   | integer | 0             | \[0,?)        |
     * | GL\_UNPACK\_SKIP\_PIXELS | integer | 0             | \[0,?)        |
     * | GL\_UNPACK\_ALIGNMENT    | integer | 4             | 1, 2, 4, or 8 |
     * 
     * 
     * 
     *  
     * 
     * The **glPixelStoref** function can be used to set any pixel store parameter. If the parameter type is Boolean, and if *param* is 0.0, then the parameter is false; otherwise it is set to true. If *pname* is an integer type parameter, then *param* is rounded to the nearest integer.
     * 
     * Likewise, the **glPixelStorei** function can also be used to set any of the pixel store parameters. Boolean parameters are set to false if *param* is 0 and true otherwise. The *param* parameter is converted to floating point before being assigned to real-valued parameters.
     * 
     * The pixel storage modes in effect when [**glDrawPixels**](gldrawpixels.md), [**glReadPixels**](glreadpixels.md), [**glTexImage1D**](glteximage1d.md), [**glTexImage2D**](glteximage2d.md), [**glBitmap**](glbitmap.md), or [**glPolygonStipple**](glpolygonstipple.md) is placed in a display list control the interpretation of memory data. The pixel storage modes in effect when a display list is executed are not significant.
     * 
     * The following functions retrieve information related to **glPixelStore**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_PACK\_SWAP\_BYTES
     * 
     * **glGet** with argument GL\_PACK\_LSB\_FIRST
     * 
     * **glGet** with argument GL\_PACK\_ROW\_LENGTH
     * 
     * **glGet** with argument GL\_PACK\_SKIP\_ROWS
     * 
     * **glGet** with argument GL\_PACK\_SKIP\_PIXELS
     * 
     * **glGet** with argument GL\_PACK\_ALIGNMENT
     * 
     * **glGet** with argument GL\_UNPACK\_SWAP\_BYTES
     * 
     * **glGet** with argument GL\_UNPACK\_LSB\_FIRST
     * 
     * **glGet** with argument GL\_UNPACK\_ROW\_LENGTH
     * 
     * **glGet** with argument GL\_UNPACK\_SKIP\_ROWS
     * 
     * **glGet** with argument GL\_UNPACK\_SKIP\_PIXELS
     * 
     * **glGet** with argument GL\_UNPACK\_ALIGNMENT
     * @param {Integer} pname The symbolic name of the parameter to be set. Six of the storage parameters affect how pixel data is returned to client memory, and are therefore significant only for [**glReadPixels**](glreadpixels.md) commands. They are as follows:
     * 
     * 
     * 
     * | Storage Parameter                                           | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
     * |-------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | GL\_PACK\_SWAP\_BYTES                                       | If true, byte ordering for multibyte color components, depth components, color indexes, or stencil indexes is reversed. That is, if a four-byte component is made up of bytes *b*0 , *b*1 , *b*2 , *b*3 , it is stored in memory as *b*3 , *b*2 , *b*1 , *b*0 if GL\_PACK\_SWAP\_BYTES is true. GL\_PACK\_SWAP\_BYTES has no effect on the memory order of components within a pixel, only on the order of bytes within components or indexes. For example, the three components of a GL\_RGB format pixel are always stored with red first, green second, and blue third, regardless of the value of GL\_PACK\_SWAP\_BYTES.                                                                                                                                                                                                                                                                                                                                                                                               |
     * | GL\_PACK\_LSB\_FIRST                                        | If true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one. This parameter is significant for bitmap data only.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
     * | GL\_PACK\_ROW\_LENGTH                                       | If greater than zero, GL\_PACK\_ROW\_LENGTH defines the number of pixels in a row. If the first pixel of a row is placed at location p in memory, then the location of the first pixel of the next row is obtained by skipping ![Equation showing the location of the first pixel of the next row in GL_PACK_ROW_LENGTH.](images/pix01.png)\[newline\] components or indexes, where *n* is the number of components or indexes in a pixel, *l* is the number of pixels in a row (gl\-pack\-row\-length if it is greater than zero, the width argument to the pixel routine otherwise), *a* is the value of gl\-pack\-alignment, and *s* is the size, in bytes, of a single component (if *a* < *s*, then it is as if *a* = *s*). in the case of 1-bit values, the location of the next row is obtained by skipping ![Equation showing the location of the next row in GL_PACK_ROW_LENGTH.](images/pix02.png)<br/> components or indexes. The word *component* in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format GL\_RGB, for example, has three components per pixel: first red, then green, and finally blue.<br/> |
     * | GL\_PACK\_SKIP\_PIXELS and <br/> GL\_PACK\_SKIP\_ROWS | These values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated simply by incrementing the pointer passed to [**glReadPixels**](glreadpixels.md). Setting GL\_PACK\_SKIP\_PIXELS to *i* is equivalent to incrementing the pointer by *i n* components or indexes, where *n* is the number of components or indexes in each pixel. Setting GL\_PACK\_SKIP\_ROWS to *j* is equivalent to incrementing the pointer by *j k* components or indexes, where *k* is the number of components or indexes per row, as computed above in the GL\_PACK\_ROW\_LENGTH section.                                                                                                                                                                                                                                                                                                                                                                                                   |
     * | GL\_PACK\_ALIGNMENT                                         | Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word alignment), and 8 (rows start on double-word boundaries).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
     * 
     * 
     * 
     *  
     * 
     * The other six storage parameters affect how pixel data is read from client memory. These values are significant for [**glDrawPixels**](gldrawpixels.md), [**glTexImage1D**](glteximage1d.md), [**glTexImage2D**](glteximage2d.md), [**glBitmap**](glbitmap.md), and [**glPolygonStipple**](glpolygonstipple.md). They are as follows:
     * 
     * 
     * 
     * | Storage Parameter                                               | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
     * |-----------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | GL\_UNPACK\_SWAP\_BYTES                                         | If true, byte ordering for multibyte color components, depth components, color indexes, or stencil indexes is reversed. That is, if a four-byte component is made up of bytes *b*0 , *b*1 , *b*2 , *b*3 , it is stored in memory as *b*3 , *b*2 , *b*1 , *b*0 if GL\_UNPACK\_SWAP\_BYTES is true. GL\_UNPACK\_SWAP\_BYTES has no effect on the memory order of components within a pixel, only on the order of bytes within components or indexes. For example, the three components of a GL\_RGB format pixel are always stored with red first, green second, and blue third, regardless of the value of GL\_UNPACK\_SWAP\_BYTES.                                                                                                                                                                                                                                                                                                                                                                                           |
     * | GL\_UNPACK\_LSB\_FIRST                                          | If true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one. This is significant for bitmap data only.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
     * | GL\_UNPACK\_ROW\_LENGTH                                         | If greater than zero, GL\_UNPACK\_ROW\_LENGTH defines the number of pixels in a row. If the first pixel of a row is placed at location p in memory, then the location of the first pixel of the next row is obtained by skipping ![Equation showing the location of the first pixel of the next row in GL_UNPACK_ROW_LENGTH.](images/pix01.png)\[newline\] components or indexes, where *n* is the number of components or indexes in a pixel, *l* is the number of pixels in a row (gl\-pack\-row\-length if it is greater than zero, the width argument to the pixel routine otherwise), *a* is the value of gl\-pack\-alignment, and *s* is the size, in bytes, of a single component (if *a* < *s*, then it is as if *a* = *s*). in the case of 1-bit values, the location of the next row is obtained by skipping ![Equation showing the location of the next row in GL_UNPACK_ROW_LENGTH.](images/pix02.png)<br/> components or indexes. The word *component* in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format GL\_RGB, for example, has three components per pixel: first red, then green, and finally blue.<br/> |
     * | GL\_UNPACK\_SKIP\_PIXELS and <br/> GL\_UNPACK\_SKIP\_ROWS | These values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated simply by incrementing the pointer passed to [**glDrawPixels**](gldrawpixels.md), [**glTexImage1D**](glteximage1d.md), [**glTexImage2D**](glteximage2d.md), [**glBitmap**](glbitmap.md), or [**glPolygonStipple**](glpolygonstipple.md). Setting GL\_UNPACK\_SKIP\_PIXELS to *i* is equivalent to incrementing the pointer by *i n* components or indexes, where *n* is the number of components or indexes in each pixel. Setting GL\_UNPACK\_SKIP\_ROWS to *j* is equivalent to incrementing the pointer by *j k* components or indexes, where *k* is the number of components or indexes per row, as computed above in the GL\_UNPACK\_ROW\_LENGTH section.                                                                                                                                                                                                                                    |
     * | GL\_UNPACK\_ALIGNMENT                                           | Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word alignment), and 8 (rows start on double-word boundaries).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
     * @param {Float} param1 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpixelstoref
     */
    static glPixelStoref(pname, param1) {
        DllCall("OPENGL32.dll\glPixelStoref", "uint", pname, "float", param1)
    }

    /**
     * Sets pixel storage modes. | glPixelStorei function (Gl.h)
     * @remarks
     * The **glPixelStore** function sets pixel storage modes that affect the operation of subsequent [**glDrawPixels**](gldrawpixels.md) and [**glReadPixels**](glreadpixels.md) as well as the unpacking of polygon stipple patterns (see [**glPolygonStipple**](glpolygonstipple.md)), bitmaps (see [**glBitmap**](glbitmap.md)), and texture patterns (see [**glTexImage1D**](glteximage1d.md), [**glTexImage2D**](glteximage2d.md), [**glTexSubImage1D**](gltexsubimage1d.md), and [**glTexSubImage2D**](gltexsubimage2d.md)).
     * 
     * The following table gives the type, initial value, and range of valid values for each of the storage parameters that can be set with **glPixelStore**.
     * 
     * 
     * 
     * | Pname                    | Type    | Initial Value | Valid Range   |
     * |--------------------------|---------|---------------|---------------|
     * | GL\_PACK\_SWAP\_BYTES    | Boolean | false         | true or false |
     * | GL\_PACK\_SWAP\_BYTES    | Boolean | false         | true or false |
     * | GL\_PACK\_ROW\_LENGTH    | integer | 0             | \[0,?)        |
     * | GL\_PACK\_SKIP\_ROWS     | integer | 0             | \[0,?)        |
     * | GL\_PACK\_SKIP\_PIXELS   | integer | 0             | \[0,?)        |
     * | GL\_PACK\_ALIGNMENT      | integer | 4             | 1, 2, 4, or 8 |
     * | GL\_UNPACK\_SWAP\_BYTES  | Boolean | false         | true or false |
     * | GL\_UNPACK\_LSB\_FIRST   | Boolean | false         | true or false |
     * | GL\_UNPACK\_ROW\_LENGTH  | integer | 0             | \[0,?)        |
     * | GL\_UNPACK\_SKIP\_ROWS   | integer | 0             | \[0,?)        |
     * | GL\_UNPACK\_SKIP\_PIXELS | integer | 0             | \[0,?)        |
     * | GL\_UNPACK\_ALIGNMENT    | integer | 4             | 1, 2, 4, or 8 |
     * 
     * 
     * 
     *  
     * 
     * The [**glPixelStoref**](glpixelstoref.md) function can be used to set any pixel store parameter. If the parameter type is Boolean, and if *param* is 0.0, then the parameter is false; otherwise it is set to true. If *pname* is an integer type parameter, then *param* is rounded to the nearest integer.
     * 
     * Likewise, the **glPixelStorei** function can also be used to set any of the pixel store parameters. Boolean parameters are set to false if *param* is 0 and true otherwise. The *param* parameter is converted to floating point before being assigned to real-valued parameters.
     * 
     * The pixel storage modes in effect when [**glDrawPixels**](gldrawpixels.md), [**glReadPixels**](glreadpixels.md), [**glTexImage1D**](glteximage1d.md), [**glTexImage2D**](glteximage2d.md), [**glBitmap**](glbitmap.md), or [**glPolygonStipple**](glpolygonstipple.md) is placed in a display list control the interpretation of memory data. The pixel storage modes in effect when a display list is executed are not significant.
     * 
     * The following functions retrieve information related to **glPixelStore**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_PACK\_SWAP\_BYTES
     * 
     * **glGet** with argument GL\_PACK\_LSB\_FIRST
     * 
     * **glGet** with argument GL\_PACK\_ROW\_LENGTH
     * 
     * **glGet** with argument GL\_PACK\_SKIP\_ROWS
     * 
     * **glGet** with argument GL\_PACK\_SKIP\_PIXELS
     * 
     * **glGet** with argument GL\_PACK\_ALIGNMENT
     * 
     * **glGet** with argument GL\_UNPACK\_SWAP\_BYTES
     * 
     * **glGet** with argument GL\_UNPACK\_LSB\_FIRST
     * 
     * **glGet** with argument GL\_UNPACK\_ROW\_LENGTH
     * 
     * **glGet** with argument GL\_UNPACK\_SKIP\_ROWS
     * 
     * **glGet** with argument GL\_UNPACK\_SKIP\_PIXELS
     * 
     * **glGet** with argument GL\_UNPACK\_ALIGNMENT
     * @param {Integer} pname The symbolic name of the parameter to be set. Six of the storage parameters affect how pixel data is returned to client memory, and are therefore significant only for [**glReadPixels**](glreadpixels.md) commands. They are as follows.
     * 
     * 
     * 
     * | Storage Parameter                                           | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
     * |-------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | GL\_PACK\_SWAP\_BYTES                                       | If true, byte ordering for multibyte color components, depth components, color indexes, or stencil indexes is reversed. That is, if a four-byte component is made up of bytes *b*0 , *b*1 , *b*2 , *b*3 , it is stored in memory as *b*3 , *b*2 , *b*1 , *b*0 if GL\_PACK\_SWAP\_BYTES is true. GL\_PACK\_SWAP\_BYTES has no effect on the memory order of components within a pixel, only on the order of bytes within components or indexes. For example, the three components of a GL\_RGB format pixel are always stored with red first, green second, and blue third, regardless of the value of GL\_PACK\_SWAP\_BYTES.                                                                                                                                                                                                                                                                                                                                                                                               |
     * | GL\_PACK\_LSB\_FIRST                                        | If true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one. This parameter is significant for bitmap data only.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
     * | GL\_PACK\_ROW\_LENGTH                                       | If greater than zero, GL\_PACK\_ROW\_LENGTH defines the number of pixels in a row. If the first pixel of a row is placed at location p in memory, then the location of the first pixel of the next row is obtained by skipping ![Equation showing the location of the first pixel of the next row in GL_PACK_ROW_LENGTH.](images/pix01.png)\[newline\] components or indexes, where *n* is the number of components or indexes in a pixel, *l* is the number of pixels in a row (gl\-pack\-row\-length if it is greater than zero, the width argument to the pixel routine otherwise), *a* is the value of gl\-pack\-alignment, and *s* is the size, in bytes, of a single component (if *a* < *s*, then it is as if *a* = *s*). in the case of 1-bit values, the location of the next row is obtained by skipping ![Equation showing the location of the next row in GL_PACK_ROW_LENGTH.](images/pix02.png)<br/> components or indexes. The word *component* in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format GL\_RGB, for example, has three components per pixel: first red, then green, and finally blue.<br/> |
     * | GL\_PACK\_SKIP\_PIXELS and <br/> GL\_PACK\_SKIP\_ROWS | These values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated simply by incrementing the pointer passed to [**glReadPixels**](glreadpixels.md). Setting GL\_PACK\_SKIP\_PIXELS to *i* is equivalent to incrementing the pointer by *i n* components or indexes, where *n* is the number of components or indexes in each pixel. Setting GL\_PACK\_SKIP\_ROWS to *j* is equivalent to incrementing the pointer by *j k* components or indexes, where *k* is the number of components or indexes per row, as computed above in the GL\_PACK\_ROW\_LENGTH section.                                                                                                                                                                                                                                                                                                                                                                                                   |
     * | GL\_PACK\_ALIGNMENT                                         | Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word alignment), and 8 (rows start on double-word boundaries).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
     * 
     * 
     * 
     *  
     * 
     * The other six storage parameters affect how pixel data is read from client memory. These values are significant for [**glDrawPixels**](gldrawpixels.md), [**glTexImage1D**](glteximage1d.md), [**glTexImage2D**](glteximage2d.md), [**glBitmap**](glbitmap.md), and [**glPolygonStipple**](glpolygonstipple.md). They are as follows:
     * 
     * 
     * 
     * | Storage Parameter                                               | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
     * |-----------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | GL\_UNPACK\_SWAP\_BYTES                                         | If true, byte ordering for multibyte color components, depth components, color indexes, or stencil indexes is reversed. That is, if a four-byte component is made up of bytes *b*0 , *b*1 , *b*2 , *b*3 , it is stored in memory as *b*3 , *b*2 , *b*1 , *b*0 if GL\_UNPACK\_SWAP\_BYTES is true. GL\_UNPACK\_SWAP\_BYTES has no effect on the memory order of components within a pixel, only on the order of bytes within components or indexes. For example, the three components of a GL\_RGB format pixel are always stored with red first, green second, and blue third, regardless of the value of GL\_UNPACK\_SWAP\_BYTES.                                                                                                                                                                                                                                                                                                                                                                                           |
     * | GL\_UNPACK\_LSB\_FIRST                                          | If true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one. This is significant for bitmap data only.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
     * | GL\_UNPACK\_ROW\_LENGTH                                         | If greater than zero, GL\_UNPACK\_ROW\_LENGTH defines the number of pixels in a row. If the first pixel of a row is placed at location p in memory, then the location of the first pixel of the next row is obtained by skipping ![Equation showing the location of the first pixel of the next row in GL_UNPACK_ROW_LENGTH.](images/pix01.png)\[newline\] components or indexes, where *n* is the number of components or indexes in a pixel, *l* is the number of pixels in a row (gl\-pack\-row\-length if it is greater than zero, the width argument to the pixel routine otherwise), *a* is the value of gl\-pack\-alignment, and *s* is the size, in bytes, of a single component (if *a* < *s*, then it is as if *a* = *s*). in the case of 1-bit values, the location of the next row is obtained by skipping ![Equation showing the location of the next row in GL_UNPACK_ROW_LENGTH.](images/pix02.png)<br/> components or indexes. The word *component* in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format GL\_RGB, for example, has three components per pixel: first red, then green, and finally blue.<br/> |
     * | GL\_UNPACK\_SKIP\_PIXELS and <br/> GL\_UNPACK\_SKIP\_ROWS | These values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated simply by incrementing the pointer passed to [**glDrawPixels**](gldrawpixels.md), [**glTexImage1D**](glteximage1d.md), [**glTexImage2D**](glteximage2d.md), [**glBitmap**](glbitmap.md), or [**glPolygonStipple**](glpolygonstipple.md). Setting GL\_UNPACK\_SKIP\_PIXELS to *i* is equivalent to incrementing the pointer by *i n* components or indexes, where *n* is the number of components or indexes in each pixel. Setting GL\_UNPACK\_SKIP\_ROWS to *j* is equivalent to incrementing the pointer by *j k* components or indexes, where *k* is the number of components or indexes per row, as computed above in the GL\_UNPACK\_ROW\_LENGTH section.                                                                                                                                                                                                                                    |
     * | GL\_UNPACK\_ALIGNMENT                                           | Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word alignment), and 8 (rows start on double-word boundaries).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
     * @param {Integer} param1 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpixelstorei
     */
    static glPixelStorei(pname, param1) {
        DllCall("OPENGL32.dll\glPixelStorei", "uint", pname, "int", param1)
    }

    /**
     * The glPixelTransferf and glPixelTransferi functions set pixel transfer modes. | glPixelTransferf function (Gl.h)
     * @remarks
     * The **glPixelTransfer** function sets pixel transfer modes that affect the operation of subsequent [**glCopyPixels**](glcopypixels.md), [**glCopyTexImage1D**](glcopyteximage1d.md), [**glCopyTexImage2D**](glcopyteximage2d.md), [**glCopyTexSubImage1D**](glcopytexsubimage1d.md), [**glCopyTexSubImage2D**](glcopytexsubimage2d.md), [**glDrawPixels**](gldrawpixels.md), [**glReadPixels**](glreadpixels.md), [**glTexImage1D**](glteximage1d.md), [**glTexImage2D**](glteximage2d.md), [**glTexSubImage1D**](gltexsubimage1d.md), and [**glTexSubImage2D**](gltexsubimage2d.md) commands. The algorithms that are specified by pixel transfer modes operate on pixels after they are read from the framebuffer (**glReadPixels** and **glCopyPixels**) or unpacked from client memory (**glDrawPixels**, **glTexImage1D**, and **glTexImage2D**). Pixel transfer operations happen in the same order, and in the same manner, regardless of the command that resulted in the pixel operation. Pixel storage modes ([**glPixelStore**](glpixelstore-functions.md)) control the unpacking of pixels being read from client memory, and the packing of pixels being written back into client memory.
     * 
     * Pixel transfer operations handle four fundamental pixel types: *color*, *color index*, *depth*, and *stencil*.Color pixels are made up of four floating-point values with unspecified mantissa and exponent sizes, scaled such that 0.0 represents zero intensity and 1.0 represents full intensity. Color indexes comprise a single fixed-point value, with unspecified precision to the right of the binary point. Depth pixels comprise a single floating-point value, with unspecified mantissa and exponent sizes, scaled such that 0.0 represents the minimum depth buffer value, and 1.0 represents the maximum depth buffer value. Finally, stencil pixels comprise a single fixed-point value, with unspecified precision to the right of the binary point.
     * 
     * The pixel transfer operations performed on the four basic pixel types are as follows:
     * 
     * 
     * 
     * | Pixel type  | Pixel transfer operation                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
     * |-------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | Color       | Each of the four color components is multiplied by a scale factor, and then added to a bias factor. That is, the red component is multiplied by GL\_RED\_SCALE, and then added to GL\_RED\_BIAS; the green component is multiplied by GL\_GREEN\_SCALE, and then added to GL\_GREEN\_BIAS; the blue component is multiplied by GL\_BLUE\_SCALE, and then added to GL\_BLUE\_BIAS; and the alpha component is multiplied by GL\_ALPHA\_SCALE, and then added to GL\_ALPHA\_BIAS. After all four color components are scaled and biased, each is clamped to the range \[0,1\]. All color scale and bias values are specified with **glPixelTransfer**. <br/> If GL\_MAP\_COLOR is true, each color component is scaled by the size of the corresponding color-to-color map, and then replaced by the contents of that map indexed by the scaled component. That is, the red component is scaled by GL\_PIXEL\_MAP\_R\_TO\_R\_SIZE, and then replaced by the contents of GL\_PIXEL\_MAP\_R\_TO\_R indexed by itself. The green component is scaled by GL\_PIXEL\_MAP\_G\_TO\_G\_SIZE, and then replaced by the contents of GL\_PIXEL\_MAP\_G\_TO\_G indexed by itself. The blue component is scaled by GL\_PIXEL\_MAP\_B\_TO\_B\_SIZE, and then replaced by the contents of GL\_PIXEL\_MAP\_B\_TO\_B indexed by itself. The alpha component is scaled by GL\_PIXEL\_MAP\_A\_TO\_A\_SIZE, and then replaced by the contents of GL\_PIXEL\_MAP\_A\_TO\_A indexed by itself. All components taken from the maps are then clamped to the range \[0,1\]. GL\_MAP\_COLOR is specified with **glPixelTransfer**. The contents of the various maps are specified with **glPixelMap**.<br/>                                                                                                                        |
     * | Color index | Each color index is shifted left by GL\_INDEX\_SHIFT bits, filling with zeros any bits beyond the number of fraction bits carried by the fixed-point index. If GL\_INDEX\_SHIFT is negative, the shift is to the right, again zero filled. GL\_INDEX\_OFFSET is then added to the index. GL\_INDEX\_SHIFT and GL\_INDEX\_OFFSET are specified with **glPixelTransfer**.<br/> From this point, operation diverges depending on the required format of the resulting pixels. If the resulting pixels are to be written to a color-index buffer, or if they are being read back to client memory in GL\_COLOR\_INDEX format, the pixels continue to be treated as indexes. If GL\_MAP\_COLOR is true, then each index is masked by 2 ^ *n* 1, where *n* is GL\_PIXEL\_MAP\_I\_TO\_I\_SIZE, and then replaced by the contents of GL\_PIXEL\_MAP\_I\_TO\_I indexed by the masked value. GL\_MAP\_COLOR is specified with **glPixelTransfer**. The contents of the index map are specified with **glPixelMap**.<br/> If the resulting pixels are to be written to an RGBA color buffer, or if they are being read back to client memory in a format other than GL\_COLOR\_INDEX, the pixels are converted from indexes to colors by referencing the four maps GL\_PIXEL\_MAP\_I\_TO\_R, GL\_PIXEL\_MAP\_I\_TO\_G, GL\_PIXEL\_MAP\_I\_TO\_B, and GL\_PIXEL\_MAP\_I\_TO\_A. Before being dereferenced, the index is masked by 2 n 1, where n is GL\_PIXEL\_MAP\_I\_TO\_R\_SIZE for the red map, GL\_PIXEL\_MAP\_I\_TO\_G\_SIZE for the green map, GL\_PIXEL\_MAP\_I\_TO\_B\_SIZE for the blue map, and GL\_PIXEL\_MAP\_I\_TO\_A\_SIZE for the alpha map. All components taken from the maps are then clamped to the range \[0,1\]. The contents of the four maps are specified with **glPixelMap**.<br/> |
     * | Depth       | Each depth value is multiplied by GL\_DEPTH\_SCALE, added to GL\_DEPTH\_BIAS, and then clamped to the range \[0,1\].                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
     * | Stencil     | Each index is shifted GL\_INDEX\_SHIFT bits just as a color index is, and then added to GL\_INDEX\_OFFSET. If GL\_MAP\_STENCIL is true, each index is masked by 2n 1, where *n* is GL\_PIXEL\_MAP\_S\_TO\_S\_SIZE, then replaced by the contents of GL\_PIXEL\_MAP\_S\_TO\_S indexed by the masked value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
     * 
     * 
     * 
     *  
     * 
     * The [**glPixelTransferf**](glpixeltransfer.md) function can be used to set any pixel transfer parameter. If the parameter type is Boolean, 0.0 implies false and any other value implies true. If *pname* is an integer parameter, *param* is rounded to the nearest integer.
     * 
     * Likewise, **glPixelTransferi** can also be used to set any of the pixel transfer parameters. Boolean parameters are set to false if *param* is 0 and true otherwise. The *param* parameter is converted to floating point before being assigned to real-valued parameters.
     * 
     * If a [**glDrawPixels**](gldrawpixels.md), [**glReadPixels**](glreadpixels.md), [**glCopyPixels**](glcopypixels.md), [**glTexImage1D**](glteximage1d.md), or [**glTexImage2D**](glteximage2d.md) command is placed in a display list (see [**glNewList**](glnewlist.md) and [**glCallList**](glcalllist.md)), the pixel transfer mode settings in effect when the display list is *executed* are the ones that are used. They may be different from the settings when the command was compiled into the display list.
     * 
     * The following functions retrieve information related to **glPixelTransfer**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP\_COLOR
     * 
     * **glGet** with argument GL\_MAP\_STENCIL
     * 
     * **glGet** with argument GL\_INDEX\_SHIFT
     * 
     * **glGet** with argument GL\_INDEX\_OFFSET
     * 
     * **glGet** with argument GL\_RED\_SCALE
     * 
     * **glGet** with argument GL\_RED\_BIAS
     * 
     * **glGet** with argument GL\_GREEN\_SCALE
     * 
     * **glGet** with argument GL\_GREEN\_BIAS
     * 
     * **glGet** with argument GL\_BLUE\_SCALE
     * 
     * **glGet** with argument GL\_BLUE\_BIAS
     * 
     * **glGet** with argument GL\_ALPHA\_SCALE
     * 
     * **glGet** with argument GL\_ALPHA\_BIAS
     * 
     * **glGet** with argument GL\_DEPTH\_SCALE
     * 
     * **glGet** with argument GL\_DEPTH\_BIAS
     * @param {Integer} pname The symbolic name of the pixel transfer parameter to be set. The following table gives the type, initial value, and range of valid values for each of the pixel transfer parameters that are set with **glPixelTransfer**.
     * 
     * 
     * 
     * | Pname             | Type    | Initial Value  | Valid Range  |
     * |-------------------|---------|----------------|--------------|
     * | GL\_MAP\_COLOR    | Boolean | false          | true/false   |
     * | GL\_MAP\_STENCIL  | Boolean | false          | true/false   |
     * | GL\_INDEX\_SHIFT  | integer | 0              | (8,8)        |
     * | GL\_INDEX\_OFFSET | integer | 0              | (8,8)        |
     * | GL\_RED\_SCALE    | integer | 1.0            | (8,8)        |
     * | GL\_GREEN\_SCALE  | float   | 1.0            | (8,8)        |
     * | GL\_BLUE\_SCALE   | float   | 1.0            | (8,8)        |
     * | GL\_ALPHA\_SCALE  | float   | 1.0            | (8,8)        |
     * | GL\_DEPTH\_SCALE  | float   | 1.0            | (8,8)        |
     * | GL\_RED\_BIAS     | float   | 0.0            | (8,8)        |
     * | GL\_GREEN\_BIAS   | float   | 0.0            | (8,8)        |
     * | GL\_BLUE\_BIAS    | float   | 0.0            | (8,8)        |
     * | GL\_ALPHA\_BIAS   | float   | 0.0            | (8,8)        |
     * | GL\_DEPTH\_BIAS   | float   | 0.0            | (8,8)        |
     * @param {Float} param1 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpixeltransferf
     */
    static glPixelTransferf(pname, param1) {
        DllCall("OPENGL32.dll\glPixelTransferf", "uint", pname, "float", param1)
    }

    /**
     * The glPixelTransferf and glPixelTransferi functions set pixel transfer modes. | glPixelTransferi function (Gl.h)
     * @remarks
     * The **glPixelTransfer** function sets pixel transfer modes that affect the operation of subsequent [**glCopyPixels**](glcopypixels.md), [**glCopyTexImage1D**](glcopyteximage1d.md), [**glCopyTexImage2D**](glcopyteximage2d.md), [**glCopyTexSubImage1D**](glcopytexsubimage1d.md), [**glCopyTexSubImage2D**](glcopytexsubimage2d.md), [**glDrawPixels**](gldrawpixels.md), [**glReadPixels**](glreadpixels.md), [**glTexImage1D**](glteximage1d.md), [**glTexImage2D**](glteximage2d.md), [**glTexSubImage1D**](gltexsubimage1d.md), and [**glTexSubImage2D**](gltexsubimage2d.md) commands. The algorithms that are specified by pixel transfer modes operate on pixels after they are read from the framebuffer (**glReadPixels** and **glCopyPixels**) or unpacked from client memory (**glDrawPixels**, **glTexImage1D**, and **glTexImage2D**). Pixel transfer operations happen in the same order, and in the same manner, regardless of the command that resulted in the pixel operation. Pixel storage modes ([**glPixelStore**](glpixelstore-functions.md)) control the unpacking of pixels being read from client memory, and the packing of pixels being written back into client memory.
     * 
     * Pixel transfer operations handle four fundamental pixel types: *color*, *color index*, *depth*, and *stencil*.Color pixels are made up of four floating-point values with unspecified mantissa and exponent sizes, scaled such that 0.0 represents zero intensity and 1.0 represents full intensity. Color indexes comprise a single fixed-point value, with unspecified precision to the right of the binary point. Depth pixels comprise a single floating-point value, with unspecified mantissa and exponent sizes, scaled such that 0.0 represents the minimum depth buffer value, and 1.0 represents the maximum depth buffer value. Finally, stencil pixels comprise a single fixed-point value, with unspecified precision to the right of the binary point.
     * 
     * The pixel transfer operations performed on the four basic pixel types are as follows:
     * 
     * 
     * 
     * | Pixel type  | Pixel transfer operation                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
     * |-------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | Color       | Each of the four color components is multiplied by a scale factor, and then added to a bias factor. That is, the red component is multiplied by GL\_RED\_SCALE, and then added to GL\_RED\_BIAS; the green component is multiplied by GL\_GREEN\_SCALE, and then added to GL\_GREEN\_BIAS; the blue component is multiplied by GL\_BLUE\_SCALE, and then added to GL\_BLUE\_BIAS; and the alpha component is multiplied by GL\_ALPHA\_SCALE, and then added to GL\_ALPHA\_BIAS. After all four color components are scaled and biased, each is clamped to the range \[0,1\]. All color scale and bias values are specified with **glPixelTransfer**. <br/> If GL\_MAP\_COLOR is true, each color component is scaled by the size of the corresponding color-to-color map, and then replaced by the contents of that map indexed by the scaled component. That is, the red component is scaled by GL\_PIXEL\_MAP\_R\_TO\_R\_SIZE, and then replaced by the contents of GL\_PIXEL\_MAP\_R\_TO\_R indexed by itself. The green component is scaled by GL\_PIXEL\_MAP\_G\_TO\_G\_SIZE, and then replaced by the contents of GL\_PIXEL\_MAP\_G\_TO\_G indexed by itself. The blue component is scaled by GL\_PIXEL\_MAP\_B\_TO\_B\_SIZE, and then replaced by the contents of GL\_PIXEL\_MAP\_B\_TO\_B indexed by itself. The alpha component is scaled by GL\_PIXEL\_MAP\_A\_TO\_A\_SIZE, and then replaced by the contents of GL\_PIXEL\_MAP\_A\_TO\_A indexed by itself. All components taken from the maps are then clamped to the range \[0,1\]. GL\_MAP\_COLOR is specified with **glPixelTransfer**. The contents of the various maps are specified with **glPixelMap**.<br/>                                                                                                                        |
     * | Color index | Each color index is shifted left by GL\_INDEX\_SHIFT bits, filling with zeros any bits beyond the number of fraction bits carried by the fixed-point index. If GL\_INDEX\_SHIFT is negative, the shift is to the right, again zero filled. GL\_INDEX\_OFFSET is then added to the index. GL\_INDEX\_SHIFT and GL\_INDEX\_OFFSET are specified with **glPixelTransfer**.<br/> From this point, operation diverges depending on the required format of the resulting pixels. If the resulting pixels are to be written to a color-index buffer, or if they are being read back to client memory in GL\_COLOR\_INDEX format, the pixels continue to be treated as indexes. If GL\_MAP\_COLOR is true, then each index is masked by 2 ^ *n* 1, where *n* is GL\_PIXEL\_MAP\_I\_TO\_I\_SIZE, and then replaced by the contents of GL\_PIXEL\_MAP\_I\_TO\_I indexed by the masked value. GL\_MAP\_COLOR is specified with **glPixelTransfer**. The contents of the index map are specified with **glPixelMap**.<br/> If the resulting pixels are to be written to an RGBA color buffer, or if they are being read back to client memory in a format other than GL\_COLOR\_INDEX, the pixels are converted from indexes to colors by referencing the four maps GL\_PIXEL\_MAP\_I\_TO\_R, GL\_PIXEL\_MAP\_I\_TO\_G, GL\_PIXEL\_MAP\_I\_TO\_B, and GL\_PIXEL\_MAP\_I\_TO\_A. Before being dereferenced, the index is masked by 2 n 1, where n is GL\_PIXEL\_MAP\_I\_TO\_R\_SIZE for the red map, GL\_PIXEL\_MAP\_I\_TO\_G\_SIZE for the green map, GL\_PIXEL\_MAP\_I\_TO\_B\_SIZE for the blue map, and GL\_PIXEL\_MAP\_I\_TO\_A\_SIZE for the alpha map. All components taken from the maps are then clamped to the range \[0,1\]. The contents of the four maps are specified with **glPixelMap**.<br/> |
     * | Depth       | Each depth value is multiplied by GL\_DEPTH\_SCALE, added to GL\_DEPTH\_BIAS, and then clamped to the range \[0,1\].                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
     * | Stencil     | Each index is shifted GL\_INDEX\_SHIFT bits just as a color index is, and then added to GL\_INDEX\_OFFSET. If GL\_MAP\_STENCIL is true, each index is masked by 2n 1, where *n* is GL\_PIXEL\_MAP\_S\_TO\_S\_SIZE, then replaced by the contents of GL\_PIXEL\_MAP\_S\_TO\_S indexed by the masked value.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
     * 
     * 
     * 
     *  
     * 
     * The [**glPixelTransferf**](glpixeltransfer.md) function can be used to set any pixel transfer parameter. If the parameter type is Boolean, 0.0 implies false and any other value implies true. If *pname* is an integer parameter, *param* is rounded to the nearest integer.
     * 
     * Likewise, **glPixelTransferi** can also be used to set any of the pixel transfer parameters. Boolean parameters are set to false if *param* is 0 and true otherwise. The *param* parameter is converted to floating point before being assigned to real-valued parameters.
     * 
     * If a [**glDrawPixels**](gldrawpixels.md), [**glReadPixels**](glreadpixels.md), [**glCopyPixels**](glcopypixels.md), [**glTexImage1D**](glteximage1d.md), or [**glTexImage2D**](glteximage2d.md) command is placed in a display list (see [**glNewList**](glnewlist.md) and [**glCallList**](glcalllist.md)), the pixel transfer mode settings in effect when the display list is *executed* are the ones that are used. They may be different from the settings when the command was compiled into the display list.
     * 
     * The following functions retrieve information related to **glPixelTransfer**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAP\_COLOR
     * 
     * **glGet** with argument GL\_MAP\_STENCIL
     * 
     * **glGet** with argument GL\_INDEX\_SHIFT
     * 
     * **glGet** with argument GL\_INDEX\_OFFSET
     * 
     * **glGet** with argument GL\_RED\_SCALE
     * 
     * **glGet** with argument GL\_RED\_BIAS
     * 
     * **glGet** with argument GL\_GREEN\_SCALE
     * 
     * **glGet** with argument GL\_GREEN\_BIAS
     * 
     * **glGet** with argument GL\_BLUE\_SCALE
     * 
     * **glGet** with argument GL\_BLUE\_BIAS
     * 
     * **glGet** with argument GL\_ALPHA\_SCALE
     * 
     * **glGet** with argument GL\_ALPHA\_BIAS
     * 
     * **glGet** with argument GL\_DEPTH\_SCALE
     * 
     * **glGet** with argument GL\_DEPTH\_BIAS
     * @param {Integer} pname The symbolic name of the pixel transfer parameter to be set. The following table gives the type, initial value, and range of valid values for each of the pixel transfer parameters that are set with **glPixelTransfer**.
     * 
     * 
     * 
     * | Pname             | Type    | Initial Value  | Valid Range  |
     * |-------------------|---------|----------------|--------------|
     * | GL\_MAP\_COLOR    | Boolean | false          | true/false   |
     * | GL\_MAP\_STENCIL  | Boolean | false          | true/false   |
     * | GL\_INDEX\_SHIFT  | integer | 0              | (8,8)        |
     * | GL\_INDEX\_OFFSET | integer | 0              | (8,8)        |
     * | GL\_RED\_SCALE    | integer | 1.0            | (8,8)        |
     * | GL\_GREEN\_SCALE  | float   | 1.0            | (8,8)        |
     * | GL\_BLUE\_SCALE   | float   | 1.0            | (8,8)        |
     * | GL\_ALPHA\_SCALE  | float   | 1.0            | (8,8)        |
     * | GL\_DEPTH\_SCALE  | float   | 1.0            | (8,8)        |
     * | GL\_RED\_BIAS     | float   | 0.0            | (8,8)        |
     * | GL\_GREEN\_BIAS   | float   | 0.0            | (8,8)        |
     * | GL\_BLUE\_BIAS    | float   | 0.0            | (8,8)        |
     * | GL\_ALPHA\_BIAS   | float   | 0.0            | (8,8)        |
     * | GL\_DEPTH\_BIAS   | float   | 0.0            | (8,8)        |
     * @param {Integer} param1 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpixeltransferi
     */
    static glPixelTransferi(pname, param1) {
        DllCall("OPENGL32.dll\glPixelTransferi", "uint", pname, "int", param1)
    }

    /**
     * The glPixelZoom function specifies the pixel zoom factors.
     * @remarks
     * The **glPixelZoom** function specifies values for the *x* and *y* zoom factors. During the execution of [**glDrawPixels**](gldrawpixels.md) or [**glCopyPixels**](glcopypixels.md), if (*x*<sub>r</sub> ,*y*<sub>r</sub> ) is the current raster position, and a given element is in the *n*th row and *m*th column of the pixel rectangle, then pixels whose centers are in the rectangle with corners at
     * 
     * ![Equation showing the locations where pixels are candidates for replacement.](images/pix05.png)
     * 
     * are candidates for replacement. Any pixel whose center lies on the bottom or left edge of this rectangular region is also modified.
     * 
     * Pixel zoom factors are not limited to positive values. Negative zoom factors reflect the resulting image about the current raster position.
     * 
     * The following functions retrieve information related to **glPixelZoom**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_ZOOM\_X
     * 
     * **glGet** with argument GL\_ZOOM\_Y
     * @param {Float} xfactor The *x* zoom factor for pixel write operations.
     * @param {Float} yfactor The *y* zoom factor for pixel write operations.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpixelzoom
     */
    static glPixelZoom(xfactor, yfactor) {
        DllCall("OPENGL32.dll\glPixelZoom", "float", xfactor, "float", yfactor)
    }

    /**
     * The glPointSize function specifies the diameter of rasterized points.
     * @remarks
     * The **glPointSize** function specifies the rasterized diameter of both aliased and antialiased points. Using a point size other than 1.0 has different effects, depending on whether point antialiasing is enabled. Point antialiasing is controlled by calling [**glEnable**](glenable.md) and **glDisable** with argument GL\_POINT\_SMOOTH.
     * 
     * If point antialiasing is disabled, the actual size is determined by rounding the supplied size to the nearest integer. (If the rounding results in the value 0, it is as if the point size were 1.) If the rounded size is odd, then the center point (*x*,*y*) of the pixel fragment that represents the point is computed as
     * 
     * (*x*<sub>w</sub> + .5, *y*<sub>w</sub> + .5)
     * 
     * where *w* subscripts indicate window coordinates. All pixels that lie within the square grid of the rounded size centered at (*x*,*y*) make up the fragment. If the size is even, the center point is
     * 
     * (*x*<sub>w</sub> + .5, *y*<sub>w</sub> + .5)
     * 
     * and the rasterized fragment's centers are the half-integer window coordinates within the square of the rounded size centered at (*x*,*y*). All pixel fragments produced in rasterizing a nonantialiased point are assigned the same associated data; that of the vertex corresponding to the point.
     * 
     * If antialiasing is enabled, then point rasterization produces a fragment for each pixel square that intersects the region lying within the circle having diameter equal to the current point size and centered at the points (*x*<sub>w</sub> ,*y*<sub>w</sub> ). The coverage value for each fragment is the window coordinate area of the intersection of the circular region with the corresponding pixel square. This value is saved and used in the final rasterization step. The data associated with each fragment is the data associated with the point being rasterized.
     * 
     * Not all sizes are supported when point antialiasing is enabled. If an unsupported size is requested, the nearest supported size is used. Only size 1.0 is guaranteed to be supported; others depend on the implementation. The range of supported sizes and the size difference between supported sizes within the range can be queried by calling [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with arguments GL\_POINT\_SIZE\_RANGE and GL\_POINT\_SIZE\_GRANULARITY.
     * 
     * The point size specified by **glPointSize** is always returned when GL\_POINT\_SIZE is queried. Clamping and rounding for aliased and antialiased points have no effect on the specified value.
     * 
     * Non-antialiased point size may be clamped to an implementation-dependent maximum. Although this maximum cannot be queried, it must be no less than the maximum value for antialiased points, rounded to the nearest integer value.
     * 
     * The following functions retrieve information related to **glPointSize**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_POINT\_SIZE
     * 
     * **glGet** with argument GL\_POINT\_SIZE\_RANGE
     * 
     * **glGet** with argument GL\_POINT\_SIZE\_GRANULARITY
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_POINT\_SMOOTH
     * @param {Float} size The diameter of rasterized points. The default is 1.0.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpointsize
     */
    static glPointSize(size) {
        DllCall("OPENGL32.dll\glPointSize", "float", size)
    }

    /**
     * The glPolygonMode function selects a polygon rasterization mode.
     * @remarks
     * The **glPolygonMode** function controls the interpretation of polygons for rasterization. The *face* parameter describes which polygons *mode* applies to: front-facing polygons (GL\_FRONT), back-facing polygons (GL\_BACK), or both (GL\_FRONT\_AND\_BACK). The polygon mode affects only the final rasterization of polygons. In particular, a polygon's vertices are lit and the polygon is clipped and possibly culled before these modes are applied.
     * 
     * To draw a surface with filled back-facing polygons and outlined front-facing polygons, call
     * 
     * **glPolygonMode**(GL\_FRONT, GL\_LINE);
     * 
     * Vertices are marked as boundary or nonboundary with an edge flag. Edge flags are generated internally by OpenGL when it decomposes polygons, and they can be set explicitly using [**glEdgeFlag**](gledgeflag-functions.md).
     * 
     * The following function retrieves information related to **glPolygonMode**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_POLYGON\_MODE
     * @param {Integer} face The polygons that *mode* applies to. Must be GL\_FRONT for front-facing polygons, GL\_BACK for back-facing polygons, or GL\_FRONT\_AND\_BACK for front- and back-facing polygons.
     * @param {Integer} mode The way polygons will be rasterized. The following modes are defined and can be specified in *mode*. The default is GL\_FILL for both front- and back-facing polygons.
     * 
     * 
     * 
     * | Value                                                                                                                                          | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                   |
     * |------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_POINT"></span><span id="gl_point"></span><dl> <dt>**GL\_POINT**</dt> </dl> | Polygon vertices that are marked as the start of a boundary edge are drawn as points. Point attributes such as GL\_POINT\_SIZE and GL\_POINT\_SMOOTH control the rasterization of the points. Polygon rasterization attributes other than GL\_POLYGON\_MODE have no effect.<br/>                                                                                                                                                    |
     * | <span id="GL_LINE"></span><span id="gl_line"></span><dl> <dt>**GL\_LINE**</dt> </dl>    | Boundary edges of the polygon are drawn as line segments. They are treated as connected line segments for line stippling; the line stipple counter and pattern are not reset between segments (see [**glLineStipple**](gllinestipple.md)). Line attributes such as GL\_LINE\_WIDTH and GL\_LINE\_SMOOTH control the rasterization of the lines. Polygon rasterization attributes other than GL\_POLYGON\_MODE have no effect.<br/> |
     * | <span id="GL_FILL"></span><span id="gl_fill"></span><dl> <dt>**GL\_FILL**</dt> </dl>    | The interior of the polygon is filled. Polygon attributes such as GL\_POLYGON\_STIPPLE and GL\_POLYGON\_SMOOTH control the rasterization of the polygon.<br/>                                                                                                                                                                                                                                                                       |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpolygonmode
     */
    static glPolygonMode(face, mode) {
        DllCall("OPENGL32.dll\glPolygonMode", "uint", face, "uint", mode)
    }

    /**
     * The glPolygonOffset function sets the scale and units OpenGL uses to calculate depth values.
     * @remarks
     * When GL\_POLYGON\_OFFSET is enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The value of the offset is *factor* \* ?z + r \**units*, where ?z is a measurement of the change in depth relative to the screen area of the polygon, and r is the smallest value that is guaranteed to produce a resolvable offset for a given implementation. The offset is added before the depth test is performed and before the value is written into the depth buffer.
     * 
     * The **glPolygonOffset** function is useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges.
     * 
     * The **glPolygonOffset** function has no effect on depth coordinates placed in the feedback buffer. It also has no effect on selection.
     * 
     * The following functions retrieve information related to **glPolygonOffset**:
     * 
     * -   [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_POLYGON\_OFFSET\_FACTOR
     * -   [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_POLYGON\_OFFSET\_UNITS
     * -   [**glIsEnabled**](glisenabled.md) with argument GL\_POLYGON\_OFFSET\_FILL
     * -   [**glIsEnabled**](glisenabled.md) with argument GL\_POLYGON\_OFFSET\_LINE
     * -   [**glIsEnabled**](glisenabled.md) with argument GL\_POLYGON\_OFFSET\_POINT
     * 
     * > [!Note]  
     * > The **glPolygonOffset** function is only available in OpenGl version 1.1 or greater.
     * @param {Float} factor Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is zero.
     * @param {Float} units Specifies a value that is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpolygonoffset
     */
    static glPolygonOffset(factor, units) {
        DllCall("OPENGL32.dll\glPolygonOffset", "float", factor, "float", units)
    }

    /**
     * The glPolygonStipple function sets the polygon stippling pattern.
     * @remarks
     * The **glPolygonStipple** function sets the polygon stippling pattern. Polygon stippling, like line stippling (see [**glLineStipple**](gllinestipple.md)), masks out certain fragments produced by rasterization, creating a pattern. Stippling is independent of polygon antialiasing.
     * 
     * The *mask* parameter is a pointer to a 32x32 stipple pattern that is stored in memory just like the pixel data supplied to **glDrawPixels** with *height* and *width* both equal to 32, a pixel *format* of GL\_COLOR\_INDEX, and data *type* of GL\_BITMAP. That is, the stipple pattern is represented as a 32x32 array of 1-bit color indexes packed in unsigned bytes. The [**glPixelStore**](glpixelstore-functions.md) function parameters, such as GL\_UNPACK\_SWAP\_BYTES and GL\_UNPACK\_LSB\_FIRST, affect the assembling of the bits into a stipple pattern. Pixel transfer operations (shift, offset, and pixel map) are not applied to the stipple image, however.
     * 
     * Polygon stippling is enabled and disabled with [**glEnable**](glenable.md) and **glDisable**, using argument GL\_POLYGON\_STIPPLE. If enabled, a rasterized polygon fragment with window coordinates *x*<sub>w</sub> and *y*<sub>w</sub> is sent to the next stage of OpenGL if and only if the (*x*<sub>w</sub> mod 32)th bit in the (*y*<sub>w</sub> mod 32)th row of the stipple pattern is one. When polygon stippling is disabled, it is as if the stipple pattern were all ones.
     * 
     * The following functions retrieve information related to **glPolygonStipple**:
     * 
     * [**glGetPolygonStipple**](glgetpolygonstipple.md)
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_POLYGON\_STIPPLE
     * @param {Pointer<Byte>} mask A pointer to a 32x32 stipple pattern that will be unpacked from memory in the same way that [**glDrawPixels**](gldrawpixels.md) unpacks pixels.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpolygonstipple
     */
    static glPolygonStipple(mask) {
        DllCall("OPENGL32.dll\glPolygonStipple", "ptr", mask)
    }

    /**
     * Pops the attribute stack.
     * @remarks
     * The [**glPushAttrib**](glpushattrib.md) function takes one argument, a mask that indicates which groups of state variables to save on the attribute stack. Symbolic constants are used to set bits in the mask. The mask parameter is typically constructed by **OR**ing several of these constants together. The special mask GL\_ALL\_ATTRIB\_BITS can be used to save all stackable states.
     * 
     * The **glPopAttrib** function restores the values of the state variables saved with the last [**glPushAttrib**](glpushattrib.md) command. Those not saved are left unchanged.
     * 
     * It is an error to push attributes onto a full stack, or to pop attributes off an empty stack. In either case, the error flag is set and no other change is made to the OpenGL state.
     * 
     * Initially, the attribute stack is empty.
     * 
     * Not all values for the OpenGL state can be saved on the attribute stack. For example, pixel pack and unpack state, render mode state, and select and feedback state cannot be saved.
     * 
     * The depth of the attribute stack depends on the implementation, but it must be at least 16.
     * 
     * The following functions retrieve information related to [**glPushAttrib**](glpushattrib.md) and **glPopAttrib**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_ATTRIB\_STACK\_DEPTH
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAX\_ATTRIB\_STACK\_DEPTH
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpopattrib
     */
    static glPopAttrib() {
        DllCall("OPENGL32.dll\glPopAttrib")
    }

    /**
     * The glPushClientAttrib and glPopClientAttrib functions save and restore groups of client-state variables on the client-attribute stack. | glPopClientAttrib function (Gl.h)
     * @remarks
     * The **glPushClientAttrib** function uses its mask parameter to determine which groups of client-state variables are saved on the client-attribute stack. You can use the bitwise OR operator to join together accepted symbolic constants to set bits and construct a mask.
     * 
     * The **glPopClientAttrib** function restores the values of the client-state variables last saved with **glPushclientAttrib**. Client-state variables not previously saved are left unchanged. Pushing attributes onto a full client-attribute stack or popping attributes off an empty stack sets an error flag and no other change is made to the OpenGL state. By default the client attribute stack is empty.
     * 
     * Some OpenGL client-state values cannot be saved on the client-attribute stack. For example, you cannot save the select or feedback states on the client-attribute stack. The depth of the client-attribute stack is at least 16.
     * 
     * The **glPushclientAttrib** and **glPopClientAttrib** functions are not compiled into display lists, but are executed immediately.
     * 
     * The **glPushClientAttrib** and **glPopClientAttrib** functions can only push and pop pixel storage modes and vertex array client states. You must use [**glPushAttrib**](glpushattrib.md) and [**glPopAttrib**](glpopattrib.md) to push and pop states that are kept on the server.
     * 
     * > [!Note]  
     * > The **glPushClientAttrib** and **glPopClientAttrib** functions are only available in OpenGL version 1.1 or later.
     * 
     *  
     * 
     * The following functions retrieve information related to **glPushClientAttrib** and **glPopClientAttrib**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CLIENT\_ATTRIB\_STACK\_DEPTH
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAX\_CLIENT\_ATTRIB\_STACK\_DEPTH
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpopclientattrib
     */
    static glPopClientAttrib() {
        DllCall("OPENGL32.dll\glPopClientAttrib")
    }

    /**
     * The glPushMatrix and glPopMatrix functions push and pop the current matrix stack. | glPopMatrix function (Gl.h)
     * @remarks
     * There is a stack of matrices for each of the matrix modes. In GL\_MODELVIEW mode, the stack depth is at least 32. In the other two modes, GL\_PROJECTION and GL\_TEXTURE, the depth is at least 2. The current matrix in any mode is the matrix on the top of the stack for that mode.
     * 
     * The [**glPushMatrix**](glpushmatrix.md) function pushes the current matrix stack down by one, duplicating the current matrix. That is, after a **glPushMatrix** call, the matrix on the top of the stack is identical to the one below it. The **glPopMatrix** function pops the current matrix stack, replacing the current matrix with the one below it on the stack. Initially, each of the stacks contains one matrix, an identity matrix.
     * 
     * The following functions retrieve information related to [**glPushMatrix**](glpushmatrix.md) and **glPopMatrix**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * 
     * **glGet** with argument GL\_MODELVIEW\_MATRIX
     * 
     * **glGet** with argument GL\_PROJECTION\_MATRIX
     * 
     * **glGet** with argument GL\_TEXTURE\_MATRIX
     * 
     * **glGet** with argument GL\_MODELVIEW\_STACK\_DEPTH
     * 
     * **glGet** with argument GL\_PROJECTION\_STACK\_DEPTH
     * 
     * **glGet** with argument GL\_TEXTURE\_STACK\_DEPTH
     * 
     * **glGet** with argument GL\_MAX\_MODELVIEW\_STACK\_DEPTH
     * 
     * **glGet** with argument GL\_MAX\_PROJECTION\_STACK\_DEPTH
     * 
     * **glGet** with argument GL\_MAX\_TEXTURE\_STACK\_DEPTH
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpopmatrix
     */
    static glPopMatrix() {
        DllCall("OPENGL32.dll\glPopMatrix")
    }

    /**
     * The glPushName and glPopName functions push and pop the name stack. | glPopName function (Gl.h)
     * @remarks
     * The [**glPushName**](glpushname.md) function causes name to be pushed onto the name stack, which is initially empty. The **glPopName** function pops one name off the top of the stack. The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It consists of an ordered set of unsigned integers.
     * 
     * The name stack is always empty while the render mode is not GL\_SELECT. Calls to [**glPushName**](glpushname.md) or **glPopName** while the render mode is not GL\_SELECT are ignored.
     * 
     * The following functions retrieve information related to [**glPushName**](glpushname.md) and **glPopName**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_NAME\_STACK\_DEPTH
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAX\_NAME\_STACK\_DEPTH
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpopname
     */
    static glPopName() {
        DllCall("OPENGL32.dll\glPopName")
    }

    /**
     * The glPrioritizeTextures function sets the residence priority of textures.
     * @remarks
     * The **glPrioritizeTextures** function assigns the *n* texture priorities specified in the *priorities* parameter to the *n* textures named in the *textures* parameter. On computers with a limited amount of texture memory, OpenGL establishes a "working set" of textures that are resident in texture memory. These textures can be bound to a texture target much more efficiently than textures that are not resident.
     * 
     * By specifying a priority for each texture, the **glPrioritizeTextures** function enables you to determine which textures should be resident.
     * 
     * The texture priorities elements in *priorities* are clamped to the range \[0.0, 1.0\] before being assigned. Zero indicates the lowest priority; thus textures with priority zero are least likely to be resident. The value 1.0 indicates the highest priority; thus textures with priority 1.0 are most likely to be resident. However, textures are not guaranteed to be resident until they are bound.
     * 
     * The **glPrioritizeTextures** function ignores attempts to prioritize texture 0, or any texture name that does not correspond to an existing texture. None of the functions named by the *textures* parameter need to be bound to a texture target.
     * 
     * If a texture is currently bound, you can also use the [**glTexParameter**](gltexparameter-functions.md) function to set its priority. This is the only way to set the priority of a default texture.
     * 
     * You can include **glPrioritizeTextures** in display lists.
     * 
     * The following function retrieves the priority of a currently-bound texture related to **glPrioritizeTextures**:
     * 
     * -   [**glGetTexParameter**](glgettexparameter.md) with parameter name GL\_TEXTURE\_PRIORITY
     * 
     * > [!Note]  
     * > The **glPrioritizeTextures** function is only available in OpenGL version 1.1 or later.
     * @param {Integer} n The number of textures to be prioritized.
     * @param {Pointer<UInt32>} textures A pointer to the first element of an array containing the names of the textures to be prioritized.
     * @param {Pointer<Single>} priorities A pointer to the first element of an array containing the texture priorities. A priority given in an element of the *priorities* parameter applies to the texture named by the corresponding element of the *textures* parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glprioritizetextures
     */
    static glPrioritizeTextures(n, textures, priorities) {
        DllCall("OPENGL32.dll\glPrioritizeTextures", "int", n, "ptr", textures, "ptr", priorities)
    }

    /**
     * Pushes the attribute stack.
     * @remarks
     * The **glPushAttrib** function takes one argument, a mask that indicates which groups of state variables to save on the attribute stack. Symbolic constants are used to set bits in the mask. The mask parameter is typically constructed by applying the logical **OR** operation to several of these constants. You can use the special mask GL\_ALL\_ATTRIB\_BITS to save all stackable states.
     * 
     * The [**glPopAttrib**](glpopattrib.md) function restores the values of the state variables saved with the last **glPushAttrib** command. Those not saved are left unchanged.
     * 
     * It is an error to push attributes onto a full stack, or to pop attributes off an empty stack. In either case, the error flag is set and no other change is made to the OpenGL state.
     * 
     * Initially, the attribute stack is empty.
     * 
     * Not all values for the OpenGL state can be saved on the attribute stack. For example, you cannot save pixel pack and unpack state, render mode state, and select and feedback state.
     * 
     * The depth of the attribute stack depends on the implementation, but it must be at least 16.
     * 
     * The following functions retrieve information related to **glPushAttrib** and [**glPopAttrib**](glpopattrib.md):
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_ATTRIB\_STACK\_DEPTH
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAX\_ATTRIB\_STACK\_DEPTH
     * @param {Integer} mask A mask that indicates which attributes to save. The symbolic mask constants and their associated OpenGL state are as follows (the indented paragraphs list which attributes are saved):
     * 
     * 
     * <span id="GL_ACCUM_BUFFER_BIT_"></span><span id="gl_accum_buffer_bit_"></span>GL\_ACCUM\_BUFFER\_BIT 
     * 
     * Accumulation buffer clear value
     * 
     * 
     * <span id="GL_COLOR_BUFFER_BIT"></span><span id="gl_color_buffer_bit"></span>GL\_COLOR\_BUFFER\_BIT
     * 
     * GL\_ALPHA\_TEST enable bit
     * 
     * Alpha test function and reference value
     * 
     * GL\_BLEND enable bit
     * 
     * Blending source and destination functions
     * 
     * GL\_DITHER enable bit
     * 
     * GL\_DRAW\_BUFFER setting
     * 
     * GL\_LOGIC\_OP enable bit
     * 
     * Logic op function
     * 
     * Color-mode and index-mode clear values
     * 
     * Color-mode and index-mode writemasks
     * 
     * 
     * <span id="GL_CURRENT_BIT"></span><span id="gl_current_bit"></span>GL\_CURRENT\_BIT
     * 
     * Current RGBA color
     * 
     * Current color index
     * 
     * Current normal vector
     * 
     * Current texture coordinates
     * 
     * Current raster position GL\_CURRENT\_RASTER\_POSITION\_VALID flag
     * 
     * RGBA color associated with current raster position
     * 
     * Color index associated with current raster position
     * 
     * Texture coordinates associated with current raster position
     * 
     * GL\_EDGE\_FLAG flag
     * 
     * 
     * <span id="GL_DEPTH_BUFFER_BIT"></span><span id="gl_depth_buffer_bit"></span>GL\_DEPTH\_BUFFER\_BIT
     * 
     * GL\_DEPTH\_TEST enable bit
     * 
     * Depth buffer test function
     * 
     * Depth buffer clear value
     * 
     * GL\_DEPTH\_WRITEMASK enable bit
     * 
     * 
     * <span id="GL_ENABLE_BIT"></span><span id="gl_enable_bit"></span>GL\_ENABLE\_BIT
     * 
     * GL\_ALPHA\_TEST flag
     * 
     * GL\_AUTO\_NORMAL flag
     * 
     * GL\_BLEND flag
     * 
     * Enable bits for the user-definable clipping planes
     * 
     * GL\_COLOR\_MATERIAL
     * 
     * GL\_CULL\_FACE flag
     * 
     * GL\_DEPTH\_TEST flag
     * 
     * GL\_DITHER flag
     * 
     * GL\_FOG flag
     * 
     * GL\_LIGHT*i* where 0 <= *i* < GL\_MAX\_LIGHTS
     * 
     * GL\_LIGHTING flag
     * 
     * GL\_LINE\_SMOOTH flag
     * 
     * GL\_LINE\_STIPPLE flag
     * 
     * GL\_COLOR\_LOGIC\_OP flag
     * 
     * GL\_INDEX\_LOGIC\_OP flag
     * 
     * GL\_MAP1\_x where x is a map type
     * 
     * GL\_MAP2\_x where x is a map type
     * 
     * GL\_NORMALIZE flag
     * 
     * GL\_POINT\_SMOOTH flag
     * 
     * GL\_POLYGON\_OFFSET\_LINE flag
     * 
     * GL\_POLYGON\_OFFSET\_FILL flag
     * 
     * GL\_POLYGON\_OFFSET\_POINT flag
     * 
     * GL\_POLYGON\_SMOOTH flag
     * 
     * GL\_POLYGON\_STIPPLE flag
     * 
     * GL\_SCISSOR\_TEST flag
     * 
     * GL\_STENCIL\_TEST flag
     * 
     * GL\_TEXTURE\_1D flag
     * 
     * GL\_TEXTURE\_2D flag
     * 
     * Flags GL\_TEXTURE\_GEN\_x where x is S, T, R, or Q
     * 
     * 
     * <span id="GL_EVAL_BIT"></span><span id="gl_eval_bit"></span>GL\_EVAL\_BIT
     * 
     * GL\_MAP1\_x enable bits, where x is a map type
     * 
     * GL\_MAP2\_x enable bits, where x is a map type
     * 
     * 1-D grid endpoints and divisions
     * 
     * 2-D grid endpoints and divisions
     * 
     * GL\_AUTO\_NORMAL enable bit
     * 
     * 
     * <span id="GL_FOG_BIT"></span><span id="gl_fog_bit"></span>GL\_FOG\_BIT
     * 
     * GL\_FOG enable flag
     * 
     * Fog color
     * 
     * Fog density
     * 
     * Linear fog start
     * 
     * Linear fog end
     * 
     * Fog index
     * 
     * GL\_FOG\_MODE value
     * 
     * 
     * <span id="GL_HINT_BIT"></span><span id="gl_hint_bit"></span>GL\_HINT\_BIT
     * 
     * GL\_PERSPECTIVE\_CORRECTION\_HINT setting
     * 
     * GL\_POINT\_SMOOTH\_HINT setting
     * 
     * GL\_LINE\_SMOOTH\_HINT setting
     * 
     * GL\_POLYGON\_SMOOTH\_HINT setting
     * 
     * GL\_FOG\_HINT setting
     * 
     * 
     * <span id="GL_LIGHTING_BIT"></span><span id="gl_lighting_bit"></span>GL\_LIGHTING\_BIT
     * 
     * GL\_COLOR\_MATERIAL enable bit
     * 
     * GL\_COLOR\_MATERIAL\_FACE value
     * 
     * Color material parameters that are tracking the current color
     * 
     * Ambient scene color
     * 
     * GL\_LIGHT\_MODEL\_LOCAL\_VIEWER value
     * 
     * GL\_LIGHT\_MODEL\_TWO\_SIDE setting
     * 
     * GL\_LIGHTING enable bit
     * 
     * Enable bit for each light
     * 
     * Ambient, diffuse, and specular intensity for each light
     * 
     * Direction, position, exponent, and cutoff angle for each light
     * 
     * Constant, linear, and quadratic attenuation factors for each light
     * 
     * Ambient, diffuse, specular, and emissive color for each material
     * 
     * Ambient, diffuse, and specular color indexes for each material
     * 
     * Specular exponent for each material GL\_SHADE\_MODEL setting
     * 
     * 
     * <span id="GL_LINE_BIT_"></span><span id="gl_line_bit_"></span>GL\_LINE\_BIT 
     * 
     * GL\_LINE\_SMOOTH flag
     * 
     * GL\_LINE\_STIPPLE enable bit
     * 
     * Line stipple pattern and repeat counter
     * 
     * Line width
     * 
     * 
     * <span id="GL_LIST_BIT"></span><span id="gl_list_bit"></span>GL\_LIST\_BIT
     * 
     * GL\_LIST\_BASE setting
     * 
     * 
     * <span id="GL_PIXEL_MODE_BIT"></span><span id="gl_pixel_mode_bit"></span>GL\_PIXEL\_MODE\_BIT
     * 
     * GL\_RED\_BIAS and GL\_RED\_SCALE settings
     * 
     * GL\_GREEN\_BIAS and GL\_GREEN\_SCALE values
     * 
     * GL\_BLUE\_BIAS and GL\_BLUE\_SCALE
     * 
     * GL\_ALPHA\_BIAS and GL\_ALPHA\_SCALE
     * 
     * GL\_DEPTH\_BIAS and GL\_DEPTH\_SCALE
     * 
     * GL\_INDEX\_OFFSET and GL\_INDEX\_SHIFT values
     * 
     * GL\_MAP\_COLOR and GL\_MAP\_STENCIL flags
     * 
     * GL\_ZOOM\_X and GL\_ZOOM\_Y factors
     * 
     * GL\_READ\_BUFFER setting
     * 
     * 
     * <span id="GL_POINT_BIT"></span><span id="gl_point_bit"></span>GL\_POINT\_BIT
     * 
     * GL\_POINT\_SMOOTH flag
     * 
     * Point size
     * 
     * 
     * <span id="GL_POLYGON_BIT"></span><span id="gl_polygon_bit"></span>GL\_POLYGON\_BIT
     * 
     * GL\_CULL\_FACE enable bit
     * 
     * GL\_CULL\_FACE\_MODE value
     * 
     * GL\_FRONT\_FACE indicator
     * 
     * GL\_POLYGON\_MODE setting
     * 
     * GL\_POLYGON\_SMOOTH flag
     * 
     * GL\_POLYGON\_STIPPLE enable bit
     * 
     * GL\_POLYGON\_OFFSET\_FILL flag
     * 
     * GL\_POLYGON\_OFFSET\_LINE flag
     * 
     * GL\_POLYGON\_OFFSET\_POINT flag
     * 
     * GL\_POLYGON\_OFFSET\_FACTOR
     * 
     * GL\_POLYGON\_OFFSET\_UNITS
     * 
     * 
     * <span id="GL_POLYGON_STIPPLE_BIT"></span><span id="gl_polygon_stipple_bit"></span>GL\_POLYGON\_STIPPLE\_BIT
     * 
     * Polygon stipple image
     * 
     * 
     * <span id="GL_SCISSOR_BIT"></span><span id="gl_scissor_bit"></span>GL\_SCISSOR\_BIT
     * 
     * GL\_SCISSOR\_TEST flag
     * 
     * Scissor box
     * 
     * 
     * <span id="GL_STENCIL_BUFFER_BIT"></span><span id="gl_stencil_buffer_bit"></span>GL\_STENCIL\_BUFFER\_BIT
     * 
     * GL\_STENCIL\_TEST enable bit
     * 
     * Stencil function and reference value
     * 
     * Stencil value mask
     * 
     * Stencil fail, pass, and depth buffer pass actions
     * 
     * Stencil buffer clear value
     * 
     * Stencil buffer writemask
     * 
     * 
     * <span id="GL_TEXTURE_BIT"></span><span id="gl_texture_bit"></span>GL\_TEXTURE\_BIT
     * 
     * Enable bits for the four texture coordinates
     * 
     * Border color for each texture image
     * 
     * Minification function for each texture image
     * 
     * Magnification function for each texture image
     * 
     * Texture coordinates and wrap mode for each texture image
     * 
     * Color and mode for each texture environment
     * 
     * Enable bits GL\_TEXTURE\_GEN\_*x*; *x* is S, T, R, and Q
     * 
     * GL\_TEXTURE\_GEN\_MODE setting for S, T, R, and Q
     * 
     * glTexGen plane equations for S, T, R, and Q
     * 
     * 
     * <span id="GL_TRANSFORM_BIT"></span><span id="gl_transform_bit"></span>GL\_TRANSFORM\_BIT
     * 
     * Coefficients of the six clipping planes
     * 
     * Enable bits for the user-definable clipping planes
     * 
     * GL\_MATRIX\_MODE value
     * 
     * GL\_NORMALIZE flag
     * 
     * 
     * <span id="GL_VIEWPORT_BIT"></span><span id="gl_viewport_bit"></span>GL\_VIEWPORT\_BIT
     * 
     * Depth range (near and far)
     * 
     * Viewport origin and extent
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpushattrib
     */
    static glPushAttrib(mask) {
        DllCall("OPENGL32.dll\glPushAttrib", "uint", mask)
    }

    /**
     * The glPushClientAttrib and glPopClientAttrib functions save and restore groups of client-state variables on the client-attribute stack. | glPushClientAttrib function (Gl.h)
     * @remarks
     * The **glPushClientAttrib** function uses its mask parameter to determine which groups of client-state variables are saved on the client-attribute stack. You can use the bitwise OR operator to join together accepted symbolic constants to set bits and construct a mask.
     * 
     * The [**glPopClientAttrib**](glpopclientattrib.md) function restores the values of the client-state variables last saved with **glPushclientAttrib**. Client-state variables not previously saved are left unchanged. Pushing attributes onto a full client-attribute stack or popping attributes off an empty stack sets an error flag and no other change is made to the OpenGL state. By default the client attribute stack is empty.
     * 
     * Some OpenGL client-state values cannot be saved on the client-attribute stack. For example, you cannot save the select or feedback states on the client-attribute stack. The depth of the client-attribute stack is at least 16.
     * 
     * The **glPushclientAttrib** and **glPopClientAttrib** functions are not compiled into display lists, but are executed immediately.
     * 
     * The **glPushClientAttrib** and **glPopClientAttrib** functions can only push and pop pixel storage modes and vertex array client states. You must use [**glPushAttrib**](glpushattrib.md) and [**glPopAttrib**](glpopattrib.md) to push and pop states that are kept on the server.
     * 
     * > [!Note]  
     * > The **glPushClientAttrib** and **glPopClientAttrib** functions are only available in OpenGL version 1.1 or later.
     * 
     *  
     * 
     * The following functions retrieve information related to **glPushClientAttrib** and **glPopClientAttrib**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CLIENT\_ATTRIB\_STACK\_DEPTH
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAX\_CLIENT\_ATTRIB\_STACK\_DEPTH
     * @param {Integer} mask A mask that indicates which attributes to save. The following are the symbolic mask constants and their associated OpenGL client states.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                                                            | Meaning                                           |
     * |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------|
     * | <span id="GL_CLIENT_PIXEL_STORE_BIT"></span><span id="gl_client_pixel_store_bit"></span><dl> <dt>**GL\_CLIENT\_PIXEL\_STORE\_BIT**</dt> </dl>                                             | Pixel storage mode attributes.<br/>         |
     * | <span id="GL_CLIENT_VERTEX_ARRAY_BIT"></span><span id="gl_client_vertex_array_bit"></span><dl> <dt>**GL\_CLIENT\_VERTEX\_ARRAY\_BIT**</dt> </dl>                                          | Vertex array attributes.<br/>               |
     * | <span id="GL_CLIENT_ALL_ATTRIB_BITs"></span><span id="gl_client_all_attrib_bits"></span><span id="GL_CLIENT_ALL_ATTRIB_BITS"></span><dl> <dt>**GL\_CLIENT\_ALL\_ATTRIB\_BITs**</dt> </dl> | all stackable client-state attributes.<br/> |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpushclientattrib
     */
    static glPushClientAttrib(mask) {
        DllCall("OPENGL32.dll\glPushClientAttrib", "uint", mask)
    }

    /**
     * The glPushMatrix and glPopMatrix functions push and pop the current matrix stack. | glPushMatrix function (Gl.h)
     * @remarks
     * There is a stack of matrices for each of the matrix modes. In GL\_MODELVIEW mode, the stack depth is at least 32. In the other two modes, GL\_PROJECTION and GL\_TEXTURE, the depth is at least 2. The current matrix in any mode is the matrix on the top of the stack for that mode.
     * 
     * The **glPushMatrix** function pushes the current matrix stack down by one, duplicating the current matrix. That is, after a **glPushMatrix** call, the matrix on the top of the stack is identical to the one below it. The **glPopMatrix** function pops the current matrix stack, replacing the current matrix with the one below it on the stack. Initially, each of the stacks contains one matrix, an identity matrix.
     * 
     * The following functions retrieve information related to **glPushMatrix** and **glPopMatrix**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * 
     * **glGet** with argument GL\_MODELVIEW\_MATRIX
     * 
     * **glGet** with argument GL\_PROJECTION\_MATRIX
     * 
     * **glGet** with argument GL\_TEXTURE\_MATRIX
     * 
     * **glGet** with argument GL\_MODELVIEW\_STACK\_DEPTH
     * 
     * **glGet** with argument GL\_PROJECTION\_STACK\_DEPTH
     * 
     * **glGet** with argument GL\_TEXTURE\_STACK\_DEPTH
     * 
     * **glGet** with argument GL\_MAX\_MODELVIEW\_STACK\_DEPTH
     * 
     * **glGet** with argument GL\_MAX\_PROJECTION\_STACK\_DEPTH
     * 
     * **glGet** with argument GL\_MAX\_TEXTURE\_STACK\_DEPTH
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpushmatrix
     */
    static glPushMatrix() {
        DllCall("OPENGL32.dll\glPushMatrix")
    }

    /**
     * The glPushName and glPopName functions push and pop the name stack. | glPushName function (Gl.h)
     * @remarks
     * The **glPushName** function causes name to be pushed onto the name stack, which is initially empty. The [**glPopName**](glpopname.md) function pops one name off the top of the stack. The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It consists of an ordered set of unsigned integers.
     * 
     * The name stack is always empty while the render mode is not GL\_SELECT. Calls to **glPushName** or [**glPopName**](glpopname.md) while the render mode is not GL\_SELECT are ignored.
     * 
     * The following functions retrieve information related to **glPushName** and [**glPopName**](glpopname.md):
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_NAME\_STACK\_DEPTH
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MAX\_NAME\_STACK\_DEPTH
     * @param {Integer} name A name that will be pushed onto the name stack.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glpushname
     */
    static glPushName(name) {
        DllCall("OPENGL32.dll\glPushName", "uint", name)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos2d function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Float} x Specifies the x-coordinate for the current raster position.
     * @param {Float} y Specifies the y-coordinate for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos2d
     */
    static glRasterPos2d(x, y) {
        DllCall("OPENGL32.dll\glRasterPos2d", "double", x, "double", y)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos2dv function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Pointer<Double>} v A pointer to an array of two elements, specifying x and y coordinates for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos2dv
     */
    static glRasterPos2dv(v) {
        DllCall("OPENGL32.dll\glRasterPos2dv", "ptr", v)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos2f function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Float} x Specifies the x-coordinate for the current raster position.
     * @param {Float} y Specifies the y-coordinate for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos2f
     */
    static glRasterPos2f(x, y) {
        DllCall("OPENGL32.dll\glRasterPos2f", "float", x, "float", y)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos2fv function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Pointer<Single>} v A pointer to an array of two elements, specifying x and y coordinates for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos2fv
     */
    static glRasterPos2fv(v) {
        DllCall("OPENGL32.dll\glRasterPos2fv", "ptr", v)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos2i function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Integer} x Specifies the x-coordinate for the current raster position.
     * @param {Integer} y Specifies the y-coordinate for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos2i
     */
    static glRasterPos2i(x, y) {
        DllCall("OPENGL32.dll\glRasterPos2i", "int", x, "int", y)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos2iv function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Pointer<Int32>} v A pointer to an array of two elements, specifying x and y coordinates for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos2iv
     */
    static glRasterPos2iv(v) {
        DllCall("OPENGL32.dll\glRasterPos2iv", "ptr", v)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos2s function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Integer} x Specifies the x-coordinate for the current raster position.
     * @param {Integer} y Specifies the y-coordinate for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos2s
     */
    static glRasterPos2s(x, y) {
        DllCall("OPENGL32.dll\glRasterPos2s", "short", x, "short", y)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos2sv function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Pointer<Int16>} v A pointer to an array of two elements, specifying x and y coordinates for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos2sv
     */
    static glRasterPos2sv(v) {
        DllCall("OPENGL32.dll\glRasterPos2sv", "ptr", v)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos3d function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Float} x Specifies the x-coordinate for the current raster position.
     * @param {Float} y Specifies the y-coordinate for the current raster position.
     * @param {Float} z Specifies the z-coordinate for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos3d
     */
    static glRasterPos3d(x, y, z) {
        DllCall("OPENGL32.dll\glRasterPos3d", "double", x, "double", y, "double", z)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos3dv function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Pointer<Double>} v A pointer to an array of three elements, specifying x, y, and z coordinates for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos3dv
     */
    static glRasterPos3dv(v) {
        DllCall("OPENGL32.dll\glRasterPos3dv", "ptr", v)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos3f function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Float} x Specifies the x-coordinate for the current raster position.
     * @param {Float} y Specifies the y-coordinate for the current raster position.
     * @param {Float} z Specifies the z-coordinate for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos3f
     */
    static glRasterPos3f(x, y, z) {
        DllCall("OPENGL32.dll\glRasterPos3f", "float", x, "float", y, "float", z)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos3fv function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Pointer<Single>} v A pointer to an array of three elements, specifying x, y, and z coordinates for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos3fv
     */
    static glRasterPos3fv(v) {
        DllCall("OPENGL32.dll\glRasterPos3fv", "ptr", v)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos3i function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Integer} x Specifies the x-coordinate for the current raster position.
     * @param {Integer} y Specifies the y-coordinate for the current raster position.
     * @param {Integer} z Specifies the z-coordinate for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos3i
     */
    static glRasterPos3i(x, y, z) {
        DllCall("OPENGL32.dll\glRasterPos3i", "int", x, "int", y, "int", z)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos3iv function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Pointer<Int32>} v A pointer to an array of three elements, specifying x, y, and z coordinates for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos3iv
     */
    static glRasterPos3iv(v) {
        DllCall("OPENGL32.dll\glRasterPos3iv", "ptr", v)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos3s function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Integer} x Specifies the x-coordinate for the current raster position.
     * @param {Integer} y Specifies the y-coordinate for the current raster position.
     * @param {Integer} z Specifies the z-coordinate for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos3s
     */
    static glRasterPos3s(x, y, z) {
        DllCall("OPENGL32.dll\glRasterPos3s", "short", x, "short", y, "short", z)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos3sv function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Pointer<Int16>} v A pointer to an array of three elements, specifying x, y, and z coordinates for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos3sv
     */
    static glRasterPos3sv(v) {
        DllCall("OPENGL32.dll\glRasterPos3sv", "ptr", v)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos4d function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Float} x Specifies the x-coordinate for the current raster position.
     * @param {Float} y Specifies the y-coordinate for the current raster position.
     * @param {Float} z Specifies the z-coordinate for the current raster position.
     * @param {Float} w The w-coordinate for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos4d
     */
    static glRasterPos4d(x, y, z, w) {
        DllCall("OPENGL32.dll\glRasterPos4d", "double", x, "double", y, "double", z, "double", w)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos4dv function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Pointer<Double>} v A pointer to an array of four elements, specifying x, y, z, and w coordinates for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos4dv
     */
    static glRasterPos4dv(v) {
        DllCall("OPENGL32.dll\glRasterPos4dv", "ptr", v)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos4f function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Float} x Specifies the x-coordinate for the current raster position.
     * @param {Float} y Specifies the y-coordinate for the current raster position.
     * @param {Float} z Specifies the z-coordinate for the current raster position.
     * @param {Float} w The w-coordinate for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos4f
     */
    static glRasterPos4f(x, y, z, w) {
        DllCall("OPENGL32.dll\glRasterPos4f", "float", x, "float", y, "float", z, "float", w)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos4fv function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Pointer<Single>} v A pointer to an array of four elements, specifying x, y, z, and w coordinates for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos4fv
     */
    static glRasterPos4fv(v) {
        DllCall("OPENGL32.dll\glRasterPos4fv", "ptr", v)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos4i function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Integer} x Specifies the x-coordinate for the current raster position.
     * @param {Integer} y Specifies the y-coordinate for the current raster position.
     * @param {Integer} z Specifies the z-coordinate for the current raster position.
     * @param {Integer} w The w-coordinate for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos4i
     */
    static glRasterPos4i(x, y, z, w) {
        DllCall("OPENGL32.dll\glRasterPos4i", "int", x, "int", y, "int", z, "int", w)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos4iv function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Pointer<Int32>} v A pointer to an array of four elements, specifying x, y, z, and w coordinates for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos4iv
     */
    static glRasterPos4iv(v) {
        DllCall("OPENGL32.dll\glRasterPos4iv", "ptr", v)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos4s function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Integer} x Specifies the x-coordinate for the current raster position.
     * @param {Integer} y Specifies the y-coordinate for the current raster position.
     * @param {Integer} z Specifies the z-coordinate for the current raster position.
     * @param {Integer} w The w-coordinate for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos4s
     */
    static glRasterPos4s(x, y, z, w) {
        DllCall("OPENGL32.dll\glRasterPos4s", "short", x, "short", y, "short", z, "short", w)
    }

    /**
     * Specifies the raster position for pixel operations. | glRasterPos4sv function (Gl.h)
     * @remarks
     * OpenGL maintains a 3-D position in window coordinates. This position, called the raster position, is maintained with subpixel accuracy. It is used to position pixel and bitmap write operations. See [**glBitmap**](glbitmap.md), [**glDrawPixels**](gldrawpixels.md), and [**glCopyPixels**](glcopypixels.md).
     * 
     * The current raster position consists of three window coordinates (*x, y, z*), a clip coordinate *w* value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The *w* coordinate is a clip coordinate, because *w* is not projected to window coordinates. The [glRasterPos4](glrasterpos-functions.md) function specifies object coordinates *x, y, z*, and *w* explicitly. The glRasterPos3 function specifies object coordinates *x, y,* and *z* explicitly, while *w* is implicitly set to one. The glRasterPos2 function uses the argument values for *x* and *y* while implicitly setting *z* and *w* to zero and one.
     * 
     * The object coordinates presented by [glRasterPos](glrasterpos-functions.md) are treated just like those of a [glVertex](glvertex-functions.md) command. They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL\_CURRENT\_RASTER\_POSITION\_VALID flag is set. If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
     * 
     * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then GL\_CURRENT\_RASTER\_COLOR, in RGBA mode, or the GL\_CURRENT\_RASTER\_INDEX, in color-index mode, is set to the color produced by the lighting calculation (see [glLight](gllight-functions.md), [glLightModel](gllightmodel-functions.md), and [**glShadeModel**](glshademodel.md)). If lighting is disabled, current color (in RGBA mode, state variable GL\_CURRENT\_COLOR) or color index (in color-index mode, state variable GL\_CURRENT\_INDEX) is used to update the current raster color.
     * 
     * Likewise, GL\_CURRENT\_RASTER\_TEXTURE\_COORDS is updated as a function of GL\_CURRENT\_TEXTURE\_COORDS, based on the texture matrix and the texture generation functions (see [glTexGen](gltexgen-functions.md)). Finally, the distance from the origin of the eye coordinate system to the vertex, as transformed by only the modelview matrix, replaces GL\_CURRENT\_RASTER\_DISTANCE.
     * 
     * Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, GL\_CURRENT\_RASTER\_INDEX is always 1; in color-index mode, the current raster RGBA color always maintains its initial value.
     * 
     * > [!Note]  
     * > The raster position is modified both by [glRasterPos](glrasterpos-functions.md) and by [**glBitmap**](glbitmap.md).
     * 
     *  
     * 
     * > [!Note]  
     * > When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to the OpenGL state).
     * 
     *  
     * 
     * The following functions retrieve information related to [glRasterPos](glrasterpos-functions.md):
     * 
     * <dl>
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION\_VALID  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_DISTANCE  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_COLOR  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_INDEX  
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_TEXTURE\_COORDS  
     * </dl>
     * @param {Pointer<Int16>} v A pointer to an array of four elements, specifying x, y, z, and w coordinates for the current raster position.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrasterpos4sv
     */
    static glRasterPos4sv(v) {
        DllCall("OPENGL32.dll\glRasterPos4sv", "ptr", v)
    }

    /**
     * The glReadBuffer function selects a color buffer source for pixels.
     * @remarks
     * The **glReadBuffer** function specifies a color buffer as the source for subsequent [**glReadPixels**](glreadpixels.md) and [**glCopyPixels**](glcopypixels.md) commands. The *mode* parameter accepts one of twelve or more predefined values. (GL\_AUX0 through GL\_AUX3 are always defined.) In a fully configured system, GL\_FRONT, GL\_LEFT, and GL\_FRONT\_LEFT all name the front-left buffer, GL\_FRONT\_RIGHT and GL\_RIGHT name the front-right buffer, and GL\_BACK\_LEFT and GL\_BACK name the back-left buffer.
     * 
     * Nonstereo double-buffered configurations have only a front-left and a back-left buffer. Single-buffered configurations have a front-left and a front-right buffer if stereo, and only a front-left buffer if nonstereo. It is an error to specify a nonexistent buffer to **glReadBuffer**.
     * 
     * By default, *mode* is GL\_FRONT in single-buffered configurations, and GL\_BACK in double-buffered configurations.
     * 
     * The following function retrieves information related to **glReadBuffer**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_READ\_BUFFER
     * @param {Integer} mode A color buffer. Accepted values are GL\_FRONT\_LEFT, GL\_FRONT\_RIGHT, GL\_BACK\_LEFT, GL\_BACK\_RIGHT, GL\_FRONT, GL\_BACK, GL\_LEFT, GL\_RIGHT, and GL\_AUX *i*, where *i* is between 0 and GL\_AUX\_BUFFERS 1.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glreadbuffer
     */
    static glReadBuffer(mode) {
        DllCall("OPENGL32.dll\glReadBuffer", "uint", mode)
    }

    /**
     * The glReadPixels function reads a block of pixels from the framebuffer.
     * @remarks
     * The **glReadPixels** function returns pixel data from the framebuffer, starting with the pixel whose lower-left corner is at location (*x*, *y*), into client memory starting at location *pixels*. Several parameters control the processing of the pixel data before it is placed into client memory. These parameters are set with three commands: [**glPixelStore**](glpixelstore-functions.md), [**glPixelTransfer**](glpixeltransfer.md), and [**glPixelMap**](glpixelmap.md). This topic describes the effects on **glReadPixels** of most, but not all of the parameters specified by these three commands.
     * 
     * The **glReadPixels** function returns values from each pixel with lower-left corner at (*x* + i, *y* + j) for 0 = i < *width* and 0 = j < *height*. This pixel is said to be the *i*th pixel in the *j*th row. Pixels are returned in row order from the lowest to the highest row, left to right in each row.
     * 
     * The shift, scale, bias, and lookup factors described above are all specified by [**glPixelTransfer**](glpixeltransfer.md). The lookup table contents are specified by [**glPixelMap**](glpixelmap.md).
     * 
     * The final step involves converting the indexes or components to the proper format, as specified by *type*. If *format* is GL\_COLOR\_INDEX or GL\_STENCIL\_INDEX and *type* is not GL\_FLOAT, each index is masked with the mask value given in the following table. If *type* is GL\_FLOAT, then each integer index is converted to single-precision floating-point format.
     * 
     * If *format* is GL\_RED, GL\_GREEN, GL\_BLUE, GL\_ALPHA, GL\_RGB, GL\_RGBA, GL\_BGR\_EXT, GL\_BGRA\_EXT, GL\_LUMINANCE, or GL\_LUMINANCE\_ALPHA and *type* is not GL\_FLOAT, each component is multiplied by the multiplier shown in the preceding table. If type is GL\_FLOAT, then each component is passed as is (or converted to the client's single-precision floating-point format if it is different from the one used by OpenGL).
     * 
     * Return values are placed in memory as follows. If *format* is GL\_COLOR\_INDEX, GL\_STENCIL\_INDEX, GL\_DEPTH\_COMPONENT, GL\_RED, GL\_GREEN, GL\_BLUE, GL\_ALPHA, or GL\_LUMINANCE, a single value is returned and the data for the *i*th pixel in the *j*th row is placed in location (*j* )*width* + *i*. GL\_RGB and GL\_BGR\_EXT return three values, GL\_RGBA and GL\_BGRA\_EXT return four values, and GL\_LUMINANCE\_ALPHA returns two values for each pixel, with all values corresponding to a single pixel occupying contiguous space in *pixels*. Storage parameters set by [**glPixelStore**](glpixelstore-functions.md), such as GL\_PACK\_SWAP\_BYTES and GL\_PACK\_LSB\_FIRST, affect the way that data is written into memory. See [**glPixelStore**](glpixelstore-functions.md) for a description.
     * 
     * Values for pixels that lie outside the window connected to the current OpenGL context are undefined.
     * 
     * If an error is generated, no change is made to the contents of *pixels*.
     * 
     * The following function retrieves information related to **glReadPixels**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_INDEX\_MODE
     * @param {Integer} x The window *x* coordinate of the first pixel that is read from the framebuffer. Together with the *y* coordinate, specifies the location of the lower-left corner of a rectangular block of pixels.
     * @param {Integer} y The window *y* coordinates of the first pixel that is read from the framebuffer. Together with the *x* coordinate, specifies the location of the lower-left corner of a rectangular block of pixels.
     * @param {Integer} width The width of the pixel rectangle.
     * @param {Integer} height The height of the pixel rectangle. *Width* and *height* parameters of value "1" correspond to a single pixel.
     * @param {Integer} format The format of the pixel data. The following symbolic values are accepted:
     * 
     * 
     * 
     * | Value                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
     * |---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_COLOR_INDEX"></span><span id="gl_color_index"></span><dl> <dt>**GL\_COLOR\_INDEX**</dt> </dl>                                                                                                                                                                                                                                                                                                               | Color indexes are read from the color buffer selected by [**glReadBuffer**](glreadbuffer.md). Each index is converted to fixed point, shifted left or right, depending on the value and sign of GL\_INDEX\_SHIFT, and added to GL\_INDEX\_OFFSET. If GL\_MAP\_COLOR is GL\_TRUE, indexes are replaced by their mappings in the table GL\_PIXEL\_MAP\_I\_TO\_I.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
     * | <span id="GL_STENCIL_INDEX"></span><span id="gl_stencil_index"></span><dl> <dt>**GL\_STENCIL\_INDEX**</dt> </dl>                                                                                                                                                                                                                                                                                                         | Stencil values are read from the stencil buffer. Each index is converted to fixed point, shifted left or right, depending on the value and sign of GL\_INDEX\_SHIFT, and added to GL\_INDEX\_OFFSET. If GL\_MAP\_STENCIL is GL\_TRUE, indexes are replaced by their mappings in the table GL\_PIXEL\_MAP\_S\_TO\_S.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_DEPTH_COMPONENT"></span><span id="gl_depth_component"></span><dl> <dt>**GL\_DEPTH\_COMPONENT**</dt> </dl>                                                                                                                                                                                                                                                                                                   | Depth values are read from the depth buffer. Each component is converted to floating point such that the minimum depth value maps to 0.0 and the maximum value maps to 1.0. Each component is then multiplied by GL\_DEPTH\_SCALE, added to GL\_DEPTH\_BIAS, and finally clamped to the range \[0,1\].<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
     * | <span id="GL_RED__GL_GREEN__GL_BLUE__GL_ALPHA__GL_RGB__GL_RGBA__GL_BGR_EXT__GL_BGRA_EXT__GL_LUMINANCE__GL_LUMINANCE_ALPHA"></span><span id="gl_red__gl_green__gl_blue__gl_alpha__gl_rgb__gl_rgba__gl_bgr_ext__gl_bgra_ext__gl_luminance__gl_luminance_alpha"></span><dl> <dt>**GL\_RED, GL\_GREEN, GL\_BLUE, GL\_ALPHA, GL\_RGB, GL\_RGBA, GL\_BGR\_EXT, GL\_BGRA\_EXT, GL\_LUMINANCE, GL\_LUMINANCE\_ALPHA**</dt> </dl> | Processing differs depending on whether color buffers store color indexes or RGBA color components. If color indexes are stored, they are read from the color buffer selected by [**glReadBuffer**](glreadbuffer.md). Each index is converted to fixed point, shifted left or right, depending on the value and sign of GL\_INDEX\_SHIFT, and added to GL\_INDEX\_OFFSET. Indexes are then replaced by the red, green, blue, and alpha values obtained by indexing the GL\_PIXEL\_MAP\_I\_TO\_R, GL\_PIXEL\_MAP\_I\_TO\_G, GL\_PIXEL\_MAP\_I\_TO\_B, and GL\_PIXEL\_MAP\_I\_TO\_A tables. If RGBA color components are stored in the color buffers, they are read from the color buffer selected by **glReadBuffer**. Each color component is converted to floating point such that zero intensity maps to 0.0 and full intensity maps to 1.0. Each component is then multiplied by GL\_c\_SCALE and added to GL\_c\_BIAS, where c is GL\_RED, GL\_GREEN, GL\_BLUE, and GL\_ALPHA. Each component is clamped to the range \[0,1\]. Finally, if GL\_MAP\_COLOR is GL\_TRUE, each color component c is replaced by its mapping in the table GL\_PIXEL\_MAP\_c\_TO\_c, where c again is GL\_RED, GL\_GREEN, GL\_BLUE, and GL\_ALPHA. Each component is scaled to the size of its corresponding table before the lookup is performed. Finally, unneeded data is discarded. For example, GL\_RED discards the green, blue, and alpha components, while GL\_RGB discards only the alpha component. GL\_LUMINANCE computes a single component value as the sum of the red, green, and blue components, and GL\_LUMINANCE\_ALPHA does the same, while keeping alpha as a second value.<br/> |
     * @param {Integer} type The data type of the pixel data. Must be one of the following values.
     * 
     * 
     * 
     * | Type                | Index mask | Component conversion |
     * |---------------------|------------|----------------------|
     * | GL\_UNSIGNED\_BYTE  | 281        | (281)*c*             |
     * | GL\_BYTE            | 271        | \[(271)*c*-1\]/2     |
     * | GL\_BITMAP          | 1          | 1                    |
     * | GL\_UNSIGNED\_SHORT | 2 61       | (2 61)*c*            |
     * | GL\_SHORT           | 2 51       | \[(2 51)*c*1\]/2     |
     * | GL\_UNSIGNED\_INT\_ | 2  1       | (2  1)*c*            |
     * | GL\_INT             | 2   1      | \[(2  1)*c*1\]/2     |
     * | GL\_FLOAT           | none       | *c*                  |
     * @param {Pointer<Void>} pixels Returns the pixel data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glreadpixels
     */
    static glReadPixels(x, y, width, height, format, type, pixels) {
        DllCall("OPENGL32.dll\glReadPixels", "int", x, "int", y, "int", width, "int", height, "uint", format, "uint", type, "ptr", pixels)
    }

    /**
     * The glRectd function draws a rectangle.
     * @remarks
     * The **glRectd** function supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of (*x*, *y*) coordinates, or as two pointers to arrays, each containing an (*x*, *y*) pair. The resulting rectangle is defined in the *z* = 0 plane.
     * 
     * The **glRectd**(*x1,* *y1,* *x2,* *y2*) function is exactly equivalent to the following sequence:
     * 
     * **glBegin**(GL\_POLYGON);
     * 
     * **glVertex2**( *x1,* *y1* );
     * 
     * **glVertex2**( *x2,* *y1* );
     * 
     * **glVertex2**( *x2,* *y2* );
     * 
     * **glVertex2**( *x1,* *y2* );
     * 
     * **glEnd**( );
     * 
     * Notice that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
     * @param {Float} x1 The *x* coordinate of the vertex of a rectangle.
     * @param {Float} y1 The *y* coordinate of the vertex of a rectangle.
     * @param {Float} x2 The *x* coordinate of the opposite vertex of the rectangle.
     * @param {Float} y2 The *y* coordinate of the opposite vertex of the rectangle.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrectd
     */
    static glRectd(x1, y1, x2, y2) {
        DllCall("OPENGL32.dll\glRectd", "double", x1, "double", y1, "double", x2, "double", y2)
    }

    /**
     * The glRectdv function draws a rectangle.
     * @remarks
     * The **glRectd** function supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of (*x*, *y*) coordinates, or as two pointers to arrays, each containing an (*x*, *y*) pair. The resulting rectangle is defined in the *z* = 0 plane.
     * 
     * The **glRectd**(*x1,* *y1,* *x2,* *y2*) function is exactly equivalent to the following sequence:
     * 
     * **glBegin**(GL\_POLYGON);
     * 
     * **glVertex2**( *x1,* *y1* );
     * 
     * **glVertex2**( *x2,* *y1* );
     * 
     * **glVertex2**( *x2,* *y2* );
     * 
     * **glVertex2**( *x1,* *y2* );
     * 
     * **glEnd**( );
     * 
     * Notice that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
     * @param {Pointer<Double>} v1 A pointer to one vertex of a rectangle.
     * @param {Pointer<Double>} v2 a pointer to the opposite vertex of the rectangle.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrectdv
     */
    static glRectdv(v1, v2) {
        DllCall("OPENGL32.dll\glRectdv", "ptr", v1, "ptr", v2)
    }

    /**
     * The glRectf function draws a rectangle.
     * @remarks
     * The **glRectf** function supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of (*x*, *y*) coordinates, or as two pointers to arrays, each containing an (*x*, *y*) pair. The resulting rectangle is defined in the *z* = 0 plane.
     * 
     * The **glRectf**(*x1,* *y1,* *x2,* *y2*) function is exactly equivalent to the following sequence:
     * 
     * **glBegin**(GL\_POLYGON);
     * 
     * **glVertex2**( *x1,* *y1* );
     * 
     * **glVertex2**( *x2,* *y1* );
     * 
     * **glVertex2**( *x2,* *y2* );
     * 
     * **glVertex2**( *x1,* *y2* );
     * 
     * **glEnd**( );
     * 
     * Notice that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
     * @param {Float} x1 The *x* coordinate of the vertex of a rectangle.
     * @param {Float} y1 The *y* coordinate of the vertex of a rectangle.
     * @param {Float} x2 The *x* coordinate of the opposite vertex of the rectangle.
     * @param {Float} y2 The *y* coordinate of the opposite vertex of the rectangle.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrectf
     */
    static glRectf(x1, y1, x2, y2) {
        DllCall("OPENGL32.dll\glRectf", "float", x1, "float", y1, "float", x2, "float", y2)
    }

    /**
     * The glRectfv function draws a rectangle.
     * @remarks
     * The **glRectf** function supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of (*x*, *y*) coordinates, or as two pointers to arrays, each containing an (*x*, *y*) pair. The resulting rectangle is defined in the *z* = 0 plane.
     * 
     * The **glRectf**(*x1,* *y1,* *x2,* *y2*) function is exactly equivalent to the following sequence:
     * 
     * **glBegin**(GL\_POLYGON);
     * 
     * **glVertex2**( *x1,* *y1* );
     * 
     * **glVertex2**( *x2,* *y1* );
     * 
     * **glVertex2**( *x2,* *y2* );
     * 
     * **glVertex2**( *x1,* *y2* );
     * 
     * **glEnd**( );
     * 
     * Notice that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
     * @param {Pointer<Single>} v1 A pointer to one vertex of a rectangle.
     * @param {Pointer<Single>} v2 a pointer to the opposite vertex of the rectangle.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrectfv
     */
    static glRectfv(v1, v2) {
        DllCall("OPENGL32.dll\glRectfv", "ptr", v1, "ptr", v2)
    }

    /**
     * The glRecti function draws a rectangle.
     * @remarks
     * The **glRecti** function supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of (*x*, *y*) coordinates, or as two pointers to arrays, each containing an (*x*, *y*) pair. The resulting rectangle is defined in the *z* = 0 plane.
     * 
     * The **glRecti**(*x1,* *y1,* *x2,* *y2*) function is exactly equivalent to the following sequence:
     * 
     * **glBegin**(GL\_POLYGON);
     * 
     * **glVertex2**( *x1,* *y1* );
     * 
     * **glVertex2**( *x2,* *y1* );
     * 
     * **glVertex2**( *x2,* *y2* );
     * 
     * **glVertex2**( *x1,* *y2* );
     * 
     * **glEnd**( );
     * 
     * Notice that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
     * @param {Integer} x1 The *x* coordinate of the vertex of a rectangle.
     * @param {Integer} y1 The *y* coordinate of the vertex of a rectangle.
     * @param {Integer} x2 The *x* coordinate of the opposite vertex of the rectangle.
     * @param {Integer} y2 The *y* coordinate of the opposite vertex of the rectangle.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrecti
     */
    static glRecti(x1, y1, x2, y2) {
        DllCall("OPENGL32.dll\glRecti", "int", x1, "int", y1, "int", x2, "int", y2)
    }

    /**
     * The glRectiv function draws a rectangle.
     * @remarks
     * The **glRecti** function supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of (*x*, *y*) coordinates, or as two pointers to arrays, each containing an (*x*, *y*) pair. The resulting rectangle is defined in the *z* = 0 plane.
     * 
     * The **glRecti**(*x1,* *y1,* *x2,* *y2*) function is exactly equivalent to the following sequence:
     * 
     * **glBegin**(GL\_POLYGON);
     * 
     * **glVertex2**( *x1,* *y1* );
     * 
     * **glVertex2**( *x2,* *y1* );
     * 
     * **glVertex2**( *x2,* *y2* );
     * 
     * **glVertex2**( *x1,* *y2* );
     * 
     * **glEnd**( );
     * 
     * Notice that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
     * @param {Pointer<Int32>} v1 A pointer to one vertex of a rectangle.
     * @param {Pointer<Int32>} v2 a pointer to the opposite vertex of the rectangle.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrectiv
     */
    static glRectiv(v1, v2) {
        DllCall("OPENGL32.dll\glRectiv", "ptr", v1, "ptr", v2)
    }

    /**
     * The glRects function draws a rectangle.
     * @remarks
     * The **glRects** function supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of (x, *y*) coordinates, or as two pointers to arrays, each containing an (*x*, *y*) pair. The resulting rectangle is defined in the *z* = 0 plane.
     * 
     * The **glRects**(*x1,* *y1,* *x2,* *y2*) function is exactly equivalent to the following sequence:
     * 
     * **glBegin**(GL\_POLYGON);
     * 
     * **glVertex2**( *x1,* *y1* );
     * 
     * **glVertex2**( *x2,* *y1* );
     * 
     * **glVertex2**( *x2,* *y2* );
     * 
     * **glVertex2**( *x1,* *y2* );
     * 
     * **glEnd**( );
     * 
     * Notice that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
     * @param {Integer} x1 The *x* coordinate of the vertex of a rectangle.
     * @param {Integer} y1 The *y* coordinate of the vertex of a rectangle.
     * @param {Integer} x2 The *x* coordinate of the opposite vertex of the rectangle.
     * @param {Integer} y2 The *y* coordinate of the opposite vertex of the rectangle.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrects
     */
    static glRects(x1, y1, x2, y2) {
        DllCall("OPENGL32.dll\glRects", "short", x1, "short", y1, "short", x2, "short", y2)
    }

    /**
     * The glRectsv function draws a rectangle.
     * @remarks
     * The **glRects** function supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of (*x*, *y*) coordinates, or as two pointers to arrays, each containing an (*x,* *y*) pair. The resulting rectangle is defined in the *z* = 0 plane.
     * 
     * The **glRects**(*x1,* *y1,* *x2,* *y2*) function is exactly equivalent to the following sequence:
     * 
     * **glBegin**(GL\_POLYGON);
     * 
     * **glVertex2**( *x1,* *y1* );
     * 
     * **glVertex2**( *x2,* *y1* );
     * 
     * **glVertex2**( *x2,* *y2* );
     * 
     * **glVertex2**( *x1,* *y2* );
     * 
     * **glEnd**( );
     * 
     * Notice that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
     * @param {Pointer<Int16>} v1 A pointer to one vertex of a rectangle.
     * @param {Pointer<Int16>} v2 a pointer to the opposite vertex of the rectangle.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrectsv
     */
    static glRectsv(v1, v2) {
        DllCall("OPENGL32.dll\glRectsv", "ptr", v1, "ptr", v2)
    }

    /**
     * The glRenderMode function sets the rasterization mode.
     * @remarks
     * The **glRenderMode** function takes one argument, *mode*, which can assume one of three predefined values above.
     * 
     * The return value of the **glRenderMode** function is determined by the render mode at the time **glRenderMode** is called, rather than by *mode*. The values returned for the three render modes are as follows.
     * 
     * 
     * 
     * | Value        | Meaning                                                                 |
     * |--------------|-------------------------------------------------------------------------|
     * | GL\_RENDER   | Zero.                                                                   |
     * | GL\_SELECT   | The number of hit records transferred to the select buffer.             |
     * | GL\_FEEDBACK | The number of values (not vertices) transferred to the feedback buffer. |
     * 
     * 
     * 
     *  
     * 
     * Refer to [**glSelectBuffer**](glselectbuffer.md) and [**glFeedbackBuffer**](glfeedbackbuffer.md) for more details concerning selection and feedback operation.
     * 
     * If an error is generated, **glRenderMode** returns zero regardless of the current render mode.
     * 
     * The following function retrieves information related to **glRenderMode**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_RENDER\_MODE
     * @param {Integer} mode The rasterization mode. The following three values are accepted. The default value is GL\_RENDER.
     * 
     * 
     * 
     * | Value                                                                                                                                                   | Meaning                                                                                                                                                                                                                                                                                                                                                                       |
     * |---------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_RENDER"></span><span id="gl_render"></span><dl> <dt>**GL\_RENDER**</dt> </dl>       | Render mode. Primitives are rasterized, producing pixel fragments, which are written into the framebuffer. This is the normal mode and also the default mode.<br/>                                                                                                                                                                                                      |
     * | <span id="GL_SELECT"></span><span id="gl_select"></span><dl> <dt>**GL\_SELECT**</dt> </dl>       | Selection mode. No pixel fragments are produced, and no change to the framebuffer contents is made. Instead, a record of the names of primitives that would have been drawn if the render mode was GL\_RENDER is returned in a select buffer, which must be created (see [**glSelectBuffer**](glselectbuffer.md)) before selection mode is entered.<br/>               |
     * | <span id="GL_FEEDBACK"></span><span id="gl_feedback"></span><dl> <dt>**GL\_FEEDBACK**</dt> </dl> | Feedback mode. No pixel fragments are produced, and no change to the framebuffer contents is made. Instead, the coordinates and attributes of vertices that would have been drawn had the render mode been GL\_RENDER are returned in a feedback buffer, which must be created (see [**glFeedbackBuffer**](glfeedbackbuffer.md)) before feedback mode is entered.<br/> |
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrendermode
     */
    static glRenderMode(mode) {
        result := DllCall("OPENGL32.dll\glRenderMode", "uint", mode, "int")
        return result
    }

    /**
     * The glRotated function multiplies the current matrix by a rotation matrix.
     * @remarks
     * The **glRotated** function computes a matrix that performs a counterclockwise rotation of *angle* degrees about the vector from the origin through the point (*x*, *y*, *z*).
     * 
     * The current matrix (see [**glMatrixMode**](glmatrixmode.md)) is multiplied by this rotation matrix, with the product replacing the current matrix. That is, if M is the current matrix and R is the translation matrix, then M is replaced with M   R.
     * 
     * If the matrix mode is either GL\_MODELVIEW or GL\_PROJECTION, all objects drawn after **glRotated** is called are rotated. Use [**glPushMatrix**](glpushmatrix.md) and [**glPopMatrix**](glpopmatrix.md) to save and restore the unrotated coordinate system.
     * 
     * The following functions retrieve information related to **glRotated**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_RENDER\_MODE
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MODELVIEW\_MATRIX
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_PROJECTION\_MATRIX
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_TEXTURE\_MATRIX
     * @param {Float} angle The angle of rotation, in degrees.
     * @param {Float} x The *x* coordinate of a vector.
     * @param {Float} y The *y* coordinate of a vector.
     * @param {Float} z The *z* coordinate of a vector.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrotated
     */
    static glRotated(angle, x, y, z) {
        DllCall("OPENGL32.dll\glRotated", "double", angle, "double", x, "double", y, "double", z)
    }

    /**
     * The glRotatef function multiplies the current matrix by a rotation matrix.
     * @remarks
     * The **glRotatef** function computes a matrix that performs a counterclockwise rotation of *angle* degrees about the vector from the origin through the point (*x*, *y*, *z*).
     * 
     * The current matrix (see [**glMatrixMode**](glmatrixmode.md)) is multiplied by this rotation matrix, with the product replacing the current matrix. That is, if M is the current matrix and R is the translation matrix, then M is replaced with M   R.
     * 
     * If the matrix mode is either GL\_MODELVIEW or GL\_PROJECTION, all objects drawn after **glRotatef** is called are rotated. Use [**glPushMatrix**](glpushmatrix.md) and [**glPopMatrix**](glpopmatrix.md) to save and restore the unrotated coordinate system.
     * 
     * The following functions retrieve information related to **glRotatef**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_RENDER\_MODE
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MODELVIEW\_MATRIX
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_PROJECTION\_MATRIX
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_TEXTURE\_MATRIX
     * @param {Float} angle The angle of rotation, in degrees.
     * @param {Float} x The *x* coordinate of a vector.
     * @param {Float} y The *y* coordinate of a vector.
     * @param {Float} z The *z* coordinate of a vector.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glrotatef
     */
    static glRotatef(angle, x, y, z) {
        DllCall("OPENGL32.dll\glRotatef", "float", angle, "float", x, "float", y, "float", z)
    }

    /**
     * The glScaled and glScalef functions multiply the current matrix by a general scaling matrix. | glScaled function (Gl.h)
     * @remarks
     * The **glScaled** function produces a general scaling along the *x*, *y*, and *z* axes. The three arguments indicate the desired scale factors along each of the three axes. The resulting matrix is
     * 
     * ![Diagram showing the matrix of scale factors along the x, y, and z axes.](images/scale01.png)
     * 
     * The current matrix (see [**glMatrixMode**](glmatrixmode.md)) is multiplied by this scale matrix, with the product replacing the current matrix. That is, if M is the current matrix and S is the scale matrix, then M is replaced with M   S.
     * 
     * If the matrix mode is either GL\_MODELVIEW or GL\_PROJECTION, all objects drawn after **glScaled** is called are scaled. Use [**glPushMatrix**](glpushmatrix.md) and [**glPopMatrix**](glpopmatrix.md) to save and restore the unscaled coordinate system.
     * 
     * If scale factors other than 1.0 are applied to the modelview matrix and lighting is enabled, automatic normalization of normals should probably also be enabled ([**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with argument GL\_NORMALIZE).
     * 
     * The following functions retrieve information related to **glScaled**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MODELVIEW\_MATRIX
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_PROJECTION\_MATRIX
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_TEXTURE\_MATRIX
     * @param {Float} x Scale factors along the *x* axis.
     * @param {Float} y Scale factors along the *y* axis.
     * @param {Float} z Scale factors along the *z* axis.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glscaled
     */
    static glScaled(x, y, z) {
        DllCall("OPENGL32.dll\glScaled", "double", x, "double", y, "double", z)
    }

    /**
     * The glScaled and glScalef functions multiply the current matrix by a general scaling matrix. | glScalef function (Gl.h)
     * @remarks
     * The **glScalef** function produces a general scaling along the *x*, *y*, and *z* axes. The three arguments indicate the desired scale factors along each of the three axes. The resulting matrix appears in the following image.
     * 
     * ![Diagram showing the matrix of scale factors along the x, y, and z axes.](images/scale01.png)
     * 
     * The current matrix (see [**glMatrixMode**](glmatrixmode.md)) is multiplied by this scale matrix, with the product replacing the current matrix. That is, if M is the current matrix and S is the scale matrix, then M is replaced with M   S.
     * 
     * If the matrix mode is either GL\_MODELVIEW or GL\_PROJECTION, all objects drawn after **glScalef** is called are scaled. Use [**glPushMatrix**](glpushmatrix.md) and [**glPopMatrix**](glpopmatrix.md) to save and restore the unscaled coordinate system.
     * 
     * If scale factors other than 1.0 are applied to the modelview matrix and lighting is enabled, automatic normalization of normals should probably also be enabled ([**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with argument GL\_NORMALIZE).
     * 
     * The following functions retrieve information related to **glScalef**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MODELVIEW\_MATRIX
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_PROJECTION\_MATRIX
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_TEXTURE\_MATRIX
     * @param {Float} x Scale factors along the *x* axis.
     * @param {Float} y Scale factors along the *y* axis.
     * @param {Float} z Scale factors along the *z* axis.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glscalef
     */
    static glScalef(x, y, z) {
        DllCall("OPENGL32.dll\glScalef", "float", x, "float", y, "float", z)
    }

    /**
     * The glScissor function defines the scissor box.
     * @remarks
     * The **glScissor** function defines a rectangle, called the scissor box, in window coordinates. The first two parameters, *x* and *y*, specify the lower-left corner of the box. The *width* and *height* parameters specify the width and height of the box.
     * 
     * The scissor test is enabled and disabled using [**glEnable**](glenable.md) and **glDisable** with argument GL\_SCISSOR\_TEST. While the scissor test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of framebuffer pixels, so **glScissor**(0,0,1,1) allows only the lower-left pixel in the window to be modified, and **glScissor**(0,0,0,0) disallows modification to all pixels in the window.
     * 
     * When the scissor test is disabled, it is as though the scissor box includes the entire window.
     * 
     * The following functions retrieve information related to **glScissor**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_SCISSOR\_BOX
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_SCISSOR\_TEST
     * @param {Integer} x The x (vertical axis) coordinate for the lower-left corner of the scissor box.
     * @param {Integer} y The y (horizontal axis) coordinate for the lower-left corner of the scissor box. Together, x and y specify the lower-left corner of the scissor box. Initially (0,0).
     * @param {Integer} width The width of the scissor box.
     * @param {Integer} height The height of the scissor box. When an OpenGL context is *first* attached to a window, *width* and *height* are set to the dimensions of that window.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glscissor
     */
    static glScissor(x, y, width, height) {
        DllCall("OPENGL32.dll\glScissor", "int", x, "int", y, "int", width, "int", height)
    }

    /**
     * The glSelectBuffer function establishes a buffer for selection mode values.
     * @remarks
     * The **glSelectBuffer** function has two parameters: *buffer* is a pointer to an array of unsigned integers, and *size* indicates the size of the array. The *buffer* parameter returns values from the name stack (see [**glInitNames**](glinitnames.md), [**glLoadName**](glloadname.md), [**glPushName**](glpushname.md)) when the rendering mode is GL\_SELECT (see [**glRenderMode**](glrendermode.md)). The **glSelectBuffer** function must be issued before selection mode is enabled, and it must not be issued while the rendering mode is GL\_SELECT.
     * 
     * Selection is used by a programmer to determine which primitives are drawn into some region of a window. The region is defined by the current modelview and perspective matrices.
     * 
     * In selection mode, no pixel fragments are produced from rasterization. Instead, if a primitive intersects the clip volume defined by the viewing frustum and the user-defined clipping planes, this primitive causes a selection hit. (With polygons, no hit occurs if the polygon is culled.) When a change is made to the name stack, or when [**glRenderMode**](glrendermode.md) is called, a hit record is copied to *buffer* if any hits have occurred since the last such event (either a name stack change or a **glRenderMode** call). The hit record consists of the number of names in the name stack at the time of the event; followed by the minimum and maximum depth values of all vertices that hit since the previous event; followed by the name stack contents, bottom name first.
     * 
     * Returned depth values are mapped such that the largest unsigned integer value corresponds to window coordinate depth 1.0, and zero corresponds to window coordinate depth 0.0.
     * 
     * An internal index into *buffer* is reset to zero whenever selection mode is entered. Each time a hit record is copied into *buffer*, the index is incremented to point to the cell just past the end of the block of namesthat is, to the next available cell. If the hit record is larger than the number of remaining locations in *buffer*, as much data as can fit is copied, and the overflow flag is set. If the name stack is empty when a hit record is copied, that record consists of zero followed by the minimum and maximum depth values.
     * 
     * Selection mode is exited by calling **glRenderMode** with an argument other than GL\_SELECT. Whenever **glRenderMode** is called while the render mode is GL\_SELECT, it returns the number of hit records copied to *buffer*, resets the overflow flag and the selection buffer pointer, and initializes the name stack to be empty. If the overflow bit was set when **glRenderMode** was called, a negative hit record count is returned.
     * 
     * The contents of *buffer* are undefined until [**glRenderMode**](glrendermode.md) is called with an argument other than GL\_SELECT.
     * 
     * The **glBegin*/*glEnd** primitives and calls to [**glRasterPos**](glrasterpos-functions.md) can result in hits.
     * 
     * The following function retrieves information related to **glSelectBuffer**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_NAME\_STACK\_DEPTH
     * @param {Integer} size The size of *buffer*.
     * @param {Pointer<UInt32>} buffer Returns the selection data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glselectbuffer
     */
    static glSelectBuffer(size, buffer) {
        DllCall("OPENGL32.dll\glSelectBuffer", "int", size, "ptr", buffer)
    }

    /**
     * The glShadeModel function selects flat or smooth shading.
     * @remarks
     * OpenGL primitives can have either flat or smooth shading. Smooth shading, the default, causes the computed colors of vertices to be interpolated as the primitive is rasterized, typically assigning different colors to each resulting pixel fragment. Flat shading selects the computed color of just one vertex and assigns it to all the pixel fragments generated by rasterizing a single primitive. In either case, the computed color of a vertex is the result of lighting, if lighting is enabled, or it is the current color at the time the vertex was specified, if lighting is disabled.
     * 
     * Flat and smooth shading are indistinguishable for points. Counting vertices and primitives from one, starting when [**glBegin**](glbegin.md) is issued, each flat-shaded line segment *i* is given the computed color of vertex *i* + 1, its second vertex. Counting similarly from one, each flat-shaded polygon is given the computed color of the vertex listed in the following table. This is the last vertex to specify the polygon in all cases except single polygons, where the first vertex specifies the flat-shaded color.
     * 
     * 
     * 
     * | Primitive type of polygon i | Vertex   |
     * |-----------------------------|----------|
     * | Single polygon (*I*=1)      | 1        |
     * | Triangle strip              | *i* + 2  |
     * | Triangle fan                | *i* + 2  |
     * | Independent triangle        | 3*I*     |
     * | Quad strip                  | 2*i* + 2 |
     * | Independent quad            | 4*I*     |
     * 
     * 
     * 
     *  
     * 
     * Flat and smooth shading are specified by **glShadeModel** with *mode* set to GL\_FLAT and GL\_SMOOTH, respectively.
     * 
     * The following function retrieves information related to **glShadeModel**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_SHADE\_MODEL
     * @param {Integer} mode A symbolic value representing a shading technique. Accepted values are GL\_FLAT and GL\_SMOOTH. The default is GL\_SMOOTH.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glshademodel
     */
    static glShadeModel(mode) {
        DllCall("OPENGL32.dll\glShadeModel", "uint", mode)
    }

    /**
     * The glStencilFunc function sets the function and reference value for stencil testing.
     * @remarks
     * Stenciling, like *z*-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using OpenGL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.
     * 
     * The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and the value in the stencil buffer. The test is enabled by [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) with argument GL\_STENCIL\_TEST. Actions taken based on the outcome of the stencil test are specified with [**glStencilOp**](glstencilop.md).
     * 
     * The *func* parameter is a symbolic constant that determines the stencil comparison function. It accepts one of the eight values shown above. The *ref* parameter is an integer reference value that is used in the stencil comparison. It is clamped to the range \[0, 2*n* 1\], where *n* is the number of bitplanes in the stencil buffer. The *mask* parameter is bitwise **AND**ed with both the reference value and the stored stencil value, with the **AND**ed values participating in the comparison.
     * 
     * If *stencil* represents the value stored in the corresponding stencil buffer location, the preceding list shows the effect of each comparison function that can be specified by *func*. Only if the comparison succeeds is the pixel passed through to the next stage in the rasterization process (see [**glStencilOp**](glstencilop.md)). All tests treat *stencil* values as unsigned integers in the range \[0, 2*n* 1\], where *n* is the number of bitplanes in the stencil buffer.
     * 
     * Initially, the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes.
     * 
     * The following functions retrieve information related to **glStencilFunc**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_STENCIL\_FUNC
     * 
     * **glGet** with argument GL\_STENCIL\_VALUE\_MASK
     * 
     * **glGet** with argument GL\_STENCIL\_REF
     * 
     * **glGet** with argument GL\_STENCIL\_BITS
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_STENCIL\_TEST
     * @param {Integer} func The test function. The following eight tokens are valid.
     * 
     * 
     * 
     * | Value                                                                                                                                                   | Meaning                                                          |
     * |---------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------|
     * | <span id="GL_NEVER"></span><span id="gl_never"></span><dl> <dt>**GL\_NEVER**</dt> </dl>          | Always fails.<br/>                                         |
     * | <span id="GL_LESS"></span><span id="gl_less"></span><dl> <dt>**GL\_LESS**</dt> </dl>             | Passes if (*ref* & *mask*) < (*stencil* & *mask*).<br/> |
     * | <span id="GL_LEQUAL"></span><span id="gl_lequal"></span><dl> <dt>**GL\_LEQUAL**</dt> </dl>       | Passes if (*ref* & *mask*) = (*stencil* & *mask*).<br/>    |
     * | <span id="GL_GREATER"></span><span id="gl_greater"></span><dl> <dt>**GL\_GREATER**</dt> </dl>    | Passes if (*ref* & *mask*) > (*stencil* & *mask*).<br/> |
     * | <span id="GL_GEQUAL"></span><span id="gl_gequal"></span><dl> <dt>**GL\_GEQUAL**</dt> </dl>       | Passes if (*ref* & *mask*) = (*stencil* & *mask*).<br/>    |
     * | <span id="GL_EQUAL"></span><span id="gl_equal"></span><dl> <dt>**GL\_EQUAL**</dt> </dl>          | Passes if (*ref* & *mask*) = (*stencil* & *mask*).<br/>    |
     * | <span id="GL_NOTEQUAL"></span><span id="gl_notequal"></span><dl> <dt>**GL\_NOTEQUAL**</dt> </dl> | Passes if (*ref* & *mask*) ? (*stencil* & *mask*).<br/>    |
     * | <span id="GL_ALWAYS"></span><span id="gl_always"></span><dl> <dt>**GL\_ALWAYS**</dt> </dl>       | Always passes.<br/>                                        |
     * @param {Integer} ref The reference value for the stencil test. The *ref* parameter is clamped to the range \[0, 2*n* 1\], where *n* is the number of bitplanes in the stencil buffer.
     * @param {Integer} mask A mask that is **AND**ed with both the reference value and the stored stencil value when the test is done.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glstencilfunc
     */
    static glStencilFunc(func, ref, mask) {
        DllCall("OPENGL32.dll\glStencilFunc", "uint", func, "int", ref, "uint", mask)
    }

    /**
     * The glStencilMask function controls the writing of individual bits in the stencil planes.
     * @remarks
     * The **glStencilMask** function controls the writing of individual bits in the stencil planes. The least significant *n* bits of *mask*, where *n* is the number of bits in the stencil buffer, specify a mask. Wherever a one appears in the mask, the corresponding bit in the stencil buffer is made writable. Where a zero appears, the bit is write-protected. Initially, all bits are enabled for writing.
     * 
     * The following functions retrieve information related to **glStencilMask**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_STENCIL\_WRITEMASK
     * 
     * glGet with argument GL\_STENCIL\_BITS
     * @param {Integer} mask A bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all ones.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glstencilmask
     */
    static glStencilMask(mask) {
        DllCall("OPENGL32.dll\glStencilMask", "uint", mask)
    }

    /**
     * The glStencilOp function sets the stencil test actions.
     * @remarks
     * Stenciling, like *z*-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using OpenGL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.
     * 
     * The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil buffer and a reference value. The test is enabled with [**glEnable**](glenable.md) and [**glDisable**](gldisable.md) calls with argument GL\_STENCIL\_TEST, and controlled with [**glStencilFunc**](glstencilfunc.md).
     * 
     * The **glStencilOp** function takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth buffers, and *fail* specifies what happens to the stencil buffer contents.
     * 
     * Stencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2*n* 1, where *n* is the value returned by querying GL\_STENCIL\_BITS.
     * 
     * The other two arguments to **glStencilOp** specify stencil buffer actions should subsequent depth buffer tests succeed (*zpass*) or fail (*zfail*). (See [**glDepthFunc**](gldepthfunc.md).) They are specified using the same six symbolic constants as *fail*. Note that *zfail* is ignored when there is no depth buffer, or when the depth buffer is not enabled. In these cases, *fail* and *zpass* specify stencil action when the stencil test fails and passes, respectively.
     * 
     * Initially the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil tests always pass, regardless of any call to **glStencilOp**.
     * 
     * The following functions retrieve information related to **glStencilOp**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_STENCIL\_FAIL
     * 
     * **glGet** with argument GL\_STENCIL\_PASS\_DEPTH\_PASS
     * 
     * **glGet** with argument GL\_STENCIL\_PASS\_DEPTH\_FAIL
     * 
     * **glGet** with argument GL\_STENCIL\_BITS
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_STENCIL\_TEST
     * @param {Integer} fail The action to take when the stencil test fails. The following six symbolic constants are accepted.
     * 
     * 
     * 
     * | Value                                                                                                                                                | Meaning                                                                                                     |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_KEEP"></span><span id="gl_keep"></span><dl> <dt>**GL\_KEEP**</dt> </dl>          | Keeps the current value.<br/>                                                                         |
     * | <span id="GL_ZERO"></span><span id="gl_zero"></span><dl> <dt>**GL\_ZERO**</dt> </dl>          | Sets the stencil buffer value to zero.<br/>                                                           |
     * | <span id="GL_REPLACE"></span><span id="gl_replace"></span><dl> <dt>**GL\_REPLACE**</dt> </dl> | Sets the stencil buffer value to *ref*, as specified by **glStencilFunc**.<br/>                       |
     * | <span id="GL_INCR"></span><span id="gl_incr"></span><dl> <dt>**GL\_INCR**</dt> </dl>          | Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.<br/> |
     * | <span id="GL_DECR"></span><span id="gl_decr"></span><dl> <dt>**GL\_DECR**</dt> </dl>          | Decrements the current stencil buffer value. Clamps to zero.<br/>                                     |
     * | <span id="GL_INVERT"></span><span id="gl_invert"></span><dl> <dt>**GL\_INVERT**</dt> </dl>    | Bitwise inverts the current stencil buffer value.<br/>                                                |
     * @param {Integer} zfail Stencil action when the stencil test passes, but the depth test fails. Accepts the same symbolic constants as *fail.*
     * @param {Integer} zpass Stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. Accepts the same symbolic constants as *fail*.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glstencilop
     */
    static glStencilOp(fail, zfail, zpass) {
        DllCall("OPENGL32.dll\glStencilOp", "uint", fail, "uint", zfail, "uint", zpass)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord1d function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Float} s The s texture coordinate.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord1d
     */
    static glTexCoord1d(s) {
        DllCall("OPENGL32.dll\glTexCoord1d", "double", s)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord1dv function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Pointer<Double>} v A pointer to an array of texture coordinates.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord1dv
     */
    static glTexCoord1dv(v) {
        DllCall("OPENGL32.dll\glTexCoord1dv", "ptr", v)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord1f function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Float} s The s texture coordinate.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord1f
     */
    static glTexCoord1f(s) {
        DllCall("OPENGL32.dll\glTexCoord1f", "float", s)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord1fv function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Pointer<Single>} v A pointer to an array of texture coordinates.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord1fv
     */
    static glTexCoord1fv(v) {
        DllCall("OPENGL32.dll\glTexCoord1fv", "ptr", v)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord1i function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Integer} s The s texture coordinate.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord1i
     */
    static glTexCoord1i(s) {
        DllCall("OPENGL32.dll\glTexCoord1i", "int", s)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord1iv function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Pointer<Int32>} v A pointer to an array of texture coordinates.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord1iv
     */
    static glTexCoord1iv(v) {
        DllCall("OPENGL32.dll\glTexCoord1iv", "ptr", v)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord1s function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Integer} s The s texture coordinate.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord1s
     */
    static glTexCoord1s(s) {
        DllCall("OPENGL32.dll\glTexCoord1s", "short", s)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord1sv function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Pointer<Int16>} v A pointer to an array of texture coordinates.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord1sv
     */
    static glTexCoord1sv(v) {
        DllCall("OPENGL32.dll\glTexCoord1sv", "ptr", v)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord2d function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Float} s The s texture coordinate.
     * @param {Float} t The t texture coordinate.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord2d
     */
    static glTexCoord2d(s, t) {
        DllCall("OPENGL32.dll\glTexCoord2d", "double", s, "double", t)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord2dv function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Pointer<Double>} v A pointer to an array of two elements, which in turn specifies the s and t texture coordinates.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord2dv
     */
    static glTexCoord2dv(v) {
        DllCall("OPENGL32.dll\glTexCoord2dv", "ptr", v)
    }

    /**
     * 
     * @param {Float} s 
     * @param {Float} t 
     * @returns {String} Nothing - always returns an empty string
     */
    static glTexCoord2f(s, t) {
        DllCall("OPENGL32.dll\glTexCoord2f", "float", s, "float", t)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord2fv function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Pointer<Single>} v A pointer to an array of two elements, which in turn specifies the s and t texture coordinates.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord2fv
     */
    static glTexCoord2fv(v) {
        DllCall("OPENGL32.dll\glTexCoord2fv", "ptr", v)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord2i function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Integer} s The s texture coordinate.
     * @param {Integer} t The t texture coordinate.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord2i
     */
    static glTexCoord2i(s, t) {
        DllCall("OPENGL32.dll\glTexCoord2i", "int", s, "int", t)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord2iv function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Pointer<Int32>} v A pointer to an array of two elements, which in turn specifies the s and t texture coordinates.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord2iv
     */
    static glTexCoord2iv(v) {
        DllCall("OPENGL32.dll\glTexCoord2iv", "ptr", v)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord2s function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Integer} s The s texture coordinate.
     * @param {Integer} t The t texture coordinate.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord2s
     */
    static glTexCoord2s(s, t) {
        DllCall("OPENGL32.dll\glTexCoord2s", "short", s, "short", t)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord2sv function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Pointer<Int16>} v A pointer to an array of two elements, which in turn specifies the s and t texture coordinates.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord2sv
     */
    static glTexCoord2sv(v) {
        DllCall("OPENGL32.dll\glTexCoord2sv", "ptr", v)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord3d function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Float} s The s texture coordinate.
     * @param {Float} t The t texture coordinate.
     * @param {Float} r The r texture coordinate.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord3d
     */
    static glTexCoord3d(s, t, r) {
        DllCall("OPENGL32.dll\glTexCoord3d", "double", s, "double", t, "double", r)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord3dv function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Pointer<Double>} v A pointer to an array of three elements, which in turn specifies the s, t, and r texture coordinates.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord3dv
     */
    static glTexCoord3dv(v) {
        DllCall("OPENGL32.dll\glTexCoord3dv", "ptr", v)
    }

    /**
     * 
     * @param {Float} s 
     * @param {Float} t 
     * @param {Float} r 
     * @returns {String} Nothing - always returns an empty string
     */
    static glTexCoord3f(s, t, r) {
        DllCall("OPENGL32.dll\glTexCoord3f", "float", s, "float", t, "float", r)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord3fv function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Pointer<Single>} v A pointer to an array of three elements, which in turn specifies the s, t, and r texture coordinates.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord3fv
     */
    static glTexCoord3fv(v) {
        DllCall("OPENGL32.dll\glTexCoord3fv", "ptr", v)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord3i function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Integer} s The s texture coordinate.
     * @param {Integer} t The t texture coordinate.
     * @param {Integer} r The r texture coordinate.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord3i
     */
    static glTexCoord3i(s, t, r) {
        DllCall("OPENGL32.dll\glTexCoord3i", "int", s, "int", t, "int", r)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord3iv function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Pointer<Int32>} v A pointer to an array of three elements, which in turn specifies the s, t, and r texture coordinates.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord3iv
     */
    static glTexCoord3iv(v) {
        DllCall("OPENGL32.dll\glTexCoord3iv", "ptr", v)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord3s function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Integer} s The s texture coordinate.
     * @param {Integer} t The t texture coordinate.
     * @param {Integer} r The r texture coordinate.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord3s
     */
    static glTexCoord3s(s, t, r) {
        DllCall("OPENGL32.dll\glTexCoord3s", "short", s, "short", t, "short", r)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord3sv function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Pointer<Int16>} v A pointer to an array of three elements, which in turn specifies the s, t, and r texture coordinates.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord3sv
     */
    static glTexCoord3sv(v) {
        DllCall("OPENGL32.dll\glTexCoord3sv", "ptr", v)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord4d function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Float} s The s texture coordinate.
     * @param {Float} t The t texture coordinate.
     * @param {Float} r The r texture coordinate.
     * @param {Float} q The q texture coordinate.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord4d
     */
    static glTexCoord4d(s, t, r, q) {
        DllCall("OPENGL32.dll\glTexCoord4d", "double", s, "double", t, "double", r, "double", q)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord4dv function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Pointer<Double>} v A pointer to an array of four elements, which in turn specifies the s, t, r, and q texture coordinates.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord4dv
     */
    static glTexCoord4dv(v) {
        DllCall("OPENGL32.dll\glTexCoord4dv", "ptr", v)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord4f function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Float} s The s texture coordinate.
     * @param {Float} t The t texture coordinate.
     * @param {Float} r The r texture coordinate.
     * @param {Float} q The q texture coordinate.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord4f
     */
    static glTexCoord4f(s, t, r, q) {
        DllCall("OPENGL32.dll\glTexCoord4f", "float", s, "float", t, "float", r, "float", q)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord4fv function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Pointer<Single>} v A pointer to an array of four elements, which in turn specifies the s, t, r, and q texture coordinates.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord4fv
     */
    static glTexCoord4fv(v) {
        DllCall("OPENGL32.dll\glTexCoord4fv", "ptr", v)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord4i function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Integer} s The s texture coordinate.
     * @param {Integer} t The t texture coordinate.
     * @param {Integer} r The r texture coordinate.
     * @param {Integer} q The q texture coordinate.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord4i
     */
    static glTexCoord4i(s, t, r, q) {
        DllCall("OPENGL32.dll\glTexCoord4i", "int", s, "int", t, "int", r, "int", q)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord4iv function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Pointer<Int32>} v A pointer to an array of four elements, which in turn specifies the s, t, r, and q texture coordinates.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord4iv
     */
    static glTexCoord4iv(v) {
        DllCall("OPENGL32.dll\glTexCoord4iv", "ptr", v)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord4s function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Integer} s The s texture coordinate.
     * @param {Integer} t The t texture coordinate.
     * @param {Integer} r The r texture coordinate.
     * @param {Integer} q The q texture coordinate.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord4s
     */
    static glTexCoord4s(s, t, r, q) {
        DllCall("OPENGL32.dll\glTexCoord4s", "short", s, "short", t, "short", r, "short", q)
    }

    /**
     * Sets the current texture coordinates. | glTexCoord4sv function (Gl.h)
     * @remarks
     * The [**glTexCoord**](gltexcoord-functions.md) function sets the current texture coordinates that are part of the data associated with polygon vertices. The **glTexCoord** function specifies texture coordinates in one, two, three, or four dimensions. The glTexCoord1 function sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1). Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q). You can update the current texture coordinates at any time. In particular, you can call glTexCoord between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md). The following function retrieves information related to **glTexCoord**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_TEXTURE\_COORDS
     * @param {Pointer<Int16>} v A pointer to an array of four elements, which in turn specifies the s, t, r, and q texture coordinates.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoord4sv
     */
    static glTexCoord4sv(v) {
        DllCall("OPENGL32.dll\glTexCoord4sv", "ptr", v)
    }

    /**
     * The glTexCoordPointer function defines an array of texture coordinates.
     * @remarks
     * The **glTexCoordPointer** function specifies the location and data of an array of texture coordinates to use when rendering.The *size* parameter specifies the number of coordinates used for each element of the array.The *type* parameter specifies the data type of each texture coordinate. The *stride* parameter determines the byte offset from one array element to the next, enabling the packing of vertices and attributes in a single array or storage in separate arrays. In some implementations, storing the vertices and attributes in a single array can be more efficient than using separate arrays. For more information, see [**glInterleavedArrays**](glinterleavedarrays.md). When a texture coordinate array is specified, size, type, stride, and pointer are saved client-side state.
     * 
     * A texture coordinate array is enabled when you specify the **GL\_TEXTURE\_COORD\_ARRAY** constant with [**glEnableClientState**](glenableclientstate.md). When enabled, [**glDrawArrays**](gldrawarrays.md), [**glDrawElements**](gldrawelements.md), and [**glArrayElement**](glarrayelement.md) use the texture coordinate array. By default the texture coordinate array is disabled.
     * 
     * You cannot include **glTexCoordPointer** in display lists.
     * 
     * When you specify a texture coordinate array using **glTexCoordPointer**, the values of all the function's texture coordinate array parameters are saved in a client-side state, and static array elements can be cached. Because the texture coordinate array parameters are client-side state, their values are not saved or restored by [**glPushAttrib**](glpushattrib.md) and [**glPopAttrib**](glpopattrib.md).
     * 
     * Although no error is generated when you call **glTexCoordPointer** within [**glBegin**](glbegin.md) and [**glEnd**](glend.md) pairs, the results are undefined.
     * 
     * The following functions retrieve information related to **glTexCoordPointer**:
     * 
     * [**glIsEnabled**](glisenabled.md) with argument **GL\_TEXTURE\_COORD\_ARRAY**
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument **GL\_TEXTURE\_COORD\_ARRAY\_SIZE**
     * 
     * **glGet** with argument **GL\_TEXTURE\_COORD\_ARRAY\_STRIDE**
     * 
     * **glGet** with argument **GL\_TEXTURE\_COORD\_ARRAY\_COUNT**
     * 
     * **glGet** with argument **GL\_TEXTURE\_COORD\_ARRAY\_TYPE**
     * 
     * [**glGetPointerv**](glgetpointerv.md) with argument **GL\_TEXTURE\_COORD\_ARRAY\_POINTER**
     * @param {Integer} size The number of coordinates per array element. The value of *size* must be 1, 2, 3, or 4.
     * @param {Integer} type The data type of each texture coordinate in the array using the following symbolic constants: **GL\_SHORT**, **GL\_INT**, **GL\_FLOAT**, and **GL\_DOUBLE**.
     * @param {Integer} stride The byte offset between consecutive array elements. When *stride* is zero, the array elements are tightly packed in the array.
     * @param {Pointer<Void>} pointer A pointer to the first coordinate of the first element in the array.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexcoordpointer
     */
    static glTexCoordPointer(size, type, stride, pointer) {
        DllCall("OPENGL32.dll\glTexCoordPointer", "int", size, "uint", type, "int", stride, "ptr", pointer)
    }

    /**
     * The glTexEnvf function sets a texture environment parameter.
     * @remarks
     * A texture environment specifies how texture values are interpreted when a fragment is textured. The *target* parameter must be GL\_TEXTURE\_ENV. The *pname* parameter is GL\_TEXTURE\_ENV\_MODE. Three texture functions are defined: GL\_MODULATE, GL\_DECAL, and GL\_BLEND.
     * 
     * A texture function acts on the fragment to be textured using the texture image value that applies to the fragment (see [**glTexParameter**](gltexparameter-functions.md)) and produces an RGBA color for that fragment. The following table shows how the RGBA color is produced for each of the three texture functions that can be chosen. *C* is a triple of color values (RGB) and *A* is the associated alpha value. RGBA values extracted from a texture image are in the range \[0, 1\]. The subscript *f* refers to the incoming fragment, the subscript *t* to the texture image, the subscript *c* to the texture environment color, and subscript *v* indicates a value produced by the texture function.
     * 
     * A texture image can have up to four components per texture element (see [**glTexImage1D**](glteximage1d.md) and [**glTexImage2D**](glteximage2d.md)). In a one-component image, Lt indicates that single component. A two-component image uses *L?*  and *A?* . A three-component image has only a color value, *C?* . A four-component image has both a color value *C?*  and an alpha value *A?* .
     * 
     * 
     * 
     * <table>
     * <thead>
     * <tr class="header">
     * <th>Number of components</th>
     * <th>GL_MODULATE</th>
     * <th>GL_DECAL</th>
     * <th>GL_BLEND</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr class="odd">
     * <td rowspan="2">1${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em> = <em>L?</em> <em>C<sub>f</sub></em></td>
     * <td rowspan="2">undefined${REMOVE}$<br />
     * </td>
     * <td><em>C</em> <em><sub>v</sub></em> = <em>(1</em> - <em>L?</em> <em>)C<sub>f</sub></em> + <em>L?</em> <em>C<sub>c</sub></em></td>
     * </tr>
     * <tr class="even">
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em></td>
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em></td>
     * 
     * 
     * </tr>
     * <tr class="odd">
     * <td rowspan="2">2${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em> = <em>L?</em> <em>C<sub>f</sub></em></td>
     * <td rowspan="2">undefined${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em> = <em>(1</em> - <em>L?</em> <em>)C<sub>f</sub></em> + <em>L?</em> <em>C<sub>c</sub></em></td>
     * </tr>
     * <tr class="even">
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em></td>
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em></td>
     * 
     * 
     * </tr>
     * <tr class="odd">
     * <td rowspan="2">3${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em> = <em>C?</em> <em>C<sub>f</sub></em></td>
     * <td><em>C<sub>v</sub></em> = <em>C?</em></td>
     * <td rowspan="2">undefined${REMOVE}$<br />
     * </td>
     * </tr>
     * <tr class="even">
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em> </td>
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em></td>
     * 
     * 
     * </tr>
     * <tr class="odd">
     * <td rowspan="2">4${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em> = <em>C?</em> <em>C<sub>f</sub></em></td>
     * <td><em>C<sub>v</sub></em> = (1 - <em>A?</em> <em>)C<sub>f</sub></em> + <em>A?</em> <em>C?</em></td>
     * <td rowspan="2">undefined${REMOVE}$<br />
     * </td>
     * </tr>
     * <tr class="even">
     * <td><em>A<sub>v</sub></em> = <em>A?</em> <em>A<sub>f</sub></em> </td>
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em></td>
     * 
     * 
     * </tr>
     * </tbody>
     * </table>
     * 
     * 
     * 
     *  
     * 
     * GL\_TEXTURE\_ENV\_MODE defaults to GL\_MODULATE.
     * 
     * The following function retrieves information related to **glTexEnvf**:
     * 
     * [**glTexGetEnvfv**](glgettexenvfv.md)
     * @param {Integer} target A texture environment. Must be GL\_TEXTURE\_ENV.
     * @param {Integer} pname The symbolic name of a single-valued texture environment parameter. Must be GL\_TEXTURE\_ENV\_MODE.
     * @param {Float} param2 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexenvf
     */
    static glTexEnvf(target, pname, param2) {
        DllCall("OPENGL32.dll\glTexEnvf", "uint", target, "uint", pname, "float", param2)
    }

    /**
     * The glTexEnvfv function sets a texture environment parameter.
     * @remarks
     * A texture environment specifies how texture values are interpreted when a fragment is textured. The *target* parameter must be GL\_TEXTURE\_ENV. The *pname* parameter can be either GL\_TEXTURE\_ENV\_MODE or GL\_TEXTURE\_ENV\_COLOR.
     * 
     * If *pname* is GL\_TEXTURE\_ENV\_MODE, then *params* is (or points to) the symbolic name of a texture function. Three texture functions are defined: GL\_MODULATE, GL\_DECAL, and GL\_BLEND.
     * 
     * A texture function acts on the fragment to be textured using the texture image value that applies to the fragment (see [**glTexParameter**](gltexparameter-functions.md)) and produces an RGBA color for that fragment. The following table shows how the RGBA color is produced for each of the three texture functions that can be chosen. *C* is a triple of color values (RGB) and *A* is the associated alpha value. RGBA values extracted from a texture image are in the range \[0, 1\]. The subscript *f* refers to the incoming fragment, the subscript *t* to the texture image, the subscript *c* to the texture environment color, and subscript *v* indicates a value produced by the texture function.
     * 
     * A texture image can have up to four components per texture element (see [**glTexImage1D**](glteximage1d.md) and [**glTexImage2D**](glteximage2d.md)). In a one-component image, Lt indicates that single component. A two-component image uses *L?*  and *A?* . A three-component image has only a color value, *C?* . A four-component image has both a color value *C?*  and an alpha value *A?* .
     * 
     * 
     * 
     * <table>
     * <thead>
     * <tr class="header">
     * <th>Number of components</th>
     * <th>GL_MODULATE</th>
     * <th>GL_DECAL</th>
     * <th>GL_BLEND</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr class="odd">
     * <td rowspan="2">1${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em> = <em>L?</em> <em>C<sub>f</sub></em></td>
     * <td rowspan="2">undefined${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em> = <em>(1</em> - <em>L?</em> <em>)C<sub>f</sub></em> + <em>L?</em> <em>C<sub>c</sub></em></td>
     * </tr>
     * <tr class="even">
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em></td>
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em></td>
     * 
     * 
     * </tr>
     * <tr class="odd">
     * <td rowspan="2">2${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em> = <em>L?</em> <em>C<sub>f</sub></em></td>
     * <td rowspan="2">undefined${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em> = <em>(1</em> - <em>L?</em> <em>)C<sub>f</sub></em> + <em>L?</em> <em>C<sub>c</sub></em></td>
     * </tr>
     * <tr class="even">
     * <td><em>A</em> <em><sub>v</sub></em>  = <em>A<sub>f</sub></em></td>
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em></td>
     * 
     * 
     * </tr>
     * <tr class="odd">
     * <td rowspan="2">3${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em> = <em>C?</em> <em>C<sub>f</sub></em></td>
     * <td><em>C<sub>v</sub></em> = <em>C?</em></td>
     * <td rowspan="2">undefined${REMOVE}$<br />
     * </td>
     * </tr>
     * <tr class="even">
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em> </td>
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em></td>
     * 
     * 
     * </tr>
     * <tr class="odd">
     * <td rowspan="2">4${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em> = <em>C?</em> <em>C<sub>f</sub></em></td>
     * <td><em>C<sub>v</sub></em> = (1 - <em>A?</em> <em>)C<sub>f</sub></em> + <em>A?</em> <em>C?</em></td>
     * <td rowspan="2">undefined${REMOVE}$<br />
     * </td>
     * </tr>
     * <tr class="even">
     * <td><em>A<sub>v</sub></em> = <em>A?</em> <em>A<sub>f</sub></em> </td>
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em></td>
     * 
     * 
     * </tr>
     * </tbody>
     * </table>
     * 
     * 
     * 
     *  
     * 
     * If pname is GL\_TEXTURE\_ENV\_COLOR, *params* is a pointer to an array that holds an RGBA color consisting of four values. Integer color components are interpreted linearly such that the most positive integer maps to 1.0, and the most negative integer maps to -1.0. The values are clamped to the range \[0, 1\] when they are specified. *C<sub>c</sub>* takes these four values.
     * 
     * GL\_TEXTURE\_ENV\_MODE defaults to GL\_MODULATE and GL\_TEXTURE\_ENV\_COLOR defaults to (0, 0, 0, 0).
     * 
     * The following function retrieves information related to **glTexEnvfv**:
     * 
     * [**glTexGetEnvfv**](glgettexenvfv.md)
     * @param {Integer} target A texture environment. Must be GL\_TEXTURE\_ENV.
     * @param {Integer} pname The symbolic name of a single-valued texture environment parameter. Accepted values are GL\_TEXTURE\_ENV\_MODE and GL\_TEXTURE\_ENV\_COLOR.
     * @param {Pointer<Single>} params A pointer to an array of parameters: either a single symbolic constant or an RGBA color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexenvfv
     */
    static glTexEnvfv(target, pname, params) {
        DllCall("OPENGL32.dll\glTexEnvfv", "uint", target, "uint", pname, "ptr", params)
    }

    /**
     * The glTexEnvi function sets a texture environment parameter.
     * @remarks
     * A texture environment specifies how texture values are interpreted when a fragment is textured. The *target* parameter must be GL\_TEXTURE\_ENV. The *pname* parameter is GL\_TEXTURE\_ENV\_MODE. Three texture functions are defined: GL\_MODULATE, GL\_DECAL, and GL\_BLEND.
     * 
     * A texture function acts on the fragment to be textured using the texture image value that applies to the fragment (see [**glTexParameter**](gltexparameter-functions.md)) and produces an RGBA color for that fragment. The following table shows how the RGBA color is produced for each of the three texture functions that can be chosen. *C* is a triple of color values (RGB) and *A* is the associated alpha value. RGBA values extracted from a texture image are in the range \[0, 1\]. The subscript *f* refers to the incoming fragment, the subscript *t* to the texture image, the subscript *c* to the texture environment color, and subscript *v* indicates a value produced by the texture function.
     * 
     * A texture image can have up to four components per texture element (see [**glTexImage1D**](glteximage1d.md) and [**glTexImage2D**](glteximage2d.md)). In a one-component image, Lt indicates that single component. A two-component image uses *L?*  and *A?* . A three-component image has only a color value, *C?* . A four-component image has both a color value *C?*  and an alpha value *A?* .
     * 
     * 
     * 
     * <table>
     * <thead>
     * <tr class="header">
     * <th>Number of components</th>
     * <th>GL_MODULATE</th>
     * <th>GL_DECAL</th>
     * <th>GL_BLEND</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr class="odd">
     * <td rowspan="2">1${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em> = <em>L?</em> <em>C<sub>f</sub></em></td>
     * <td rowspan="2">undefined${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em> = <em>(1</em> - <em>L?</em> <em>)C<sub>f</sub></em> + <em>L?</em> <em>C<sub>c</sub></em></td>
     * </tr>
     * <tr class="even">
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em></td>
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em></td>
     * 
     * 
     * </tr>
     * <tr class="odd">
     * <td rowspan="2">2${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em> = <em>L?</em> <em>C<sub>f</sub></em></td>
     * <td rowspan="2">undefined${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em> = <em>(1</em> - <em>L?</em> <em>)C<sub>f</sub></em> + <em>L?</em> <em>C<sub>c</sub></em></td>
     * </tr>
     * <tr class="even">
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em></td>
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em></td>
     * 
     * 
     * </tr>
     * <tr class="odd">
     * <td rowspan="2">3${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em> = <em>C?</em> <em>C<sub>f</sub></em></td>
     * <td><em>C<sub>v</sub></em> = <em>C?</em></td>
     * <td rowspan="2">undefined${REMOVE}$<br />
     * </td>
     * </tr>
     * <tr class="even">
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em> </td>
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em></td>
     * 
     * 
     * </tr>
     * <tr class="odd">
     * <td rowspan="2">4${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em> = <em>C?</em> <em>C<sub>f</sub></em></td>
     * <td><em>C<sub>v</sub></em> = (1 - <em>A?</em> <em>)C<sub>f</sub></em> + <em>A?</em> <em>C?</em></td>
     * <td rowspan="2">undefined${REMOVE}$<br />
     * </td>
     * </tr>
     * <tr class="even">
     * <td><em>A<sub>v</sub></em> = <em>A?</em> <em>A<sub>f</sub></em> </td>
     * <td><em>A<sub>v</sub></em> = <em>A<sub>f</sub></em></td>
     * 
     * 
     * </tr>
     * </tbody>
     * </table>
     * 
     * 
     * 
     *  
     * 
     * GL\_TEXTURE\_ENV\_MODE defaults to GL\_MODULATE.
     * 
     * The following function retrieves information related to **glTexEnvi**:
     * 
     * [**glTexGetEnviv**](glgettexenviv.md)
     * @param {Integer} target A texture environment. Must be GL\_TEXTURE\_ENV.
     * @param {Integer} pname The symbolic name of a single-valued texture environment parameter. Must be GL\_TEXTURE\_ENV\_MODE.
     * @param {Integer} param2 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexenvi
     */
    static glTexEnvi(target, pname, param2) {
        DllCall("OPENGL32.dll\glTexEnvi", "uint", target, "uint", pname, "int", param2)
    }

    /**
     * The glTexEnviv function sets a texture environment parameter.
     * @remarks
     * A texture environment specifies how texture values are interpreted when a fragment is textured. The *target* parameter must be GL\_TEXTURE\_ENV. The *pname* parameter can be either GL\_TEXTURE\_ENV\_MODE or GL\_TEXTURE\_ENV\_COLOR.
     * 
     * If *pname* is GL\_TEXTURE\_ENV\_MODE, then *params* is (or points to) the symbolic name of a texture function. Three texture functions are defined: GL\_MODULATE, GL\_DECAL, and GL\_BLEND.
     * 
     * A texture function acts on the fragment to be textured using the texture image value that applies to the fragment (see [**glTexParameter**](gltexparameter-functions.md)) and produces an RGBA color for that fragment. The following table shows how the RGBA color is produced for each of the three texture functions that can be chosen. *C* is a triple of color values (RGB) and *A* is the associated alpha value. RGBA values extracted from a texture image are in the range \[0, 1\]. The subscript *f* refers to the incoming fragment, the subscript *t* to the texture image, the subscript *c* to the texture environment color, and subscript *v* indicates a value produced by the texture function.
     * 
     * A texture image can have up to four components per texture element (see [**glTexImage1D**](glteximage1d.md) and [**glTexImage2D**](glteximage2d.md)). In a one-component image, Lt indicates that single component. A two-component image uses *L?*  and *A?* . A three-component image has only a color value, *C?* . A four-component image has both a color value *C?*  and an alpha value *A?* .
     * 
     * 
     * 
     * <table>
     * <thead>
     * <tr class="header">
     * <th>Number of components</th>
     * <th>GL_MODULATE</th>
     * <th>GL_DECAL</th>
     * <th>GL_BLEND</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr class="odd">
     * <td rowspan="2">1${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em>  = <em>L?</em> <em>C<sub>f</sub></em></td>
     * <td rowspan="2">undefined${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em>  = <em>(1</em> - <em>L?</em> <em>)C<sub>f</sub></em> + <em>L?</em> <em>C<sub>c</sub></em></td>
     * </tr>
     * <tr class="even">
     * <td><em>A<sub>v</sub></em>  = <em>A<sub>f</sub></em></td>
     * <td><em>A<sub>v</sub></em>  = <em>A<sub>f</sub></em></td>
     * 
     * 
     * </tr>
     * <tr class="odd">
     * <td rowspan="2">2${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em>  = <em>L?</em> <em>C<sub>f</sub></em></td>
     * <td rowspan="2">undefined${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em>  = <em>(1</em> - <em>L?</em> <em>)C<sub>f</sub></em> + <em>L?</em> <em>C<sub>c</sub></em></td>
     * </tr>
     * <tr class="even">
     * <td><em>A<sub>v</sub></em>  = <em>A<sub>f</sub></em></td>
     * <td><em>A<sub>v</sub></em>  = <em>A<sub>f</sub></em></td>
     * 
     * 
     * </tr>
     * <tr class="odd">
     * <td rowspan="2">3${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em>  = <em>C?</em> <em>C<sub>f</sub></em></td>
     * <td><em>C<sub>v</sub></em>  = <em>C?</em></td>
     * <td rowspan="2">undefined${REMOVE}$<br />
     * </td>
     * </tr>
     * <tr class="even">
     * <td><em>A<sub>v</sub></em>  = <em>A<sub>f</sub></em> </td>
     * <td><em>A<sub>v</sub></em>  = <em>A<sub>f</sub></em></td>
     * 
     * 
     * </tr>
     * <tr class="odd">
     * <td rowspan="2">4${REMOVE}$<br />
     * </td>
     * <td><em>C<sub>v</sub></em>  = <em>C?</em> <em>C<sub>f</sub></em></td>
     * <td><em>C<sub>v</sub></em>  = (1 - <em>A?</em> <em>)C<sub>f</sub></em> + <em>A?</em> <em>C?</em></td>
     * <td rowspan="2">undefined${REMOVE}$<br />
     * </td>
     * </tr>
     * <tr class="even">
     * <td><em>A<sub>v</sub></em>  = <em>A?</em> <em>A<sub>f</sub></em> </td>
     * <td><em>A<sub>v</sub></em>  = <em>A<sub>f</sub></em></td>
     * 
     * 
     * </tr>
     * </tbody>
     * </table>
     * 
     * 
     * 
     *  
     * 
     * If pname is GL\_TEXTURE\_ENV\_COLOR, *params* is a pointer to an array that holds an RGBA color consisting of four values. Integer color components are interpreted linearly such that the most positive integer maps to 1.0, and the most negative integer maps to -1.0. The values are clamped to the range \[0, 1\] when they are specified. *C<sub>c</sub>* takes these four values.
     * 
     * GL\_TEXTURE\_ENV\_MODE defaults to GL\_MODULATE and GL\_TEXTURE\_ENV\_COLOR defaults to (0, 0, 0, 0).
     * 
     * The following function retrieves information related to **glTexEnviv**:
     * 
     * [**glTexGetEnviv**](glgettexenviv.md)
     * @param {Integer} target A texture environment. Must be GL\_TEXTURE\_ENV.
     * @param {Integer} pname The symbolic name of a single-valued texture environment parameter. Accepted values are GL\_TEXTURE\_ENV\_MODE and GL\_TEXTURE\_ENV\_COLOR.
     * @param {Pointer<Int32>} params A pointer to an array of parameters: either a single symbolic constant or an RGBA color.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexenviv
     */
    static glTexEnviv(target, pname, params) {
        DllCall("OPENGL32.dll\glTexEnviv", "uint", target, "uint", pname, "ptr", params)
    }

    /**
     * Controls the generation of texture coordinates. | glTexGend function (Gl.h)
     * @remarks
     * The **glTexGen** function selects a texture-coordinate generation function or supplies coefficients for one of the functions. The *coord* parameter names one of the (s,t,r,q) texture coordinates, and it must be one of these symbols: GL\_S, GL\_T, GL\_R, or GL\_Q. The *pname* parameter must be one of three symbolic constants: GL\_TEXTURE\_GEN\_MODE, GL\_OBJECT\_PLANE, or GL\_EYE\_PLANE. If *pname* is GL\_TEXTURE\_GEN\_MODE, then *param* specifies a mode, one of GL\_OBJECT\_LINEAR, GL\_EYE\_LINEAR, or GL\_SPHERE\_MAP. If *pname* is either GL\_OBJECT\_PLANE or GL\_EYE\_PLANE, *param* contains coefficients for the corresponding texture generation function.
     * 
     * If the texture generation function is GL\_OBJECT\_LINEAR, the function
     * 
     * ![Equation showing the glTexGen function when the texture generation function is GL_OBJECT_LINEAR.](images/tex02.png)
     * 
     * is used, where g is the value computed for the coordinate named in coord; p1, p2, p3, and p4 are the four values supplied in params; and x?, y?, z?, and w? are the object coordinates of the vertex. You can use this function to texture-map terrain by using sea level as a reference plane (defined by p1, p2, p3, and p4). The GL\_OBJECT\_LINEAR coordinate generation function computes the altitude of a terrain vertex as its distance from sea level; that altitude is used to index the texture image to map white snow onto peaks and green grass onto foothills, for example.
     * 
     * If the texture generation function is GL\_EYE\_LINEAR, the function
     * 
     * ![Equation showing the glTexGen function when the texture generation function is GL_EYE_LINEAR.](images/tex02.png)
     * 
     * is used, where
     * 
     * ![Equation showing the eye coordinates of the vertex.](images/tex03.png)
     * 
     * and x?, y?, z?, and w? are the eye coordinates of the vertex, p1, p2, p3, and p4 are the values supplied in *param*, and M is the modelview matrix when you call **glTexGen**. If M is poorly conditioned or singular, texture coordinates generated by the resulting function can be inaccurate or undefined.
     * 
     * The values in *param* define a reference plane in eye coordinates. The modelview matrix that is applied to them cannot be the same one in effect when the polygon vertices are transformed. This function establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
     * 
     * If *pname* is GL\_SPHERE\_MAP and *coord* is either GL\_S or GL\_T, s and t texture coordinates are generated as follows. Let u be the unit vector pointing from the origin to the polygon vertex (in eye coordinates). Let n  be the current normal, after transformation to eye coordinates. Let f = (fx ( ) fy ( ) fz)T be the reflection vector such that
     * 
     * ![Equation showing the reflection vector as a function of unit vector and current normal.](images/tex05.png)
     * 
     * Finally, let
     * 
     * ![Equation showing m as a function of reflection vector.](images/tex07.png)
     * 
     * Then the values assigned to the i and t texture coordinates are
     * 
     * ![Equation showing values assigned to the i and t texture coordinates.](images/tex06.png)
     * 
     * You can enable or disable a texture-coordinate generation function by using [**glEnable**](glenable.md) or [**glDisable**](gldisable.md) with one of the symbolic texture-coordinate names (GL\_TEXTURE\_GEN\_S, GL\_TEXTURE\_GEN\_T, GL\_TEXTURE\_GEN\_R, or GL\_TEXTURE\_GEN\_Q) as the argument. When this function is enabled, the specified texture coordinate is computed according to the generating function associated with that coordinate. When the function is disabled, subsequent vertices take the specified texture coordinate from the current set of texture coordinates. Initially, all texture generation functions are set to GL\_EYE\_LINEAR and are disabled. Both s plane equations are (1,0,0,0); both t plane equations are (0,1,0,0); and all r and q plane equations are (0,0,0,0).
     * 
     * The following functions retrieve information related to glTexGen:
     * 
     * <dl>
     * 
     * [**glGetTexGen**](glgettexgen.md)  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_S  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_T  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_R  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_Q  
     * </dl>
     * @param {Integer} coord A texture coordinate. Must be one of the following: GL\_S, GL\_T, GL\_R, or GL\_Q.
     * @param {Integer} pname The symbolic name of the texture coordinate generation function.
     * @param {Float} param2 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexgend
     */
    static glTexGend(coord, pname, param2) {
        DllCall("OPENGL32.dll\glTexGend", "uint", coord, "uint", pname, "double", param2)
    }

    /**
     * Controls the generation of texture coordinates. | glTexGendv function (Gl.h)
     * @remarks
     * The **glTexGen** function selects a texture-coordinate generation function or supplies coefficients for one of the functions. The *coord* parameter names one of the (s,t,r,q) texture coordinates, and it must be one of these symbols: GL\_S, GL\_T, GL\_R, or GL\_Q. The *pname* parameter must be one of three symbolic constants: GL\_TEXTURE\_GEN\_MODE, GL\_OBJECT\_PLANE, or GL\_EYE\_PLANE. If *pname* is either GL\_OBJECT\_PLANE or GL\_EYE\_PLANE, *param* contains coefficients for the corresponding texture generation function.
     * 
     * If the texture generation function is GL\_OBJECT\_LINEAR, the function
     * 
     * ![Equation showing the glTexGen function when the texture generation function is GL_OBJECT_LINEAR.]
     * 
     * is used, where g is the value computed for the coordinate named in coord; p1, p2, p3, and p4 are the four values supplied in params; and x?, y?, z?, and w? are the object coordinates of the vertex. You can use this function to texture-map terrain by using sea level as a reference plane (defined by p1, p2, p3, and p4). The GL\_OBJECT\_LINEAR coordinate generation function computes the altitude of a terrain vertex as its distance from sea level; that altitude is used to index the texture image to map white snow onto peaks and green grass onto foothills, for example.
     * 
     * If the texture generation function is GL\_EYE\_LINEAR, the function
     * 
     * ![Equation showing the glTexGen function when the texture generation function is GL_EYE_LINEAR.]
     * 
     * is used, where
     * 
     * ![Equation showing the eye coordinates of the vertex.](images/tex03.png)
     * 
     * and x?, y?, z?, and w? are the eye coordinates of the vertex, p1, p2, p3, and p4 are the values supplied in *param*, and M is the modelview matrix when you **callglTexGen**. If M is poorly conditioned or singular, texture coordinates generated by the resulting function can be inaccurate or undefined.
     * 
     * Note that the values in *param* define a reference plane in eye coordinates. The modelview matrix that is applied to them may not be the same one in effect when the polygon vertices are transformed. This function establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
     * 
     * If *pname* is GL\_SPHERE\_MAP and *coord* is either GL\_S or GL\_T, s and t texture coordinates are generated as follows. Let u be the unit vector pointing from the origin to the polygon vertex (in eye coordinates). Let n  be the current normal, after transformation to eye coordinates. Let f = (fx ( ) fy ( ) fz)T be the reflection vector such that
     * 
     * ![Equation showing the reflection vector as a function of unit vector and current normal.](images/tex05.png)
     * 
     * Finally, let
     * 
     * ![Equation showing m as a function of reflection vector.](images/tex07.png)
     * 
     * Then the values assigned to the i and t texture coordinates are
     * 
     * ![Equation showing values assigned to the i and t texture coordinates.](images/tex06.png)
     * 
     * You can enable or disable a texture-coordinate generation function by using [**glEnable**](glenable.md) or [**glDisable**](gldisable.md) with one of the symbolic texture-coordinate names (GL\_TEXTURE\_GEN\_S, GL\_TEXTURE\_GEN\_T, GL\_TEXTURE\_GEN\_R, or GL\_TEXTURE\_GEN\_Q) as the argument. When this function is enabled, the specified texture coordinate is computed according to the generating function associated with that coordinate. When this function is disabled, subsequent vertices take the specified texture coordinate from the current set of texture coordinates. Initially, all texture generation functions are set to GL\_EYE\_LINEAR and are disabled. Both s plane equations are (1,0,0,0); both t plane equations are (0,1,0,0); and all r and q plane equations are (0,0,0,0).
     * 
     * The following functions retrieve information related to glTexGen:
     * 
     * <dl>
     * 
     * [**glGetTexGen**](glgettexgen.md)  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_S  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_T  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_R  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_Q  
     * </dl>
     * @param {Integer} coord A texture coordinate. Must be one of the following: GL\_S, GL\_T, GL\_R, or GL\_Q.
     * @param {Integer} pname The symbolic name of the texture coordinate generation function.
     * @param {Pointer<Double>} params An array that contains the coefficients for the corresponding texture generation function.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexgendv
     */
    static glTexGendv(coord, pname, params) {
        DllCall("OPENGL32.dll\glTexGendv", "uint", coord, "uint", pname, "ptr", params)
    }

    /**
     * Controls the generation of texture coordinates. | glTexGenf function (Gl.h)
     * @remarks
     * The **glTexGen** function selects a texture-coordinate generation function or supplies coefficients for one of the functions. The *coord* parameter names one of the (s,t,r,q) texture coordinates, and it must be one of these symbols: GL\_S, GL\_T, GL\_R, or GL\_Q. The *pname* parameter must be one of three symbolic constants: GL\_TEXTURE\_GEN\_MODE, GL\_OBJECT\_PLANE, or GL\_EYE\_PLANE. If *pname* is GL\_TEXTURE\_GEN\_MODE, then *param* specifies a mode, one of GL\_OBJECT\_LINEAR, GL\_EYE\_LINEAR, or GL\_SPHERE\_MAP. If *pname* is either GL\_OBJECT\_PLANE or GL\_EYE\_PLANE, *param* contains coefficients for the corresponding texture generation function.
     * 
     * If the texture generation function is GL\_OBJECT\_LINEAR, the function
     * 
     * ![Equation showing the glTexGen function when the texture generation function is GL_OBJECT_LINEAR.]
     * 
     * is used, where g is the value computed for the coordinate named in coord; p1, p2, p3, and p4 are the four values supplied in params; and x?, y?, z?, and w? are the object coordinates of the vertex. You can use this function to texture-map terrain by using sea level as a reference plane (defined by p1, p2, p3, and p4). The GL\_OBJECT\_LINEAR coordinate generation function computes the altitude of a terrain vertex as its distance from sea level; that altitude is used to index the texture image to map white snow onto peaks and green grass onto foothills, for example.
     * 
     * If the texture generation function is GL\_EYE\_LINEAR, the function
     * 
     * ![Equation showing the glTexGen function when the texture generation function is GL_EYE_LINEAR.]
     * 
     * is used, where
     * 
     * ![Equation showing the eye coordinates of the vertex.](images/tex03.png)
     * 
     * and x?, y?, z?, and w? are the eye coordinates of the vertex, p1, p2, p3, and p4 are the values supplied in *param*, and M is the modelview matrix when you call **glTexGen**. If M is poorly conditioned or singular, texture coordinates generated by the resulting function can be inaccurate or undefined.
     * 
     * Note that the values in *param* define a reference plane in eye coordinates. The modelview matrix that is applied to them may not be the same one in effect when the polygon vertices are transformed. This function establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
     * 
     * If *pname* is GL\_SPHERE\_MAP and *coord* is either GL\_S or GL\_T, s and t texture coordinates are generated as follows. Let u be the unit vector pointing from the origin to the polygon vertex (in eye coordinates). Let n  be the current normal, after transformation to eye coordinates. Let f = (fx ( ) fy ( ) fz)T be the reflection vector such that
     * 
     * ![Equation showing the reflection vector as a function of unit vector and current normal.](images/tex05.png)
     * 
     * Finally, let
     * 
     * ![Equation showing m as a function of reflection vector.](images/tex07.png)
     * 
     * Then the values assigned to the i and t texture coordinates are
     * 
     * ![Equation showing values assigned to the i and t texture coordinates.](images/tex06.png)
     * 
     * You can enable or disable a texture-coordinate generation function by using [**glEnable**](glenable.md) or [**glDisable**](gldisable.md) with one of the symbolic texture-coordinate names (GL\_TEXTURE\_GEN\_S, GL\_TEXTURE\_GEN\_T, GL\_TEXTURE\_GEN\_R, or GL\_TEXTURE\_GEN\_Q) as the argument. When this function is enabled, the specified texture coordinate is computed according to the generating function associated with that coordinate. When this function is disabled, subsequent vertices take the specified texture coordinate from the current set of texture coordinates. Initially, all texture generation functions are set to GL\_EYE\_LINEAR and are disabled. Both s plane equations are (1,0,0,0); both t plane equations are (0,1,0,0); and all r and q plane equations are (0,0,0,0).
     * 
     * The following functions retrieve information related to glTexGen:
     * 
     * <dl>
     * 
     * [**glGetTexGen**](glgettexgen.md)  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_S  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_T  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_R  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_Q  
     * </dl>
     * @param {Integer} coord A texture coordinate. Must be one of the following: GL\_S, GL\_T, GL\_R, or GL\_Q.
     * @param {Integer} pname The symbolic name of the texture coordinate generation function.
     * @param {Float} param2 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexgenf
     */
    static glTexGenf(coord, pname, param2) {
        DllCall("OPENGL32.dll\glTexGenf", "uint", coord, "uint", pname, "float", param2)
    }

    /**
     * Controls the generation of texture coordinates. | glTexGenfv function (Gl.h)
     * @remarks
     * The **glTexGen** function selects a texture-coordinate generation function or supplies coefficients for one of the functions. The *coord* parameter names one of the (s,t,r,q) texture coordinates, and it must be one of these symbols: GL\_S, GL\_T, GL\_R, or GL\_Q. The *pname* parameter must be one of three symbolic constants: GL\_TEXTURE\_GEN\_MODE, GL\_OBJECT\_PLANE, or GL\_EYE\_PLANE. If *pname* is either GL\_OBJECT\_PLANE or GL\_EYE\_PLANE, *param* contains coefficients for the corresponding texture generation function.
     * 
     * If the texture generation function is GL\_OBJECT\_LINEAR, the function
     * 
     * ![Equation showing the glTexGen function when the texture generation function is GL_OBJECT_LINEAR.]
     * 
     * is used, where g is the value computed for the coordinate named in coord; p1, p2, p3, and p4 are the four values supplied in params; and x?, y?, z?, and w? are the object coordinates of the vertex. You can use this function to texture-map terrain by using sea level as a reference plane (defined by p1, p2, p3, and p4). The GL\_OBJECT\_LINEAR coordinate generation function computes the altitude of a terrain vertex as its distance from sea level; that altitude is used to index the texture image to map white snow onto peaks and green grass onto foothills, for example.
     * 
     * If the texture generation function is GL\_EYE\_LINEAR, the function
     * 
     * ![Equation showing the glTexGen function when the texture generation function is GL_EYE_LINEAR.]
     * 
     * is used, where
     * 
     * ![Equation showing the eye coordinates of the vertex.](images/tex03.png)
     * 
     * and x?, y?, z?, and w? are the eye coordinates of the vertex, p1, p2, p3, and p4 are the values supplied in *param*, and M is the modelview matrix when you call **glTexGen**. If M is poorly conditioned or singular, texture coordinates generated by the resulting function can be inaccurate or undefined.
     * 
     * Note that the values in *param* define a reference plane in eye coordinates. The modelview matrix that is applied to them may not be the same one in effect when the polygon vertices are transformed. This function establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
     * 
     * If *pname* is GL\_SPHERE\_MAP and *coord* is either GL\_S or GL\_T, s and t texture coordinates are generated as follows. Let u be the unit vector pointing from the origin to the polygon vertex (in eye coordinates). Let n  be the current normal, after transformation to eye coordinates. Let f = (fx ( ) fy ( ) fz)T be the reflection vector such that
     * 
     * ![Equation showing the reflection vector as a function of unit vector and current normal.](images/tex05.png)
     * 
     * Finally, let
     * 
     * ![Equation showing m as a function of reflection vector.](images/tex07.png)
     * 
     * Then the values assigned to the i and t texture coordinates are
     * 
     * ![Equation showing values assigned to the i and t texture coordinates.](images/tex06.png)
     * 
     * You can enable or disable a texture-coordinate generation function by using [**glEnable**](glenable.md) or [**glDisable**](gldisable.md) with one of the symbolic texture-coordinate names (GL\_TEXTURE\_GEN\_S, GL\_TEXTURE\_GEN\_T, GL\_TEXTURE\_GEN\_R, or GL\_TEXTURE\_GEN\_Q) as the argument. When this function is enabled, the specified texture coordinate is computed according to the generating function associated with that coordinate. When this function is disabled, subsequent vertices take the specified texture coordinate from the current set of texture coordinates. Initially, all texture generation functions are set to GL\_EYE\_LINEAR and are disabled. Both s plane equations are (1,0,0,0); both t plane equations are (0,1,0,0); and all r and q plane equations are (0,0,0,0).
     * 
     * The following functions retrieve information related to glTexGen:
     * 
     * <dl>
     * 
     * [**glGetTexGen**](glgettexgen.md)  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_S  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_T  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_R  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_Q  
     * </dl>
     * @param {Integer} coord A texture coordinate. Must be one of the following: GL\_S, GL\_T, GL\_R, or GL\_Q.
     * @param {Integer} pname The symbolic name of the texture coordinate generation function.
     * @param {Pointer<Single>} params An array of floats that contains the coefficients for the corresponding texture generation function.
     * 
     * ``` syntax
     * GLfloat zPlane[] = { 0.0f, 0.0f, 1.0f, 0.0f };
     * ```
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexgenfv
     */
    static glTexGenfv(coord, pname, params) {
        DllCall("OPENGL32.dll\glTexGenfv", "uint", coord, "uint", pname, "ptr", params)
    }

    /**
     * Controls the generation of texture coordinates. | glTexGeni function (Gl.h)
     * @remarks
     * The **glTexGen** function selects a texture-coordinate generation function or supplies coefficients for one of the functions. The *coord* parameter names one of the (s,t,r,q) texture coordinates, and it must be one of these symbols: GL\_S, GL\_T, GL\_R, or GL\_Q. The *pname* parameter must be one of three symbolic constants: GL\_TEXTURE\_GEN\_MODE, GL\_OBJECT\_PLANE, or GL\_EYE\_PLANE. If *pname* is GL\_TEXTURE\_GEN\_MODE, then *param* specifies a mode, one of GL\_OBJECT\_LINEAR, GL\_EYE\_LINEAR, or GL\_SPHERE\_MAP. If *pname* is either GL\_OBJECT\_PLANE or GL\_EYE\_PLANE, *param* contains coefficients for the corresponding texture generation function.
     * 
     * If the texture generation function is GL\_OBJECT\_LINEAR, the function
     * 
     * ![Equation showing the glTexGen function when the texture generation function is GL_OBJECT_LINEAR.]
     * 
     * is used, where g is the value computed for the coordinate named in coord; p1, p2, p3, and p4 are the four values supplied in params; and x?, y?, z?, and w? are the object coordinates of the vertex. You can use this function to texture-map terrain by using sea level as a reference plane (defined by p1, p2, p3, and p4). The GL\_OBJECT\_LINEAR coordinate generation function computes the altitude of a terrain vertex as its distance from sea level; that altitude is used to index the texture image to map white snow onto peaks and green grass onto foothills, for example.
     * 
     * If the texture generation function is GL\_EYE\_LINEAR, the function
     * 
     * ![Equation showing the glTexGen function when the texture generation function is GL_EYE_LINEAR.]
     * 
     * is used, where
     * 
     * ![Equation showing the eye coordinates of the vertex.](images/tex03.png)
     * 
     * and x?, y?, z?, and w? are the eye coordinates of the vertex, p1, p2, p3, and p4 are the values supplied in *param*, and M is the modelview matrix when you call **glTexGen**. If M is poorly conditioned or singular, texture coordinates generated by the resulting function can be inaccurate or undefined.
     * 
     * Note that the values in *param* define a reference plane in eye coordinates. The modelview matrix that is applied to them may not be the same one in effect when the polygon vertices are transformed. This function establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
     * 
     * If *pname* is GL\_SPHERE\_MAP and *coord* is either GL\_S or GL\_T, s and t texture coordinates are generated as follows. Let u be the unit vector pointing from the origin to the polygon vertex (in eye coordinates). Let n  be the current normal, after transformation to eye coordinates. Let f = (fx ( ) fy ( ) fz)T be the reflection vector such that
     * 
     * ![Equation showing the reflection vector as a function of unit vector and current normal.](images/tex05.png)
     * 
     * Finally, let
     * 
     * ![Equation showing m as a function of reflection vector.](images/tex07.png)
     * 
     * Then the values assigned to the i and t texture coordinates are
     * 
     * ![Equation showing values assigned to the i and t texture coordinates.](images/tex06.png)
     * 
     * You can enable or disable a texture-coordinate generation function by using [**glEnable**](glenable.md) or [**glDisable**](gldisable.md) with one of the symbolic texture-coordinate names (GL\_TEXTURE\_GEN\_S, GL\_TEXTURE\_GEN\_T, GL\_TEXTURE\_GEN\_R, or GL\_TEXTURE\_GEN\_Q) as the argument. When this function is enabled, the specified texture coordinate is computed according to the generating function associated with that coordinate. When this function is disabled, subsequent vertices take the specified texture coordinate from the current set of texture coordinates. Initially, all texture generation functions are set to GL\_EYE\_LINEAR and are disabled. Both s plane equations are (1,0,0,0); both t plane equations are (0,1,0,0); and all r and q plane equations are (0,0,0,0).
     * 
     * The following functions retrieve information related to glTexGen:
     * 
     * <dl>
     * 
     * [**glGetTexGen**](glgettexgen.md)  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_S  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_T  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_R  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_Q  
     * </dl>
     * @param {Integer} coord A texture coordinate. Must be one of the following: GL\_S, GL\_T, GL\_R, or GL\_Q.
     * @param {Integer} pname The symbolic name of the texture coordinate generation function.
     * @param {Integer} param2 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexgeni
     */
    static glTexGeni(coord, pname, param2) {
        DllCall("OPENGL32.dll\glTexGeni", "uint", coord, "uint", pname, "int", param2)
    }

    /**
     * Controls the generation of texture coordinates. | glTexGeniv function (Gl.h)
     * @remarks
     * The **glTexGen** function selects a texture-coordinate generation function or supplies coefficients for one of the functions. The *coord* parameter names one of the (s,t,r,q) texture coordinates, and it must be one of these symbols: GL\_S, GL\_T, GL\_R, or GL\_Q. The *pname* parameter must be one of three symbolic constants: GL\_TEXTURE\_GEN\_MODE, GL\_OBJECT\_PLANE, or GL\_EYE\_PLANE. If *pname* is either GL\_OBJECT\_PLANE or GL\_EYE\_PLANE, *param* contains coefficients for the corresponding texture generation function.
     * 
     * If the texture generation function is GL\_OBJECT\_LINEAR, the function
     * 
     * ![Equation showing the glTexGen function when the texture generation function is GL_OBJECT_LINEAR.]
     * 
     * is used, where g is the value computed for the coordinate named in coord; p1, p2, p3, and p4 are the four values supplied in params; and x?, y?, z?, and w? are the object coordinates of the vertex. You can use this function to texture-map terrain by using sea level as a reference plane (defined by p1, p2, p3, and p4). The GL\_OBJECT\_LINEAR coordinate generation function computes the altitude of a terrain vertex as its distance from sea level; that altitude is used to index the texture image to map white snow onto peaks and green grass onto foothills, for example.
     * 
     * If the texture generation function is GL\_EYE\_LINEAR, the function
     * 
     * ![Equation showing the glTexGen function when the texture generation function is GL_EYE_LINEAR.]
     * 
     * is used, where
     * 
     * ![Equation showing the eye coordinates of the vertex.](images/tex03.png)
     * 
     * and x?, y?, z?, and w? are the eye coordinates of the vertex, p1, p2, p3, and p4 are the values supplied in *param*, and M is the modelview matrix when you call **glTexGen**. If M is poorly conditioned or singular, texture coordinates generated by the resulting function can be inaccurate or undefined.
     * 
     * Note that the values in *param* define a reference plane in eye coordinates. The modelview matrix that is applied to them may not be the same one in effect when the polygon vertices are transformed. This function establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
     * 
     * If *pname* is GL\_SPHERE\_MAP and *coord* is either GL\_S or GL\_T, s and t texture coordinates are generated as follows. Let u be the unit vector pointing from the origin to the polygon vertex (in eye coordinates). Let n  be the current normal, after transformation to eye coordinates. Let f = (fx ( ) fy ( ) fz)T be the reflection vector such that
     * 
     * ![Equation showing the reflection vector as a function of unit vector and current normal.](images/tex05.png)
     * 
     * Finally, let
     * 
     * ![Equation showing m as a function of reflection vector.](images/tex07.png)
     * 
     * Then the values assigned to the i and t texture coordinates are
     * 
     * ![Equation showing values assigned to the i and t texture coordinates.](images/tex06.png)
     * 
     * You can enable or disable a texture-coordinate generation function by using [**glEnable**](glenable.md) or [**glDisable**](gldisable.md) with one of the symbolic texture-coordinate names (GL\_TEXTURE\_GEN\_S, GL\_TEXTURE\_GEN\_T, GL\_TEXTURE\_GEN\_R, or GL\_TEXTURE\_GEN\_Q) as the argument. When this function is enabled, the specified texture coordinate is computed according to the generating function associated with that coordinate. When this function is disabled, subsequent vertices take the specified texture coordinate from the current set of texture coordinates. Initially, all texture generation functions are set to GL\_EYE\_LINEAR and are disabled. Both s plane equations are (1,0,0,0); both t plane equations are (0,1,0,0); and all r and q plane equations are (0,0,0,0).
     * 
     * The following functions retrieve information related to glTexGen:
     * 
     * <dl>
     * 
     * [**glGetTexGen**](glgettexgen.md)  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_S  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_T  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_R  
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_GEN\_Q  
     * </dl>
     * @param {Integer} coord A texture coordinate. Must be one of the following: GL\_S, GL\_T, GL\_R, or GL\_Q.
     * @param {Integer} pname The symbolic name of the texture coordinate generation function.
     * @param {Pointer<Int32>} params An array that contains the coefficients for the corresponding texture generation function.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexgeniv
     */
    static glTexGeniv(coord, pname, params) {
        DllCall("OPENGL32.dll\glTexGeniv", "uint", coord, "uint", pname, "ptr", params)
    }

    /**
     * The glTexImage1D function specifies a one-dimensional texture image.
     * @remarks
     * The **glTexImage1D** function specifies a one-dimensional texture image. Texturing maps a portion of a specified *texture image* onto each graphical primitive for which texturing is enabled. One-dimensional texturing is enabled and disabled using [**glEnable**](glenable.md) and **glDisable** with argument GL\_TEXTURE\_1D.
     * 
     * Texture images are defined with **glTexImage1D**. The arguments describe the parameters of the texture image, such as width, width of the border, level-of-detail number (see [**glTexParameter**](gltexparameter-functions.md)), and number of color components provided. The last three arguments describe the way the image is represented in memory. These arguments are identical to the pixel formats used for [**glDrawPixels**](gldrawpixels.md).
     * 
     * Data is read from *pixels* as a sequence of signed or unsigned bytes, shorts or longs, or single-precision floating-point values, depending on *type*. These values are grouped into sets of one, two, three, or four values, depending on *format*, to form elements. If *type* is GL\_BITMAP, the data is considered as a string of unsigned bytes (and *format* must be GL\_COLOR\_INDEX). Each data byte is treated as eight 1-bit elements, with bit ordering determined by GL\_UNPACK\_LSB\_FIRST (see [**glPixelStore**](glpixelstore-functions.md)).
     * 
     * A texture image can have up to four components per texture element, depending on *components*. A one-component texture image uses only the red component of the RGBA color extracted from *pixels*. A two-component image uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.
     * 
     * Texturing has no effect in color-index mode.
     * 
     * The texture image can be represented by the same data formats as the pixels in a [**glDrawPixels**](gldrawpixels.md) command, except that GL\_STENCIL\_INDEX and GL\_DEPTH\_COMPONENT cannot be used. The [**glPixelStore**](glpixelstore-functions.md) and [**glPixelTransfer**](glpixeltransfer.md) modes affect texture images in exactly the way they affect **glDrawPixels**.
     * 
     * A texture image with zero width indicates the null texture. If the null texture is specified for level-of-detail 0, it is as if texturing were disabled.
     * 
     * The following functions retrieve information related to **glTexImageID**:
     * 
     * [**glGetTexImage**](glgetteximage.md)
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_1D
     * @param {Integer} target The target texture. Must be GL\_TEXTURE\_1D.
     * @param {Integer} level The level-of-detail number. Level 0 is the base image level. Level *n* is the *n*Th mipmap reduction image.
     * @param {Integer} internalformat Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL\_ALPHA, GL\_ALPHA4, GL\_ALPHA8, GL\_ALPHA12, GL\_ALPHA16, GL\_LUMINANCE, GL\_LUMINANCE4, GL\_LUMINANCE8, GL\_LUMINANCE12, GL\_LUMINANCE16, GL\_LUMINANCE\_ALPHA, GL\_LUMINANCE4\_ALPHA4, GL\_LUMINANCE6\_ALPHA2, GL\_LUMINANCE8\_ALPHA8, GL\_LUMINANCE12\_ALPHA4, GL\_LUMINANCE12\_ALPHA12, GL\_LUMINANCE16\_ALPHA16, GL\_INTENSITY, GL\_INTENSITY4, GL\_INTENSITY8, GL\_INTENSITY12, GL\_INTENSITY16, GL\_RGB, GL\_R3\_G3\_B2, GL\_RGB4, GL\_RGB5, GL\_RGB8, GL\_RGB10, GL\_RGB12, GL\_RGB16, GL\_RGBA, GL\_RGBA2, GL\_RGBA4, GL\_RGB5\_A1, GL\_RGBA8, GL\_RGB10\_A2, GL\_RGBA12, or GL\_RGBA16.
     * @param {Integer} width The width of the texture image. Must be 2*n* + 2( *border* ) for some integer *n*. The height of the texture image is 1.
     * @param {Integer} border The width of the border. Must be either 0 or 1.
     * @param {Integer} format The format of the pixel data. It can assume one of nine symbolic values.
     * 
     * 
     * 
     * | Value                                                                                                                                                                         | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_COLOR_INDEX"></span><span id="gl_color_index"></span><dl> <dt>**GL\_COLOR\_INDEX**</dt> </dl>             | Each element is a single value, a color index. It is converted to fixed point (with an unspecified number of 0 bits to the right of the binary point), shifted left or right, depending on the value and sign of GL\_INDEX\_SHIFT, and added to GL\_INDEX\_OFFSET (see [**glPixelTransfer**](glpixeltransfer.md)). The resulting index is converted to a set of color components using the GL\_PIXEL\_MAP\_I\_TO\_R, GL\_PIXEL\_MAP\_I\_TO\_G, GL\_PIXEL\_MAP\_I\_TO\_B, and GL\_PIXEL\_MAP\_I\_TO\_A tables, and clamped to the range \[0,1\].<br/> |
     * | <span id="GL_RED"></span><span id="gl_red"></span><dl> <dt>**GL\_RED**</dt> </dl>                                      | Each element is a single red component. It is converted to floating point and assembled into an RGBA element by attaching 0.0 for green and blue, and 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                                                |
     * | <span id="GL_GREEN"></span><span id="gl_green"></span><dl> <dt>**GL\_GREEN**</dt> </dl>                                | Each element is a single green component. It is converted to floating point and assembled into an RGBA element by attaching 0.0 for red and blue, and 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see [**glPixelTransfer**](glpixeltransfer.md)).<br/>                                                                                                                                                                         |
     * | <span id="GL_BLUE"></span><span id="gl_blue"></span><dl> <dt>**GL\_BLUE**</dt> </dl>                                   | Each element is a single blue component. It is converted to floating point and assembled into an RGBA element by attaching 0.0 for red and green, and 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                                                |
     * | <span id="GL_ALPHA"></span><span id="gl_alpha"></span><dl> <dt>**GL\_ALPHA**</dt> </dl>                                | Each element is a single red component. It is converted to floating point and assembled into an RGBA element by attaching 0.0 for red, green, and blue. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see [**glPixelTransfer**](glpixeltransfer.md)).<br/>                                                                                                                                                                                      |
     * | <span id="GL_RGB"></span><span id="gl_rgb"></span><dl> <dt>**GL\_RGB**</dt> </dl>                                      | Each element is an RGB triple. It is converted to floating point and assembled into an RGBA element by attaching 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                                                                                     |
     * | <span id="GL_RGBA"></span><span id="gl_rgba"></span><dl> <dt>**GL\_RGBA**</dt> </dl>                                   | Each element is a complete RGBA element. It is converted to floating point. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_BGR_EXT"></span><span id="gl_bgr_ext"></span><dl> <dt>**GL\_BGR\_EXT**</dt> </dl>                         | Each pixel is a group of three components in this order: blue, green, red.<br/> GL\_BGR\_EXT provides a format that matches the memory layout of Windows device-independent bitmaps (DIBs). Thus your applications can use the same data with Windows function calls and OpenGL pixel function calls.<br/>                                                                                                                                                                                                                                      |
     * | <span id="GL_BGRA_EXT"></span><span id="gl_bgra_ext"></span><dl> <dt>**GL\_BGRA\_EXT**</dt> </dl>                      | Each pixel is a group of four components in this order: blue, green, red, alpha.<br/> GL\_BGRA\_EXT provides a format that matches the memory layout of Windows device-independent bitmaps (DIBs). Thus your applications can use the same data with Windows function calls and OpenGL pixel function calls.<br/>                                                                                                                                                                                                                               |
     * | <span id="GL_LUMINANCE"></span><span id="gl_luminance"></span><dl> <dt>**GL\_LUMINANCE**</dt> </dl>                    | Each element is a single luminance value. It is converted to floating point, and then assembled into an RGBA element by replicating the luminance value three times for red, green, and blue, and attaching 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see [**glPixelTransfer**](glpixeltransfer.md)).<br/>                                                                                                                   |
     * | <span id="GL_LUMINANCE_ALPHA"></span><span id="gl_luminance_alpha"></span><dl> <dt>**GL\_LUMINANCE\_ALPHA**</dt> </dl> | Each element is a luminance/alpha pair. It is converted to floating point, and then assembled into an RGBA element by replicating the luminance value three times for red, green, and blue. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                         |
     * @param {Integer} type The data type of the pixel data. The following symbolic values are accepted: GL\_UNSIGNED\_BYTE, GL\_BYTE, GL\_BITMAP, GL\_UNSIGNED\_SHORT, GL\_SHORT, GL\_UNSIGNED\_INT, GL\_INT, and GL\_FLOAT.
     * @param {Pointer<Void>} pixels A pointer to the image data in memory.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glteximage1d
     */
    static glTexImage1D(target, level, internalformat, width, border, format, type, pixels) {
        DllCall("OPENGL32.dll\glTexImage1D", "uint", target, "int", level, "int", internalformat, "int", width, "int", border, "uint", format, "uint", type, "ptr", pixels)
    }

    /**
     * The glTexImage2D function specifies a two-dimensional texture image.
     * @remarks
     * The **glTexImage2D** function specifies a two-dimensional texture image. Texturing maps a portion of a specified *texture image* onto each graphical primitive for which texturing is enabled. Two-dimensional texturing is enabled and disabled using [**glEnable**](glenable.md) and **glDisable** with argument GL\_TEXTURE\_2D.
     * 
     * Texture images are defined with **glTexImage2D**. The arguments describe the parameters of the texture image, such as height, width, width of the border, level-of-detail number (see [**glTexParameter**](gltexparameter-functions.md)), and number of color components provided. The last three arguments describe the way the image is represented in memory. These arguments are identical to the pixel formats used for [**glDrawPixels**](gldrawpixels.md).
     * 
     * Data is read from *pixels* as a sequence of signed or unsigned bytes, shorts or longs, or single-precision floating-point values, depending on *type*. These values are grouped into sets of one, two, three, or four values, depending on *format*, to form elements. If *type* is GL\_BITMAP, the data is considered as a string of unsigned bytes (and *format* must be GL\_COLOR\_INDEX). Each data byte is treated as eight 1-bit elements, with bit ordering determined by GL\_UNPACK\_LSB\_FIRST (see [**glPixelStore**](glpixelstore-functions.md)). Please see [**glDrawPixels**](gldrawpixels.md) for a description of the acceptable values for the *type* parameter.
     * 
     * A texture image can have up to four components per texture element, depending on *components*. A one-component texture image uses only the red component of the RGBA color extracted from *pixels*. A two-component image uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.
     * 
     * Texturing has no effect in color-index mode.
     * 
     * The texture image can be represented by the same data formats as the pixels in a **glDrawPixels** command, except that GL\_STENCIL\_INDEX and GL\_DEPTH\_COMPONENT cannot be used. The [**glPixelStore**](glpixelstore-functions.md) and [**glPixelTransfer**](glpixeltransfer.md) modes affect texture images in exactly the way they affect **glDrawPixels**.
     * 
     * A texture image with zero height or width indicates the null texture. If the null texture is specified for level-of-detail 0, it is as if texturing were disabled.
     * 
     * The following functions retrieve information related to **glTexImage2D**:
     * 
     * [**glGetTexImage**](glgetteximage.md)
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_2D
     * @param {Integer} target The target texture. Must be GL\_TEXTURE\_2D.
     * @param {Integer} level The level-of-detail number. Level 0 is the base image level. Level *n* is the *n* th mipmap reduction image.
     * @param {Integer} internalformat The number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL\_ALPHA, GL\_ALPHA4, GL\_ALPHA8, GL\_ALPHA12, GL\_ALPHA16, GL\_LUMINANCE, GL\_LUMINANCE4, GL\_LUMINANCE8, GL\_LUMINANCE12, GL\_LUMINANCE16, GL\_LUMINANCE\_ALPHA, GL\_LUMINANCE4\_ALPHA4, GL\_LUMINANCE6\_ALPHA2, GL\_LUMINANCE8\_ALPHA8, GL\_LUMINANCE12\_ALPHA4, GL\_LUMINANCE12\_ALPHA12, GL\_LUMINANCE16\_ALPHA16, GL\_INTENSITY, GL\_INTENSITY4, GL\_INTENSITY8, GL\_INTENSITY12, GL\_INTENSITY16, GL\_R3\_G3\_B2, GL\_RGB, GL\_RGB4, GL\_RGB5, GL\_RGB8, GL\_RGB10, GL\_RGB12, GL\_RGB16, GL\_RGBA, GL\_RGBA2, GL\_RGBA4, GL\_RGB5\_A1, GL\_RGBA8, GL\_RGB10\_A2, GL\_RGBA12, or GL\_RGBA16.
     * @param {Integer} width The width of the texture image. Must be 2*n* + 2(*border*) for some integer *n*.
     * @param {Integer} height The height of the texture image. Must be 2*<sup>m</sup>* + 2(*border*) for some integer *m*.
     * @param {Integer} border The width of the border. Must be either 0 or 1.
     * @param {Integer} format The format of the pixel data. It can assume one of nine symbolic values.
     * 
     * 
     * 
     * | Value                                                                                                                                                                         | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_COLOR_INDEX"></span><span id="gl_color_index"></span><dl> <dt>**GL\_COLOR\_INDEX**</dt> </dl>             | Each element is a single value, a color index. It is converted to fixed point (with an unspecified number of 0 bits to the right of the binary point), shifted left or right depending on the value and sign of GL\_INDEX\_SHIFT, and added to GL\_INDEX\_OFFSET (see [**glPixelTransfer**](glpixeltransfer.md)). The resulting index is converted to a set of color components using the GL\_PIXEL\_MAP\_I\_TO\_R, GL\_PIXEL\_MAP\_I\_TO\_G, GL\_PIXEL\_MAP\_I\_TO\_B, and GL\_PIXEL\_MAP\_I\_TO\_A tables, and clamped to the range \[0,1\].<br/> |
     * | <span id="GL_RED"></span><span id="gl_red"></span><dl> <dt>**GL\_RED**</dt> </dl>                                      | Each element is a single red component. It is converted to floating point and assembled into an RGBA element by attaching 0.0 for green and blue, and 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                                               |
     * | <span id="GL_GREEN"></span><span id="gl_green"></span><dl> <dt>**GL\_GREEN**</dt> </dl>                                | Each element is a single green component. It is converted to floating point and assembled into an RGBA element by attaching 0.0 for red and blue, and 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see [**glPixelTransfer**](glpixeltransfer.md)).<br/>                                                                                                                                                                        |
     * | <span id="GL_BLUE"></span><span id="gl_blue"></span><dl> <dt>**GL\_BLUE**</dt> </dl>                                   | Each element is a single blue component. It is converted to floating point and assembled into an RGBA element by attaching 0.0 for red and green, and 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                                               |
     * | <span id="GL_ALPHA"></span><span id="gl_alpha"></span><dl> <dt>**GL\_ALPHA**</dt> </dl>                                | Each element is a single red component. It is converted to floating point and assembled into an RGBA element by attaching 0.0 for red, green, and blue. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see [**glPixelTransfer**](glpixeltransfer.md)).<br/>                                                                                                                                                                                     |
     * | <span id="GL_RGB"></span><span id="gl_rgb"></span><dl> <dt>**GL\_RGB**</dt> </dl>                                      | Each element is an RGB triple. It is converted to floating point and assembled into an RGBA element by attaching 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                                                                                    |
     * | <span id="GL_RGBA"></span><span id="gl_rgba"></span><dl> <dt>**GL\_RGBA**</dt> </dl>                                   | Each element is a complete RGBA element. It is converted to floating point. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see [**glPixelTransfer**](glpixeltransfer.md)).<br/>                                                                                                                                                                                                                                                                 |
     * | <span id="GL_BGR_EXT"></span><span id="gl_bgr_ext"></span><dl> <dt>**GL\_BGR\_EXT**</dt> </dl>                         | Each pixel is a group of three components in this order: blue, green, red.<br/> GL\_BGR\_EXT provides a format that matches the memory layout of Windows device-independent bitmaps (DIBs). Thus your applications can use the same data with Windows function calls and OpenGL pixel function calls.<br/>                                                                                                                                                                                                                                     |
     * | <span id="GL_BGRA_EXT"></span><span id="gl_bgra_ext"></span><dl> <dt>**GL\_BGRA\_EXT**</dt> </dl>                      | Each pixel is a group of four components in this order: blue, green, red, alpha. GL\_BGRA\_EXT provides a format that matches the memory layout of Windows device-independent bitmaps (DIBs). Thus your applications can use the same data with Windows function calls and OpenGL pixel function calls.<br/>                                                                                                                                                                                                                                         |
     * | <span id="GL_LUMINANCE"></span><span id="gl_luminance"></span><dl> <dt>**GL\_LUMINANCE**</dt> </dl>                    | Each element is a single luminance value. It is converted to floating point, and then assembled into an RGBA element by replicating the luminance value three times for red, green, and blue, and attaching 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                         |
     * | <span id="GL_LUMINANCE_ALPHA"></span><span id="gl_luminance_alpha"></span><dl> <dt>**GL\_LUMINANCE\_ALPHA**</dt> </dl> | Each element is a luminance/alpha pair. It is converted to floating point, and then assembled into an RGBA element by replicating the luminance value three times for red, green, and blue. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see [**glPixelTransfer**](glpixeltransfer.md)).<br/>                                                                                                                                                 |
     * @param {Integer} type The data type of the pixel data. The following symbolic values are accepted: GL\_UNSIGNED\_BYTE, GL\_BYTE, GL\_BITMAP, GL\_UNSIGNED\_SHORT, GL\_SHORT, GL\_UNSIGNED\_INT, GL\_INT, and GL\_FLOAT.
     * @param {Pointer<Void>} pixels A pointer to the image data in memory.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glteximage2d
     */
    static glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels) {
        DllCall("OPENGL32.dll\glTexImage2D", "uint", target, "int", level, "int", internalformat, "int", width, "int", height, "int", border, "uint", format, "uint", type, "ptr", pixels)
    }

    /**
     * Sets texture parameters. | glTexParameterf function (Gl.h)
     * @remarks
     * Texture mapping is a technique that applies an image onto an object's surface as if the image were a decal or cellophane shrink-wrap. The image is created in texture space, with an (*s*, *t*) coordinate system. A texture is a one- or two-dimensional image and a set of parameters that determine how samples are derived from the image.
     * 
     * The **glTexParameter** function assigns the value or values in params to the texture parameter specified as pname. The target parameter defines the target texture, either GL\_TEXTURE\_1D or GL\_TEXTURE\_2D.
     * 
     * As more texture elements are sampled in the minification process, fewer aliasing artifacts will be apparent. While the GL\_NEAREST and GL\_LINEAR minification functions can be faster than the other four, they sample only one or four texture elements to determine the texture value of the pixel being rendered and can produce moire patterns or ragged transitions. The default value of GL\_TEXTURE\_MIN\_FILTER is GL\_NEAREST\_MIPMAP\_LINEAR.
     * 
     * Suppose that texturing is enabled (by calling [**glEnable**](glenable.md) with argument GL\_TEXTURE\_1D or GL\_TEXTURE\_2D) and GL\_TEXTURE\_MIN\_FILTER is set to one of the functions that requires a mipmap. If either the dimensions of the texture images currently defined (with previous calls to [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md)) do not follow the proper sequence for mipmaps, or there are fewer texture images defined than are needed, or the set of texture images have differing numbers of texture components, then it is as if texture mapping were disabled. Linear filtering accesses the four nearest texture elements only in 2-D textures. In 1-D textures, linear filtering accesses the two nearest texture elements. The following function retrieves information related to **glTexParameterf**, **glTexParameteri**, **glTexParameterfv**, and **glTexParameteriv**.
     * @param {Integer} target The target texture, which must be either GL\_TEXTURE\_1D or GL\_TEXTURE\_2D.
     * @param {Integer} pname The symbolic name of a single valued texture parameter. The following symbols are accepted in *pname*.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                   | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_TEXTURE_MIN_FILTER"></span><span id="gl_texture_min_filter"></span><dl> <dt>**GL\_TEXTURE\_MIN\_FILTER**</dt> </dl> | The texture minifying function is used whenever the pixel being textured maps to an area greater than one texture element. There are six defined minifying functions. Two of them use the nearest one or nearest four texture elements to compute the texture value. The other four use mipmaps.<br/> A mipmap is an ordered set of arrays representing the same image at progressively lower resolutions. If the texture has dimensions 2nx2<sup>m</sup> there are max(n, m) + 1 mipmaps. The first mipmap is the original texture, with dimensions 2nx2<sup>m</sup>. Each subsequent mipmap has dimensions 2<sup>k</sup>1x2<sup>l</sup>1 where 2<sup>k</sup>x2<sup>l</sup> are the dimensions of the previous mipmap, until either k = 0 or l = 0. At that point, subsequent mipmaps have dimension 1x2<sup>l</sup>1 or 2<sup>k</sup>1x1 until the final mipmap, which has dimension 1x1. Mipmaps are defined using [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md) with the level-of-detail argument indicating the order of the mipmaps. Level 0 is the original texture; level bold max(n, m) is the final 1x1 mipmap.<br/> |
     * | <span id="GL_TEXTURE_MAG_FILTER"></span><span id="gl_texture_mag_filter"></span><dl> <dt>**GL\_TEXTURE\_MAG\_FILTER**</dt> </dl> | The texture magnification function is used when the pixel being textured maps to an area less than or equal to one texture element. It sets the texture magnification function to either GL\_NEAREST or GL\_LINEAR.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_TEXTURE_WRAP_S"></span><span id="gl_texture_wrap_s"></span><dl> <dt>**GL\_TEXTURE\_WRAP\_S**</dt> </dl>             | Sets the wrap parameter for texture coordinate s to either GL\_CLAMP or GL\_REPEAT. GL\_CLAMP causes s coordinates to be clamped to the range \[0,1\] and is useful for preventing wrapping artifacts when mapping a single image onto an object. GL\_REPEAT causes the integer part of the s coordinate to be ignored; OpenGL uses only the fractional part, thereby creating a repeating pattern. Border texture elements are accessed only if wrapping is set to GL\_CLAMP. Initially, GL\_TEXTURE\_WRAP\_S is set to GL\_REPEAT.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
     * | <span id="GL_TEXTURE_WRAP_T"></span><span id="gl_texture_wrap_t"></span><dl> <dt>**GL\_TEXTURE\_WRAP\_T**</dt> </dl>             | Sets the wrap parameter for texture coordinate t to either GL\_CLAMP or GL\_REPEAT. See the discussion under GL\_TEXTURE\_WRAP\_S. Initially, GL\_TEXTURE\_WRAP\_T is set to GL\_REPEAT<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
     * @param {Float} param2 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexparameterf
     */
    static glTexParameterf(target, pname, param2) {
        DllCall("OPENGL32.dll\glTexParameterf", "uint", target, "uint", pname, "float", param2)
    }

    /**
     * Sets texture parameters. | glTexParameterfv function (Gl.h)
     * @remarks
     * Texture mapping is a technique that applies an image onto an object's surface as if the image were a decal or cellophane shrink-wrap. The image is created in texture space, with an (*s*, *t*) coordinate system. A texture is a one- or two-dimensional image and a set of parameters that determine how samples are derived from the image.
     * 
     * The **glTexParameter** function assigns the value or values in params to the texture parameter specified as pname. The target parameter defines the target texture, either GL\_TEXTURE\_1D or GL\_TEXTURE\_2D.
     * 
     * As more texture elements are sampled in the minification process, fewer aliasing artifacts will be apparent. While the GL\_NEAREST and GL\_LINEAR minification functions can be faster than the other four, they sample only one or four texture elements to determine the texture value of the pixel being rendered and can produce moire patterns or ragged transitions. The default value of GL\_TEXTURE\_MIN\_FILTER is GL\_NEAREST\_MIPMAP\_LINEAR.
     * 
     * Suppose that texturing is enabled (by calling [**glEnable**](glenable.md) with argument GL\_TEXTURE\_1D or GL\_TEXTURE\_2D) and GL\_TEXTURE\_MIN\_FILTER is set to one of the functions that requires a mipmap. If either the dimensions of the texture images currently defined (with previous calls to [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md)) do not follow the proper sequence for mipmaps, or there are fewer texture images defined than are needed, or the set of texture images have differing numbers of texture components, then it is as if texture mapping were disabled. Linear filtering accesses the four nearest texture elements only in 2-D textures. In 1-D textures, linear filtering accesses the two nearest texture elements. The following function retrieves information related to **glTexParameterf**, **glTexParameteri**, **glTexParameterfv**, and **glTexParameteriv**:
     * 
     * [**glGetTexParameter**](glgettexparameter.md)
     * @param {Integer} target The target texture, which must be either GL\_TEXTURE\_1D or GL\_TEXTURE\_2D.
     * @param {Integer} pname The symbolic name of a single valued texture parameter. The following symbols are accepted in *pname*.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                         | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_TEXTURE_MIN_FILTER"></span><span id="gl_texture_min_filter"></span><dl> <dt>**GL\_TEXTURE\_MIN\_FILTER**</dt> </dl>       | The texture minifying function is used whenever the pixel being textured maps to an area greater than one texture element. There are six defined minifying functions. Two of them use the nearest one or nearest four texture elements to compute the texture value. The other four use mipmaps. <br/> A mipmap is an ordered set of arrays representing the same image at progressively lower resolutions. If the texture has dimensions 2nx2<sup>m</sup> there are max(n, m) + 1 mipmaps. The first mipmap is the original texture, with dimensions 2nx2<sup>m</sup>. Each subsequent mipmap has dimensions 2<sup>k</sup>1x2<sup>l</sup>1 where 2<sup>k</sup>x2<sup>l</sup> are the dimensions of the previous mipmap, until either k = 0 or l = 0. At that point, subsequent mipmaps have dimension 1x2<sup>l</sup>1 or 2<sup>k</sup>1x1 until the final mipmap, which has dimension 1x1. Mipmaps are defined using [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md) with the level-of-detail argument indicating the order of the mipmaps. Level 0 is the original texture; level bold max(n, m) is the final 1x1 mipmap.<br/> |
     * | <span id="GL_TEXTURE_MAG_FILTER"></span><span id="gl_texture_mag_filter"></span><dl> <dt>**GL\_TEXTURE\_MAG\_FILTER**</dt> </dl>       | The texture magnification function is used when the pixel being textured maps to an area less than or equal to one texture element. It sets the texture magnification function to either GL\_NEAREST or GL\_LINEAR.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_TEXTURE_WRAP_S"></span><span id="gl_texture_wrap_s"></span><dl> <dt>**GL\_TEXTURE\_WRAP\_S**</dt> </dl>                   | Sets the wrap parameter for texture coordinate s to either GL\_CLAMP or GL\_REPEAT. GL\_CLAMP causes s coordinates to be clamped to the range \[0,1\] and is useful for preventing wrapping artifacts when mapping a single image onto an object. GL\_REPEAT causes the integer part of the s coordinate to be ignored; OpenGL uses only the fractional part, thereby creating a repeating pattern. Border texture elements are accessed only if wrapping is set to GL\_CLAMP. Initially, GL\_TEXTURE\_WRAP\_S is set to GL\_REPEAT.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_TEXTURE_WRAP_T"></span><span id="gl_texture_wrap_t"></span><dl> <dt>**GL\_TEXTURE\_WRAP\_T**</dt> </dl>                   | Sets the wrap parameter for texture coordinate t to either GL\_CLAMP or GL\_REPEAT. See the discussion under GL\_TEXTURE\_WRAP\_S. Initially, GL\_TEXTURE\_WRAP\_T is set to GL\_REPEAT.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_TEXTURE_BORDER_COLOR"></span><span id="gl_texture_border_color"></span><dl> <dt>**GL\_TEXTURE\_BORDER\_COLOR**</dt> </dl> | Sets a border color. The *params* parameter contains four values that comprise the RGBA color of the texture border. Integer color components are interpreted linearly such that the most positive integer maps to 1.0, and the most negative integer maps to 1.0. The values are clamped to the range \[0,1\] when they are specified. Initially, the border color is (0, 0, 0, 0).<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_TEXTURE_PRIORITY"></span><span id="gl_texture_priority"></span><dl> <dt>**GL\_TEXTURE\_PRIORITY**</dt> </dl>              | Specifies the texture residence priority of the currently bound texture. Permissible values are in the range \[0, 1\]. See [**glPrioritizeTextures**](glprioritizetextures.md) and [**glBindTexture**](glbindtexture.md) for more information.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
     * @param {Pointer<Single>} params A pointer to an array where the value or values of pname are stored. The params parameter supplies a function for minifying the texture as one of the following.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                               | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_NEAREST_"></span><span id="gl_nearest_"></span><dl> <dt>**GL\_NEAREST** </dt> </dl>                                             | Returns the value of the texture element that is nearest (in Manhattan distance) to the center of the pixel being textured. <br/>                                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_LINEAR"></span><span id="gl_linear"></span><dl> <dt>**GL\_LINEAR**</dt> </dl>                                                   | Returns the weighted average of the four texture elements that are closest to the center of the pixel being textured. These can include border texture elements, depending on the values of GL\_TEXTURE\_WRAP\_S, GL\_TEXTURE\_WRAP\_T, and on the exact mapping. GL\_NEAREST is generally faster than GL\_LINEAR, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. The default value of GL\_TEXTURE\_MAG\_FILTER is GL\_LINEAR.<br/> |
     * | <span id="GL_NEAREST_MIPMAP_NEAREST"></span><span id="gl_nearest_mipmap_nearest"></span><dl> <dt>**GL\_NEAREST\_MIPMAP\_NEAREST**</dt> </dl> | Chooses the mipmap that most closely matches the size of the pixel being textured and uses the GL\_NEAREST criterion (the texture element nearest to the center of the pixel) to produce a texture value. <br/>                                                                                                                                                                                                                                                                                              |
     * | <span id="GL_LINEAR_MIPMAP_NEAREST"></span><span id="gl_linear_mipmap_nearest"></span><dl> <dt>**GL\_LINEAR\_MIPMAP\_NEAREST**</dt> </dl>    | Chooses the mipmap that most closely matches the size of the pixel being textured and uses the GL\_LINEAR criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value. <br/>                                                                                                                                                                                                                                                          |
     * | <span id="GL_NEAREST_MIPMAP_LINEAR"></span><span id="gl_nearest_mipmap_linear"></span><dl> <dt>**GL\_NEAREST\_MIPMAP\_LINEAR**</dt> </dl>    | Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the GL\_NEAREST criterion (the texture element nearest to the center of the pixel) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values. <br/>                                                                                                                                                                                                       |
     * | <span id="GL_LINEAR_MIPMAP_LINEAR"></span><span id="gl_linear_mipmap_linear"></span><dl> <dt>**GL\_LINEAR\_MIPMAP\_LINEAR**</dt> </dl>       | Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the GL\_LINEAR criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.<br/>                                                                                                                                                                    |
     * 
     * 
     * 
     *  
     * 
     * The *params* parameter supplies a function for magnifying the texture as one of the following.
     * 
     * 
     * 
     * | Value                                                                                                                                                   | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * |---------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_NEAREST_"></span><span id="gl_nearest_"></span><dl> <dt>**GL\_NEAREST** </dt> </dl> | Returns the value of the texture element that is nearest (in Manhattan distance) to the center of the pixel being textured. <br/>                                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_LINEAR"></span><span id="gl_linear"></span><dl> <dt>**GL\_LINEAR**</dt> </dl>       | Returns the weighted average of the four texture elements that are closest to the center of the pixel being textured. These can include border texture elements, depending on the values of GL\_TEXTURE\_WRAP\_S, GL\_TEXTURE\_WRAP\_T, and on the exact mapping. GL\_NEAREST is generally faster than GL\_LINEAR, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. The default value of GL\_TEXTURE\_MAG\_FILTER is GL\_LINEAR.<br/> |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexparameterfv
     */
    static glTexParameterfv(target, pname, params) {
        DllCall("OPENGL32.dll\glTexParameterfv", "uint", target, "uint", pname, "ptr", params)
    }

    /**
     * Sets texture parameters. | glTexParameteri function (Gl.h)
     * @remarks
     * Texture mapping is a technique that applies an image onto an object's surface as if the image were a decal or cellophane shrink-wrap. The image is created in texture space, with an (*s*, *t*) coordinate system. A texture is a one- or two-dimensional image and a set of parameters that determine how samples are derived from the image.
     * 
     * The **glTexParameter** function assigns the value or values in params to the texture parameter specified as pname. The target parameter defines the target texture, either GL\_TEXTURE\_1D or GL\_TEXTURE\_2D.
     * 
     * As more texture elements are sampled in the minification process, fewer aliasing artifacts will be apparent. While the GL\_NEAREST and GL\_LINEAR minification functions can be faster than the other four, they sample only one or four texture elements to determine the texture value of the pixel being rendered and can produce moire patterns or ragged transitions. The default value of GL\_TEXTURE\_MIN\_FILTER is GL\_NEAREST\_MIPMAP\_LINEAR.
     * 
     * Suppose that texturing is enabled (by calling [**glEnable**](glenable.md) with argument GL\_TEXTURE\_1D or GL\_TEXTURE\_2D) and GL\_TEXTURE\_MIN\_FILTER is set to one of the functions that requires a mipmap. If either the dimensions of the texture images currently defined (with previous calls to [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md)) do not follow the proper sequence for mipmaps, or there are fewer texture images defined than are needed, or the set of texture images have differing numbers of texture components, then it is as if texture mapping were disabled. Linear filtering accesses the four nearest texture elements only in 2-D textures. In 1-D textures, linear filtering accesses the two nearest texture elements. The following function retrieves information related to **glTexParameterf**, **glTexParameteri**, **glTexParameterfv**, and **glTexParameteriv**:
     * 
     * [**glGetTexParameter**](glgettexparameter.md)
     * @param {Integer} target The target texture, which must be either GL\_TEXTURE\_1D or GL\_TEXTURE\_2D.
     * @param {Integer} pname The symbolic name of a single valued texture parameter. The following symbols are accepted in *pname*.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                   | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_TEXTURE_MIN_FILTER"></span><span id="gl_texture_min_filter"></span><dl> <dt>**GL\_TEXTURE\_MIN\_FILTER**</dt> </dl> | The texture minifying function is used whenever the pixel being textured maps to an area greater than one texture element. There are six defined minifying functions. Two of them use the nearest one or nearest four texture elements to compute the texture value. The other four use mipmaps. <br/> A mipmap is an ordered set of arrays representing the same image at progressively lower resolutions. If the texture has dimensions 2nx2<sup>m</sup> there are max(n, m) + 1 mipmaps. The first mipmap is the original texture, with dimensions 2nx2<sup>m</sup>. Each subsequent mipmap has dimensions 2<sup>k</sup>1x2<sup>l</sup>1 where 2<sup>k</sup>x2<sup>l</sup> are the dimensions of the previous mipmap, until either k = 0 or l = 0. At that point, subsequent mipmaps have dimension 1x2<sup>l</sup>1 or 2<sup>k</sup>1x1 until the final mipmap, which has dimension 1x1. Mipmaps are defined using [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md) with the level-of-detail argument indicating the order of the mipmaps. Level 0 is the original texture; level bold max(n, m) is the final 1x1 mipmap.<br/> |
     * | <span id="GL_TEXTURE_MAG_FILTER"></span><span id="gl_texture_mag_filter"></span><dl> <dt>**GL\_TEXTURE\_MAG\_FILTER**</dt> </dl> | The texture magnification function is used when the pixel being textured maps to an area less than or equal to one texture element. It sets the texture magnification function to either GL\_NEAREST or GL\_LINEAR.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_TEXTURE_WRAP_S"></span><span id="gl_texture_wrap_s"></span><dl> <dt>**GL\_TEXTURE\_WRAP\_S**</dt> </dl>             | Sets the wrap parameter for texture coordinate s to either GL\_CLAMP or GL\_REPEAT. GL\_CLAMP causes s coordinates to be clamped to the range \[0,1\] and is useful for preventing wrapping artifacts when mapping a single image onto an object. GL\_REPEAT causes the integer part of the s coordinate to be ignored; OpenGL uses only the fractional part, thereby creating a repeating pattern. Border texture elements are accessed only if wrapping is set to GL\_CLAMP. Initially, GL\_TEXTURE\_WRAP\_S is set to GL\_REPEAT.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_TEXTURE_WRAP_T"></span><span id="gl_texture_wrap_t"></span><dl> <dt>**GL\_TEXTURE\_WRAP\_T**</dt> </dl>             | Sets the wrap parameter for texture coordinate t to either GL\_CLAMP or GL\_REPEAT. See the discussion under GL\_TEXTURE\_WRAP\_S. Initially, GL\_TEXTURE\_WRAP\_T is set to GL\_REPEAT<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
     * @param {Integer} param2 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexparameteri
     */
    static glTexParameteri(target, pname, param2) {
        DllCall("OPENGL32.dll\glTexParameteri", "uint", target, "uint", pname, "int", param2)
    }

    /**
     * Sets texture parameters. | glTexParameteriv function (Gl.h)
     * @remarks
     * Texture mapping is a technique that applies an image onto an object's surface as if the image were a decal or cellophane shrink-wrap. The image is created in texture space, with an (*s*, *t*) coordinate system. A texture is a one- or two-dimensional image and a set of parameters that determine how samples are derived from the image.
     * 
     * The **glTexParameter** function assigns the value or values in params to the texture parameter specified as pname. The target parameter defines the target texture, either GL\_TEXTURE\_1D or GL\_TEXTURE\_2D.
     * 
     * As more texture elements are sampled in the minification process, fewer aliasing artifacts will be apparent. While the GL\_NEAREST and GL\_LINEAR minification functions can be faster than the other four, they sample only one or four texture elements to determine the texture value of the pixel being rendered and can produce moire patterns or ragged transitions. The default value of GL\_TEXTURE\_MIN\_FILTER is GL\_NEAREST\_MIPMAP\_LINEAR.
     * 
     * Suppose that texturing is enabled (by calling [**glEnable**](glenable.md) with argument GL\_TEXTURE\_1D or GL\_TEXTURE\_2D) and GL\_TEXTURE\_MIN\_FILTER is set to one of the functions that requires a mipmap. If either the dimensions of the texture images currently defined (with previous calls to [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md)) do not follow the proper sequence for mipmaps, or there are fewer texture images defined than are needed, or the set of texture images have differing numbers of texture components, then it is as if texture mapping were disabled. Linear filtering accesses the four nearest texture elements only in 2-D textures. In 1-D textures, linear filtering accesses the two nearest texture elements. The following function retrieves information related to **glTexParameterf**, **glTexParameteri**, **glTexParameterfv**, and **glTexParameteriv**:
     * 
     * [**glGetTexParameter**](glgettexparameter.md)
     * @param {Integer} target The target texture, which must be either GL\_TEXTURE\_1D or GL\_TEXTURE\_2D.
     * @param {Integer} pname The symbolic name of a single valued texture parameter. The following symbols are accepted in *pname*.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                         | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_TEXTURE_MIN_FILTER"></span><span id="gl_texture_min_filter"></span><dl> <dt>**GL\_TEXTURE\_MIN\_FILTER**</dt> </dl>       | The texture minifying function is used whenever the pixel being textured maps to an area greater than one texture element. There are six defined minifying functions. Two of them use the nearest one or nearest four texture elements to compute the texture value. The other four use mipmaps. <br/> A mipmap is an ordered set of arrays representing the same image at progressively lower resolutions. If the texture has dimensions 2nx2<sup>m</sup> there are max(n, m) + 1 mipmaps. The first mipmap is the original texture, with dimensions 2nx2<sup>m</sup>. Each subsequent mipmap has dimensions 2<sup>k</sup>1x2<sup>l</sup>1 where 2<sup>k</sup>x2<sup>l</sup> are the dimensions of the previous mipmap, until either k = 0 or l = 0. At that point, subsequent mipmaps have dimension 1x2<sup>l</sup>1 or 2<sup>k</sup>1x1 until the final mipmap, which has dimension 1x1. Mipmaps are defined using [**glTexImage1D**](glteximage1d.md) or [**glTexImage2D**](glteximage2d.md) with the level-of-detail argument indicating the order of the mipmaps. Level 0 is the original texture; level bold max(n, m) is the final 1x1 mipmap.<br/> |
     * | <span id="GL_TEXTURE_MAG_FILTER"></span><span id="gl_texture_mag_filter"></span><dl> <dt>**GL\_TEXTURE\_MAG\_FILTER**</dt> </dl>       | The texture magnification function is used when the pixel being textured maps to an area less than or equal to one texture element. It sets the texture magnification function to either GL\_NEAREST or GL\_LINEAR.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
     * | <span id="GL_TEXTURE_WRAP_S"></span><span id="gl_texture_wrap_s"></span><dl> <dt>**GL\_TEXTURE\_WRAP\_S**</dt> </dl>                   | Sets the wrap parameter for texture coordinate s to either GL\_CLAMP or GL\_REPEAT. GL\_CLAMP causes s coordinates to be clamped to the range \[0,1\] and is useful for preventing wrapping artifacts when mapping a single image onto an object. GL\_REPEAT causes the integer part of the s coordinate to be ignored; OpenGL uses only the fractional part, thereby creating a repeating pattern. Border texture elements are accessed only if wrapping is set to GL\_CLAMP. Initially, GL\_TEXTURE\_WRAP\_S is set to GL\_REPEAT.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_TEXTURE_WRAP_T"></span><span id="gl_texture_wrap_t"></span><dl> <dt>**GL\_TEXTURE\_WRAP\_T**</dt> </dl>                   | Sets the wrap parameter for texture coordinate t to either GL\_CLAMP or GL\_REPEAT. See the discussion under GL\_TEXTURE\_WRAP\_S. Initially, GL\_TEXTURE\_WRAP\_T is set to GL\_REPEAT.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
     * | <span id="GL_TEXTURE_BORDER_COLOR"></span><span id="gl_texture_border_color"></span><dl> <dt>**GL\_TEXTURE\_BORDER\_COLOR**</dt> </dl> | Sets a border color. The *params* parameter contains four values that comprise the RGBA color of the texture border. Integer color components are interpreted linearly such that the most positive integer maps to 1.0, and the most negative integer maps to 1.0. The values are clamped to the range \[0,1\] when they are specified. Initially, the border color is (0, 0, 0, 0).<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_TEXTURE_PRIORITY"></span><span id="gl_texture_priority"></span><dl> <dt>**GL\_TEXTURE\_PRIORITY**</dt> </dl>              | Specifies the texture residence priority of the currently bound texture. Permissible values are in the range \[0, 1\]. See [**glPrioritizeTextures**](glprioritizetextures.md) and [**glBindTexture**](glbindtexture.md) for more information.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
     * @param {Pointer<Int32>} params A pointer to an array where the value or values of pname are stored. The params parameter supplies a function for minifying the texture as one of the following.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                               | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_NEAREST_"></span><span id="gl_nearest_"></span><dl> <dt>**GL\_NEAREST** </dt> </dl>                                             | Returns the value of the texture element that is nearest (in Manhattan distance) to the center of the pixel being textured. <br/>                                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_LINEAR"></span><span id="gl_linear"></span><dl> <dt>**GL\_LINEAR**</dt> </dl>                                                   | Returns the weighted average of the four texture elements that are closest to the center of the pixel being textured. These can include border texture elements, depending on the values of GL\_TEXTURE\_WRAP\_S, GL\_TEXTURE\_WRAP\_T, and on the exact mapping. GL\_NEAREST is generally faster than GL\_LINEAR, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. The default value of GL\_TEXTURE\_MAG\_FILTER is GL\_LINEAR.<br/> |
     * | <span id="GL_NEAREST_MIPMAP_NEAREST"></span><span id="gl_nearest_mipmap_nearest"></span><dl> <dt>**GL\_NEAREST\_MIPMAP\_NEAREST**</dt> </dl> | Chooses the mipmap that most closely matches the size of the pixel being textured and uses the GL\_NEAREST criterion (the texture element nearest to the center of the pixel) to produce a texture value. <br/>                                                                                                                                                                                                                                                                                              |
     * | <span id="GL_LINEAR_MIPMAP_NEAREST"></span><span id="gl_linear_mipmap_nearest"></span><dl> <dt>**GL\_LINEAR\_MIPMAP\_NEAREST**</dt> </dl>    | Chooses the mipmap that most closely matches the size of the pixel being textured and uses the GL\_LINEAR criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value. <br/>                                                                                                                                                                                                                                                          |
     * | <span id="GL_NEAREST_MIPMAP_LINEAR"></span><span id="gl_nearest_mipmap_linear"></span><dl> <dt>**GL\_NEAREST\_MIPMAP\_LINEAR**</dt> </dl>    | Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the GL\_NEAREST criterion (the texture element nearest to the center of the pixel) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values. <br/>                                                                                                                                                                                                       |
     * | <span id="GL_LINEAR_MIPMAP_LINEAR"></span><span id="gl_linear_mipmap_linear"></span><dl> <dt>**GL\_LINEAR\_MIPMAP\_LINEAR**</dt> </dl>       | Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the GL\_LINEAR criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.<br/>                                                                                                                                                                    |
     * 
     * 
     * 
     *  
     * 
     * The *params* parameter supplies a function for magnifying the texture as one of the following.
     * 
     * 
     * 
     * | Value                                                                                                                                                   | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * |---------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_NEAREST_"></span><span id="gl_nearest_"></span><dl> <dt>**GL\_NEAREST** </dt> </dl> | Returns the value of the texture element that is nearest (in Manhattan distance) to the center of the pixel being textured. <br/>                                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GL_LINEAR"></span><span id="gl_linear"></span><dl> <dt>**GL\_LINEAR**</dt> </dl>       | Returns the weighted average of the four texture elements that are closest to the center of the pixel being textured. These can include border texture elements, depending on the values of GL\_TEXTURE\_WRAP\_S, GL\_TEXTURE\_WRAP\_T, and on the exact mapping. GL\_NEAREST is generally faster than GL\_LINEAR, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. The default value of GL\_TEXTURE\_MAG\_FILTER is GL\_LINEAR.<br/> |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexparameteriv
     */
    static glTexParameteriv(target, pname, params) {
        DllCall("OPENGL32.dll\glTexParameteriv", "uint", target, "uint", pname, "ptr", params)
    }

    /**
     * The glTexSubImage1D function specifies a portion of an existing one-dimensional texture image. You cannot define a new texture with glTexSubImage1D.
     * @remarks
     * One-dimensional texturing for a primitive is enabled using [**glEnable**](glenable.md) and **glDisable** with the argument GL\_TEXTURE\_1D. During texturing, part of a specified texture image is mapped into each enabled primitive. You use the **glTexSubImage1D** function to specify a contiguous sub-image of an existing one-dimensional texture image for texturing.
     * 
     * The texels referenced by *pixels* replace a region of the existing texture array with *x* indexes of *xoffset* and *xoffset* + (*width* 1) inclusive. This region cannot include any texels outside the range of the originally specified texture array.
     * 
     * Specifying a sub-image with a *width* of zero has no effect and does not generate an error.
     * 
     * Texturing has no effect in color-index mode.
     * 
     * In general, texture images can be represented by the same data formats as the pixels in a [**glDrawPixels**](gldrawpixels.md) command, except that GL\_STENCIL\_INDEX and GL\_DEPTH\_COMPONENT cannot be used. The [**glPixelStore**](glpixelstore-functions.md) and [**glPixelTransfer**](glpixeltransfer.md) modes affect texture images in exactly the way they affect **glDrawPixels**.
     * 
     * The following functions retrieve information related to **glTexSubImage1D**:
     * 
     * [**glGetTexImage**](glgetteximage.md)
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_1D
     * @param {Integer} target The target texture. Must be GL\_TEXTURE\_1D.
     * @param {Integer} level The level-of-detail number. Level 0 is the base image. Level *n* is the *n*th mipmap reduction image.
     * @param {Integer} xoffset A texel offset in the *x* direction within the texture array.
     * @param {Integer} width The width of the texture sub-image.
     * @param {Integer} format The format of the pixel data. This parameter can assume one of the following symbolic values.
     * 
     * 
     * 
     * | Value                                                                                                                                                                         | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_COLOR_INDEX"></span><span id="gl_color_index"></span><dl> <dt>**GL\_COLOR\_INDEX**</dt> </dl>             | Each element is a single value, a color index. It is converted to fixed point format (with an unspecified number of 0 bits to the right of the binary point), shifted left or right, depending on the value and sign of GL\_INDEX\_SHIFT, and added to GL\_INDEX\_OFFSET (see [**glPixelTransfer**](glpixeltransfer.md)). The resulting index is converted to a set of color components using the GL\_PIXEL\_MAP\_I\_TO\_R, GL\_PIXEL\_MAP\_I\_TO\_G, GL\_PIXEL\_MAP\_I\_TO\_B, and GL\_PIXEL\_MAP\_I\_TO\_A tables, and clamped to the range \[0,1\].<br/> |
     * | <span id="GL_RED"></span><span id="gl_red"></span><dl> <dt>**GL\_RED**</dt> </dl>                                      | Each element is a single red component. It is converted to floating point format and assembled into an RGBA element by attaching 0.0 for green and blue, and 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                                                |
     * | <span id="GL_GREEN"></span><span id="gl_green"></span><dl> <dt>**GL\_GREEN**</dt> </dl>                                | Each element is a single green component. It is converted to floating point format and assembled into an RGBA element by attaching 0.0 for red and blue, and 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see [**glPixelTransfer**](glpixeltransfer.md)).<br/>                                                                                                                                                                         |
     * | <span id="GL_BLUE"></span><span id="gl_blue"></span><dl> <dt>**GL\_BLUE**</dt> </dl>                                   | Each element is a single blue component. It is converted to floating point format and assembled into an RGBA element by attaching 0.0 for red and green, and 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                                                |
     * | <span id="GL_ALPHA"></span><span id="gl_alpha"></span><dl> <dt>**GL\_ALPHA**</dt> </dl>                                | Each element is a single alpha component. It is converted to floating point format and assembled into an RGBA element by attaching 0.0 for red, green, and blue. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see [**glPixelTransfer**](glpixeltransfer.md)).<br/>                                                                                                                                                                                    |
     * | <span id="GL_RGB"></span><span id="gl_rgb"></span><dl> <dt>**GL\_RGB**</dt> </dl>                                      | Each element is an RGB triple. It is converted to floating point and assembled into an RGBA element by attaching 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                                                                                            |
     * | <span id="GL_RGBA"></span><span id="gl_rgba"></span><dl> <dt>**GL\_RGBA**</dt> </dl>                                   | Each element is a complete RGBA element. It is converted to floating point format. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                                                                                                                                         |
     * | <span id="GL_LUMINANCE"></span><span id="gl_luminance"></span><dl> <dt>**GL\_LUMINANCE**</dt> </dl>                    | Each element is a single luminance value. It is converted to floating point format, and then assembled into an RGBA element by replicating the luminance value three times for red, green, and blue, and attaching 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see [**glPixelTransfer**](glpixeltransfer.md)).<br/>                                                                                                                   |
     * | <span id="GL_LUMINANCE_ALPHA"></span><span id="gl_luminance_alpha"></span><dl> <dt>**GL\_LUMINANCE\_ALPHA**</dt> </dl> | Each element is a luminance/alpha pair. It is converted to floating point format, and then assembled into an RGBA element by replicating the luminance value three times for red, green, and blue. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                         |
     * @param {Integer} type The data type of the pixel data. The following symbolic values are accepted: GL\_UNSIGNED\_BYTE, GL\_BYTE, GL\_BITMAP, GL\_UNSIGNED\_SHORT, GL\_SHORT, GL\_UNSIGNED\_INT, GL\_INT, and GL\_FLOAT.
     * @param {Pointer<Void>} pixels A pointer to the image data in memory.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexsubimage1d
     */
    static glTexSubImage1D(target, level, xoffset, width, format, type, pixels) {
        DllCall("OPENGL32.dll\glTexSubImage1D", "uint", target, "int", level, "int", xoffset, "int", width, "uint", format, "uint", type, "ptr", pixels)
    }

    /**
     * The glTexSubImage2D function specifies a portion of an existing one-dimensional texture image. You cannot define a new texture with glTexSubImage2D.
     * @remarks
     * Two-dimensional texturing for a primitive is enabled using [**glEnable**](glenable.md) and **glDisable** with the argument GL\_TEXTURE\_2D. During texturing, part of a specified texture image is mapped into each enabled primitive. You use the **glTexSubImage2D** function to specify a contiguous sub-image of an existing two-dimensional texture image for texturing.
     * 
     * The texels referenced by *pixels* replace a region of the existing texture array with *x* indexes of *xoffset* and *xoffset* + (*width* 1) inclusive and *y* indexes of *yoffset* and *yoffset* + (*height* 1) inclusive. This region cannot include any texels outside the range of the originally specified texture array.
     * 
     * Specifying a sub-image with a *width* of zero has no effect and does not generate an error.
     * 
     * Texturing has no effect in color-index mode.
     * 
     * In general, texture images can be represented by the same data formats as the pixels in a [**glDrawPixels**](gldrawpixels.md) command, except that GL\_STENCIL\_INDEX and GL\_DEPTH\_COMPONENT cannot be used. The [**glPixelStore**](glpixelstore-functions.md) and [**glPixelTransfer**](glpixeltransfer.md) modes affect texture images in exactly the way they affect **glDrawPixels**.
     * 
     * The following functions retrieve information related to **glTexSubImage2D**:
     * 
     * [**glGetTexImage**](glgetteximage.md)
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_TEXTURE\_2D
     * @param {Integer} target The target texture. Must be GL\_TEXTURE\_2D.
     * @param {Integer} level The level-of-detail number. Level 0 is the base image. Level *n* is the *n*th mipmap reduction image.
     * @param {Integer} xoffset A texel offset in the *x* direction within the texture array.
     * @param {Integer} yoffset A texel offset in the *y* direction within the texture array.
     * @param {Integer} width The width of the texture sub-image.
     * @param {Integer} height The height of the texture sub-image.
     * @param {Integer} format The format of the pixel data. It can assume one of the following symbolic values.
     * 
     * 
     * 
     * | Value                                                                                                                                                                         | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GL_COLOR_INDEX"></span><span id="gl_color_index"></span><dl> <dt>**GL\_COLOR\_INDEX**</dt> </dl>             | Each element is a single value, a color index. It is converted to fixed point format (with an unspecified number of 0 bits to the right of the binary point), shifted left or right, depending on the value and sign of GL\_INDEX\_SHIFT, and added to GL\_INDEX\_OFFSET (see [**glPixelTransfer**](glpixeltransfer.md)). The resulting index is converted to a set of color components using the GL\_PIXEL\_MAP\_I\_TO\_R, GL\_PIXEL\_MAP\_I\_TO\_G, GL\_PIXEL\_MAP\_I\_TO\_B, and GL\_PIXEL\_MAP\_I\_TO\_A tables, and clamped to the range \[0,1\].<br/> |
     * | <span id="GL_RED"></span><span id="gl_red"></span><dl> <dt>**GL\_RED**</dt> </dl>                                      | Each element is a single red component. It is converted to floating point format and assembled into an RGBA element by attaching 0.0 for green and blue, and 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                                                |
     * | <span id="GL_GREEN"></span><span id="gl_green"></span><dl> <dt>**GL\_GREEN**</dt> </dl>                                | Each element is a single green component. It is converted to floating point format and assembled into an RGBA element by attaching 0.0 for red and blue, and 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see [**glPixelTransfer**](glpixeltransfer.md)).<br/>                                                                                                                                                                         |
     * | <span id="GL_BLUE"></span><span id="gl_blue"></span><dl> <dt>**GL\_BLUE**</dt> </dl>                                   | Each element is a single blue component. It is converted to floating point format and assembled into an RGBA element by attaching 0.0 for red and green, and 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                                                |
     * | <span id="GL_ALPHA"></span><span id="gl_alpha"></span><dl> <dt>**GL\_ALPHA**</dt> </dl>                                | Each element is a single alpha component. It is converted to floating point format and assembled into an RGBA element by attaching 0.0 for red, green, and blue. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see [**glPixelTransfer**](glpixeltransfer.md)).<br/>                                                                                                                                                                                    |
     * | <span id="GL_RGB"></span><span id="gl_rgb"></span><dl> <dt>**GL\_RGB**</dt> </dl>                                      | Each element is an RGB triple. It is converted to floating point format and assembled into an RGBA element by attaching 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                                                                                     |
     * | <span id="GL_RGBA"></span><span id="gl_rgba"></span><dl> <dt>**GL\_RGBA**</dt> </dl>                                   | Each element is a complete RGBA element. It is converted to floating point. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                                                                                                                                                |
     * | <span id="GL_LUMINANCE"></span><span id="gl_luminance"></span><dl> <dt>**GL\_LUMINANCE**</dt> </dl>                    | Each element is a single luminance value. It is converted to floating point format, and then assembled into an RGBA element by replicating the luminance value three times for red, green, and blue, and attaching 1.0 for alpha. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see [**glPixelTransfer**](glpixeltransfer.md)).<br/>                                                                                                                   |
     * | <span id="GL_LUMINANCE_ALPHA"></span><span id="gl_luminance_alpha"></span><dl> <dt>**GL\_LUMINANCE\_ALPHA**</dt> </dl> | Each element is a luminance/alpha pair. It is converted to floating point format, and then assembled into an RGBA element by replicating the luminance value three times for red, green, and blue. Each component is then multiplied by the signed scale factor GL\_c\_SCALE, added to the signed bias GL\_c\_BIAS, and clamped to the range \[0,1\] (see **glPixelTransfer**).<br/>                                                                                                                                                                         |
     * @param {Integer} type The data type of the pixel data. The following symbolic values are accepted: GL\_UNSIGNED\_BYTE, GL\_BYTE, GL\_BITMAP, GL\_UNSIGNED\_SHORT, GL\_SHORT, GL\_UNSIGNED\_INT, GL\_INT, and GL\_FLOAT.
     * @param {Pointer<Void>} pixels A pointer to the image data in memory.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltexsubimage2d
     */
    static glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels) {
        DllCall("OPENGL32.dll\glTexSubImage2D", "uint", target, "int", level, "int", xoffset, "int", yoffset, "int", width, "int", height, "uint", format, "uint", type, "ptr", pixels)
    }

    /**
     * The glTranslated function multiplies the current matrix by a translation matrix.
     * @remarks
     * The **glTranslated** function produces the translation specified by (*x*, *y*, *z*). The translation vector is used to compute a 4x4 translation matrix:
     * 
     * ![Diagram showing the 4x4 translation matrix specified by x, y, z.](images/trans01.png)
     * 
     * The current matrix (see [**glMatrixMode**](glmatrixmode.md)) is multiplied by this translation matrix, with the product replacing the current matrix. That is, if M is the current matrix and T is the translation matrix, then M is replaced with M T.
     * 
     * If the matrix mode is either GL\_MODELVIEW or GL\_PROJECTION, all objects drawn after **glTranslated** is called are translated. Use [**glPushMatrix**](glpushmatrix.md) and **glPopMatrix** to save and restore the untranslated coordinate system.
     * 
     * The following functions retrieve information related to [**glTranslated**](gltranslate.md):
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * 
     * **glGet** with argument GL\_MODELVIEW\_MATRIX
     * 
     * **glGet** with argument GL\_PROJECTION\_MATRIX
     * 
     * **glGet** with argument GL\_TEXTURE\_MATRIX
     * @param {Float} x The *x* coordinate of a translation vector.
     * @param {Float} y The *y* coordinate of a translation vector.
     * @param {Float} z The *z* coordinate of a translation vector.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltranslated
     */
    static glTranslated(x, y, z) {
        DllCall("OPENGL32.dll\glTranslated", "double", x, "double", y, "double", z)
    }

    /**
     * The glTranslatef function multiplies the current matrix by a translation matrix.
     * @remarks
     * The **glTranslatef** function produces the translation specified by (*x*, *y*, *z*). The translation vector is used to compute a 4x4 translation matrix:
     * 
     * ![Diagram showing the 4x4 translation matrix specified by x, y, z.](images/trans01.png)
     * 
     * The current matrix (see [**glMatrixMode**](glmatrixmode.md)) is multiplied by this translation matrix, with the product replacing the current matrix. That is, if M is the current matrix and T is the translation matrix, then M is replaced with M T.
     * 
     * If the matrix mode is either GL\_MODELVIEW or GL\_PROJECTION, all objects drawn after **glTranslatef** is called are translated. Use [**glPushMatrix**](glpushmatrix.md) and **glPopMatrix** to save and restore the untranslated coordinate system.
     * 
     * The following functions retrieve information related to [**glTranslated**](gltranslate.md) and **glTranslatef**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_MATRIX\_MODE
     * 
     * **glGet** with argument GL\_MODELVIEW\_MATRIX
     * 
     * **glGet** with argument GL\_PROJECTION\_MATRIX
     * 
     * **glGet** with argument GL\_TEXTURE\_MATRIX
     * @param {Float} x The *x* coordinate of a translation vector.
     * @param {Float} y The *y* coordinate of a translation vector.
     * @param {Float} z The *z* coordinate of a translation vector.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gltranslatef
     */
    static glTranslatef(x, y, z) {
        DllCall("OPENGL32.dll\glTranslatef", "float", x, "float", y, "float", z)
    }

    /**
     * Specifies a vertex. | glVertex2d function (Gl.h)
     * @remarks
     * The glVertex function commands are used within [**glBegin**](glbegin.md)/[**glEnd**](glend.md) pairs to specify point, line, and polygon vertices. The current color, normal, and texture coordinates are associated with the vertex when glVertex is called. When only *x* and *y* are specified, *z* defaults to 0.0 and *w* defaults to 1.0. When *x*, *y*, and *z* are specified, *w* defaults to 1.0. Invoking glVertex outside of a **glBegin*/*glEnd** pair results in undefined behavior.
     * @param {Float} x Specifies the x-coordinate of a vertex.
     * @param {Float} y Specifies the y-coordinate of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex2d
     */
    static glVertex2d(x, y) {
        DllCall("OPENGL32.dll\glVertex2d", "double", x, "double", y)
    }

    /**
     * Specifies a vertex. | glVertex2dv function (Gl.h)
     * @param {Pointer<Double>} v A pointer to an array of two elements. The elements are the x and y coordinates of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex2dv
     */
    static glVertex2dv(v) {
        DllCall("OPENGL32.dll\glVertex2dv", "ptr", v)
    }

    /**
     * Specifies a vertex. | glVertex2f function (Gl.h)
     * @remarks
     * The glVertex function commands are used within [**glBegin**](glbegin.md)/[**glEnd**](glend.md) pairs to specify point, line, and polygon vertices. The current color, normal, and texture coordinates are associated with the vertex when glVertex is called. When only *x* and *y* are specified, *z* defaults to 0.0 and *w* defaults to 1.0. When *x*, *y*, and *z* are specified, *w* defaults to 1.0. Invoking glVertex outside of a **glBegin*/*glEnd** pair results in undefined behavior.
     * @param {Float} x Specifies the x-coordinate of a vertex.
     * @param {Float} y Specifies the y-coordinate of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex2f
     */
    static glVertex2f(x, y) {
        DllCall("OPENGL32.dll\glVertex2f", "float", x, "float", y)
    }

    /**
     * Specifies a vertex. | glVertex2fv function (Gl.h)
     * @param {Pointer<Single>} v A pointer to an array of two elements. The elements are the x and y coordinates of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex2fv
     */
    static glVertex2fv(v) {
        DllCall("OPENGL32.dll\glVertex2fv", "ptr", v)
    }

    /**
     * Specifies a vertex. | glVertex2i function (Gl.h)
     * @remarks
     * The glVertex function commands are used within [**glBegin**](glbegin.md)/[**glEnd**](glend.md) pairs to specify point, line, and polygon vertices. The current color, normal, and texture coordinates are associated with the vertex when glVertex is called. When only *x* and *y* are specified, *z* defaults to 0.0 and *w* defaults to 1.0. When *x*, *y*, and *z* are specified, *w* defaults to 1.0. Invoking glVertex outside of a **glBegin*/*glEnd** pair results in undefined behavior.
     * @param {Integer} x Specifies the x-coordinate of a vertex.
     * @param {Integer} y Specifies the y-coordinate of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex2i
     */
    static glVertex2i(x, y) {
        DllCall("OPENGL32.dll\glVertex2i", "int", x, "int", y)
    }

    /**
     * Specifies a vertex. | glVertex2iv function (Gl.h)
     * @param {Pointer<Int32>} v A pointer to an array of two elements. The elements are the x and y coordinates of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex2iv
     */
    static glVertex2iv(v) {
        DllCall("OPENGL32.dll\glVertex2iv", "ptr", v)
    }

    /**
     * Specifies a vertex. | glVertex2s function (Gl.h)
     * @remarks
     * The glVertex function commands are used within [**glBegin**](glbegin.md)/[**glEnd**](glend.md) pairs to specify point, line, and polygon vertices. The current color, normal, and texture coordinates are associated with the vertex when glVertex is called. When only *x* and *y* are specified, *z* defaults to 0.0 and *w* defaults to 1.0. When *x*, *y*, and *z* are specified, *w* defaults to 1.0. Invoking glVertex outside of a **glBegin*/*glEnd** pair results in undefined behavior.
     * @param {Integer} x Specifies the x-coordinate of a vertex.
     * @param {Integer} y Specifies the y-coordinate of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex2s
     */
    static glVertex2s(x, y) {
        DllCall("OPENGL32.dll\glVertex2s", "short", x, "short", y)
    }

    /**
     * Specifies a vertex. | glVertex2sv function (Gl.h)
     * @param {Pointer<Int16>} v A pointer to an array of two elements. The elements are the x and y coordinates of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex2sv
     */
    static glVertex2sv(v) {
        DllCall("OPENGL32.dll\glVertex2sv", "ptr", v)
    }

    /**
     * Specifies a vertex. | glVertex3d function (Gl.h)
     * @remarks
     * The glVertex function commands are used within [**glBegin**](glbegin.md)/[**glEnd**](glend.md) pairs to specify point, line, and polygon vertices. The current color, normal, and texture coordinates are associated with the vertex when glVertex is called. When only *x* and *y* are specified, *z* defaults to 0.0 and *w* defaults to 1.0. When *x*, *y*, and *z* are specified, *w* defaults to 1.0. Invoking glVertex outside of a **glBegin*/*glEnd** pair results in undefined behavior.
     * @param {Float} x Specifies the x-coordinate of a vertex.
     * @param {Float} y Specifies the y-coordinate of a vertex.
     * @param {Float} z Specifies the z-coordinate of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex3d
     */
    static glVertex3d(x, y, z) {
        DllCall("OPENGL32.dll\glVertex3d", "double", x, "double", y, "double", z)
    }

    /**
     * Specifies a vertex. | glVertex3dv function (Gl.h)
     * @param {Pointer<Double>} v A pointer to an array of three elements. The elements are the x, y, and z coordinates of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex3dv
     */
    static glVertex3dv(v) {
        DllCall("OPENGL32.dll\glVertex3dv", "ptr", v)
    }

    /**
     * Specifies a vertex. | glVertex3f function (Gl.h)
     * @remarks
     * The glVertex function commands are used within [**glBegin**](glbegin.md)/[**glEnd**](glend.md) pairs to specify point, line, and polygon vertices. The current color, normal, and texture coordinates are associated with the vertex when glVertex is called. When only *x* and *y* are specified, *z* defaults to 0.0 and *w* defaults to 1.0. When *x*, *y*, and *z* are specified, *w* defaults to 1.0. Invoking glVertex outside of a **glBegin*/*glEnd** pair results in undefined behavior.
     * @param {Float} x Specifies the x-coordinate of a vertex.
     * @param {Float} y Specifies the y-coordinate of a vertex.
     * @param {Float} z Specifies the z-coordinate of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex3f
     */
    static glVertex3f(x, y, z) {
        DllCall("OPENGL32.dll\glVertex3f", "float", x, "float", y, "float", z)
    }

    /**
     * Specifies a vertex. | glVertex3fv function (Gl.h)
     * @param {Pointer<Single>} v A pointer to an array of three elements. The elements are the x, y, and z coordinates of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex3fv
     */
    static glVertex3fv(v) {
        DllCall("OPENGL32.dll\glVertex3fv", "ptr", v)
    }

    /**
     * Specifies a vertex. | glVertex3i function (Gl.h)
     * @remarks
     * The glVertex function commands are used within [**glBegin**](glbegin.md)/[**glEnd**](glend.md) pairs to specify point, line, and polygon vertices. The current color, normal, and texture coordinates are associated with the vertex when glVertex is called. When only *x* and *y* are specified, *z* defaults to 0.0 and *w* defaults to 1.0. When *x*, *y*, and *z* are specified, *w* defaults to 1.0. Invoking glVertex outside of a **glBegin*/*glEnd** pair results in undefined behavior.
     * @param {Integer} x Specifies the x-coordinate of a vertex.
     * @param {Integer} y Specifies the y-coordinate of a vertex.
     * @param {Integer} z Specifies the z-coordinate of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex3i
     */
    static glVertex3i(x, y, z) {
        DllCall("OPENGL32.dll\glVertex3i", "int", x, "int", y, "int", z)
    }

    /**
     * Specifies a vertex. | glVertex3iv function (Gl.h)
     * @param {Pointer<Int32>} v A pointer to an array of three elements. The elements are the x, y, and z coordinates of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex3iv
     */
    static glVertex3iv(v) {
        DllCall("OPENGL32.dll\glVertex3iv", "ptr", v)
    }

    /**
     * Specifies a vertex. | glVertex3s function (Gl.h)
     * @remarks
     * The glVertex function commands are used within [**glBegin**](glbegin.md)/[**glEnd**](glend.md) pairs to specify point, line, and polygon vertices. The current color, normal, and texture coordinates are associated with the vertex when glVertex is called. When only *x* and *y* are specified, *z* defaults to 0.0 and *w* defaults to 1.0. When *x*, *y*, and *z* are specified, *w* defaults to 1.0. Invoking glVertex outside of a **glBegin*/*glEnd** pair results in undefined behavior.
     * @param {Integer} x Specifies the x-coordinate of a vertex.
     * @param {Integer} y Specifies the y-coordinate of a vertex.
     * @param {Integer} z Specifies the z-coordinate of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex3s
     */
    static glVertex3s(x, y, z) {
        DllCall("OPENGL32.dll\glVertex3s", "short", x, "short", y, "short", z)
    }

    /**
     * Specifies a vertex. | glVertex3sv function (Gl.h)
     * @param {Pointer<Int16>} v A pointer to an array of three elements. The elements are the x, y, and z coordinates of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex3sv
     */
    static glVertex3sv(v) {
        DllCall("OPENGL32.dll\glVertex3sv", "ptr", v)
    }

    /**
     * Specifies a vertex. | glVertex4d function (Gl.h)
     * @remarks
     * The glVertex function commands are used within [**glBegin**](glbegin.md)/[**glEnd**](glend.md) pairs to specify point, line, and polygon vertices. The current color, normal, and texture coordinates are associated with the vertex when glVertex is called. When only *x* and *y* are specified, *z* defaults to 0.0 and *w* defaults to 1.0. When *x*, *y*, and *z* are specified, *w* defaults to 1.0. Invoking glVertex outside of a **glBegin*/*glEnd** pair results in undefined behavior.
     * @param {Float} x Specifies the x-coordinate of a vertex.
     * @param {Float} y Specifies the y-coordinate of a vertex.
     * @param {Float} z Specifies the z-coordinate of a vertex.
     * @param {Float} w Specifies the w-coordinate of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex4d
     */
    static glVertex4d(x, y, z, w) {
        DllCall("OPENGL32.dll\glVertex4d", "double", x, "double", y, "double", z, "double", w)
    }

    /**
     * Specifies a vertex. | glVertex4dv function (Gl.h)
     * @param {Pointer<Double>} v A pointer to an array of four elements. The elements are the x, y, z, and w coordinates of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex4dv
     */
    static glVertex4dv(v) {
        DllCall("OPENGL32.dll\glVertex4dv", "ptr", v)
    }

    /**
     * Specifies a vertex. | glVertex4f function (Gl.h)
     * @remarks
     * The glVertex function commands are used within [**glBegin**](glbegin.md)/[**glEnd**](glend.md) pairs to specify point, line, and polygon vertices. The current color, normal, and texture coordinates are associated with the vertex when glVertex is called. When only *x* and *y* are specified, *z* defaults to 0.0 and *w* defaults to 1.0. When *x*, *y*, and *z* are specified, *w* defaults to 1.0. Invoking glVertex outside of a **glBegin*/*glEnd** pair results in undefined behavior.
     * @param {Float} x Specifies the x-coordinate of a vertex.
     * @param {Float} y Specifies the y-coordinate of a vertex.
     * @param {Float} z Specifies the z-coordinate of a vertex.
     * @param {Float} w Specifies the w-coordinate of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex4f
     */
    static glVertex4f(x, y, z, w) {
        DllCall("OPENGL32.dll\glVertex4f", "float", x, "float", y, "float", z, "float", w)
    }

    /**
     * Specifies a vertex. | glVertex4fv function (Gl.h)
     * @param {Pointer<Single>} v A pointer to an array of four elements. The elements are the x, y, z, and w coordinates of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex4fv
     */
    static glVertex4fv(v) {
        DllCall("OPENGL32.dll\glVertex4fv", "ptr", v)
    }

    /**
     * Specifies a vertex. | glVertex4i function (Gl.h)
     * @remarks
     * The glVertex function commands are used within [**glBegin**](glbegin.md)/[**glEnd**](glend.md) pairs to specify point, line, and polygon vertices. The current color, normal, and texture coordinates are associated with the vertex when glVertex is called. When only *x* and *y* are specified, *z* defaults to 0.0 and *w* defaults to 1.0. When *x*, *y*, and *z* are specified, *w* defaults to 1.0. Invoking glVertex outside of a **glBegin*/*glEnd** pair results in undefined behavior.
     * @param {Integer} x Specifies the x-coordinate of a vertex.
     * @param {Integer} y Specifies the y-coordinate of a vertex.
     * @param {Integer} z Specifies the z-coordinate of a vertex.
     * @param {Integer} w Specifies the w-coordinate of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex4i
     */
    static glVertex4i(x, y, z, w) {
        DllCall("OPENGL32.dll\glVertex4i", "int", x, "int", y, "int", z, "int", w)
    }

    /**
     * Specifies a vertex. | glVertex4iv function (Gl.h)
     * @param {Pointer<Int32>} v A pointer to an array of four elements. The elements are the x, y, z, and w coordinates of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex4iv
     */
    static glVertex4iv(v) {
        DllCall("OPENGL32.dll\glVertex4iv", "ptr", v)
    }

    /**
     * Specifies a vertex. | glVertex4s function (Gl.h)
     * @remarks
     * The glVertex function commands are used within [**glBegin**](glbegin.md)/[**glEnd**](glend.md) pairs to specify point, line, and polygon vertices. The current color, normal, and texture coordinates are associated with the vertex when glVertex is called. When only *x* and *y* are specified, *z* defaults to 0.0 and *w* defaults to 1.0. When *x*, *y*, and *z* are specified, *w* defaults to 1.0. Invoking glVertex outside of a **glBegin*/*glEnd** pair results in undefined behavior.
     * @param {Integer} x Specifies the x-coordinate of a vertex.
     * @param {Integer} y Specifies the y-coordinate of a vertex.
     * @param {Integer} z Specifies the z-coordinate of a vertex.
     * @param {Integer} w Specifies the w-coordinate of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex4s
     */
    static glVertex4s(x, y, z, w) {
        DllCall("OPENGL32.dll\glVertex4s", "short", x, "short", y, "short", z, "short", w)
    }

    /**
     * Specifies a vertex. | glVertex4sv function (Gl.h)
     * @param {Pointer<Int16>} v A pointer to an array of four elements. The elements are the x, y, z, and w coordinates of a vertex.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertex4sv
     */
    static glVertex4sv(v) {
        DllCall("OPENGL32.dll\glVertex4sv", "ptr", v)
    }

    /**
     * The glVertexPointer function defines an array of vertex data.
     * @remarks
     * The **glVertexPointer** function specifies the location and data of an array of vertex coordinates to use when rendering. The *size* parameter specifies the number of coordinates per vertex. The *type* parameter specifies the data type of each vertex coordinate. The *stride* parameter determines the byte offset from one vertex to the next, enabling the packing of vertices and attributes in a single array or storage in separate arrays. In some implementations, storing the vertices and attributes in a single array can be more efficient than using separate arrays (see [**glInterleavedArrays**](glinterleavedarrays.md)).
     * 
     * A vertex array is enabled when you specify the GL\_VERTEX\_ARRAY constant with [**glEnableClientState**](glenableclientstate.md). When enabled, [**glDrawArrays**](gldrawarrays.md), [**glDrawElements**](gldrawelements.md), and [**glArrayElement**](glarrayelement.md) use the vertex array. By default, the vertex array is disabled.
     * 
     * You cannot include **glVertexPointer** in display lists.
     * 
     * When you specify a vertex array using **glVertexPointer**, the values of all the function's vertex array parameters are saved in a client-side state, and static array elements can be cached. Because the vertex array parameters are client-side state, their values are not saved or restored by [**glPushAttrib**](glpushattrib.md) and **glPopAttrib**.
     * 
     * Although no error is generated if you call **glVertexPointer** within [**glBegin**](glbegin.md) and [**glEnd**](glend.md) pairs, the results are undefined.
     * 
     * The following functions retrieve information related to **glVertexPointer**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_VERTEX\_ARRAY\_SIZE
     * 
     * **glGet** with argument GL\_VERTEX\_ARRAY\_STRIDE
     * 
     * **glGet** with argument GL\_VERTEX\_ARRAY\_COUNT
     * 
     * **glGet** with argument GL\_VERTEX\_ARRAY\_TYPE
     * 
     * [**glGetPointerv**](glgetpointerv.md) with argument GL\_VERTEX\_ARRAY\_POINTER
     * 
     * [**glIsEnabled**](glisenabled.md) with argument GL\_VERTEX\_ARRAY
     * @param {Integer} size The number of coordinates per vertex. The value of *size* must be 2, 3, or 4.
     * @param {Integer} type The data type of each coordinate in the array using the following symbolic constants: GL\_SHORT, GL\_INT, GL\_FLOAT, and GL\_DOUBLE.
     * @param {Integer} stride The byte offset between consecutive vertices. When *stride* is zero, the vertices are tightly packed in the array.
     * @param {Pointer<Void>} pointer A pointer to the first coordinate of the first vertex in the array.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glvertexpointer
     */
    static glVertexPointer(size, type, stride, pointer) {
        DllCall("OPENGL32.dll\glVertexPointer", "int", size, "uint", type, "int", stride, "ptr", pointer)
    }

    /**
     * The glViewport function sets the viewport.
     * @remarks
     * The **glViewport** function specifies the affine transformation of *x* and *y* from normalized device coordinates to window coordinates. Let (*x*<sub>nd</sub> , *y*<sub>nd</sub> ) be normalized device coordinates. The window coordinates (*x*<sub>w</sub> , *y*<sub>w</sub> ) are then computed as follows:
     * 
     * ![Equation showing computation of the window coordinates.](images/view01.png)
     * 
     * Viewport width and height are silently clamped to a range that depends on the implementation. This range is queried by calling **glGet** with argument GL\_MAX\_VIEWPORT\_DIMS.
     * 
     * The following functions retrieve information related to **glViewport**:
     * 
     * [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_VIEWPORT
     * 
     * **glGet** with argument GL\_MAX\_VIEWPORT\_DIMS
     * @param {Integer} x The lower-left corner of the viewport rectangle, in pixels. The default is (0,0).
     * @param {Integer} y The lower-left corner of the viewport rectangle, in pixels. The default is (0,0).
     * @param {Integer} width The width of the viewport. When an OpenGL context is first attached to a window, *width* and *height* are set to the dimensions of that window.
     * @param {Integer} height The height of the viewport. When an OpenGL context is first attached to a window, *width* and *height* are set to the dimensions of that window.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glviewport
     */
    static glViewport(x, y, width, height) {
        DllCall("OPENGL32.dll\glViewport", "int", x, "int", y, "int", width, "int", height)
    }

    /**
     * The gluErrorString function produces an error string from an OpenGL or GLU error code. The error string is ANSI only.
     * @remarks
     * The **gluErrorString** function produces an error string from an OpenGL or GLU error code. The string is in an ISO Latin 1 format. For example, **gluErrorString**(GL\_OUT\_OF\_MEMORY) returns the string "out of memory".
     * 
     * The standard GLU error codes are GLU\_INVALID\_ENUM, GLU\_INVALID\_VALUE, and GLU\_OUT\_OF\_MEMORY. Certain other GLU functions can return specialized error codes through callbacks. For the list of OpenGL error codes, see [**glGetError**](glgeterror.md).
     * 
     * The **gluErrorString** function produces error strings in ANSI only. Whenever possible, use **gluErrorStringWIN**, which allows ANSI or Unicode error strings. This makes it easier to localize your program for use with another language.
     * @param {Integer} errCode An OpenGL or GLU error code.
     * @returns {Pointer<Byte>} 
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gluerrorstring
     */
    static gluErrorString(errCode) {
        result := DllCall("GLU32.dll\gluErrorString", "uint", errCode, "ptr")
        return result
    }

    /**
     * 
     * @param {Integer} errCode 
     * @returns {Pointer<PWSTR>} 
     */
    static gluErrorUnicodeStringEXT(errCode) {
        result := DllCall("GLU32.dll\gluErrorUnicodeStringEXT", "uint", errCode, "ptr")
        return result
    }

    /**
     * The gluGetString function gets a string that describes the GLU version number or supported GLU extension calls.
     * @remarks
     * The **gluGetString** function returns a pointer to a static, null-terminated string. When *name* is GLU\_VERSION, the returned string is a value that represents the version number of GLU. The format of the version number is as follows:
     * 
     * ``` syntax
     * <version number><space><vendor-specific information> 
     * (for example, "1.2.11 Microsoft Windows")
     * ```
     * 
     * The version number has the form "major\_number.minor\_number" or "major\_number.minor\_number.release\_number". The vendor-specific information is optional, and the format and contents depend on the implementation.
     * 
     * When *name* is GLU\_EXTENSIONS, the returned string contains a list of names of supported GLU extensions that are separated by spaces. The format of the returned list of names is as follows:
     * 
     * ``` syntax
     * <extension_name><space><extension_name><space> . . .
     * (for example, "GLU_NURBS GL_TESSELATION")
     * ```
     * 
     * The extension names cannot contain any spaces.
     * 
     * The **gluGetString** function is valid for GLU version 1.1 or later.
     * @param {Integer} name Either the version number of GLU (GLU\_VERSION) or available vendor-specific extension calls (GLU\_EXTENSIONS).
     * @returns {Pointer<Byte>} 
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glugetstring
     */
    static gluGetString(name) {
        result := DllCall("GLU32.dll\gluGetString", "uint", name, "ptr")
        return result
    }

    /**
     * The gluOrtho2D function defines a 2-D orthographic projection matrix.
     * @remarks
     * The **gluOrtho2D** function sets up a two-dimensional orthographic viewing region. This is equivalent to calling [**glOrtho**](glortho.md) with zNear = -1 and zFar = 1.
     * @param {Float} left The coordinate for the left vertical clipping plane.
     * @param {Float} right The coordinate for the right vertical clipping plane.
     * @param {Float} bottom The coordinate for the bottom horizontal clipping plane.
     * @param {Float} top The coordinate for the top horizontal clipping plane.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gluortho2d
     */
    static gluOrtho2D(left, right, bottom, top) {
        DllCall("GLU32.dll\gluOrtho2D", "double", left, "double", right, "double", bottom, "double", top)
    }

    /**
     * The gluPerspective function sets up a perspective projection matrix.
     * @remarks
     * The **gluPerspective** function specifies a viewing frustum into the world coordinate system. In general, the aspect ratio in **gluPerspective** should match the aspect ratio of the associated viewport. For example, *aspect* = 2.0 means the viewer's angle of view is twice as wide in *x* as it is in *y*. If the viewport is twice as wide as it is tall, it displays the image without distortion.
     * 
     * The matrix generated by **gluPerspective** is multiplied by the current matrix, just as if [**glMultMatrix**](glmultmatrix.md) were called with the generated matrix. To load the perspective matrix onto the current matrix stack instead, precede the call to **gluPerspective** with a call to [**glLoadIdentity**](glloadidentity.md).
     * @param {Float} fovy The field of view angle, in degrees, in the y-direction.
     * @param {Float} aspect The aspect ratio that determines the field of view in the x-direction. The aspect ratio is the ratio of *x* (width) to *y* (height).
     * @param {Float} zNear The distance from the viewer to the near clipping plane (always positive).
     * @param {Float} zFar The distance from the viewer to the far clipping plane (always positive).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gluperspective
     */
    static gluPerspective(fovy, aspect, zNear, zFar) {
        DllCall("GLU32.dll\gluPerspective", "double", fovy, "double", aspect, "double", zNear, "double", zFar)
    }

    /**
     * The gluPickMatrix function defines a picking region.
     * @remarks
     * The **gluPickMatrix** function creates a projection matrix you can use to restrict drawing to a small region of the viewport.
     * 
     * 1.  Use **gluPickMatrix** to restrict drawing to a small region around the cursor.
     * 2.  Enter selection mode (with [**glRenderMode**](glrendermode.md)), and then rerender the scene.
     * 
     *     All primitives that would have been drawn near the cursor are identified and stored in the selection buffer.
     * 
     * The matrix created by **gluPickMatrix** is multiplied by the current matrix just as if [**glMultMatrix**](glmultmatrix.md) were called with the generated matrix.
     * 
     * 1.  Call [**glLoadIdentity**](glloadidentity.md) to load an identity matrix onto the perspective matrix stack.
     * 2.  Call **gluPickMatrix**.
     * 3.  Call a function (such as [**gluPerspective**](gluperspective.md)) to multiply the perspective matrix by the pick matrix.
     * 
     * When using **gluPickMatrix** to pick Non-Uniform Rational B-Spline ([NURBS](using-nurbs-curves-and-surfaces.md)), be careful to turn off the NURBS property, GLU\_AUTO\_LOAD\_MATRIX. If GLU\_AUTO\_LOAD\_MATRIX is not turned off, any NURBS surface rendered is subdivided differently with the pick matrix from how it was subdivided without the pick matrix.
     * @param {Float} x The x window coordinate of a picking region.
     * @param {Float} y The y window coordinate of a picking region.
     * @param {Float} width The width of the picking region in window coordinates.
     * @param {Float} height The height of the picking region in window coordinates.
     * @param {Pointer<Int32>} viewport The current viewport (as from a [**glGetIntegerv**](glgetintegerv.md) call).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glupickmatrix
     */
    static gluPickMatrix(x, y, width, height, viewport) {
        DllCall("GLU32.dll\gluPickMatrix", "double", x, "double", y, "double", width, "double", height, "ptr", viewport)
    }

    /**
     * The gluLookAt function defines a viewing transformation.
     * @remarks
     * The **gluLookAt** function creates a viewing matrix derived from an eye point, a reference point indicating the center of the scene, and an up vector. The matrix maps the reference point to the negative z-axis and the eye point to the origin, so that when you use a typical projection matrix, the center of the scene maps to the center of the viewport. Similarly, the direction described by the up vector projected onto the viewing plane is mapped to the positive y-axis so that it points upward in the viewport. The up vector must not be parallel to the line of sight from the eye to the reference point.
     * 
     * The matrix generated by **gluLookAt** postmultiplies the current matrix.
     * @param {Float} eyex The position of the eye point.
     * @param {Float} eyey The position of the eye point.
     * @param {Float} eyez The position of the eye point.
     * @param {Float} centerx The position of the reference point.
     * @param {Float} centery The position of the reference point.
     * @param {Float} centerz The position of the reference point.
     * @param {Float} upx The direction of the up vector.
     * @param {Float} upy The direction of the up vector.
     * @param {Float} upz The direction of the up vector.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glulookat
     */
    static gluLookAt(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz) {
        DllCall("GLU32.dll\gluLookAt", "double", eyex, "double", eyey, "double", eyez, "double", centerx, "double", centery, "double", centerz, "double", upx, "double", upy, "double", upz)
    }

    /**
     * The gluProject function maps object coordinates to window coordinates.
     * @remarks
     * The **gluProject** function transforms the specified object coordinates into window coordinates using *modelMatrix*, *projMatrix*, and *viewport*. The result is stored in *winx*, *winy*, and *winz*.
     * @param {Float} objx The x object coordinate.
     * @param {Float} objy The y object coordinate.
     * @param {Float} objz The z object coordinate.
     * @param {Pointer<Double>} modelMatrix The current modelview matrix (as from a [**glGetDoublev**](glgetdoublev.md) call).
     * @param {Pointer<Double>} projMatrix The current projection matrix (as from a **glGetDoublev** call).
     * @param {Pointer<Int32>} viewport The current viewport (as from a [**glGetIntegerv**](glgetintegerv.md) call).
     * @param {Pointer<Double>} winx The computed x window coordinate.
     * @param {Pointer<Double>} winy The computed y window coordinate.
     * @param {Pointer<Double>} winz The computed z window coordinate.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gluproject
     */
    static gluProject(objx, objy, objz, modelMatrix, projMatrix, viewport, winx, winy, winz) {
        DllCall("GLU32.dll\gluProject", "double", objx, "double", objy, "double", objz, "ptr", modelMatrix, "ptr", projMatrix, "ptr", viewport, "ptr", winx, "ptr", winy, "ptr", winz)
    }

    /**
     * The gluUnProject function maps window coordinates to object coordinates.
     * @remarks
     * The **gluUnProject** function maps the specified window coordinates into object coordinates using *modelMatrix*, *projMatrix*, and *viewport*. The result is stored in *objx*, *objy*, and *objz*.
     * @param {Float} winx The x window coordinate to be mapped.
     * @param {Float} winy The y window coordinate to be mapped.
     * @param {Float} winz The z window coordinate to be mapped.
     * @param {Pointer<Double>} modelMatrix The modelview matrix (as from a [**glGetDoublev**](glgetdoublev.md) call).
     * @param {Pointer<Double>} projMatrix The projection matrix (as from a **glGetDoublev** call).
     * @param {Pointer<Int32>} viewport The viewport (as from a [**glGetIntegerv**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) call).
     * @param {Pointer<Double>} objx The computed x object coordinate.
     * @param {Pointer<Double>} objy The computed y object coordinate.
     * @param {Pointer<Double>} objz The computed z object coordinate.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gluunproject
     */
    static gluUnProject(winx, winy, winz, modelMatrix, projMatrix, viewport, objx, objy, objz) {
        DllCall("GLU32.dll\gluUnProject", "double", winx, "double", winy, "double", winz, "ptr", modelMatrix, "ptr", projMatrix, "ptr", viewport, "ptr", objx, "ptr", objy, "ptr", objz)
    }

    /**
     * The gluScaleImage function scales an image to an arbitrary size.
     * @remarks
     * The **gluScaleImage** function scales a pixel image using the appropriate pixel store modes to unpack data from the source image and pack data into the destination image.
     * 
     * When shrinking an image, **gluScaleImage** uses a box filter to sample the source image and create pixels for the destination image. When magnifying an image, the pixels from the source image are linearly interpolated to create the destination image.
     * 
     * For a description of the acceptable values for the *format*, *typein*, and *typeout* parameters, see [**glReadPixels**](glreadpixels.md).
     * @param {Integer} format The format of the pixel data. The following symbolic values are valid: GL\_COLOR\_INDEX, GL\_STENCIL\_INDEX, GL\_DEPTH\_COMPONENT, GL\_RED, GL\_GREEN, GL\_BLUE, GL\_ALPHA, GL\_RGB, GL\_RGBA, GL\_BGR\_EXT, GL\_BGRA\_EXT, GL\_LUMINANCE, and GL\_LUMINANCE\_ALPHA.
     * @param {Integer} widthin The width of the source image that is scaled.
     * @param {Integer} heightin The height of the source image that is scaled.
     * @param {Integer} typein The data type for *datain*. Must be one of the following: GL\_UNSIGNED\_BYTE, GL\_BYTE, GL\_BITMAP, GL\_UNSIGNED\_SHORT, GL\_SHORT, GL\_UNSIGNED\_INT, GL\_INT, or GL\_FLOAT.
     * @param {Pointer<Void>} datain A pointer to the source image.
     * @param {Integer} widthout The width of the destination image.
     * @param {Integer} heightout The height of the destination image.
     * @param {Integer} typeout The data type for *dataout*. Must be one of the following: GL\_UNSIGNED\_BYTE, GL\_BYTE, GL\_BITMAP, GL\_UNSIGNED\_SHORT, GL\_SHORT, GL\_UNSIGNED\_INT, GL\_INT, or GL\_FLOAT.
     * @param {Pointer<Void>} dataout A pointer to the destination image.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gluscaleimage
     */
    static gluScaleImage(format, widthin, heightin, typein, datain, widthout, heightout, typeout, dataout) {
        DllCall("GLU32.dll\gluScaleImage", "uint", format, "int", widthin, "int", heightin, "uint", typein, "ptr", datain, "int", widthout, "int", heightout, "uint", typeout, "ptr", dataout)
    }

    /**
     * The gluBuild1DMipmaps function creates 1-D mipmaps.
     * @remarks
     * The **gluBuild1DMipmaps** function obtains the input image and generates all mipmap images (using [**gluScaleImage**](gluscaleimage.md)) so that the input image can be used as a mipmapped texture image. The [**glTexImage1D**](glteximage1d.md) function is then called to load each of the images. If the width of the input image is not a power of two, then the image is scaled to the nearest power of two before the mipmaps are generated.
     * 
     * A return value of zero indicates success. Otherwise, a GLU error code is returned (see [**gluErrorString**](gluerrorstring.md)).
     * 
     * For a description of the acceptable values for the *format* parameter, see **glTexImage1D**. For a description of the acceptable values for the *type* parameter, see [**glDrawPixels**](gldrawpixels.md).
     * @param {Integer} target The target texture. Must be GL\_TEXTURE\_1D.
     * @param {Integer} components The number of color components in the texture. Must be 1, 2, 3, or 4.
     * @param {Integer} width The width of the texture image.
     * @param {Integer} format The format of the pixel data. The following values are valid: GL\_COLOR\_INDEX, GL\_RED, GL\_GREEN, GL\_BLUE, GL\_ALPHA, GL\_RGB, GL\_RGBA, GL\_BGR\_EXT, GL\_BGRA\_EXT, GL\_LUMINANCE, or GL\_LUMINANCE\_ALPHA.
     * @param {Integer} type The data type for *data*. The following values are valid: GL\_UNSIGNED\_BYTE, GL\_BYTE, GL\_BITMAP, GL\_UNSIGNED\_SHORT, GL\_SHORT, GL\_UNSIGNED\_INT, GL\_INT, or GL\_FLOAT.
     * @param {Pointer<Void>} data A pointer to the image data in memory.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glubuild1dmipmaps
     */
    static gluBuild1DMipmaps(target, components, width, format, type, data) {
        DllCall("GLU32.dll\gluBuild1DMipmaps", "uint", target, "int", components, "int", width, "uint", format, "uint", type, "ptr", data)
    }

    /**
     * The gluBuild2DMipmaps function creates 2-D mipmaps.
     * @remarks
     * The **gluBuild2DMipmaps** function obtains the input image and generates all mipmap images (using [**gluScaleImage**](gluscaleimage.md)) so the input image can be used as a mipmapped texture image. To load each of the images, call [**glTexImage2D**](glteximage2d.md). If the dimensions of the input image are not powers of two, then the image is scaled so that both the width and height are powers of two before the mipmaps are generated.
     * 
     * A return value of zero indicates success. Otherwise, a GLU error code is returned (see [**gluErrorString**](gluerrorstring.md)).
     * 
     * For a description of the acceptable values for the *format* parameter, see **glTexImage2D**. For a description of the acceptable values for *type*, see [**glDrawPixels**](gldrawpixels.md).
     * @param {Integer} target The target texture. Must be GL\_TEXTURE\_2D.
     * @param {Integer} components The number of color components in the texture. Must be 1, 2, 3, or 4.
     * @param {Integer} width The width of the texture image.
     * @param {Integer} height The height of the texture image.
     * @param {Integer} format The format of the pixel data. Must be one of the following: GL\_COLOR\_INDEX, GL\_RED, GL\_GREEN, GL\_BLUE, GL\_ALPHA, GL\_RGB, GL\_RGBA, GL\_BGR\_EXT, GL\_BGRA\_EXT, GL\_LUMINANCE, or GL\_LUMINANCE\_ALPHA.
     * @param {Integer} type The data type for *data*. Must be one of the following: GL\_UNSIGNED\_BYTE, GL\_BYTE, GL\_BITMAP, GL\_UNSIGNED\_SHORT, GL\_SHORT, GL\_UNSIGNED\_INT, GL\_INT, or GL\_FLOAT.
     * @param {Pointer<Void>} data A pointer to the image data in memory.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glubuild2dmipmaps
     */
    static gluBuild2DMipmaps(target, components, width, height, format, type, data) {
        DllCall("GLU32.dll\gluBuild2DMipmaps", "uint", target, "int", components, "int", width, "int", height, "uint", format, "uint", type, "ptr", data)
    }

    /**
     * The gluNewQuadric function creates a quadric object.
     * @remarks
     * This function has no parameters.
     * 
     * 
     * The **gluNewQuadric** function creates and returns a pointer to a new quadric object. Refer to this object when calling quadric rendering and control functions. A return value of zero means there is not enough memory to allocate to the object.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glunewquadric
     */
    static gluNewQuadric() {
        DllCall("GLU32.dll\gluNewQuadric")
    }

    /**
     * The gluDeleteQuadric function destroys a quadric object.
     * @remarks
     * The **gluDeleteQuadric** function destroys the quadric object and frees any memory that it used. After you have called **gluDeleteQuadric**, you cannot use *state* again.
     * @param {Pointer<IntPtr>} state The quadric object to be destroyed (created with [**gluNewQuadric**](glunewquadric.md)).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gludeletequadric
     */
    static gluDeleteQuadric(state) {
        DllCall("GLU32.dll\gluDeleteQuadric", "ptr", state)
    }

    /**
     * The gluQuadricNormals function specifies what kind of normals are to be used for quadrics.
     * @remarks
     * The **gluQuadricNormals** function specifies what kind of normals are to be used for quadrics rendered with **quadObject**.
     * @param {Pointer<IntPtr>} quadObject The quadric object (created with [**gluNewQuadric**](glunewquadric.md)).
     * @param {Integer} normals The desired type of normals. The following values are valid.
     * 
     * 
     * 
     * | Value                                                                                                                                                | Meaning                                                                                      |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------|
     * | <span id="GLU_NONE"></span><span id="glu_none"></span><dl> <dt>**GLU\_NONE**</dt> </dl>       | No normals are generated.<br/>                                                         |
     * | <span id="GLU_FLAT"></span><span id="glu_flat"></span><dl> <dt>**GLU\_FLAT**</dt> </dl>       | One normal is generated for every facet of a quadric.<br/>                             |
     * | <span id="GLU_SMOOTH"></span><span id="glu_smooth"></span><dl> <dt>**GLU\_SMOOTH**</dt> </dl> | One normal is generated for every vertex of a quadric. This is the default value.<br/> |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gluquadricnormals
     */
    static gluQuadricNormals(quadObject, normals) {
        DllCall("GLU32.dll\gluQuadricNormals", "ptr", quadObject, "uint", normals)
    }

    /**
     * The gluQuadricTexture function specifies whether quadrics are to be textured.
     * @remarks
     * The **gluQuadricTexture** function specifies whether texture coordinates are to be generated for quadrics rendered with **quadObject**.
     * 
     * The manner in which texture coordinates are generated depends upon the specific quadric rendered.
     * @param {Pointer<IntPtr>} quadObject The quadric object (created with [**gluNewQuadric**](glunewquadric.md)).
     * @param {Integer} textureCoords A flag indicating whether texture coordinates are to be generated. The following values are valid.
     * 
     * 
     * 
     * | Value                                                                                                                                          | Meaning                                                                    |
     * |------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------|
     * | <span id="GL_TRUE"></span><span id="gl_true"></span><dl> <dt>**GL\_TRUE**</dt> </dl>    | Generate texture coordinates.<br/>                                   |
     * | <span id="GL_FALSE"></span><span id="gl_false"></span><dl> <dt>**GL\_FALSE**</dt> </dl> | Do not generate texture coordinates. This is the default value.<br/> |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gluquadrictexture
     */
    static gluQuadricTexture(quadObject, textureCoords) {
        DllCall("GLU32.dll\gluQuadricTexture", "ptr", quadObject, "char", textureCoords)
    }

    /**
     * The gluQuadricOrientation function specifies inside or outside orientation for quadrics.
     * @remarks
     * The **gluQuadricOrientation** function specifies what kind of orientation is desired for quadrics rendered with **quadObject**. The interpretation of outward and inward depends on the quadric being drawn.
     * @param {Pointer<IntPtr>} quadObject The quadric object (created with [**gluNewQuadric**](glunewquadric.md)).
     * @param {Integer} orientation The desired orientation. The following values are valid.
     * 
     * 
     * 
     * | Value                                                                                                                                                   | Meaning                                                                            |
     * |---------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------|
     * | <span id="GLU_OUTSIDE"></span><span id="glu_outside"></span><dl> <dt>**GLU\_OUTSIDE**</dt> </dl> | Draw quadrics with normals pointing outward. This is the default value.<br/> |
     * | <span id="GLU_INSIDE"></span><span id="glu_inside"></span><dl> <dt>**GLU\_INSIDE**</dt> </dl>    | Draw quadrics with normals pointing inward.<br/>                             |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gluquadricorientation
     */
    static gluQuadricOrientation(quadObject, orientation) {
        DllCall("GLU32.dll\gluQuadricOrientation", "ptr", quadObject, "uint", orientation)
    }

    /**
     * The gluQuadricDrawStyle function specifies the draw style desired for quadrics.
     * @remarks
     * The **gluQuadricDrawStyle** function specifies the draw style for quadrics rendered with **quadObject**.
     * @param {Pointer<IntPtr>} quadObject The quadric object (created with [**gluNewQuadric**](glunewquadric.md)).
     * @param {Integer} drawStyle The desired draw style. The following values are valid.
     * 
     * 
     * 
     * | Value                                                                                                                                                            | Meaning                                                                                                                                                                                                                |
     * |------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GLU_FILL"></span><span id="glu_fill"></span><dl> <dt>**GLU\_FILL**</dt> </dl>                   | Quadrics are rendered with polygon primitives. The polygons are drawn in a counterclockwise fashion with respect to their normals (as defined with [**gluQuadricOrientation**](gluquadricorientation.md)).<br/> |
     * | <span id="GLU_LINE"></span><span id="glu_line"></span><dl> <dt>**GLU\_LINE**</dt> </dl>                   | Quadrics are rendered as a set of lines.<br/>                                                                                                                                                                    |
     * | <span id="GLU_SILHOUETTE"></span><span id="glu_silhouette"></span><dl> <dt>**GLU\_SILHOUETTE**</dt> </dl> | Quadrics are rendered as a set of lines, except that edges separating coplanar faces will not be drawn.<br/>                                                                                                     |
     * | <span id="GLU_POINT"></span><span id="glu_point"></span><dl> <dt>**GLU\_POINT**</dt> </dl>                | Quadrics are rendered as a set of points.<br/>                                                                                                                                                                   |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gluquadricdrawstyle
     */
    static gluQuadricDrawStyle(quadObject, drawStyle) {
        DllCall("GLU32.dll\gluQuadricDrawStyle", "ptr", quadObject, "uint", drawStyle)
    }

    /**
     * The gluCylinder function draws a cylinder.
     * @remarks
     * The **gluCylinder** function draws a cylinder oriented along the z-axis. The base of the cylinder is placed at *z* = 0, and the top at *z* = *height*. Like a sphere, a cylinder is subdivided around the z-axis into slices, and along the z-axis into stacks.
     * 
     * Note that if *topRadius* is set to zero, then this routine will generate a cone.
     * 
     * If the orientation is set to GLU\_OUTSIDE (with [**gluQuadricOrientation**](gluquadricorientation.md)), then any generated normals point away from the z-axis. Otherwise, they point toward the z-axis.
     * 
     * If texturing is turned on (with [**gluQuadricTexture**](gluquadrictexture.md)): texture coordinates are generated so that *t* ranges linearly from 0.0 at *z* = 0 to 1.0 at *z* = *height*; and *s* ranges from 0.0 at the positive y-axis, to 0.25 at the positive x-axis, to 0.5 at the negative y-axis, to 0.75 at the negative x-axis, and back to 1.0 at the positive y-axis.
     * @param {Pointer<IntPtr>} qobj The quadric object (created with [**gluNewQuadric**](glunewquadric.md)).
     * @param {Float} baseRadius The radius of the cylinder at *z* = 0.
     * @param {Float} topRadius The radius of the cylinder at *z* = *height*.
     * @param {Float} height The height of the cylinder.
     * @param {Integer} slices The number of subdivisions around the z-axis.
     * @param {Integer} stacks The number of subdivisions along the z-axis.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glucylinder
     */
    static gluCylinder(qobj, baseRadius, topRadius, height, slices, stacks) {
        DllCall("GLU32.dll\gluCylinder", "ptr", qobj, "double", baseRadius, "double", topRadius, "double", height, "int", slices, "int", stacks)
    }

    /**
     * The gluDisk function draws a disk.
     * @remarks
     * The **gluDisk** function renders a disk on the *z* = 0 plane. The disk has a radius of *outerRadius*, and contains a concentric circular hole with a radius of *innerRadius*. If *innerRadius* is 0, then no hole is generated. The disk is subdivided around the z-axis into slices (like pizza slices) and also about the z-axis into rings (as specified by *slices* and *loops*, respectively).
     * 
     * With respect to orientation, the positive *z*-side of the disk is considered to be *outside* (see [**gluQuadricOrientation**](gluquadricorientation.md)). This means that if the orientation is set to GLU\_OUTSIDE, then any normals generated point along the positive z-axis.
     * 
     * If texturing is turned on (with [**gluQuadricTexture**](gluquadrictexture.md)), texture coordinates are generated linearly such that where *r* = *outerRadius*, the value at (*r*, 0, 0) is (1, 0.5); at (0, *r*, 0) it is (0.5, 1); at (-*r*, 0, 0) it is (0, 0.5); and at (0, -*r*, 0) it is (0.5, 0).
     * @param {Pointer<IntPtr>} qobj The quadric object (created with [**gluNewQuadric**](glunewquadric.md)).
     * @param {Float} innerRadius The inner radius of the disk (may be zero).
     * @param {Float} outerRadius The outer radius of the disk.
     * @param {Integer} slices The number of subdivisions around the z-axis.
     * @param {Integer} loops The number of concentric rings about the origin into which the disk is subdivided.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gludisk
     */
    static gluDisk(qobj, innerRadius, outerRadius, slices, loops) {
        DllCall("GLU32.dll\gluDisk", "ptr", qobj, "double", innerRadius, "double", outerRadius, "int", slices, "int", loops)
    }

    /**
     * The gluPartialDisk function draws an arc of a disk.
     * @remarks
     * The **gluPartialDisk** function renders a partial disk on the *z* = 0 plane. A partial disk is similar to a full disk, except that only the subset of the disk from *startAngle* through *startAngle* + *sweepAngle* is included (where 0 degrees is along the positive y-axis, 90 degrees is along the positive x-axis, 180 degrees is along the negative y-axis, and 270 degrees is along the negative x-axis).
     * 
     * The partial disk has a radius of *outerRadius* and contains a concentric circular hole with a radius of *innerRadius*. If *innerRadius* is zero, then no hole is generated. The partial disk is subdivided around the z-axis into slices (like pizza slices), and also about the z-axis into rings (as specified by *slices* and *loops*, respectively).
     * 
     * With respect to orientation, the positive z-side of the partial disk is considered to be outside (see [**gluQuadricOrientation**](gluquadricorientation.md)). This means that if the orientation is set to GLU\_OUTSIDE, then any normals generated point along the positive z-axis.
     * 
     * If you have turned on texturing (with [**gluQuadricTexture**](gluquadrictexture.md)), **gluPartialDisk** generates texture coordinates linearly such that where *r* = *outerRadius*, the value at (*r*, 0, 0) is (1, 0.5); at (0, *r*, 0) it is (0.5, 1); at (*r*, 0, 0) it is (0, 0.5); and at (0, *r*, 0) it is (0.5, 0).
     * @param {Pointer<IntPtr>} qobj A quadric object (created with [**gluNewQuadric**](glunewquadric.md)).
     * @param {Float} innerRadius The inner radius of the partial disk (can be zero).
     * @param {Float} outerRadius The outer radius of the partial disk.
     * @param {Integer} slices The number of subdivisions around the z-axis.
     * @param {Integer} loops The number of concentric rings about the origin into which the partial disk is subdivided.
     * @param {Float} startAngle The starting angle, in degrees, of the disk portion.
     * @param {Float} sweepAngle The sweep angle, in degrees, of the disk portion.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glupartialdisk
     */
    static gluPartialDisk(qobj, innerRadius, outerRadius, slices, loops, startAngle, sweepAngle) {
        DllCall("GLU32.dll\gluPartialDisk", "ptr", qobj, "double", innerRadius, "double", outerRadius, "int", slices, "int", loops, "double", startAngle, "double", sweepAngle)
    }

    /**
     * The gluSphere function draws a sphere.
     * @remarks
     * The **gluSphere** function draws a sphere of the given radius centered around the origin. The sphere is subdivided around the z-axis into slices and along the z-axis into stacks (similar to lines of longitude and latitude).
     * 
     * If the orientation is set to GLU\_OUTSIDE (with **gluQuadricOrientation**), any normals generated point away from the center of the sphere. Otherwise, they point toward the center of the sphere.
     * 
     * If texturing is turned on (with **gluQuadricTexture**): texture coordinates are generated so that *t* ranges from 0.0 at *z* = -*radius* to 1.0 at *z* = *radius* (*t* increases linearly along longitudinal lines); and *s* ranges from 0.0 at the positive y-axis, to 0.25 at the positive x-axis, to 0.5 at the negative y-axis, to 0.75 at the negative x-axis, and back to 1.0 at the positive y-axis.
     * @param {Pointer<IntPtr>} qobj The quadric object (created with [**gluNewQuadric**](glunewquadric.md)).
     * @param {Float} radius The radius of the sphere.
     * @param {Integer} slices The number of subdivisions around the z-axis (similar to lines of longitude).
     * @param {Integer} stacks The number of subdivisions along the z-axis (similar to lines of latitude).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glusphere
     */
    static gluSphere(qobj, radius, slices, stacks) {
        DllCall("GLU32.dll\gluSphere", "ptr", qobj, "double", radius, "int", slices, "int", stacks)
    }

    /**
     * The gluQuadricCallback function defines a callback for a quadric object.
     * @remarks
     * Use **gluQuadricCallback** to define a new callback to be used by a quadric object. If the specified callback is already defined, it is replaced. If *fn* is **NULL**, any existing callback is erased.
     * @param {Pointer<IntPtr>} qobj The quadric object (created with [**gluNewQuadric**](glunewquadric.md)).
     * @param {Integer} which The callback being defined. The only valid value is GLU\_ERROR.
     * 
     * 
     * 
     * | Value                                                                                                                                             | Meaning                                                                                                                                                                                                                                                                                                 |
     * |---------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GLU_ERROR"></span><span id="glu_error"></span><dl> <dt>**GLU\_ERROR**</dt> </dl> | The **gluQuadricCallback** function is called when an error is encountered. Its single argument is of type **GLenum**, and it indicates the specific error that occurred. Character strings describing these errors can be retrieved with the [**gluErrorString**](gluerrorstring.md) call.<br/> |
     * @param {Pointer} fn The function to be called.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gluquadric
     */
    static gluQuadricCallback(qobj, which, fn) {
        DllCall("GLU32.dll\gluQuadricCallback", "ptr", qobj, "uint", which, "ptr", fn)
    }

    /**
     * The gluNewTess function creates a tessellation object.
     * @remarks
     * This function has no parameters.
     * 
     * 
     * The **gluNewTess** function creates and returns a pointer to a new tessellation object. Refer to this object when calling tessellation functions. A return value of zero means there is not enough memory to allocate to the object.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glunewtess
     */
    static gluNewTess() {
        DllCall("GLU32.dll\gluNewTess")
    }

    /**
     * The gluDeleteTess function destroys a tessellation object.
     * @remarks
     * The **gluDeleteTess** function destroys the indicated tessellation object and frees any memory that it used.
     * @param {Pointer<IntPtr>} tess The tessellation object to destroy (created with [**gluNewTess**](glunewtess.md)).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gludeletetess
     */
    static gluDeleteTess(tess) {
        DllCall("GLU32.dll\gluDeleteTess", "ptr", tess)
    }

    /**
     * The gluTessBeginPolygon and gluTessEndPolygon functions delimit a polygon description. | gluTessBeginPolygon function (Glu.h)
     * @remarks
     * The **gluTessBeginPolygon** and [**gluTessEndPolygon**](glutessendpolygon.md) functions delimit the definition of a nonconvex polygon. Within each **gluTessBeginPolygon** / **gluTessEndPolygon** pair, include one or more calls to [**gluTessBeginContour**](glutessbegincontour.md). Within each contour, there are zero or more calls to [**gluTessVertex**](glutessvertex.md). The vertexes specify a closed contour (the last vertex of each contour is automatically linked to the first).
     * 
     * The *polygon\_data* parameter is a pointer to a programmer-defined data structure. If the appropriate callbacks are specified (see [*gluTessCallback*](glutess.md)), this pointer is returned to the callback function or functions, making it a convenient way to store per-polygon information.
     * 
     * When you call [**gluTessEndPolygon**](glutessendpolygon.md), the polygon is tessellated, and the resulting triangles are described through callbacks. For descriptions of the callback functions, see [*gluTessCallback*](glutess.md).
     * @param {Pointer<IntPtr>} tess The tessellation object (created with [**gluNewTess**](glunewtess.md)).
     * 
     * 
     * *polygon\_data* 
     * 
     * A pointer to a programmer-defined polygon data structure.
     * @param {Pointer<Void>} polygon_data 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glutessbeginpolygon
     */
    static gluTessBeginPolygon(tess, polygon_data) {
        DllCall("GLU32.dll\gluTessBeginPolygon", "ptr", tess, "ptr", polygon_data)
    }

    /**
     * The gluTessBeginContour and gluTessEndContour functions delimit a contour description. | gluTessBeginContour function (Glu.h)
     * @remarks
     * The **gluTessBeginContour** and [**gluTessEndPolygon**](glutessendpolygon.md) functions delimit the definition of a polygon contour. Within each **gluTessBeginContour*/*gluTessEndPolygon** pair, there can be zero or more calls to [**gluTessVertex**](glutessvertex.md). The vertexes specify a closed contour (the last vertex of each contour is automatically linked to the first). You can call **gluTessBeginContour** only between [**gluTessBeginPolygon**](glutessbeginpolygon.md) and **gluTessEndPolygon**.
     * @param {Pointer<IntPtr>} tess The tessellation object (created with [**gluNewTess**](glunewtess.md)).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glutessbegincontour
     */
    static gluTessBeginContour(tess) {
        DllCall("GLU32.dll\gluTessBeginContour", "ptr", tess)
    }

    /**
     * The gluTessVertex function specifies a vertex on a polygon.
     * @remarks
     * The **gluTessVertex** function describes a vertex on a polygon that the user is defining. Successive **gluTessVertex** calls describe a closed contour. For example, to describe a quadrilateral, call **gluTessVertex** four times. You can only call **gluTessVertex** between [**gluTessBeginContour**](glutessbegincontour.md) and [**gluTessEndContour**](glutessendcontour.md).
     * 
     * The *data* parameter normally points to a structure containing the vertex location, as well as other per-vertex attributes such as color and normal. This pointer is passed back to the program through the GLU\_VERTEX callback after tessellation (see [*gluTessCallback*](glutess.md)).
     * @param {Pointer<IntPtr>} tess The tessellation object (created with [**gluNewTess**](glunewtess.md)).
     * @param {Pointer<Double>} coords The location of the vertex.
     * @param {Pointer<Void>} data An pointer passed back to the program with the vertex callback (as specified by [*gluTessCallback*](glutess.md)).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glutessvertex
     */
    static gluTessVertex(tess, coords, data) {
        DllCall("GLU32.dll\gluTessVertex", "ptr", tess, "ptr", coords, "ptr", data)
    }

    /**
     * The gluTessBeginContour and gluTessEndContour functions delimit a contour description. | gluTessEndContour function (Glu.h)
     * @remarks
     * The [**gluTessBeginContour**](glutessbegincontour.md) and **gluTessEndContour** functions delimit the definition of a polygon contour. Within each **gluTessBeginContour*/*gluTessEndContour** pair, there can be zero or more calls to [**gluTessVertex**](glutessvertex.md). The vertexes specify a closed contour (the last vertex of each contour is automatically linked to the first). You can call **gluTessBeginContour** only between [**gluTessBeginPolygon**](glutessbeginpolygon.md) and [**gluTessEndPolygon**](glutessendpolygon.md).
     * @param {Pointer<IntPtr>} tess The tessellation object (created with [**gluNewTess**](glunewtess.md)).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glutessendcontour
     */
    static gluTessEndContour(tess) {
        DllCall("GLU32.dll\gluTessEndContour", "ptr", tess)
    }

    /**
     * The gluTessBeginPolygon and gluTessEndPolygon functions delimit a polygon description. | gluTessEndPolygon function (Glu.h)
     * @remarks
     * The [**gluTessBeginPolygon**](glutessbeginpolygon.md) and **gluTessEndPolygon** functions delimit the definition of a nonconvex polygon. Within each **gluTessBeginPolygon** / **gluTessEndPolygon** pair, include one or more calls to [**gluTessBeginContour**](glutessbegincontour.md). Within each contour, there are zero or more calls to [**gluTessVertex**](glutessvertex.md). The vertexes specify a closed contour (the last vertex of each contour is automatically linked to the first).
     * 
     * The *polygon\_data* parameter is a pointer to a programmer-defined data structure. If the appropriate callbacks are specified (see [*gluTessCallback*](glutess.md)), this pointer is returned to the callback function or functions, making it a convenient way to store per-polygon information.
     * 
     * When you call **gluTessEndPolygon**, the polygon is tessellated, and the resulting triangles are described through callbacks. For descriptions of the callback functions, see [*gluTessCallback*](glutess.md).
     * @param {Pointer<IntPtr>} tess The tessellation object (created with [**gluNewTess**](glunewtess.md)).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glutessendpolygon
     */
    static gluTessEndPolygon(tess) {
        DllCall("GLU32.dll\gluTessEndPolygon", "ptr", tess)
    }

    /**
     * The gluTessProperty function sets the property of a tessellation object.
     * @remarks
     * The **gluTessProperty** function controls properties stored in a tessellation object. These properties affect the way the polygons are interpreted and rendered.
     * @param {Pointer<IntPtr>} tess The tessellation object (created with [**gluNewTess**](glunewtess.md)).
     * @param {Integer} which The property value to set. The following values are valid: GLU\_TESS\_WINDING\_RULE, GLU\_TESS\_BOUNDARY\_ONLY, and GLU\_TESS\_TOLERANCE.
     * 
     * 
     * 
     * | Value                                                                                                                                                                                      | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
     * |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GLU_TESS_WINDING_RULE"></span><span id="glu_tess_winding_rule"></span><dl> <dt>**GLU\_TESS\_WINDING\_RULE**</dt> </dl>    | Determines which parts of the polygon are on the interior. The value parameter may be set to one of the following: GLU\_TESS\_WINDING\_ODD, GLU\_TESS\_WINDING\_NONZERO, GLU\_TESS\_WINDING\_POSITIVE, GLU\_TESS\_WINDING\_NEGATIVE, or GLU\_TESS\_WINDING\_ABS\_GEQ\_TWO. <br/> To understand how the winding rule works, first consider that the input contours partition the plane into regions. The winding rule determines which of these regions are inside the polygon.<br/> For a single-contour C, the winding number of a point x is simply the signed number of revolutions we make around x as we travel once around C (where counterclockwise is positive). When there are several contours, the individual winding numbers are summed. This procedure associates a signed integer value with each point x in the plane. Note that the winding number is the same for all points in a single region.<br/> The winding rule classifies a region as "inside" if its winding number belongs to the chosen category (odd, nonzero, positive, negative, or absolute value of at least two). The previous GLU tessellator (prior to GLU 1.2) used the "odd" rule. The "nonzero" rule (GLU\_TESS\_WINDING\_NONZERO) is another common way to define the interior. The other three rules (GLU\_TESS\_WINDING\_POSITIVE, GLU\_TESS\_WINDING\_NEGATIVE, GLU\_TESS\_WINDING\_ABS\_GEQ\_TWO) are useful for polygon CSG operations.<br/> |
     * | <span id="GLU_TESS_BOUNDARY_ONLY"></span><span id="glu_tess_boundary_only"></span><dl> <dt>**GLU\_TESS\_BOUNDARY\_ONLY**</dt> </dl> | Specifies a Boolean value (set value to GL\_TRUE or GL\_FALSE). When you set value to GL\_TRUE, a set of closed contours separating the polygon interior and exterior is returned instead of a tessellation. Exterior contours are oriented counterclockwise with respect to the normal; interior contours are oriented clockwise. The GLU\_TESS\_BEGIN and GLU\_TESS\_BEGIN\_DATA callbacks use the type GL\_LINE\_LOOP for each contour.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
     * | <span id="GLU_TESS_TOLERANCE"></span><span id="glu_tess_tolerance"></span><dl> <dt>**GLU\_TESS\_TOLERANCE**</dt> </dl>              | Specifies a tolerance for merging features to reduce the size of the output. For example, two vertexes that are very close to each other might be replaced by a single vertex. The tolerance is multiplied by the largest coordinate magnitude of any input vertex; this specifies the maximum distance that any feature can move as the result of a single merge operation. If a single feature takes part in several merge operations, the total distance moved can be larger. <br/> Feature merging is completely optional; the tolerance is only a hint. The implementation is free to merge in some cases and not in others, or to never merge features at all. The default tolerance is zero.<br/> The current implementation merges vertexes only if they are exactly coincident, regardless of the current tolerance. A vertex is spliced into an edge only if the implementation is unable to distinguish which side of the edge the vertex lies on. Two edges are merged only when both endpoints are identical.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                 |
     * @param {Float} value The value of the indicated property.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glutessproperty
     */
    static gluTessProperty(tess, which, value) {
        DllCall("GLU32.dll\gluTessProperty", "ptr", tess, "uint", which, "double", value)
    }

    /**
     * The gluTessNormal function specifies a normal for a polygon.
     * @remarks
     * The **gluTessNormal** function describes a normal for a polygon that you define. All input data is projected onto a plane perpendicular to one of the three coordinate axes before tessellation, and all output triangles are oriented counterclockwise with respect to the normal. (To obtain clockwise orientation, reverse the sign of the supplied normal). For example, if you know that all polygons lie in the x-y plane, call **gluTessNormal**(tess, 0.0, 0.0, 1.0) before rendering any polygons.
     * 
     * If the supplied normal is (0.0, 0.0, 0.0) (the default value), the normal is determined as follows:
     * 
     * 1.  The direction of the normal, up to its sign, is found by fitting a plane to the vertexes, without regard to how the vertexes are connected. It is expected that the input data lies approximately in the plane; otherwise projection perpendicular to one of the three coordinate axes can change the geometry substantially.
     * 2.  The sign of the normal is chosen so that the sum of the signed areas of all input contours is nonnegative (where a counterclockwise contour has positive area).
     * 
     * The supplied normal persists until another call to **gluTessNormal** changes it.
     * @param {Pointer<IntPtr>} tess The tessellation object (created with [**gluNewTess**](glunewtess.md)).
     * @param {Float} x The x-coordinate component of a normal.
     * @param {Float} y The y-coordinate component of a normal.
     * @param {Float} z The z-coordinate component of a normal.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glutessnormal
     */
    static gluTessNormal(tess, x, y, z) {
        DllCall("GLU32.dll\gluTessNormal", "ptr", tess, "double", x, "double", y, "double", z)
    }

    /**
     * The gluTessCallback function defines a callback for a tessellation object.
     * @remarks
     * Use **gluTessCallback** to specify a callback to be used by a tessellation object. If the specified callback is already defined, then it is replaced. If *fn* is **NULL**, then the existing callback becomes undefined.
     * 
     * The tessellation object uses these callbacks to describe how a polygon that you specify is broken into triangles.
     * 
     * There are two versions of each callback, one with polygon data that you can define and one without. If both versions of a particular callback are specified, the callback with the polygon data you specify will be used. The *polygon\_data* parameter of [**gluTessBeginPolygon**](glutessbeginpolygon.md) is a copy of the pointer that was specified when **gluTessBeginPolygon** was called.
     * 
     * The following are valid callbacks:
     * 
     * 
     * 
     * 
     * | Callback | Description | 
     * |----------|-------------|
     * | GLU_TESS_BEGIN | The GLU_TESS_BEGIN callback is invoked like <a href="glbegin.md"><strong>glBegin</strong></a> to indicate the start of a (triangle) primitive. The function takes a single argument of type <strong>GLenum</strong>. If you set the GLU_TESS_BOUNDARY_ONLY property to GL_FALSE, the argument is set to either GL_TRIANGLE_FAN, GL_TRIANGLE_STRIP, or GL_TRIANGLES. If you set the GLU_TESS_BOUNDARY_ONLY property to GL_TRUE, the argument is set to GL_LINE_LOOP. The function prototype for this callback is as follows: <strong>void</strong><strong>begin</strong> (<strong>GLenum</strong><em>type</em>);<br /> | 
     * | GLU_TESS_BEGIN_DATA | GLU_TESS_BEGIN_DATA is the same as the GLU_TESS_BEGIN callback except that it takes an additional pointer argument. This pointer is identical to the opaque pointer provided when you call <a href="glutessbeginpolygon.md"><strong>gluTessBeginPolygon</strong></a>. The function prototype for this callback is: <strong>void</strong><strong>beginData</strong> (<strong>GLenum</strong><em>type</em>, <strong>void</strong> * <em>polygon_data</em>);<br /> | 
     * | GLU_TESS_EDGE_FLAG | The GLU_TESS_EDGE_FLAG callback is similar to <a href="gledgeflag-functions.md"><strong>glEdgeFlag</strong></a>. The function takes a single Boolean flag that indicates which edges lie on the polygon boundary. If the flag is GL_TRUE, then each vertex that follows begins an edge that lies on the polygon boundary; that is, an edge which separates an interior region from an exterior one. If the flag is GL_FALSE, then each vertex that follows begins an edge that lies in the polygon interior. The GLU_TESS_EDGE_FLAG callback (if defined) is invoked before the first vertex callback is made. Because triangle fans and triangle strips do not support edge flags, the begin callback is not called with GL_TRIANGLE_FAN or GL_TRIANGLE_STRIP if an edge flag callback is provided. Instead, the fans and strips are converted to independent triangles. The function prototype for this callback is:<br /><strong>void</strong><strong>edgeFlag</strong> (<strong>GLboolean</strong><em>flag</em>);<br /> | 
     * | GLU_TESS_EDGE_FLAG_DATA | The GLU_TESS_EDGE_FLAG_DATA callback is the same as the GLU_TESS_EDGE_FLAG callback except that it takes an additional pointer argument. This pointer is identical to the opaque pointer provided when you call <a href="glutessbeginpolygon.md"><strong>gluTessBeginPolygon</strong></a>. The function prototype for this callback is: <strong>void</strong><strong>edgeFlagData</strong> (<strong>GLboolean</strong><em>flag</em>, <strong>void</strong> * <em>polygon_data</em>);<br /> | 
     * | GLU_TESS_VERTEX | The GLU_TESS_VERTEX callback is invoked between the begin and end callbacks. It is similar to glVertex , and it defines the vertexes of the triangles created by the tessellation process. The function takes a pointer as its only argument. This pointer is identical to the opaque pointer that you provided when you defined the vertex (see <a href="glutessvertex.md"><strong>gluTessVertex</strong></a>). The function prototype for this callback is: <strong>void</strong><strong>vertex</strong> (<strong>void</strong> * <em>vertex_data</em>);<br /> | 
     * | GLU_TESS_VERTEX_DATA | The GLU_TESS_VERTEX_DATA is the same as the GLU_TESS_VERTEX callback except that it takes an additional pointer argument. This pointer is identical to the opaque pointer provided when you call <a href="glutessbeginpolygon.md"><strong>gluTessBeginPolygon</strong></a>. The function prototype for this callback is: <strong>void</strong><strong>vertexData</strong> (void * <em>vertex_data</em>, <strong>void</strong> * <em>polygon_data</em>);<br /> | 
     * | GLU_TESS_END | The GLU_TESS_END callback serves the same purpose as <a href="glend.md"><strong>glEnd</strong></a>. It indicates the end of a primitive, and it takes no arguments. The function prototype for this callback is: <strong>void</strong><strong>end</strong> (<strong>void</strong>);<br /> | 
     * | GLU_TESS_END_DATA | The GLU_TESS_END_DATA callback is the same as the GLU_TESS_END callback except that it takes an additional pointer argument. This pointer is identical to the opaque pointer provided when you call <a href="glutessbeginpolygon.md"><strong>gluTessBeginPolygon</strong></a>. The function prototype for this callback is: <strong>void</strong><strong>endData</strong> (<strong>void</strong> * <em>polygon_data</em>);<br /> | 
     * | GLU_TESS_COMBINE | Call the GLU_TESS_COMBINE callback to create a new vertex when the tessellation detects an intersection, or to merge features. The function takes four arguments: An array of three elements, each of type Gldouble.<br /> An array of four pointers.<br /> An array of four elements, each of type GLfloat.<br /> A pointer to a pointer.<br /> The function prototype for this callback is: <br /><strong>void</strong><strong>combine</strong>(<strong>GLdouble</strong><em>coords</em>[3], <strong>void</strong> * <em>vertex_data</em>[4], <strong>GLfloat</strong><em>weight</em>[4], <strong>void</strong> **<em>outData</em>);<br /> The vertex is defined as a linear combination of up to four existing vertexes, stored in vertex_data. The coefficients of the linear combination are given by weight; these weights always sum to 1.0. All vertex pointers are valid even when some of the weights are zero. The coords parameter gives the location of the new vertex.<br /> Allocate another vertex, interpolate parameters using vertex_data and weight, and return the new vertex pointer in outData. This handle is supplied during rendering callbacks. Free the memory sometime after calling <a href="glutessendpolygon.md"><strong>gluTessEndPolygon</strong></a>.<br /> For example, if the polygon lies in an arbitrary plane in three-dimensional space, and you associate a color with each vertex, the GLU_TESS_COMBINE callback might look like the following:<br /><pre data-space="preserve"><c>void myCombine( GLdouble coords[3], VERTEX *d[4],                 GLfloat w[4], VERTEX **dataOut ) {     VERTEX *newVertex = new_vertex();     newVertex-&gt;x = coords[0];     newVertex-&gt;y = coords[1];     newVertex-&gt;z = coords[2];     newVertex-&gt;r = w[0]*d[0]-&gt;r + w[1]*d[1]-&gt;r + w[2]*d[2]-&gt;r +                    w[3]*d[3]-&gt;r;     newVertex-&gt;g = w[0]*d[0]-&gt;g + w[1]*d[1]-&gt;g + w[2]*d[2]-&gt;g +                    w[3]*d[3]-&gt;g;     newVertex-&gt;b = w[0]*d[0]-&gt;b + w[1]*d[1]-&gt;b + w[2]*d[2]-&gt;b +                    w[3]*d[3]-&gt;b;     newVertex-&gt;a = w[0]*d[0]-&gt;a + w[1]*d[1]-&gt;a + w[2]*d[2]-&gt;a +                    w[3]*d[3]-&gt;a;     *dataOut = newVertex; }</c></pre>When the tessellation detects an intersection, the GLU_TESS_COMBINE or GLU_TESS_COMBINE_DATA callback (see below) must be defined, and must write a non-<strong>NULL</strong> pointer into dataOut. Otherwise the GLU_TESS_NEED_COMBINE_CALLBACK error occurs, and no output is generated. (This is the only error that can occur during tessellation and rendering.)<br /> | 
     * | GLU_TESS_COMBINE_DATA | The GLU_TESS_COMBINE_DATA callback is the same as the GLU_TESS_COMBINE callback except that it takes an additional pointer argument. This pointer is identical to the opaque pointer provided when you call <a href="glutessbeginpolygon.md"><strong>gluTessBeginPolygon</strong></a>. The function prototype for this callback is: <strong>void</strong><strong>combineData</strong> (<strong>GLdouble</strong><em>coords</em>[3], <strong>void</strong> *<em>vertex_data</em>[4], <strong>GLfloat</strong><em>weight</em>[4], <strong>void</strong> **<em>outData</em>, <strong>void</strong> * <em>polygon_data</em>);<br /> | 
     * | GLU_TESS_ERROR | The GLU_TESS_ERROR callback is called when an error is encountered. The one argument is of type <strong>GLenum</strong>; it indicates the specific error that occurred and is set to one of the following: GLU_TESS_MISSING_BEGIN_POLYGON<br /> GLU_TESS_MISSING_END_POLYGON<br /> GLU_TESS_MISSING_BEGIN_CONTOUR<br /> GLU_TESS_MISSING_END_CONTOUR<br /> GLU_TESS_COORD_TOO_LARGE<br /> GLU_TESS_NEED_COMBINE_CALLBACK<br /> Call gluErrorString to retrieve character strings describing these errors. The function prototype for this callback is as follows:<br /><strong>void</strong><strong>error</strong> (<strong>GLenum</strong><em>errno</em>);<br /> The GLU library recovers from the first four errors by inserting the missing call or calls. GLU_TESS_COORD_TOO_LARGE indicates that some vertex coordinate exceeded the predefined constant GLU_TESS_MAX_COORD in absolute value, and that the value has been clamped. (Coordinate values must be small enough that two can be multiplied together without overflow.) GLU_TESS_NEED_COMBINE_CALLBACK indicates that the tessellation detected an intersection between two edges in the input data, and the GLU_TESS_COMBINE or GLU_TESS_COMBINE_DATA callback was not provided. No output will be generated.<br /> | 
     * | GLU_TESS_ERROR_DATA | The GLU_TESS_ERROR_DATA callback is the same as the GLU_TESS_ERROR callback, except that it takes an additional pointer argument. This pointer is identical to the opaque pointer provided when you call <a href="glutessbeginpolygon.md"><strong>gluTessBeginPolygon</strong></a>. The function prototype for this callback is: <strong>void</strong><strong>errorData</strong> (<strong>GLenum</strong><em>errno</em>, <strong>void</strong> * <em>polygon_data</em>);<br /> |
     * @param {Pointer<IntPtr>} tess The tessellation object (created with [**gluNewTess**](glunewtess.md)).
     * @param {Integer} which The callback being defined. The following values are valid: GLU\_TESS\_BEGIN, GLU\_TESS\_BEGIN\_DATA, GLU\_TESS\_EDGE\_FLAG, GLU\_TESS\_EDGE\_FLAG\_DATA, GLU\_TESS\_VERTEX, GLU\_TESS\_VERTEX\_DATA, GLU\_TESS\_END, GLU\_TESS\_END\_DATA, GLU\_TESS\_COMBINE, GLU\_TESS\_COMBINE\_DATA, GLU\_TESS\_ERROR, and GLU\_TESS\_ERROR\_DATA.
     * 
     * For more information on these callbacks, see the following Remarks section.
     * @param {Pointer} fn The function to be called.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glutess
     */
    static gluTessCallback(tess, which, fn) {
        DllCall("GLU32.dll\gluTessCallback", "ptr", tess, "uint", which, "ptr", fn)
    }

    /**
     * The gluGetTessProperty function gets a tessellation object property.
     * @remarks
     * Use **gluGetTessProperty** to retrieve properties stored in a tessellation object. These properties affect the way tessellation objects are interpreted and rendered. For information about what the properties are and what they do, see [**gluTessProperty**](glutessproperty.md).
     * @param {Pointer<IntPtr>} tess The tessellation object (created with [**gluNewTess**](glunewtess.md)).
     * @param {Integer} which The property whose value is to be retrieved. The following values are valid: GLU\_TESS\_WINDING\_RULE, GLU\_TESS\_BOUNDARY\_ONLY, and GLU\_TESS\_TOLERANCE.
     * @param {Pointer<Double>} value A pointer to the location where the value of the named property is written.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glugettessproperty
     */
    static gluGetTessProperty(tess, which, value) {
        DllCall("GLU32.dll\gluGetTessProperty", "ptr", tess, "uint", which, "ptr", value)
    }

    /**
     * The gluNewNurbsRenderer function creates a Non-Uniform Rational B-Spline (NURBS) object.
     * @remarks
     * This function has no parameters.
     * 
     * 
     * The **gluNewNurbsRenderer** function creates and returns a pointer to a new NURBS object. Refer to this object when calling NURBS rendering and control functions. A return value of zero means there is not enough memory to allocate to the object.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glunewnurbsrenderer
     */
    static gluNewNurbsRenderer() {
        DllCall("GLU32.dll\gluNewNurbsRenderer")
    }

    /**
     * The gluDeleteNurbsRenderer function destroys a Non-Uniform Rational B-Spline (NURBS) object.
     * @remarks
     * The **gluDeleteNurbsRenderer** function destroys the NURBS object and frees any memory that it used. After you have called **gluDeleteNurbsRenderer**, you cannot use *nobj* again.
     * @param {Pointer<IntPtr>} nobj The NURBS object to be destroyed (created with **gluNewNurbsRenderer**).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gludeletenurbsrenderer
     */
    static gluDeleteNurbsRenderer(nobj) {
        DllCall("GLU32.dll\gluDeleteNurbsRenderer", "ptr", nobj)
    }

    /**
     * The gluBeginSurface and gluEndSurface functions delimit a Non-Uniform Rational B-Spline (NURBS) surface definition. | gluBeginSurface function (Glu.h)
     * @remarks
     * The **gluBeginSurface** and **gluEndSurface** functions mark the beginning and end of NURBS surface definitions, which are defined with calls to **gluNurbsSurface**.
     * 
     * 1.  Call **gluBeginSurface** to mark the beginning of a NURBS surface definition.
     * 2.  Make one or more calls to **gluNurbsSurface** to define the attributes of the surface.
     * 
     *     Exactly one of these calls to **gluNurbsSurface** must have a surface type of GL\_MAP2\_VERTEX\_3 or GL\_MAP2\_VERTEX\_4.
     * 
     * 3.  To mark the end of the NURBS surface definition, call **gluEndSurface**.
     * 
     * The [**gluBeginTrim**](glubegintrim.md), [**gluPwlCurve**](glupwlcurve.md), [**gluNurbsCurve**](glunurbscurve.md), and [**gluEndTrim**](gluendtrim.md) functions support trimming of NURBS surfaces.
     * 
     * Use OpenGL evaluators to render the NURBS surface as a set of polygons. Preserve the evaluator state during rendering with [**glPushAttrib**](glpushattrib.md)(GL\_EVAL\_BIT) and [**glPopAttrib**](glpopattrib.md).
     * @param {Pointer<IntPtr>} nobj The NURBS object (created with [**gluNewNurbsRenderer**](glunewnurbsrenderer.md)).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glubeginsurface
     */
    static gluBeginSurface(nobj) {
        DllCall("GLU32.dll\gluBeginSurface", "ptr", nobj)
    }

    /**
     * The gluBeginCurve and gluEndCurve functions delimit a Non-Uniform Rational B-Spline (NURBS) curve definition. | gluBeginCurve function (Glu.h)
     * @remarks
     * Use **gluBeginCurve** to mark the beginning of a NURBS curve definition. After calling **gluBeginCurve**, make one or more calls to [**gluNurbsCurve**](glunurbscurve.md) to define the attributes of the curve. Exactly one of the calls to **gluNurbsCurve** must have a curve type of GL\_MAP1\_VERTEX\_3 or GL\_MAP1\_VERTEX\_4. To mark the end of the NURBS curve definition, call [**gluEndCurve**](gluendcurve.md).
     * 
     * OpenGL evaluators are used to render the NURBS curve as a series of line segments. Evaluator state is preserved during rendering with [**glPushAttrib**](glpushattrib.md) (GL\_EVAL\_BIT) and [**glPopAttrib**](glpopattrib.md). For information on exactly what state these calls preserve, see **glPushAttrib**.
     * @param {Pointer<IntPtr>} nobj The NURBS object (created with [**gluNewNurbsRenderer**](glunewnurbsrenderer.md)).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glubegincurve
     */
    static gluBeginCurve(nobj) {
        DllCall("GLU32.dll\gluBeginCurve", "ptr", nobj)
    }

    /**
     * The gluBeginCurve and gluEndCurve functions delimit a Non-Uniform Rational B-Spline (NURBS) curve definition. | gluEndCurve function (Glu.h)
     * @remarks
     * Use [**gluBeginCurve**](glubegincurve.md) to mark the beginning of a NURBS curve definition. After calling **gluBeginCurve**, make one or more calls to [**gluNurbsCurve**](glunurbscurve.md) to define the attributes of the curve. Exactly one of the calls to **gluNurbsCurve** must have a curve type of GL\_MAP1\_VERTEX\_3 or GL\_MAP1\_VERTEX\_4. To mark the end of the NURBS curve definition, call **gluEndCurve**.
     * 
     * OpenGL evaluators are used to render the NURBS curve as a series of line segments. Evaluator state is preserved during rendering with [**glPushAttrib**](glpushattrib.md) (GL\_EVAL\_BIT ) and [**glPopAttrib**](glpopattrib.md). For information on exactly what state these calls preserve, see **glPushAttrib**.
     * @param {Pointer<IntPtr>} nobj The NURBS object (created with [**gluNewNurbsRenderer**](glunewnurbsrenderer.md)).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gluendcurve
     */
    static gluEndCurve(nobj) {
        DllCall("GLU32.dll\gluEndCurve", "ptr", nobj)
    }

    /**
     * The gluBeginSurface and gluEndSurface functions delimit a Non-Uniform Rational B-Spline (NURBS) surface definition. | gluEndSurface function (Glu.h)
     * @remarks
     * The [**gluBeginSurface**](glubeginsurface.md) and **gluEndSurface** functions mark the beginning and end of NURBS surface definitions, which are defined with calls to **gluNurbsSurface**.
     * 
     * 1.  Call **gluBeginSurface** to mark the beginning of a NURBS surface definition.
     * 2.  Make one or more calls to **gluNurbsSurface** to define the attributes of the surface.
     * 
     *     Exactly one of these calls to **gluNurbsSurface** must have a surface type of GL\_MAP2\_VERTEX\_3 or GL\_MAP2\_VERTEX\_4.
     * 
     * 3.  To mark the end of the NURBS surface definition, call **gluEndSurface**.
     * 
     * The [**gluBeginTrim**](glubegintrim.md), [**gluPwlCurve**](glupwlcurve.md), [**gluNurbsCurve**](glunurbscurve.md), and **gluEndTrim** functions support trimming of NURBS surfaces.
     * 
     * Use OpenGL evaluators to render the NURBS surface as a set of polygons. Preserve the evaluator state during rendering with [**glPushAttrib**](glpushattrib.md) (GL\_EVAL\_BIT) and [**glPopAttrib**](glpopattrib.md).
     * @param {Pointer<IntPtr>} nobj The NURBS object (created with [**gluNewNurbsRenderer**](glunewnurbsrenderer.md)).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gluendsurface
     */
    static gluEndSurface(nobj) {
        DllCall("GLU32.dll\gluEndSurface", "ptr", nobj)
    }

    /**
     * The gluBeginTrim and gluEndTrim functions delimit a Non-Uniform Rational B-Spline (NURBS) trimming loop definition. | gluBeginTrim function (Glu.h)
     * @remarks
     * Use **gluBeginTrim** to mark the beginning of a trimming loop, and **gluEndTrim** to mark the end of a trimming loop. A trimming loop is a set of oriented curve segments (forming a closed curve) that define boundaries of a NURBS surface. You include these trimming loops in the definition of a NURBS surface, between calls to [**gluBeginSurface**](glubeginsurface.md) and [**gluEndSurface**](gluendsurface.md).
     * 
     * The definition for a NURBS surface can contain many trimming loops. For example, if you write a definition for a NURBS surface that resembles a rectangle with a hole punched out, the definition would contain two trimming loops. One loop would define the outer edge of the rectangle; the other would define the punched-out hole. The definitions of each of these trimming loops would be bracketed by a **gluBeginTrim** / **gluEndTrim** pair.
     * 
     * The definition of a single closed trimming loop can consist of multiple curve segments, each described as a series of line segments that form a linear curve (see [**gluPwlCurve**](glupwlcurve.md)), as a single NURBS curve (see [**gluNurbsCurve**](glunurbscurve.md)), or as a combination of both in any order. The only library calls that can appear in a trimming-loop definition (between the calls to **gluBeginTrim** and **gluEndTrim**) are **gluPwlCurve** and **gluNurbsCurve**.
     * 
     * The displayed area of the NURBS surface is the region in the domain to the left of the trimming curve as the curve parameter increases. Thus, the retained region of the NURBS surface is inside a counterclockwise trimming loop and outside a clockwise trimming loop. For the rectangle mentioned earlier, the trimming loop for the outer edge of the rectangle runs counterclockwise, while the trimming loop for the punched-out hole runs clockwise.
     * 
     * If you use more than one curve to define a single trimming loop, the curve segments must form a closed loop (that is, the endpoint of each curve must be the starting point of the next curve, and the endpoint of the final curve must be the starting point of the first curve). If the endpoints of the curve are sufficiently close together but not exactly coincident, they will be forced to match. If the endpoints are not sufficiently close, an error results (see [*gluNurbsCallback*](glunurbs.md)).
     * 
     * If a trimming-loop definition contains multiple curves, the direction of the curves must be consistent (that is, the inside must be to the left of all of the curves). You can use nested trimming loops as long as the curve orientations alternate correctly. Trimming curves cannot be self-intersecting, nor can they intersect one another (or an error results).
     * 
     * If no trimming information is given for a NURBS surface, the entire surface is drawn.
     * @param {Pointer<IntPtr>} nobj The NURBS object (created with [**gluNewNurbsRenderer**](glunewnurbsrenderer.md)).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glubegintrim
     */
    static gluBeginTrim(nobj) {
        DllCall("GLU32.dll\gluBeginTrim", "ptr", nobj)
    }

    /**
     * The gluBeginTrim and gluEndTrim functions delimit a Non-Uniform Rational B-Spline (NURBS) trimming loop definition. | gluEndTrim function (Glu.h)
     * @remarks
     * Use [**gluBeginTrim**](glubegintrim.md) to mark the beginning of a trimming loop, and **gluEndTrim** to mark the end of a trimming loop. A trimming loop is a set of oriented curve segments (forming a closed curve) that define boundaries of a NURBS surface. You include these trimming loops in the definition of a NURBS surface, between calls to [**gluBeginSurface**](glubeginsurface.md) and [**gluEndSurface**](gluendsurface.md).
     * 
     * The definition for a NURBS surface can contain many trimming loops. For example, if you write a definition for a NURBS surface that resembles a rectangle with a hole punched out, the definition would contain two trimming loops. One loop would define the outer edge of the rectangle; the other would define the punched-out hole. The definitions of each of these trimming loops would be bracketed by a [**gluBeginTrim**](glubegintrim.md) / **gluEndTrim** pair.
     * 
     * The definition of a single closed trimming loop can consist of multiple curve segments, each described as a series of line segments that form a linear curve (see [**gluPwlCurve**](glupwlcurve.md)), as a single NURBS curve (see [**gluNurbsCurve**](glunurbscurve.md)), or as a combination of both in any order. The only library calls that can appear in a trimming-loop definition (between the calls to [**gluBeginTrim**](glubegintrim.md) and **gluEndTrim**) are **gluPwlCurve** and **gluNurbsCurve**.
     * 
     * The displayed area of the NURBS surface is the region in the domain to the left of the trimming curve as the curve parameter increases. Thus, the retained region of the NURBS surface is inside a counterclockwise trimming loop and outside a clockwise trimming loop. For the rectangle mentioned earlier, the trimming loop for the outer edge of the rectangle runs counterclockwise, while the trimming loop for the punched-out hole runs clockwise.
     * 
     * If you use more than one curve to define a single trimming loop, the curve segments must form a closed loop (that is, the endpoint of each curve must be the starting point of the next curve, and the endpoint of the final curve must be the starting point of the first curve). If the endpoints of the curve are sufficiently close together but not exactly coincident, they will be forced to match. If the endpoints are not sufficiently close, an error results (see [*gluNurbsCallback*](glunurbs.md)).
     * 
     * If a trimming-loop definition contains multiple curves, the direction of the curves must be consistent (that is, the inside must be to the left of all of the curves). You can use nested trimming loops as long as the curve orientations alternate correctly. Trimming curves cannot be self-intersecting, nor can they intersect one another (or an error results).
     * 
     * If no trimming information is given for a NURBS surface, the entire surface is drawn.
     * @param {Pointer<IntPtr>} nobj The NURBS object (created with [**gluNewNurbsRenderer**](glunewnurbsrenderer.md)).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gluendtrim
     */
    static gluEndTrim(nobj) {
        DllCall("GLU32.dll\gluEndTrim", "ptr", nobj)
    }

    /**
     * The gluPwlCurve function describes a piecewise linear Non-Uniform Rational B-Spline (NURBS) trimming curve.
     * @remarks
     * The **gluPwlCurve** function describes a piecewise linear trimming curve for a NURBS surface. A piecewise linear curve consists of a list of coordinates of points in the parameter space for the NURBS surface to be trimmed. These points are connected with line segments to form a curve. If the curve is an approximation to a real curve, the points should be close enough that the resulting path appears curved at the resolution used in the application.
     * 
     * If *type* is GLU\_MAP1\_TRIM\_2, it describes a curve in two-dimensional (*u* and *v*) parameter space. If it is GLU\_MAP1\_TRIM\_3, then it describes a curve in two-dimensional homogeneous (*u*, *v*, and *w*) parameter space. For more information about trimming curves, see [**gluBeginTrim**](glubegintrim.md).
     * @param {Pointer<IntPtr>} nobj The NURBS object (created with [**gluNewNurbsRenderer**](glunewnurbsrenderer.md)).
     * @param {Integer} count The number of points on the curve.
     * @param {Pointer<Single>} array An array containing the curve points.
     * @param {Integer} stride The offset (a number of single-precision floating-point values) between points on the curve.
     * @param {Integer} type The type of curve. Must be either GLU\_MAP1\_TRIM\_2 or GLU\_MAP1\_TRIM\_3.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glupwlcurve
     */
    static gluPwlCurve(nobj, count, array, stride, type) {
        DllCall("GLU32.dll\gluPwlCurve", "ptr", nobj, "int", count, "ptr", array, "int", stride, "uint", type)
    }

    /**
     * The gluNurbsCurve function defines the shape of a Non-Uniform Rational B-Spline (NURBS) curve.
     * @remarks
     * When **gluNurbsCurve** appears between a **gluBeginCurve*/*gluEndCurve** pair, it describes a curve to be rendered. You associate positional, texture, and color coordinates by presenting each as a separate **gluNurbsCurve** between a **gluBeginCurve*/*gluEndCurve** pair. Do not make more than one call to **gluNurbsCurve** for color, position, and texture data within a single **gluBeginCurve*/*gluEndCurve** pair. Make exactly one call to describe the position of the curve (a *type* of GL\_MAP1\_VERTEX\_3 or GL\_MAP1\_VERTEX\_4).
     * 
     * When **gluNurbsCurve** appears between a [**gluBeginTrim**](glubegintrim.md)/[**gluEndTrim**](gluendtrim.md) pair, it describes a trimming curve on a NURBS surface. If *type* is GLU\_MAP1\_TRIM\_2, it describes a curve in two-dimensional (*u* and *v*) parameter space. If it is GLU\_MAP1\_TRIM\_3, it describes a curve in two-dimensional homogeneous (*u*, *v*, and *w*) parameter space. For more discussion about trimming curves, see **gluBeginTrim**.
     * @param {Pointer<IntPtr>} nobj The NURBS object (created with [**gluNewNurbsRenderer**](glunewnurbsrenderer.md)).
     * @param {Integer} nknots The number of knots in *knot*. The *nknots* parameter equals the number of control points plus the order.
     * @param {Pointer<Single>} knot An array of *nknots* nondecreasing knot values.
     * @param {Integer} stride The offset (as a number of single-precision floating-point values) between successive curve control points.
     * @param {Pointer<Single>} ctlarray A pointer to an array of control points. The coordinates must agree with *type*.
     * @param {Integer} order The order of the NURBS curve. The *order* parameter equals degree + 1; hence a cubic curve has an order of 4.
     * @param {Integer} type The type of the curve. If this curve is defined within a [**gluBeginCurve**](glubegincurve.md)/[**gluEndCurve**](gluendcurve.md) pair, then the type can be any of the valid one-dimensional evaluator types (such as GL\_MAP1\_VERTEX\_3 or GL\_MAP1\_COLOR\_4). Between a [**gluBeginTrim**](glubegintrim.md)/[**gluEndTrim**](gluendtrim.md) pair, the only valid types are GLU\_MAP1\_TRIM\_2 and GLU\_MAP1\_TRIM\_3.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glunurbscurve
     */
    static gluNurbsCurve(nobj, nknots, knot, stride, ctlarray, order, type) {
        DllCall("GLU32.dll\gluNurbsCurve", "ptr", nobj, "int", nknots, "ptr", knot, "int", stride, "ptr", ctlarray, "int", order, "uint", type)
    }

    /**
     * The gluNurbsSurface function defines the shape of a Non-Uniform Rational B-Spline (NURBS) surface.
     * @remarks
     * Use **gluNurbsSurface** within a NURBS surface definition to describe the shape of a NURBS surface (before any trimming). To mark the beginning of a NURBS surface definition, use the [**gluBeginSurface**](glubeginsurface.md) function. To mark the end of a NURBS surface definition, use the [**gluEndSurface**](gluendsurface.md) function. Call **gluNurbsSurface** within a NURBS surface definition only.
     * 
     * You associate positional, texture, and color coordinates with a surface by presenting each as a separate **gluNurbsSurface** between a **gluBeginSurface*/*gluEndSurface** pair. Within a single **gluBeginSurface*/*gluEndSurface** pair, you can make only one call to **gluNurbsSurface** for color, position, and texture data. Make exactly one call to describe the position of the surface (a *type* of GL\_MAP2\_VERTEX\_3 or GL\_MAP2\_VERTEX\_4).
     * 
     * You can trim a NURBS surface by using the [**gluNurbsCurve**](glunurbscurve.md) and [**gluPwlCurve**](glupwlcurve.md) functions between calls to [**gluBeginTrim**](glubegintrim.md) and [**gluEndTrim**](gluendtrim.md).
     * 
     * A **gluNurbsSurface** with *sknot\_count* knots in the *u* direction and *tknot\_count* knots in the *v* direction with orders *sorder* and *torder* must have (*sknot\_count* -*sorder*) multipied by (*tknot\_count* -*torder*) control points.
     * @param {Pointer<IntPtr>} nobj The NURBS object (created with [**gluNewNurbsRenderer**](glunewnurbsrenderer.md)).
     * 
     * 
     * *sknot\_count* 
     * 
     * The number of knots in the parametric *u* direction.
     * @param {Integer} sknot_count 
     * @param {Pointer<Single>} sknot An array of *sknot\_count* nondecreasing knot values in the parametric *u* direction.
     * 
     * 
     * *tknot\_count* 
     * 
     * The number of knots in the parametric *v* direction.
     * @param {Integer} tknot_count 
     * @param {Pointer<Single>} tknot An array of *tknot\_count* nondecreasing knot values in the parametric *v* direction.
     * 
     * 
     * *s\_stride* 
     * 
     * The offset (as a number of single precisionfloating-point values) between successive control points in the parametric *u* direction in *ctlarray*.
     * 
     * 
     * *t\_stride* 
     * 
     * The offset (in single precisionfloating-point values) between successive control points in the parametric *v* direction in *ctlarray*.
     * @param {Integer} s_stride 
     * @param {Integer} t_stride 
     * @param {Pointer<Single>} ctlarray An array containing control points for the NURBS surface. The offsets between successive control points in the parametric *u* and *v* directions are given by *s\_stride* and *t\_stride*.
     * @param {Integer} sorder The order of the NURBS surface in the parametric *u* direction. The order is one more than the degree, hence a surface that is cubic in *u* has a *u* order of 4.
     * @param {Integer} torder The order of the NURBS surface in the parametric *v* direction. The order is one more than the degree, hence a surface that is cubic in *v* has a *v* order of 4.
     * @param {Integer} type The type of the surface. The *type* parameter can be any of the valid two-dimensional evaluator types (such as GL\_MAP2\_VERTEX\_3 or GL\_MAP2\_COLOR\_4).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glunurbssurface
     */
    static gluNurbsSurface(nobj, sknot_count, sknot, tknot_count, tknot, s_stride, t_stride, ctlarray, sorder, torder, type) {
        DllCall("GLU32.dll\gluNurbsSurface", "ptr", nobj, "int", sknot_count, "ptr", sknot, "int", tknot_count, "ptr", tknot, "int", s_stride, "int", t_stride, "ptr", ctlarray, "int", sorder, "int", torder, "uint", type)
    }

    /**
     * The gluLoadSamplingMatrices function loads Non-Uniform Rational B-Spline (NURBS) sampling and culling matrices.
     * @remarks
     * The **gluLoadSamplingMatrices** function uses *modelMatrix*, *projMatrix*, and *viewport* to recompute the sampling and culling matrices stored in *nobj*. The sampling matrix determines how finely a NURBS curve or surface must be tessellated to satisfy the sampling tolerance (as determined by the GLU\_SAMPLING\_TOLERANCE property). The culling matrix is used in deciding if a NURBS curve or surface should be culled before rendering (when the GLU\_CULLING property is turned on).
     * 
     * The **gluLoadSamplingMatrices** function is necessary only if the GLU\_AUTO\_LOAD\_MATRIX property is turned off (see [**gluNurbsProperty**](glunurbsproperty.md)). Although it can be convenient to leave the GLU\_AUTO\_LOAD\_MATRIX property turned on, doing so necessitates a round trip to the OpenGL server to get the current values of the modelview matrix, projection matrix, and viewport.)
     * @param {Pointer<IntPtr>} nobj The NURBS object (created with [**gluNewNurbsRenderer**](glunewnurbsrenderer.md)).
     * @param {Pointer<Single>} modelMatrix A modelview matrix (as from a [**glGetFloatv**](glgetfloatv.md) call).
     * @param {Pointer<Single>} projMatrix A projection matrix (as from a **glGetFloatv** call).
     * @param {Pointer<Int32>} viewport A viewport (as from a [**glGetIntegerv**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) call).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gluloadsamplingmatrices
     */
    static gluLoadSamplingMatrices(nobj, modelMatrix, projMatrix, viewport) {
        DllCall("GLU32.dll\gluLoadSamplingMatrices", "ptr", nobj, "ptr", modelMatrix, "ptr", projMatrix, "ptr", viewport)
    }

    /**
     * The gluNurbsProperty function sets a Non-Uniform Rational B-Spline (NURBS) property.
     * @remarks
     * Use **gluNurbsProperty** to control properties stored in a NURBS object. These properties affect the way a NURBS curve is rendered.
     * @param {Pointer<IntPtr>} nobj The NURBS object (created with [**gluNewNurbsRenderer**](glunewnurbsrenderer.md)).
     * @param {Integer} property The property to be set. The following values are valid:
     * 
     * 
     * 
     * | Value                                                                                                                                                                                           | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GLU_SAMPLING_TOLERANCE"></span><span id="glu_sampling_tolerance"></span><dl> <dt>**GLU\_SAMPLING\_TOLERANCE**</dt> </dl>       | Specifies the maximum length, in pixels, to use when the sampling method is set to GLU\_PATH\_LENGTH. The default value is 50.0 pixels.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
     * | <span id="GLU_DISPLAY_MODE"></span><span id="glu_display_mode"></span><dl> <dt>**GLU\_DISPLAY\_MODE**</dt> </dl>                         | The *value* parameter defines how a NURBS surface is to be rendered. You can set *value* to GLU\_FILL, GLU\_OUTLINE\_POLYGON, or GLU\_OUTLINE\_PATCH. <br/> GLU\_FILL. The surface is rendered as a set of polygons. This is the default value. <br/> GLU\_OUTLINE\_POLYGON. The NURBS library draws only the outlines of the polygons created by tessellation. <br/> GLU\_OUTLINE\_PATCH. Only the outlines of patches and trim curves defined by the user are drawn.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GLU_CULLING"></span><span id="glu_culling"></span><dl> <dt>**GLU\_CULLING**</dt> </dl>                                         | The *value* parameter is a Boolean value. When value is set to GL\_TRUE, NURBS curves whose control points lie outside the current viewport are discarded prior to tessellation. The default is GL\_FALSE (because a NURBS curve cannot fall entirely within the convex hull of its control points).<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
     * | <span id="GLU_AUTO_LOAD_MATRIX"></span><span id="glu_auto_load_matrix"></span><dl> <dt>**GLU\_AUTO\_LOAD\_MATRIX**</dt> </dl>            | The *value* parameter is a Boolean value. When set to GL\_TRUE, the NURBS code downloads the projection matrix, modelview matrix, and viewport from the OpenGL server to compute sampling and culling matrices for each NURBS curve that is rendered. Sampling and culling matrices are required to determine the tessellation of a NURBS surface into line segments or polygons and to cull a NURBS surface if it lies outside of the viewport. <br/> If this mode is set to GL\_FALSE, you must provide a projection matrix, modelview matrix, and viewport for the NURBS renderer to use to construct sampling and culling matrices. You can do this with the [**gluLoadSamplingMatrices**](gluloadsamplingmatrices.md) function.<br/> The default for this mode is GL\_TRUE. Changing this mode from GL\_TRUE to GL\_FALSE does not affect the sampling and culling matrices until you call [**gluLoadSamplingMatrices**](gluloadsamplingmatrices.md). <br/> The following property parameters are supported in GLU version 1.1 or later and are not valid for GLU version 1.0: GLU\_PARAMETRIC\_TOLERANCE, GLU\_SAMPLING\_METHOD, GLU\_U\_STEP, and GLU\_V\_STEP.<br/> The following value parameters are supported in GLU version 1.1 or later and are not valid for GLU version 1.0: GLU\_PATH\_LENGTH, GLU\_PARAMETRIC\_ERROR, and GLU\_DOMAIN\_DISTANCE.<br/> |
     * | <span id="GLU_PARAMETRIC_TOLERANCE"></span><span id="glu_parametric_tolerance"></span><dl> <dt>**GLU\_PARAMETRIC\_TOLERANCE**</dt> </dl> | Specifies the maximum distance, in pixels, to use when the sampling method is set to GLU\_PARAMETRIC\_ERROR. The default value is 0.5.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
     * | <span id="GLU_SAMPLING_METHOD"></span><span id="glu_sampling_method"></span><dl> <dt>**GLU\_SAMPLING\_METHOD**</dt> </dl>                | Specifies how to tessallate a NURBS surface. GLU\_SAMPLING\_METHOD can have one of the following three values. <br/> GLU\_PATH\_LENGTH. The default value. Specifies that surfaces rendered with the maximum length, in pixels, of the edges of the tessellation polygons are no greater than the value specified by GLU\_SAMPLING\_TOLERANCE. <br/> GLU\_PARAMETRIC\_ERROR. Specifies that in rendering the surface, the value of GLU\_PARAMETRIC\_TOLERANCE specifies the maximum distance, in pixels, between the tessellation polygons and the surfaces they approximate. <br/> GLU\_DOMAIN\_DISTANCE. Specifies, in parametric coordinates, how many sample points per unit length to take in the *u* and *v* dimensions.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
     * | <span id="GLU_U_STEP"></span><span id="glu_u_step"></span><dl> <dt>**GLU\_U\_STEP**</dt> </dl>                                           | Specifies the number of sample points per unit length taken along the *u* dimension in parametric coordinates. The value of GLU\_U\_STEP is used when GLU\_SAMPLING\_METHOD is set to GLU\_DOMAIN\_DISTANCE. The default value is 100.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
     * | <span id="GLU_V_STEP"></span><span id="glu_v_step"></span><dl> <dt>**GLU\_V\_STEP**</dt> </dl>                                           | Specifies the number of sample points per unit length taken along the *v* dimension in parametric coordinates. The value of GLU\_V\_STEP is used when GLU\_SAMPLING\_METHOD is set to GLU\_DOMAIN\_DISTANCE. The default value is 100.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
     * @param {Float} value The value to which to set the indicated property. The *value* parameter can be a numeric value or one of the following three values: GLU\_PATH\_LENGTH, GLU\_PARAMETRIC\_ERROR, or GLU\_DOMAIN\_DISTANCE.
     * 
     * 
     * 
     * | Value                                                                                                                                                                               | Meaning                                                                                                                                                                                                           |
     * |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GLU_PATH_LENGTH"></span><span id="glu_path_length"></span><dl> <dt>**GLU\_PATH\_LENGTH**</dt> </dl>                | The default value. Specifies that surfaces rendered with the maximum length, in pixels, of the edges of the tessellation polygons are no greater than the value specified by GLU\_SAMPLING\_TOLERANCE.<br/> |
     * | <span id="GLU_PARAMETRIC_ERROR"></span><span id="glu_parametric_error"></span><dl> <dt>**GLU\_PARAMETRIC\_ERROR**</dt> </dl> | Specifies that in rendering the surface, the value of GLU\_PARAMETRIC\_TOLERANCE specifies the maximum distance, in pixels, between the tessellation polygons and the surfaces they approximate.<br/>       |
     * | <span id="GLU_DOMAIN_DISTANCE"></span><span id="glu_domain_distance"></span><dl> <dt>**GLU\_DOMAIN\_DISTANCE**</dt> </dl>    | Specifies, in parametric coordinates, how many sample points per unit length to take in the *u* and *v* dimensions.<br/>                                                                                    |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glunurbsproperty
     */
    static gluNurbsProperty(nobj, property, value) {
        DllCall("GLU32.dll\gluNurbsProperty", "ptr", nobj, "uint", property, "float", value)
    }

    /**
     * The gluGetNurbsProperty function gets a Non-Uniform Rational B-Spline (NURBS) property.
     * @remarks
     * Use **gluGetNurbsProperty** to retrieve properties stored in a NURBS object. These properties affect the way NURBS curves and surfaces are rendered. For information about NURBS properties, see [**gluNurbsProperty**](glunurbsproperty.md).
     * @param {Pointer<IntPtr>} nobj The NURBS object (created with [**gluNewNurbsRenderer**](glunewnurbsrenderer.md)).
     * @param {Integer} property The property whose value is to be retrieved. The following values are valid: GLU\_SAMPLING\_TOLERANCE, GLU\_DISPLAY\_MODE, GLU\_CULLING, GLU\_AUTO\_LOAD\_MATRIX, GLU\_PARAMETRIC\_TOLERANCE, GLU\_SAMPLING\_METHOD, GLU\_U\_STEP, and GLU\_V\_STEP.
     * @param {Pointer<Single>} value A pointer to the location into which the value of the named property is written.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glugetnurbsproperty
     */
    static gluGetNurbsProperty(nobj, property, value) {
        DllCall("GLU32.dll\gluGetNurbsProperty", "ptr", nobj, "uint", property, "ptr", value)
    }

    /**
     * The gluNurbsCallback function defines a callback for a Non-Uniform Rational B-Spline (NURBS) object.
     * @remarks
     * Use **gluNurbsCallback** to define a callback to be used by a NURBS object. If the specified callback is already defined, it is replaced. If *fn* is **NULL**, then any existing callback is erased.
     * @param {Pointer<IntPtr>} nobj The NURBS object (created with [**gluNewNurbsRenderer**](glunewnurbsrenderer.md)).
     * @param {Integer} which The callback being defined. The only valid value is GLU\_ERROR. The meaning of GLU\_ERROR means that the error function is called when an error is encountered. Its single argument is of type **GLenum**, and it indicates the specific error that occurred. There are 37 errors unique to NURBS, named GLU\_NURBS\_ERROR1 through GLU\_NURBS\_ERROR37. Character strings describing these errors can be retrieved with [**gluErrorString**](gluerrorstring.md).
     * @param {Pointer} fn A pointer to the callback function.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glunurbs
     */
    static gluNurbsCallback(nobj, which, fn) {
        DllCall("GLU32.dll\gluNurbsCallback", "ptr", nobj, "uint", which, "ptr", fn)
    }

    /**
     * The gluBeginPolygon and gluEndPolygon functions delimit a polygon description. | gluBeginPolygon function (Glu.h)
     * @remarks
     * Use **gluBeginPolygon** and **gluEndPolygon** to delimit the definition of a nonconvex polygon.
     * 
     * 1.  Call **gluBeginPolygon**.
     * 2.  Define the contours of the polygon by calling [**gluTessVertex**](glutessvertex.md) for each vertex and [**gluNextContour**](glunextcontour.md) to start each new contour.
     * 3.  Call **gluEndPolygon** to signal the end of the definition.
     * 
     *     Once **gluEndPolygon** is called, the polygon is tessellated, and the resulting triangles are described through callbacks. For descriptions of the callback functions, see [*gluTessCallback*](glutess.md).
     * @param {Pointer<IntPtr>} tess The tessellation object (created with [**gluNewTess**](glunewtess.md)).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glubeginpolygon
     */
    static gluBeginPolygon(tess) {
        DllCall("GLU32.dll\gluBeginPolygon", "ptr", tess)
    }

    /**
     * The gluNextContour function marks the beginning of another contour.
     * @remarks
     * Use the **gluNextContour** function to describe polygons with multiple contours. After you describe the first contour through a series of [**gluTessVertex**](glutessvertex.md) calls, a **gluNextContour** call indicates that the previous contour is complete and that the next contour is about to begin. Perform another series of **gluTessVertex** calls to describe the new contour. Repeat this process until all contours have been described.
     * 
     * The *type* parameter defines what type of contour follows.
     * 
     * To define the type of the first contour, you can call **gluNextContour** before describing the first contour. If you do not call **gluNextContour** before the first contour, the first contour is marked GLU\_EXTERIOR.
     * @param {Pointer<IntPtr>} tess The tessellation object (created with [**gluNewTess**](glunewtess.md)).
     * @param {Integer} type The type of the contour being defined. The following values are valid.
     * 
     * 
     * 
     * | Value                                                                                                                                                                | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
     * |----------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | <span id="GLU_EXTERIOR"></span><span id="glu_exterior"></span><dl> <dt>**GLU\_EXTERIOR**</dt> </dl>           | An exterior contour defines an exterior boundary of the polygon.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
     * | <span id="GLU_INTERIOR"></span><span id="glu_interior"></span><dl> <dt>**GLU\_INTERIOR**</dt> </dl>           | An interior contour defines an interior boundary of the polygon (such as a hole).<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
     * | <span id="GLU_UNKNOWN"></span><span id="glu_unknown"></span><dl> <dt>**GLU\_UNKNOWN**</dt> </dl>              | An unknown contour is analyzed by the library to determine whether it is interior or exterior.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
     * | <span id="GLU_CCW__GLU_CW"></span><span id="glu_ccw__glu_cw"></span><dl> <dt>**GLU\_CCW, GLU\_CW**</dt> </dl> | The first GLU\_CCW or GLU\_CW contour defined is considered to be exterior. All other contours are considered to be exterior if they are oriented in the same direction (clockwise or counterclockwise) as the first contour, and interior if they are not.<br/> If one contour is of type GLU\_CCW or GLU\_CW, then all contours must be of the same type (if they are not, then all GLU\_CCW and GLU\_CW contours will be changed to GLU\_UNKNOWN). Note that there is no real difference between the GLU\_CCW and GLU\_CW contour types.<br/> |
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/glunextcontour
     */
    static gluNextContour(tess, type) {
        DllCall("GLU32.dll\gluNextContour", "ptr", tess, "uint", type)
    }

    /**
     * The gluBeginPolygon and gluEndPolygon functions delimit a polygon description. | gluEndPolygon function (Glu.h)
     * @remarks
     * Use [**gluBeginPolygon**](glubeginpolygon.md) and **gluEndPolygon** to delimit the definition of a nonconvex polygon.
     * 
     * 1.  Call **gluBeginPolygon**.
     * 2.  Define the contours of the polygon by calling [**gluTessVertex**](glutessvertex.md) for each vertex and [**gluNextContour**](glunextcontour.md) to start each new contour.
     * 3.  Call **gluEndPolygon** to signal the end of the definition.
     * 
     *     Once **gluEndPolygon** is called, the polygon is tessellated, and the resulting triangles are described through callbacks. For descriptions of the callback functions, see [*gluTessCallback*](glutess.md).
     * @param {Pointer<IntPtr>} tess The tessellation object (created with [**gluNewTess**](glunewtess.md)).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/OpenGL/gluendpolygon
     */
    static gluEndPolygon(tess) {
        DllCall("GLU32.dll\gluEndPolygon", "ptr", tess)
    }

;@endregion Methods
}
